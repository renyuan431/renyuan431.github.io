<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>20-Multicast | Rookie的博客</title><meta name="author" content="Rookie"><meta name="copyright" content="Rookie"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="我们可以为网络选择三种类型的流量：  单播； 广播； 组播；  如果需要将数据，从一个源设备发送到一个终端设备时，使用单播；如果需要将数据，从一个源设备发送给所有其他设备时，使用广播。 如果需要将数据，从一个源设备发送给一组但不是所有设备时，应该使用组播。 组播VS广播VS单播为什么要使用组播而不是广播或单播呢？让我们来举个例子，假设你要在网络中将一部电影播放给其他人的，看看这时使用单播、广播和组">
<meta property="og:type" content="article">
<meta property="og:title" content="20-Multicast">
<meta property="og:url" content="https://renyuan431.github.io/2022/01/20/20-Multicast/index.html">
<meta property="og:site_name" content="Rookie的博客">
<meta property="og:description" content="我们可以为网络选择三种类型的流量：  单播； 广播； 组播；  如果需要将数据，从一个源设备发送到一个终端设备时，使用单播；如果需要将数据，从一个源设备发送给所有其他设备时，使用广播。 如果需要将数据，从一个源设备发送给一组但不是所有设备时，应该使用组播。 组播VS广播VS单播为什么要使用组播而不是广播或单播呢？让我们来举个例子，假设你要在网络中将一部电影播放给其他人的，看看这时使用单播、广播和组">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://renyuan431.github.io/img/index.jpg">
<meta property="article:published_time" content="2022-01-20T07:34:09.000Z">
<meta property="article:modified_time" content="2022-01-20T07:36:47.992Z">
<meta property="article:author" content="Rookie">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://renyuan431.github.io/img/index.jpg"><link rel="shortcut icon" href="/img/avatar.jpg"><link rel="canonical" href="https://renyuan431.github.io/2022/01/20/20-Multicast/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '20-Multicast',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-01-20 15:36:47'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><!-- hexo injector head_end start --><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.css" /><link rel="stylesheet" href="https://unpkg.zhimg.com/hexo-filter-gitcalendar/lib/gitcalendar.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.0.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/index.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Rookie的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首頁</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">20-Multicast</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-20T07:34:09.000Z" title="发表于 2022-01-20 15:34:09">2022-01-20</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-01-20T07:36:47.992Z" title="更新于 2022-01-20 15:36:47">2022-01-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%B7%AF%E7%94%B1%E4%BA%A4%E6%8D%A2%E6%96%B9%E5%90%91/">路由交换方向</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">13.6k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>43分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="20-Multicast"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>我们可以为网络选择三种类型的流量：</p>
<ol>
<li>单播；</li>
<li>广播；</li>
<li>组播；</li>
</ol>
<p>如果需要将数据，从一个源设备发送到一个终端设备时，使用单播；如果需要将数据，从一个源设备发送给所有其他设备时，使用广播。</p>
<p>如果需要将数据，从一个源设备发送给一组但不是所有设备时，应该使用组播。</p>
<h1 id="组播VS广播VS单播"><a href="#组播VS广播VS单播" class="headerlink" title="组播VS广播VS单播"></a>组播VS广播VS单播</h1><p>为什么要使用组播而不是广播或单播呢？让我们来举个例子，假设你要在网络中将一部电影播放给其他人的，看看这时使用单播、广播和组播有什么区别，<strong>先看单播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622272190582-da2dc063-4690-4fed-9d0e-98b8c8149a0a.png" alt="img"></p>
<p>在上图的小型网络中使用单播播放电影的话，一台服务器为四台终端播放，两台终端在同一网段中，另外两台终端在其他网段中，两个路由器之间的带宽为30Mbit。</p>
<p>给单个终端串流视频需要6Mbps的带宽，给4个终端播放视频意味着需要24Mbps的流量，在使用单播的情况下，每增加一个用户就会需要更多的带宽。如果在右侧H3和H4的网段内出现大量的用户，那么两台路由器之间的30Mbit带宽是无法满足太多设备同时串流的需求的。</p>
<p>从上面的例子能够看出，单播的劣势就是它不可扩展，优势在于配置较为简单。</p>
<p><strong>现在来看广播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622449819852-bbc587f9-1c22-4240-a904-ac59544f5498.png" alt="img"></p>
<p>如果我们使用广播来串流视频，那么服务器的负载会小很多，服务器只需要发送一次数据即可。问题在于只有广播域内的用户能够收到，而广播域之外的的其他用户无法收到，比如上图中广播域内的H1和H2可以收到广播的串流，而另一个广播域的H3和H4则无法收到。</p>
<p><strong>最后来看组播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622450406809-837fed5c-4578-44b1-beca-4357f751f59a.png" alt="img"></p>
<p>组播在视频串流这种场景下的效果要好得多，不管有多少台设备需要串流，只需要发送一次数据即可。使用组播不仅可以降低服务器的负载，也能降低对网络带宽的消耗。</p>
<p>使用单薄时，用户越多，对服务器和网络的负载要求越高，而使用单薄的话则没有变化：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622450516798-54021796-64da-4165-9231-4d734c88acf9.png" alt="img"></p>
<p>既然单播的效率如此之高，互联网中的视频巨头，比如优酷、YouTube用的就是这种方式来给用户服务的吗？并不是，互联网中的组播并未真正部署过，这视频巨头用的依旧是单播，比如CDN，互联网中唯一能用到组播的地方就是IPTV。</p>
<h1 id="组播定义"><a href="#组播定义" class="headerlink" title="组播定义"></a>组播定义</h1><p>组播，Multicast，用来将数据发送给一组特定的网络设备或终端，这些设备可以在不同的网段中，这些设备称之为一个组播组。组播在传输时，主机只发送一份数据，这份数据的目的地址为组播组的地址。组播组中的所有成员都可以接收到同样的数据拷贝，这个数据拷贝通过路由器进行复制分发，并且只有组播组内的设备可以接收该数据。由于每个分支只发送一份报文，所以网络规模的增大不会额外增加网络的负担。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622462093382-c8ac3547-e875-4287-acad-0a2ec29afc50.png" alt="img"></p>
<p><strong>组播的优势为：</strong></p>
<ul>
<li>降低网络流量；</li>
<li>降低服务器的负载；</li>
</ul>
<p>组播的不足为：</p>
<ul>
<li><p>因为组播只支持UDP，所以所有UDP的缺点它都有，比如因为UDP是尽力投递，不能确保数据一定会发送到所以不可靠，没有拥塞机制，报文可能会错乱等；</p>
</li>
<li><p>组播报文的复制使得路由器的资源消耗增加；</p>
</li>
<li><p>可控性差，用户管理困难，存在安全问题，因为用户可以随意加入某个组播组而无需密码；</p>
</li>
</ul>
<p><strong>组播的使用场景为：</strong></p>
<ul>
<li><p>多媒体会议；</p>
</li>
<li><p>任何的‘单点到多点’应用；</p>
</li>
<li><p>金融应用；</p>
</li>
<li><p>远程教学等；</p>
</li>
</ul>
<h1 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h1><p>组播使用D类IP地址，以1110开头，组播范围为224.0.0.0——239.255.255.255。</p>
<p>各个地址范围段含义如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622462486090-41ec1dee-4a5f-4892-b38b-cf30c023a9d5.png" alt="img"></p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>终止地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.0</td>
<td>224.0.0.255</td>
<td>永久地址组，除了224.0.0.0做保留不分配以外，其他地址提供给路由协议、拓扑查找和协议维护等使用，也就是预先留给那些‘well know’的协议使用，比如OSPF建立邻居使用224.0.0.5和224.0.0.6。</td>
</tr>
<tr>
<td>224.0.1.0</td>
<td>224.0.1.255</td>
<td>公用组播地址，可以用于互联网使用。</td>
</tr>
<tr>
<td>224.0.2.0</td>
<td>238.255.255.255</td>
<td>用户可用的组播地址，也就是临时地址组，全网范围内有效。</td>
</tr>
<tr>
<td>239.0.0.0</td>
<td>239.255.255.255</td>
<td>本地管理组地址，仅在本地管理域内有效，使用本地管理组地址可以灵活定义组播的范围，以实现不同组播域之间的地址隔离，从而有助于在不同组播域内重复使用相同的组播地址而不会引起冲突。</td>
</tr>
</tbody></table>
<p>几个常用的组播地址如下：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.1</td>
<td>子网上所有主机，包括路由器。</td>
</tr>
<tr>
<td>224.0.0.2</td>
<td>子网上所有路由器。</td>
</tr>
<tr>
<td>224.0.0.5</td>
<td>所有OSPF路由器</td>
</tr>
<tr>
<td>224.0.0.6</td>
<td>OSPF DR路由器</td>
</tr>
<tr>
<td>224.0.0.9</td>
<td>RIP-2路由器</td>
</tr>
<tr>
<td>224.0.0.25</td>
<td>所有的交换机</td>
</tr>
<tr>
<td>224.2.0.0-224.2.255.255</td>
<td>多媒体会议呼叫</td>
</tr>
</tbody></table>
<h1 id="组播MAC地址映射"><a href="#组播MAC地址映射" class="headerlink" title="组播MAC地址映射"></a>组播MAC地址映射</h1><p>封装数据的时候，除了有源目的IP地址以外，还要封装源目的MAC地址，上面已经说了组播IP地址的分类，那么如何封装组播的MAC地址呢？MAC地址为48位：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622517381383-4df18c2e-f726-4a40-ac07-67c644a009a9.png" alt="img"></p>
<p>从上图中可以看出，第一个八位组中，有一位保留，用于标识MAC地址是用于组播还是广播，当数据为单播时，这位置0，当数据为广播或组播时，该位置1。在二层也有保留给组播使用的MAC地址段，就是01-00-5E开头的MAC地址段，也就是说组播的MAC地址一定是以01:00:5e开头的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622517702661-49cc2169-6258-426c-96fb-76435c561b44.png" alt="img"></p>
<p>前三个八位组已经规定好，也就是前24bit已经规定好不能更改了，第25bit规定了必须是0，所以48-24-1=23，也就是说后23bit可以随意使用，前24位成为‘组织唯一标识符’，英文是Organizationally Unique Identifier，简称OUI，会统一为不同的组织\公司分配不同的值，后24bit分配给具体的设备使用。</p>
<p>IP组播长度为32bit，前4bit固定为1110，后面跟着28bit可变的地址，为了将32bit组播IP地址映射成48bit的MAC地址，需要进行以下操作：</p>
<p>将24bit的OUI地址（组织唯一标识符）填充最前面的24bit，也就是说最前面是‘01-00-5E’，第25bit恒定为0，组播MAC地址剩下还有23bit，这个空间由组播IP地址的后23bit填满，32-23=5，也就是下图中组播地址中标红的地方，2的5次方为32，所以也就是说有32个IP地址映射的组播地址是相同的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622514231143-1877203a-5aae-4250-8a8f-8a24ff2e2d71.png" alt="img"></p>
<p>用上面的方式进行了组播IP地址——组播MAC地址的映射以后，有一些IP地址的映射相同，具体来说就是有32个组播IP地址映射后的组播MAC地址是相同的，听起来是个大问题，但实际中并不是，因为MAC地址只在链路上使用，相同链路上组播IP地址处于一个区间概率很小，所以映射的组播MAC地址相同的几率也会很小，当然也是有可能映射的组播MAC地址相同，因此设备会假定它所收到的组播报文并不是发给它这个组播组的，设备会将这个组播报文交给IP层去查看组播IP地址，如果IP层判断这个报文并不是发给它这个组播组的，那么这个报文将会被丢弃，这种情况很少发生，所以多一道工序使得效率降低一些也可以接受。</p>
<h1 id="组播分发树"><a href="#组播分发树" class="headerlink" title="组播分发树"></a>组播分发树</h1><p>组播分发树用来描述IP组播报文在网络中经过的路径，也就是从源主机到数据接收者的传输路径，组播转发树有两类，有源树和共享树。</p>
<h2 id="有源树"><a href="#有源树" class="headerlink" title="有源树"></a>有源树</h2><p>有源树也叫最短路径树，英文为Source or Shortest Path Tree，由组播源到用户之间的最短路径构成。路由器必须为每个组播源保存路由信息，占用内存较多，但路径最优，接收者到多播源是最佳路径，延迟最小。</p>
<p>有源树的根，是组播数据流的来源，有源树的分支形成了通过网络到达接收站点的分布树：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535325802-6d962656-dc69-4b8f-87b9-16db98445cfe.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535330089-52de9420-be7a-4498-abbf-f7ba3a64ab64.png" alt="img"></p>
<h2 id="共享树"><a href="#共享树" class="headerlink" title="共享树"></a>共享树</h2><p>共享树英文为Shared Tree，以网络上某特定节点为公用根，占用内存较少，路径不一定是最优的，多播流量转发必须先经过RP（Rendezvous Point，汇聚点），引入额外的延迟，对RP的可靠性和处理能力要求很高。</p>
<p>共享树的根不在多播数据流的源头，而位于网络中管理员指定的汇聚点，RP，所有多播源先把多播流发送到RP，再由RP分发到各个接收站点，目标组地址向它的多个源节点共享多播分布树。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535536609-b829e199-6ac5-4c25-9e5d-4d29c1d7f808.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535620240-7e73fdaa-b962-4286-98d0-6f62c55ad89e.png" alt="img"></p>
<h1 id="组播数据转发"><a href="#组播数据转发" class="headerlink" title="组播数据转发"></a>组播数据转发</h1><p>组播路由转发和单播路由转发是相反的：</p>
<ul>
<li>单播路由转发关心数据报文要到哪里去，关心的是终点；</li>
<li>组播路由转发关心数据报文从哪里来，关心的是起点；</li>
</ul>
<p>组播路由转发使用‘返乡路径转发’机制，避免环路。多播数据流从多播路由器入口路由到出口路由转发出去，入口由RPF决定，出口由IGMP和多播路由协议决定。</p>
<h2 id="RPF"><a href="#RPF" class="headerlink" title="RPF"></a>RPF</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>什么是RPF？英文是Reverse Path Forwarding，也就是反向路径转发，路由器收到组播数据报文后，只有确认这个数据报文是从自己前往源的出接口上收到后，才会进行转发，如果不是则会丢弃报文。上面确认源接口的过程由RPF检查完成，路由器会在单播路由表中查找到组播报文源地址的路由，如果该路由的出接口就是报文的入接口，则RPF成功，否则表示RPF失败。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536163160-5354be9d-3e29-45f1-8c85-918db0f5e3c1.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536193757-69feca91-53a8-4afd-a102-c9df1f4f6d47.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536206887-e2f03d97-c891-4c04-bd37-9d2f7d81ea54.png" alt="img"></p>
<h3 id="检测顺序"><a href="#检测顺序" class="headerlink" title="检测顺序"></a>检测顺序</h3><h4 id="优先级优先（默认）"><a href="#优先级优先（默认）" class="headerlink" title="优先级优先（默认）"></a>优先级优先（默认）</h4><ol>
<li><p>如果同时存在单播和组播路由（用于RPF检查的组播路由条目），比较优先级，优先级越小越优；</p>
</li>
<li><p>如果优先级相同，则组播静态&gt;MBGP&gt;单播（默认情况下组播静态优先级为1，MBGP优先级为255，单播路由需要视协议而定）；</p>
</li>
<li><p>如果都是单播路由，比较路由的掩码长度，掩码长度越长越优；</p>
</li>
<li><p>如果掩码长度一样，比较下一跳的IP地址，IP地址越大越优；</p>
</li>
</ol>
<h4 id="掩码长度优先"><a href="#掩码长度优先" class="headerlink" title="掩码长度优先"></a>掩码长度优先</h4><ol>
<li><p>如果同时存在单播和组播路由，比较掩码长度，掩码长度越长越优；</p>
</li>
<li><p>如果掩码长度一样，比较路由协议优先级，优先级越小越优；</p>
</li>
<li><p>如果优先级一样，组播静态&gt;MBGP&gt;单播；</p>
</li>
<li><p>如果都是单播路由，比较下一跳的IP地址，IP地址越大越优；</p>
</li>
</ol>
<h1 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h1><h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>IGMP协议全称是Internet Group Management Protocol，互联网组管理协议，该协议是TCP/IP协议簇中负责IP组播成员管理的协议，主要用于在IP主机和其直接相邻的组播路由器之间建立，维护组播组成员的关系，它是一个主机和路由器之间的协议。IGMP通过在接收者和组播路由器之间交互IGMP报文实现组成员管理功能，IGMP报文封装在IP报文中。主机通过IGMP协议向路由器报告自己想加入的组，路由器通过IGMP协议查询网上是否还有特定组的成员。</p>
<p>IP组播通信的特点是报文从一个源发出，被转发到一组特定的接收者，但在组播通信模型中，发送者不关注接收者的位置信息，只是将数据发送到约定的目的组播地址，要使组播报文最终能够到达接收者，需要某种机制，这种机制使得接收者所在的路由器能够知道该网段存在哪些组播接收者，同时保证接收者可以加入相应的组播中。IGMP就是用来在接收者主机和它（接收者主机）所在网段连接的路由器之间，建立、维护组播组成员关系的协议。组播路由器通过IGMP协议了解每个接口连接的网段上是否存在组播接收者，也就是组成员。如果存在组成员，组播路由器会把组播数据包转发到这个网段，如果没有成员则停止转发。</p>
<h2 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h2><p>IGMPV1中定义了基本的组成员查询和报告过程，IGMPV2在此基础上添加了查询器选举和成员离开的机制，IGMPV2版本是目前使用的协议，IGMPV3中增加的主要功能是成员可以指定接收或指定不接收某些组播源的报文。三个版本在演进过程中对报文的处理是向前兼容的，也就是说高版本可以兼容低版本的报文。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622537662433-3291ffb8-a5bd-48f1-bc5d-a9ec2546b95f.png" alt="img"></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>IGMP采用路由器查询、主机报告两种方式维持组员关系：</p>
<ul>
<li><p>路由器查询：路由器周期性的，每六十秒发送查询（目的为224.0.0.1，TTL=1）试图发现感兴趣的组员，主机每次都会回复路由器的查询；</p>
</li>
<li><p>主机报告：主机主动发送一个IGMP报告（目的为组播组地址，TTL=1）表示要加入某个组播组，这里面包含了要加入的组播组的地址，也可以用来回复路由器的查询。同一网段中，只需要一台主机发送Report报文，避免网络中充斥大量的Report报文。</p>
</li>
<li><p>抑制机制：倒数报告计时器的默认时间为10S；</p>
</li>
</ul>
<h3 id="IGMP-V1"><a href="#IGMP-V1" class="headerlink" title="IGMP V1"></a>IGMP V1</h3><p>IGMP V1协议主要基于查询和响应机制完成组播组管理，当一个网段内有多个组播路由器时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一组路由器发送查询报文就够了，改组播路由器称为IGMP查询器（Querier）。在IGMP V1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMP V1的查询器，负责该网段的组成员关系查询。</p>
<p>IGMP V1的工作机制可以分为普遍组查询和响应机制，新成员加入机制和组成员离开机制三个方面。</p>
<h4 id="普遍组查询和响应机制"><a href="#普遍组查询和响应机制" class="headerlink" title="普遍组查询和响应机制"></a>普遍组查询和响应机制</h4><p>通过普遍组查询和响应，IGMP查询器可以了解到该网段内哪些组播组存在成员。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622602965988-0c5616dd-cee3-4ab3-92d0-8f2e66de85ee.png" alt="img"></p>
<p>如上图所示，普遍组查询和响应过程如下：</p>
<ul>
<li>IGMP查询器发送目的地址为224.0.01（表示同一网段内所有主机和路由器）的普遍查询报文；收到该查询报文的组成员启动定时器。查询器所发送的普遍组查询报文是周期性发送的，发送周期可以通过命令配置，默认情况下每隔60秒发送一次。Host A和Host B是组播组G1的成员，则在本地启动定时器Timer-G1。缺省情况下，HostA和B的定时器范围为0-10秒之间的随机值。下图中IGMP版本为V1版本，目的IP地址为224.0.0.1，源IP地址为自己接口的IP地址，在组播地址中，填充为0.0.0.0。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622604418259-22900164-3839-4f18-b845-fae61e7dcc4e.png" alt="img"></p>
<ul>
<li>第一个定时器超时的组成员发送针对该组播组的报告报文。假设Host A上的Timer-G1首先超时，Host A向该网段发送目的地址为G1的报告报文。也想加入G1的Host B收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文，报告报文被抑制，可以减少网段上的流量。下图中是主机像路由器发送的报告报文，类型值为0X12，源IP地址为自己主机的IP地址，目的IP地址为组播地址。下图中，是主机像路由器发送的报告的抓包，类型值为0x12，源IP地址为自己主机的IP地址，目的IP地址为组播地址。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622604927603-f942692b-5f96-4c08-b756-4398c336c219.png" alt="img"></p>
<h4 id="新成员加入机制"><a href="#新成员加入机制" class="headerlink" title="新成员加入机制"></a>新成员加入机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622606359352-f0988066-6e48-47bd-ae24-b0b21139ceea.png" alt="img"></p>
<p>如上图所示，主机Host C加入组播组G2的过程如下：</p>
<ul>
<li>主机Host C不等待普遍组查询报文的到来，主动发送针对G2的报告报文，声明加入该组播组；</li>
<li>IGMP查询器接收到Host C的报告报文后，了解到本地网段内出现了组播组G2的成员，则生成组播转发项（*，G2），网络中一旦有G2的数据到达路由器，将向该网段转发；</li>
</ul>
<h4 id="组成员离开机制"><a href="#组成员离开机制" class="headerlink" title="组成员离开机制"></a>组成员离开机制</h4><p>IGMP V1没有专门定义离开组的报文，主机离开组播组后，便不会再对普通组查询报文做出回应。</p>
<ul>
<li>假设Host A想要退出组播组G1：Host A收到IGMP 查询器发送的普遍组查询报文时，不再发送针对G1的报告报文，由于网段内还存在G1组成员Host B，Host B会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到Host A的离开；</li>
<li>假设Host C想要退出组播组G2：Host C收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间内（默认为130秒）后，删除G2所对应的组播转发表项；</li>
</ul>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><p>V1版本包括两种类型的报文：</p>
<ul>
<li>普遍组查询报文：英文为General Query，是查询器向共享网络上所有主机和路由发送的查询报文，用于了解哪些组播组存在成员；</li>
<li>成员报告报文：英文为Report，是主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622548966946-e76ee04a-80e5-467e-a8af-09858c6415d4.png" alt="img"></p>
<ul>
<li><p>Version：版本号，在IGMP V1中该值为1；</p>
</li>
<li><p>Type：报文类型，该字段有以下两种取值：0x11，表示普遍组查询报文。0x12，表示成员报告报文；</p>
</li>
<li><p>Unused：在IGMP V1中，该字段在发送时被设置为0，并在接收时被忽略；</p>
</li>
<li><p>Checksum：IGMP报文的校验和，校验和是IGMP报文长度（也就是IP报文的整个有效载荷）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0.当发送报文时，必须计算校验和并插入到Checksum字段中去，当接收报文时，校验和必须在处理该报文之前进行校验；</p>
</li>
<li><p>Group Address：组播地址，在普遍组查询报文中，该字段为0，在成员报告报文中，该字段为成员加入的组播组地址；</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622549396314-69df852c-9fa3-411f-98c2-100565dc131d.png" alt="img"></p>
<h3 id="IGMP-V2"><a href="#IGMP-V2" class="headerlink" title="IGMP V2"></a>IGMP V2</h3><p>IGMP V2工作机制与IGMP V1基本相同，最大不同之处在于IGMP V2增加了离开组机制，成员主机离开组播组时，会主动发送成员离开报文通知IGMP查询器；IGMP查询器在收到成员离开报文后，会连续发送特定查询报文，询问该组播组是否还存在组成员。如果在一段时间内没有收到成员主机发送的报告报文，IGMP查询器将不再维护该组的组成员关系。IGMP V2可以使IGMP查询器即使了解到网段内哪些组播组已经不存在成员，从而即使更新组成员关系，减少网络中冗余的组播流量。</p>
<p>和IGMP V1相比，V2版本增加了查询器选举和离开组的机制。</p>
<h4 id="查询器选举机制"><a href="#查询器选举机制" class="headerlink" title="查询器选举机制"></a>查询器选举机制</h4><p>IGMPV2使用独立的查询器选举机制，当共享网段上存在多个组播路由器时，<strong>IP地址最小的路由器成为查询器。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618789348-45b81e15-fd91-400f-adf1-34d6bb33c78b.png" alt="img"></p>
<p>如上图所示，在IGMP V2中，查询器的选举过程如下：</p>
<ul>
<li>最初，所有运行IGMP V2的组播路由器（上图中的Router A和Router B）都会认为自己试查询器，向本网段内所有主机和组播路由器发送普遍查询报文。Router A和B在收到对方发送的普遍查组查询报文后，将报文的源IP地址与自己的接口地址作比较，通过比较，IP地址最小的组播路由器将成为查询器，其他组播路由器成为非查询器（Non-Querier），V2查询报文示例如下：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618970687-4a5cd027-2193-45b4-bd8c-483042819cfe.png" alt="img"></p>
<p>IGMP V2报告报文如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618994148-25511dfe-94fa-4430-8deb-c247ead1a2d1.png" alt="img"></p>
<ul>
<li>此后，将由IGMP查询器，也就是上一步选举出来的IP地址最小的Router A，向本网段内所有主机和其他组播路由器发送普遍查询报文，而非查询器（Router B）将不再发送普遍组查询报文。非查询器（Router B）上都会启动一个定时器（即其他查询器存在时间的定时器，Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的查询报文，则重置该定时器；否则就认为原查询器失效，并发起新的查询器选举过程。</li>
</ul>
<h4 id="离开组机制"><a href="#离开组机制" class="headerlink" title="离开组机制"></a>离开组机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622619463267-c728555a-f309-4534-91af-8d490286df3e.png" alt="img"></p>
<p>如上图所示在IGMP V2中，主机Host A离开组播组G1的过程如下：</p>
<ul>
<li><p>Host A向本地网段内的所有组播路由器（也就是目标地址为224.0.0.2）发送针对组G1的离开报文；</p>
</li>
<li><p>查询器收到离开报文，会发送针对组G1的特定组查询报文。发送间隔和发送次数可以通过命令配置，缺省情况下，每隔1秒发送一次，一共会发送两次，同时查询器会启动组成员关系定时器（Timer-Membership=发送间隔X发送次数）；</p>
</li>
<li><p>如果该网段内<strong>还存在</strong>组G1的其他成员，这些成员在收到查询器发送的特定查询报文后，会立即发送针对组G1的报告报文。查询器收到针对组G1的报告报文后，将继续维护该组成员关系；</p>
</li>
<li><p>如果该网段内<strong>不存在</strong>组G1的其他成员，查询器将不会收到针对组G1的报告报文。在Timer-Membership超时后，查询器将删除（*，G1）对应的IGMP组表项。当有组G1的组播数据到达查询器时，查询器将不会向下游转发。</p>
</li>
</ul>
<h4 id="报文分析"><a href="#报文分析" class="headerlink" title="报文分析"></a>报文分析</h4><p>和IGMP V1相比，IGMP V2除了普遍组查询报文和成员报告报文之外，IGMP V2新增了两种报文：</p>
<ul>
<li>成员离开报文（Leave）：成员离开组播组时，会主动向查询器发送离开报文，用于宣告自己离开了某个组播组；</li>
<li>特定组查询报文（Group-Specific Query）：查询器向共享网段内指定组播组发送的查询报文，用于查询该组播组是否存在成员；</li>
</ul>
<p>报文方面的另一个变化是，IGMP V2对普遍组查询报文的格式进行了改进，添加了最大响应时间（Max Response Time）字段，该字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。查询报文的抓包如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622620680251-e616a989-93aa-4283-a169-63914a5259ce.png" alt="img"></p>
<ul>
<li><p>Type：报文类型，该字段有四种取值：0x11表示查询报文，包括普遍组查询报文和特定组查询报文两类；0x12表示IGMPV1成员报告报文；0x16表示IGMPV2成员报告报文；0x17表示成员离开报文。</p>
</li>
<li><p>Max Response Time：最大响应时间，成员主机在收到IGMP查询器发送的普遍查询报文后，需要在最大相应时间内做出回应，该字段仅在IGMP查询报文中有效。</p>
</li>
<li><p>Group Address：组播组地址。在普遍查询报文中，该字段为0.0.0.0；在特定组查询宝文中，该字段为要查询的组播组地址；在成员报告报文和离开报文中，该字段为组成员要加入或离开的组播组地址。</p>
</li>
</ul>
<h3 id="IGMP-V3"><a href="#IGMP-V3" class="headerlink" title="IGMP V3"></a>IGMP V3</h3><p>IGMP V3主要是为了配合SSM（Source-Specific Multicast）模型发展起来的，提供了在报文中携带组播源信息的能力，也就是说主机可以对组播源进行选择。</p>
<h4 id="特定组的加入"><a href="#特定组的加入" class="headerlink" title="特定组的加入"></a>特定组的加入</h4><p>IGMP V3的成员报告报文的目的地址为224.0.0.22（表示同一网段所有能使用IGMP V3的路由器）。通过在报告报文中携带组记录，主机在加入组播组的同时，能够明确要求接收或不接收特定组播源发出的组播数据。</p>
<p>如果Host和组播路由器之间运行的是IGMP V1或IGMP V2，那么Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMP V3，成员主机可以选择仅仅接收S1组播的数据。</p>
<ul>
<li>方法1：Host发送IGMP V3报告（G，Include，（S1）），仅接收源S1向组播组G发送的数据；</li>
<li>方法2：Host发送IGMP V3报告（G，Include，（S2）），不仅接收指定源S2向组播组G发送的数据，从而仅有来自S1的组播数据才能传递到Host。</li>
</ul>
<h4 id="特定组查询"><a href="#特定组查询" class="headerlink" title="特定组查询"></a>特定组查询</h4><p>当接收到组成员发送的改变组播组与愿列表的对应关系的报告时（比如Change_to_include_mode\Change_to _exclude_mode），IGMP查询器会发送特定源的组查询报文，如果组成员希望接收其中任意一个源的组播数据，将反馈报告报文。IGMP查询器根据反馈的组成员报告更新该组对应的源列表。</p>
<h3 id="IGMP-SSM-Mapping"><a href="#IGMP-SSM-Mapping" class="headerlink" title="IGMP SSM Mapping"></a>IGMP SSM Mapping</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>SSM（Source-Specific Multicast）成为指定源组播，要求路由器能了解成员主机加入组播时所指定的组播源。如果成员主机上运行IGMP V3，可以在IGMP V3报文中直接指定组播源地址，但是在某些情况下，成员主机只能运行IGMP V1或V2，为了使其也能够使用SSM服务，路由器上需要提供IGMP SSM Mapping功能。</p>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>通过在路由器上静态配置SSM地址的映射规则，将IGMP V1和V2报告报文中的（*，G）信息转化为对应的（G，Include，（S1，S2….））信息，以提供SSM组播服务。</p>
<ul>
<li><p>SSM模型针对特定源和组的绑定数据流提供服务，接收者主机在加入组播组时，可以指定只接收哪些源的数据或指定拒绝接收来自哪些源的数据。加入组播组以后，主机只会收到指定源发送到该组的数据；</p>
</li>
<li><p>SSM模型对组播地址不再要求全网唯一，只需要每个组播源保持唯一。这里的唯一指的是同一个源上不同的组播应用必须使用不同的SSM地址来区分。不同的源之间可以使用相同的组地址，因为SSM模型中针对每一个（源，组）信息都会生成表项。这样一方面节省了组播组地址，另一方面也不会造成网络拥塞；</p>
</li>
<li><p>如果G在ASM（And-Source Multicast）范围内，只提供ASM服务。</p>
</li>
<li><p>如果G在SSM组地址范围内（默认情况下为232.0.0.0-232.255.255.255），如果路由器上没有G对应的SSM Mapping规则，那么无法提供SSM服务，丢弃该报文；如果路由器上有G对应的SSM Mapping规则，则一句规则将报告报文中所包含的（*，G）信息映射为（G，Include，（S1，S2…..））信息，提供SSM服务。</p>
</li>
</ul>
<h3 id="IGMP-Proxy"><a href="#IGMP-Proxy" class="headerlink" title="IGMP Proxy"></a>IGMP Proxy</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>IGMP Proxy，也称为IGMP代理，通常被部署在接入设备（Router A）和成员主机之间的三层设备上，IGMP Proxy设备可以手机下游成员主机的IGMP报告\离开报文，将报告\离开报文汇聚后，代理下游成员主机同一上报给接入设备；另一方面IGMP Proxy设备也可以代理IGMP查询器向下游成员主机发送查询报文，维护成员关系，基于组成员关系进行组转发。在接入设备Router A看来，Router B就是一台主机，在下游成员主机看来，Router B就是IGMP查询器。</p>
<ul>
<li>上游接口：指IGMP代理设备上配置IGMP Proxy功能的接口，该接口执行IGMP代理设备的主机行为，因此也称为主机接口（Host Interface）；</li>
<li>下游接口：指IGMP代理设备上配置IGMP功能的接口，该接口执行IGMP代理设备的路由器行为，因此也称为路由器接口（Router Interface）；</li>
</ul>
<h4 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h4><p>IGMP代理设备实现的功能主要分为两种：主机行为和路由器行为。</p>
<p>主机行为是指IGMP代理设备的上游接口收到查询报文时，根据当前组播转发表的状态对查询报文做出响应，或者当组播转发表发生变化时，上游接口主动向接入设备发送报告\离开报文。主机行为的工作机制如下：</p>
<ul>
<li><p>IGMP代理设备上游接口收到查询报文时，会根据当前组播转发表的状态对查询报文作出相应；</p>
</li>
<li><p>IGMP代理设备收到某组播组的报告报文后，会在组播转发表中查找该组播组。如果没有找到相应的组播组，IGMP代理设备会向接入设备发送针对该组播组的报告报文，并在组播转发表中添加该组播组。如果找到相应的组播组，IGMP代理设备就不需要向接入设备报告发送报告报文；</p>
</li>
<li><p>IGMP代理设备收到某组播组G的离开报文后，会向接收到该离开保温的接口发送一个特定组查询报文，检查该接口下是否还存在组播组G的其他成员。如果没有其他成员，IGMP代理设备会向接入设备发送针对该组播组的离开报文，并在组播转发表中将对应的接口删除。如果有其他成员，IGMP代理设备会继续向该接口转发组播数据；</p>
</li>
</ul>
<h2 id="IGMP命令"><a href="#IGMP命令" class="headerlink" title="IGMP命令"></a>IGMP命令</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">ip multicast</span><br><span class="line">开启组播路由功能</span><br><span class="line"></span><br><span class="line">ip igmp version&#123;1|2|3&#125;</span><br><span class="line">设置igmp版本</span><br><span class="line"></span><br><span class="line">ip igmp query-interval XX</span><br><span class="line">设置查询报文发送间隔，默认为60秒</span><br><span class="line"></span><br><span class="line">ip igmp query-max-response-time XX</span><br><span class="line">设置igmp普遍组查询报文的最大响应时间，默认为10秒</span><br><span class="line"></span><br><span class="line">ip igmp query-timeout XX</span><br><span class="line">设置igmp通告过期时间</span><br><span class="line"></span><br><span class="line">ip igmp join-group X.X.X.X</span><br><span class="line">接口需要侦听某个组播组</span><br><span class="line"></span><br><span class="line">show ip igmp interface E0/0</span><br><span class="line">查看接口上igmp配置</span><br></pre></td></tr></table></figure>

<h1 id="PIM协议"><a href="#PIM协议" class="headerlink" title="PIM协议"></a>PIM协议</h1><p>PIM协议英文全称为，Protocol Independent Multicast，中文是协议无关组播，这里的协议无关指的是与单播路由协议无关，也就是说，PIM不需要维护专门的单播路由协议。作为组播路由解决方案，它直接利用单播路由表的路由信息，对组播报文执行RPF（Reverse Path Forwarding，逆向路径转发）检查，检查通过后创建组播路由表项，从而转发组播报文。，目前设备实际支持的IPM协议包括：PIM-DM（PIM-Dense Mode）、PIM-SM（PIM-Sparse Mode）</p>
<h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="组播分发树-1"><a href="#组播分发树-1" class="headerlink" title="组播分发树"></a>组播分发树</h3><p>PIM网络以组播组为单位在路由器上建立单点到多点的组播转发路径。由于组播转发路径呈现树形结构，也称为组播分发树MDT（Multicast Distribution Tree）。主要包括SPT和RPT两种。</p>
<h4 id="SPT"><a href="#SPT" class="headerlink" title="SPT"></a>SPT</h4><ul>
<li><p>SPT全称为Shortest-Path Tree，中文为最短路径树，以组播源为根，是组播组成员为叶子的组播分发树，SPT同时适用于PIM-DM网络和PIM-SM网络；</p>
</li>
<li><p>主要使用（S,G）表项；</p>
</li>
<li><p>源树的分支形成了通过网络到达接收者所在分支的分布树，因为最短路径树使用最短的、从源起始贯穿网络到达组播接收者的路径，所以又叫最短路径树；</p>
</li>
</ul>
<h4 id="RPT"><a href="#RPT" class="headerlink" title="RPT"></a>RPT</h4><ul>
<li><p>以RP（Rendezvous Point）为根，也就是使用RP为汇聚点，组播组成员为叶子的组播分发树称为RPT（RP Tree），RPT适用于PIM-SM网络；</p>
</li>
<li><p>主要使用（*,G）表项；</p>
</li>
<li><p>多个组播组可以共用一个RP，需要接收组播流量的路由器，通过组播协议在自己与RP之间建立一条RPT的分支，组播流量首先需要从源发送到RP，然后再由RP将组播流量转发下来，组播流量顺着RPT最终到达各个接收者所在的终端网络；</p>
</li>
</ul>
<h3 id="PIM路由器"><a href="#PIM路由器" class="headerlink" title="PIM路由器"></a>PIM路由器</h3><p>在接口上使用了PIM协议的路由器即为PIM路由器。在建立组播分发树的过程中，PIM路由器又分为以下几种：</p>
<ul>
<li><p>叶子路由器，与用户主机相连的PIM路由器，但连接的用户主机不一定为组成员；</p>
</li>
<li><p>第一跳路由器：组播转发路径上，与组播源相连且负责转发该组播源发出的组播数据的PIM路由器；</p>
</li>
<li><p>最后一跳路由器：组播转发路径上，与组播组成员相连且负责向改组播组成员转发组播数据的PIM路由器；</p>
</li>
<li><p>中间路由器：组播转发路径上，第一跳路由器与最后一跳路由器之间的PIM路由器；</p>
</li>
</ul>
<h3 id="RPF-1"><a href="#RPF-1" class="headerlink" title="RPF"></a>RPF</h3><p>RPF全称为Reverse Path Forwarding，反向路径转发。在组播网络中，如果组播流量出现转发环路，比起单播报文的转发环路的危害要大得多，路由器在转发组播报文时，除了会关注报文的目的地址，还会特别关心该报文的源地址。组播路由器通过RPF的机制来实现组播数据转发的无环化。</p>
<p>RPF机制确保组播数据从正确的接口被收到，只有通过RPF检查的组播数据包才会被路由器沿着组播树进行转发，如果数据包从错误的接口被收到，路由器将丢弃这些报文。这里所谓的正确接口，其实就是通过了RPF检查的接口，也就是经常说的上游接口，一种常见的情况是，设备借助其单播路由表来实现RPF检查。</p>
<h3 id="PIM路由表项"><a href="#PIM路由表项" class="headerlink" title="PIM路由表项"></a>PIM路由表项</h3><p>PIM路由表项就是那些通过PIM协议建立的组播路由表项。PIM网络中存在两种表项：（S,G）路由表项或（，G）路由表项。S表示组播源，G表示任意的组播组。</p>
<ul>
<li>（S,G）路由表项主要用于在PIM网络中建立SPT（Shortest Path Tree，最短路径树），路由表项知道组播源S的位置，用于PIM-DM网络和PIM-SM网络；</li>
<li>（*,G）路由表项主要用于在PIM网络中建立RPT（Rendezvous Point Tree，共享树），路由表项只知道组播G的存在，用于PIM-SM和PIM-DM网络；</li>
</ul>
<p>路由器上可能同时存在两种路由表项，当收到源地址为S，组地址为G的组播报文，且RPF检测通过的情况下，按照如下的规则转发：</p>
<ul>
<li>如果存在（S,G）路由表项，则由（S,G）路由表项指导报文转发；</li>
<li>如果不存在（S,G）路由表项，只存在（,G）路由表项，则先依照（,G）路由表项创建（S,G）路由表项，再由（S,G）路由表项指导报文转发；</li>
</ul>
<p>PIM路由表项中主要用于指导转发的信息如下：</p>
<ul>
<li><p>组播源地址；</p>
</li>
<li><p>组播组地址；</p>
</li>
<li><p>上游接口：本地路由器上接收到组播数据的接口；</p>
</li>
<li><p>下游接口：将组播数据转发出去的接口；</p>
</li>
</ul>
<h1 id="PIM-DM"><a href="#PIM-DM" class="headerlink" title="PIM-DM"></a>PIM-DM</h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>PIM-DM全称Protocol-Independent Multicast-Dense Mode，可以翻译成协议无关组播的密集模式，使用的‘推（Push）模式’转发组播报文，一般应用于组播组成员规模相对较小，相对密集的网络。在实现过程中，它会假设网络中的组成员分布非常稠密，每个网段都可能存在组成员，当有活跃的组播源出现时，PIM-DM将组播源发来的组播报文扩散到整个网络的PIM路由器上，再裁减掉不存在的组成员的分支。PIM-DM通过周期性的进行‘扩散（Flooding）——修剪（Prune）’，来构建并维护一颗连接组播源和组成员的单向无环SPT（Specific Shortest Path Tree）。如果在下一次‘扩散-修剪’进行前，被裁剪掉的分支由于其叶子路由器上有新的组成员加入而希望提前恢复转发状态，也可通过嫁接（Graft）机制主动恢复其对组播报文的转发。</p>
<p>PIM-DM工作机制包括邻居发现、扩散、裁剪、嫁接、断言和状态刷新。其中扩散、裁剪和嫁接是构建SPT的主要方法。</p>
<ul>
<li><p>使用‘推(push)’模型，也就是说不管你要不要这个组播，先推送给你；</p>
</li>
<li><p>组播数据流整个网络泛洪（Flood）；</p>
</li>
<li><p>下游不需要这个组播的话则会裁剪（Prune）；</p>
</li>
<li><p>泛洪——裁剪——泛洪——裁剪，周而复始，每隔三分钟泛洪一次；</p>
</li>
</ul>
<h2 id="几种动作"><a href="#几种动作" class="headerlink" title="几种动作"></a>几种动作</h2><h3 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h3><p>PIM路由器上每个使用了PIM协议的接口都会对外发送Hello报文，每个30S（Hello Interval）会使用组播的PIM Hello报文选入它的连入，105S内收不到邻居的Hello报文则会认为邻居失效，在组播转发时经过RPF检测后会将组播流量发送给所有PIM邻居路由器，查看邻居的命令为:show ip pim neighbor。</p>
<p>封装Hello报文的组播报文的目的地址是224.0.0.13（表示同一网段中所有PIM路由器）、源地址为接口的IP地址、TTL数值为1。</p>
<p>Hello报文的作用如下：</p>
<ul>
<li><p>发现PIM邻居。同一网段中的PIM路由器都必须接收目的地址为224.0.0.13的组播报文，这样直接相连的PIM路由器之间通过交互Hello报文以后，就可以彼此知道自己的邻居信息，建立邻居关系。只有邻居关系建立成功后，PIM路由器才能接收其他PIM协议报文，从而创建组播路由表项；</p>
</li>
<li><p>维持邻居关系。PIM路由器之间周期性地发送Hello报文，如果Holdtime超时还没有收到该PIM邻居发出的新的Hello报文，PIM路由器就认为该邻居不可达，将其从邻居列表中清除。PIM邻居的变化将导致网络中组播拓扑的变化。如果组播分发树上的某上游邻居或下游邻居不可达，将导致组播路由重新收敛，组播分发树迁移；</p>
</li>
<li><p>协调各项PIM协议报文参数。Hello报文中携带多项PIM协议报文参数，主要用于邻居之间PIM协议报文的控制：</p>
</li>
</ul>
<ol>
<li><p>DR_Priority：表示各路由器接口精选DR的优先级，优先级越高越容易获胜；</p>
</li>
<li><p>Holdtime：表示保持邻居为可达状态的超时时间，如果在超时时间内没有收到PIM邻居发送的Hello报文，路由器则认为邻居不可达；</p>
</li>
<li><p>LAN_Delay：表示共享网段内传输Prune报文的延迟时间；</p>
</li>
<li><p>Neighbor-Tracking：表示邻居跟踪功能；</p>
</li>
<li><p>Override-Interval：表示Hello报文中携带的否决裁剪的时间间隔；</p>
</li>
</ol>
<h3 id="扩散（Flooding）"><a href="#扩散（Flooding）" class="headerlink" title="扩散（Flooding）"></a>扩散（Flooding）</h3><p>当PIM-DM网络中出现活跃的组播源之后，组播源发送的组播报文将在全网内扩散，当PIM路由器接收到组播报文，根据单播路由表进行RPF检查通过后，就会在该路由器上创建（S,G）表项，下游接口列表中包括除上游接口之外与所有PIM邻居相连的接口，后续到达的组播报文将从各个下游接口转发出去。</p>
<p>最后组播报文扩散到达叶子路由器，会出现以下两种情况：</p>
<ul>
<li>若与该叶子路由器相连用户网段上存在组成员，则将与该网段相连的接口加入（S,G）表项的下游接口列表中，后续的组播报文会向组成员转发；</li>
<li>若与该叶子路由器相连用户网段上不存在组成员，则不需要向其下游PIM邻居转发组播报文，则执行裁剪动作；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483842043-cfe5005b-ba16-4a94-b6db-9671b06b24f9.png" alt="img"></p>
<h3 id="裁剪（Prune）"><a href="#裁剪（Prune）" class="headerlink" title="裁剪（Prune）"></a>裁剪（Prune）</h3><p>当PIM路由器接收到组播报文后，RPF检查通过，但是下游网段没有组播报文需求。此时PIM路由器会向上游发送裁剪报文，通知上游路由器禁止相应下游接口的转发，将其从（S,G）表项的下游接口列表中删除。裁剪操作由叶子路由器发起，逐跳向上，最终组播转发路径上只存在与组成员相连的分支。</p>
<p>路由器为被裁剪的下游接口启动一个裁剪计时器，计时器超时后接口恢复转发。组播报文重新在全网范围内扩散，新加入的组成员可以接收到组播报文。随后，下游不存在组成员的叶子路由器将向上发起裁剪的操作。这种周期性的扩散-裁剪，PIM-DM周期性的刷新SPT（Shortest Path Tree，最短路径树）。</p>
<p>当下游接口被裁剪后：</p>
<ul>
<li>如果下游叶子路由器有组成员加入，并且希望在下次‘扩散-裁剪’前就恢复组播报文转发，则执行嫁接动作；</li>
<li>如果下游叶子路由器一直没有组成员加入，希望该接口保持一直转发状态，则执行状态刷新动作；</li>
</ul>
<p>会发生Prune的情况：</p>
<ul>
<li><p>该接口下没有接收者；</p>
</li>
<li><p>没有下游PIM邻居；</p>
</li>
<li><p>非RPF接口收到多播流，也就是当前路由器向上游路由器发送Prune；</p>
</li>
<li><p>多路访问环境下由于Assert原因，自己不能转发多播流，重复Prune之前会等待3秒钟延迟来等待有无Join；</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483947038-5a5b82de-e489-41cf-98f2-764c7867599d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483968748-1ca715d6-8b9c-45ae-950f-dba40437fb15.png" alt="img"></p>
<h3 id="嫁接（Graft）"><a href="#嫁接（Graft）" class="headerlink" title="嫁接（Graft）"></a>嫁接（Graft）</h3><p>PIM-DM通过嫁接机制，使有新组成员加入的网段快速得到组播报文。叶子路由器通过IGMP了解到与其相连的用户网段上，组播组G有新的组成员加入。随后叶子路由器会向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S,G）表项下游接口列表中。</p>
<p>嫁接过程从叶子路由器开始，到有组播报文到达的路由器结束。</p>
<h3 id="状态刷新（State-Refresh）"><a href="#状态刷新（State-Refresh）" class="headerlink" title="状态刷新（State Refresh）"></a>状态刷新（State Refresh）</h3><p>在PIM-DM网络中，由于裁剪计时器为3分钟，也就是说3分钟后那些不需要组播，被裁剪了的路由器将会重复一遍‘泛洪——裁剪’的动作，使得网络中充满了组播的泛洪以及裁剪数据，为了避免被裁剪的接口因为‘裁剪定时器’超时而一次次的恢复转发，去消耗网络带宽，离组播源最近的第一跳路由器会周期性的触发State Refresh报文在全网内扩散，收到State Refresh报文的PIM路由器会刷新裁剪定时器的状态，被裁剪接口的下游叶子路由器如果一直没有成员加入，则该接口一直处于被抑制转发的状态。配置命令为到接口下输入: ip pim state-refresh origination-interval XX。</p>
<h3 id="断言（Assert）"><a href="#断言（Assert）" class="headerlink" title="断言（Assert）"></a>断言（Assert）</h3><p>当一个网段内有多个相连的PIM路由器，使用RPF检查通过向该网段转发组播报文时，则需要通过断言机制来保证只有一个PIM路由器向该网段转发组播报文。PIM路由器在接收到邻居路由器发送的相同组播报文后，会以组播的方式向本网段的所有PIM路由器发送Assert报文，其中目的地址为永久组地址224.0.0.13。其他PIM路由器在接收到Assert报文后，将自身参数与对方报文中携带的参数作比较，进行Assert竞选，规则如下：</p>
<ul>
<li><p>单播路由协议优先级较高者获胜；</p>
</li>
<li><p>如果优先级相同，则到组播源的开销较小者获胜；</p>
</li>
<li><p>如果以上都相同，则下游接口IP地址最大者获胜；</p>
</li>
</ul>
<p>根据Assert竞选结果，路由器将执行不同的操作：</p>
<ul>
<li>获胜一方的下游接口称为Assert Winner，将负责后续对该网段组播报文的转发；</li>
<li>落败的乙方的下游接口称为Assert Loser，后续不会对该网段转发组播报文，PIM路由器也会将其从（S,G）表项下游接口列表中删除；</li>
</ul>
<p>Assert竞选结束后，该网段上只存在一个下游接口，只传输一份组播报文。所有Assert Loser可以周期性地恢复组播报文转发，从而引发周期性的Assert竞选。</p>
<h2 id="协议数据包"><a href="#协议数据包" class="headerlink" title="协议数据包"></a>协议数据包</h2><h3 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h3><p>Hello消息的作用是发现和维护邻居关系。默认发送间隔是30秒也就是Hello Interval是30秒，邻居超时时间为Hello的3.5倍，也就是105秒。在PIM-DM网络中，刚启动的组播路由器需要使用Hello消息来发现邻居、维护邻居关系以及选举DR指定路由器。路由器之间周期性的发送Hello消息来构建和维护SPT树（Shortest Path Tree，最短路径树）。在PIM-DM中，只需要Hello报文就能够接收组播的数据而不需要其他的报文。</p>
<p>Hello Interval，在接口下配置发送Hello消息的时间间隔，Hello消息默认周期是30S。Holdtime interval，在接口下配置Hello消息超时的时间，默认情况下超时时间为105S。</p>
<p>Hello消息还有一个重要的功能，就是在多个路由器网段中选举DR指定路由器，DR路由器充当IGMP V1的查询器，查询器的选举由组播协议决定。在PIM-DM中各路由器通过比较Hello消息中携带的优先级和IP地址，为多个路由器网段选举指定路由器DR，充当IGMP V1的查询器。当DR出现故障时，接收Hello消息将会超时，邻居路由器之间会触发新的DR选举过程。</p>
<p><strong>PIM DR的选举过程为：</strong></p>
<ul>
<li>优先级大的为DR，优先级默认为1；</li>
<li>IP地址大的；</li>
</ul>
<p>在PIM-DM模式下，DR只充当IGMP V1版本的查询者，没有其他用途。</p>
<h3 id="Join-Prune"><a href="#Join-Prune" class="headerlink" title="Join\Prune"></a>Join\Prune</h3><p>加入和裁剪组播树。</p>
<p>当有新的组播成员要加入组播组时，它所连入的当前路由器要加入组播树，由于当前路由器以前被</p>
<h3 id="Graft"><a href="#Graft" class="headerlink" title="Graft"></a>Graft</h3><p>嫁接，嫁接报文用于<strong>重新</strong>加入一个组播组，而这个路由器之前使用裁剪动作退出了该组播组。</p>
<p>graft message is specific for re-joining to a group which was pruned by the router earlier</p>
<p>​                                                                  <a target="_blank" rel="noopener" href="https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023">出自</a></p>
<h3 id="Graft-ACK"><a href="#Graft-ACK" class="headerlink" title="Graft ACK"></a>Graft ACK</h3><p>嫁接成功后的确认报文。</p>
<h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>声明。在多路访问环境下，用来协商哪台多播路由器来向该多路访问网络中转发组播数据流。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623486301187-4337483e-bebe-4aef-8254-abcb3b2aaf75.png" alt="img"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>首先保证单播的路由通信正常；</li>
<li>其次在网络设备上配置组播协议：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">全局启用组播：</span><br><span class="line">ip multicast-routing</span><br><span class="line"></span><br><span class="line">三层接口上启用PIM-DM</span><br><span class="line">ip pim dense-mode</span><br></pre></td></tr></table></figure>

<ul>
<li>配置接收节点并‘放号’；</li>
<li>查看与拍错；</li>
</ul>
<p>在接口上配置‘ip pim dense-mode’时，首先必须运行单播路由协议，否则PIM无法做RPF，确定RPF接口；第二是配置了PIM的时候必须每个接口都启用该协议，否则可能会出现RPF故障。</p>
<p>show ip igmp interface XX 来查看接口运行组播情况。</p>
<h2 id="PIM-DM总结"><a href="#PIM-DM总结" class="headerlink" title="PIM DM总结"></a>PIM DM总结</h2><p>PIM-DM对于小型网络来说非常有效。</p>
<p>优点：</p>
<ul>
<li>易于配置，只有两条命令；</li>
<li>实现机制简单，基于泛洪——裁剪；</li>
</ul>
<p>不足：</p>
<ul>
<li><p>泛洪——裁剪的过程不够高效；</p>
</li>
<li><p>复杂的Assert机制；</p>
</li>
<li><p>控制和数据平面混合；</p>
</li>
<li><p>容易导致网络内部所有的路由器上都有（S,G）表项；</p>
</li>
<li><p>可能会导致非确定性的拓扑行为；</p>
</li>
<li><p>不支持共享树；</p>
</li>
</ul>
<h1 id="PIM-SM"><a href="#PIM-SM" class="headerlink" title="PIM-SM"></a>PIM-SM</h1><p>PIM-SM全称是Protocol-Independent Sparse Mode，可以翻译成协议无关组播的稀疏模式。PIM-SM有两种模型，分别是ASM（Any-Source Multicast，任意信源组播)和SSM（Source-Specific Multicast，指定信源组播），ASM模型可以支持PIM-DM和PIM-SM两种模式；SSM模型只有PIM-SM模式，目前PIM-SM用的绝大多数都是SSM模式。</p>
<p>ASM模式出现较早也就是协议更老一些，在组播组中可以存在多个组播源，而SSM在组播组中只能有一个组播源。现网中用的基本都是SSM，而ASM使用较少的原因是安全问题，因为可以指定多个组播源，谁都可以向这个组播发送报文，容易乱套，而SSM都是指定源IP，加上有RPF，安全性相对较好。</p>
<h2 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="ASM模型"><a href="#ASM模型" class="headerlink" title="ASM模型"></a>ASM模型</h3><p>在ASM（Any-Source Multicast）模型中，PIM-SM使用‘拉(pull)模式’转发组播报文，一般应用于组播成员规模相对较大，相对较稀疏的网络。基于这一种西数的网络模型，它的实现方法是：</p>
<ul>
<li><p>在网络中维护一台重要的PIM路由器，汇聚点RP（Rendezvous Point），可以为随时出现的组播成员或组播源服务。网络中所有PIM路由器都知道RP的位置；</p>
</li>
<li><p>当网络中出现组成员（用户主机通过IGMP加入某组播组G）时，最后一跳路由器向RP发送Join报文，逐跳创建（*,G）表项，生成一颗以RP为根的RPT（Rendezvous Point Tree）；</p>
</li>
<li><p>当网络中出现活跃的组播源（组播源向某组播组G发送第一个组播数据）时，第一跳路由器将组播数据封装在Register报文中单播发送给RP，在RP上创建（S,G）表项，注册源信息；</p>
</li>
</ul>
<p>在ASM模型中，PIM-SM的关键机制包括邻居发现、DR精选、RP发现、RPT构建、组播源注册、SPT切换、断言；同时可以通过配置BSR（Bootstrap Router）管理域来实现单个PIM-SM域的精细化管理。</p>
<p>由于ASM用的比较少</p>
<h3 id="SSM模型"><a href="#SSM模型" class="headerlink" title="SSM模型"></a>SSM模型</h3><p>SSM模型是借助PIM-SM的部分技术和IGMP V3\MLD V2来实现的，无需维护RP、无需构建RPT、无需注册组播源，可以直接在源与组播成员之间建立SPT。</p>
<p>SSM的特点是网络用户能够预先知道组播源的具体位置，因此用户在加入组播组时，可以明确指定从哪些源来接收信息，组成员端DR了解到用户主机的需求后，直接向源端发送Join报文，Join报文逐跳向上传输，在源与组成员之间建立SPT。</p>
<p>在SSM模型中，PIM-SM的关键机制包括邻居发现，DR竞选，构建SPT。</p>
<h2 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h2><h3 id="DR选举"><a href="#DR选举" class="headerlink" title="DR选举"></a>DR选举</h3><p>在组播源或组成员所在的网段，通常同时连着多台PIM路由器。这些PIM路由器之间通过交互Hello报文成为PIM邻居，Hello报文中携带DR优先级和该网段接口地址。PIM路由器将自身条件与对方对方报文中携带的信息进行比较，选举出DR来负责源端或组成员端组播报文的收发。选举规则如下：</p>
<ul>
<li>如果网段中所有PIM路由器都支持DR优先级，那么DR优先级较高者获胜；</li>
<li>如果DR优先级相同或该网段存在至少一台PIM路由器不支持在Hello报文中携带DR优先级，则IP地址较大者获胜。</li>
</ul>
<p>如果当前DR出现故障，导致PIM邻居关系超时，其他PIM邻居之间会触发新一轮的DR选举。</p>
<p><a target="_blank" rel="noopener" href="https://www.juniper.net/documentation/us/en/software/junos/multicast/topics/concept/multicast-pim-ssm.html">https://www.juniper.net/documentation/us/en/software/junos/multicast/topics/concept/multicast-pim-ssm.html</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jannet.hk/zh-Hans/post/protocol-independent-multicast-pim/">https://www.jannet.hk/zh-Hans/post/protocol-independent-multicast-pim/</a></p>
<p><a target="_blank" rel="noopener" href="https://cshihong.github.io/2018/02/13/%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%85%B3%E7%BB%84%E6%92%AD-PIM/">https://cshihong.github.io/2018/02/13/%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%85%B3%E7%BB%84%E6%92%AD-PIM/</a></p>
<h1 id="组播衍生问题"><a href="#组播衍生问题" class="headerlink" title="组播衍生问题"></a>组播衍生问题</h1><p>为什么OSPF这种IGP协议的邻居必须直连，没法像BGP一样，非直连也能建立邻居呢？因为BGP使用TCP来建立邻居，TCP连接可以跨设备不需直连，而OSPF使用组播地址建立邻居，也就是224.0.0.5和224.0.0.6，这个地址段不能被路由，传播范围仅限于本链路，不能传给下一个链路，RFC5771上规定的是：</p>
<ol>
<li>Local Network Control Block (224.0.0/24)<br>Addresses in the Local Network Control Block are used for protocol control traffic that is not forwarded off link. Examples of this type of use include OSPFIGP All Routers (224.0.0.5) [RFC2328].</li>
</ol>
<p>所以使用组播建立邻居的动态路由协议，比如OSPF，邻居必须直连，因为用来建立邻居的组播只能在本链路内传递。</p>
<p><a target="_blank" rel="noopener" href="https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023">https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023</a></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a target="_blank" rel="noopener" href="https://networklessons.com/cisco/ccie-enterprise-infrastructure/introduction-to-multicast">Introduction to Multicast</a></p>
<p><a target="_blank" rel="noopener" href="http://wulc.me/2016/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--%E7%BB%84%E6%92%AD%E5%9F%BA%E7%A1%80/">计算机网络课程总结–组播基础</a></p>
<p><a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_IPMulticastAddressing.htm">IP Multicast Addressing</a></p>
<p><a target="_blank" rel="noopener" href="https://network.51cto.com/art/201901/590835.htm">这是全面的IGMP协议总结，没有之一！</a></p>
<p><a target="_blank" rel="noopener" href="https://networkengineering.stackexchange.com/questions/51956/why-we-use-224-as-multicast-address-in-many-protocols">Why we use 224 as multicast address in many protocols?</a></p>
<p><a target="_blank" rel="noopener" href="http://www.tcpipguide.com/free/t_IPMulticasting.htm">IP Multicasting</a></p>
<p><a target="_blank" rel="noopener" href="https://cshihong.github.io/2018/02/12/IGMP%E5%9F%BA%E7%A1%80/">IGMP基础</a></p>
<p><a target="_blank" rel="noopener" href="https://community.cisco.com/t5/switching/multicast-source-tree-pim-graft-shared-tree-pim-join-prune/td-p/1683050">Multicast Source-Tree: PIM-Graft - Shared Tree: PIM Join/Prune</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Rookie</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://renyuan431.github.io/2022/01/20/20-Multicast/">https://renyuan431.github.io/2022/01/20/20-Multicast/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://renyuan431.github.io" target="_blank">Rookie的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="/img/index.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechatpay.png" target="_blank"><img class="post-qr-code-img" src="/img/wechatpay.png" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.png" target="_blank"><img class="post-qr-code-img" src="/img/alipay.png" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/21/21-SDWAN/"><img class="prev-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">21-SDWAN</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/20/19-Switch/"><img class="next-cover" src="/img/index.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">19-Switch</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="disqus_thread"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Rookie</div><div class="author-info__description"></div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">22</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">1</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%ADVS%E5%B9%BF%E6%92%ADVS%E5%8D%95%E6%92%AD"><span class="toc-number">1.</span> <span class="toc-text">组播VS广播VS单播</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%AE%9A%E4%B9%89"><span class="toc-number">2.</span> <span class="toc-text">组播定义</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%9C%B0%E5%9D%80"><span class="toc-number">3.</span> <span class="toc-text">组播地址</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%ADMAC%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84"><span class="toc-number">4.</span> <span class="toc-text">组播MAC地址映射</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%88%86%E5%8F%91%E6%A0%91"><span class="toc-number">5.</span> <span class="toc-text">组播分发树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%89%E6%BA%90%E6%A0%91"><span class="toc-number">5.1.</span> <span class="toc-text">有源树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E6%A0%91"><span class="toc-number">5.2.</span> <span class="toc-text">共享树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91"><span class="toc-number">6.</span> <span class="toc-text">组播数据转发</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#RPF"><span class="toc-number">6.1.</span> <span class="toc-text">RPF</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">6.1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E9%A1%BA%E5%BA%8F"><span class="toc-number">6.1.2.</span> <span class="toc-text">检测顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E4%BC%98%E5%85%88%EF%BC%88%E9%BB%98%E8%AE%A4%EF%BC%89"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">优先级优先（默认）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A9%E7%A0%81%E9%95%BF%E5%BA%A6%E4%BC%98%E5%85%88"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">掩码长度优先</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#IGMP%E5%8D%8F%E8%AE%AE"><span class="toc-number">7.</span> <span class="toc-text">IGMP协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%AE%80%E4%BB%8B"><span class="toc-number">7.1.</span> <span class="toc-text">协议简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E7%89%88%E6%9C%AC"><span class="toc-number">7.2.</span> <span class="toc-text">协议版本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-V1"><span class="toc-number">7.3.1.</span> <span class="toc-text">IGMP V1</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%99%AE%E9%81%8D%E7%BB%84%E6%9F%A5%E8%AF%A2%E5%92%8C%E5%93%8D%E5%BA%94%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.1.</span> <span class="toc-text">普遍组查询和响应机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E6%88%90%E5%91%98%E5%8A%A0%E5%85%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.2.</span> <span class="toc-text">新成员加入机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E6%88%90%E5%91%98%E7%A6%BB%E5%BC%80%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.1.3.</span> <span class="toc-text">组成员离开机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87"><span class="toc-number">7.3.1.4.</span> <span class="toc-text">报文</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-V2"><span class="toc-number">7.3.2.</span> <span class="toc-text">IGMP V2</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E5%99%A8%E9%80%89%E4%B8%BE%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.2.1.</span> <span class="toc-text">查询器选举机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E5%BC%80%E7%BB%84%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.2.2.</span> <span class="toc-text">离开组机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A5%E6%96%87%E5%88%86%E6%9E%90"><span class="toc-number">7.3.2.3.</span> <span class="toc-text">报文分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-V3"><span class="toc-number">7.3.3.</span> <span class="toc-text">IGMP V3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%BB%84%E7%9A%84%E5%8A%A0%E5%85%A5"><span class="toc-number">7.3.3.1.</span> <span class="toc-text">特定组的加入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%AE%9A%E7%BB%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.3.3.2.</span> <span class="toc-text">特定组查询</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-SSM-Mapping"><span class="toc-number">7.3.4.</span> <span class="toc-text">IGMP SSM Mapping</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-1"><span class="toc-number">7.3.4.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.4.2.</span> <span class="toc-text">工作机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IGMP-Proxy"><span class="toc-number">7.3.5.</span> <span class="toc-text">IGMP Proxy</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">7.3.5.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6-1"><span class="toc-number">7.3.5.2.</span> <span class="toc-text">工作机制</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IGMP%E5%91%BD%E4%BB%A4"><span class="toc-number">7.4.</span> <span class="toc-text">IGMP命令</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PIM%E5%8D%8F%E8%AE%AE"><span class="toc-number">8.</span> <span class="toc-text">PIM协议</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-3"><span class="toc-number">8.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E5%88%86%E5%8F%91%E6%A0%91-1"><span class="toc-number">8.1.1.</span> <span class="toc-text">组播分发树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SPT"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">SPT</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RPT"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">RPT</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIM%E8%B7%AF%E7%94%B1%E5%99%A8"><span class="toc-number">8.1.2.</span> <span class="toc-text">PIM路由器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RPF-1"><span class="toc-number">8.1.3.</span> <span class="toc-text">RPF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PIM%E8%B7%AF%E7%94%B1%E8%A1%A8%E9%A1%B9"><span class="toc-number">8.1.4.</span> <span class="toc-text">PIM路由表项</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PIM-DM"><span class="toc-number">9.</span> <span class="toc-text">PIM-DM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-1"><span class="toc-number">9.1.</span> <span class="toc-text">基本原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%A0%E7%A7%8D%E5%8A%A8%E4%BD%9C"><span class="toc-number">9.2.</span> <span class="toc-text">几种动作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0"><span class="toc-number">9.2.1.</span> <span class="toc-text">邻居发现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E6%95%A3%EF%BC%88Flooding%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">扩散（Flooding）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A3%81%E5%89%AA%EF%BC%88Prune%EF%BC%89"><span class="toc-number">9.2.3.</span> <span class="toc-text">裁剪（Prune）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AB%81%E6%8E%A5%EF%BC%88Graft%EF%BC%89"><span class="toc-number">9.2.4.</span> <span class="toc-text">嫁接（Graft）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E5%88%B7%E6%96%B0%EF%BC%88State-Refresh%EF%BC%89"><span class="toc-number">9.2.5.</span> <span class="toc-text">状态刷新（State Refresh）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%AD%E8%A8%80%EF%BC%88Assert%EF%BC%89"><span class="toc-number">9.2.6.</span> <span class="toc-text">断言（Assert）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%8F%E8%AE%AE%E6%95%B0%E6%8D%AE%E5%8C%85"><span class="toc-number">9.3.</span> <span class="toc-text">协议数据包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Hello"><span class="toc-number">9.3.1.</span> <span class="toc-text">Hello</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Join-Prune"><span class="toc-number">9.3.2.</span> <span class="toc-text">Join\Prune</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graft"><span class="toc-number">9.3.3.</span> <span class="toc-text">Graft</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Graft-ACK"><span class="toc-number">9.3.4.</span> <span class="toc-text">Graft ACK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Assert"><span class="toc-number">9.3.5.</span> <span class="toc-text">Assert</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE"><span class="toc-number">9.4.</span> <span class="toc-text">配置</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#PIM-DM%E6%80%BB%E7%BB%93"><span class="toc-number">9.5.</span> <span class="toc-text">PIM DM总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#PIM-SM"><span class="toc-number">10.</span> <span class="toc-text">PIM-SM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86-2"><span class="toc-number">10.1.</span> <span class="toc-text">基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ASM%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.1.</span> <span class="toc-text">ASM模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SSM%E6%A8%A1%E5%9E%8B"><span class="toc-number">10.1.2.</span> <span class="toc-text">SSM模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6"><span class="toc-number">10.2.</span> <span class="toc-text">关键机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DR%E9%80%89%E4%B8%BE"><span class="toc-number">10.2.1.</span> <span class="toc-text">DR选举</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E6%92%AD%E8%A1%8D%E7%94%9F%E9%97%AE%E9%A2%98"><span class="toc-number">11.</span> <span class="toc-text">组播衍生问题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E6%96%87%E7%AB%A0"><span class="toc-number">12.</span> <span class="toc-text">引用文章</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/03/10/tabletest/" title="Java类型与SQL类型的映射表(Mapping table of Java types to SQL types)">Java类型与SQL类型的映射表(Mapping table of Java types to SQL types)</a><time datetime="2022-03-10T11:55:43.000Z" title="发表于 2022-03-10 19:55:43">2022-03-10</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/21/21-SDWAN/" title="21-SDWAN">21-SDWAN</a><time datetime="2022-01-21T02:30:09.000Z" title="发表于 2022-01-21 10:30:09">2022-01-21</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/20/20-Multicast/" title="20-Multicast">20-Multicast</a><time datetime="2022-01-20T07:34:09.000Z" title="发表于 2022-01-20 15:34:09">2022-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/20/19-Switch/" title="19-Switch">19-Switch</a><time datetime="2022-01-20T07:32:18.000Z" title="发表于 2022-01-20 15:32:18">2022-01-20</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2022/01/20/18-MPLSVPN/" title="18-MPLSVPN">18-MPLSVPN</a><time datetime="2022-01-20T07:30:18.000Z" title="发表于 2022-01-20 15:30:18">2022-01-20</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2022 By Rookie</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>function loadDisqus () {
  var disqus_config = function () {
    this.page.url = 'https://renyuan431.github.io/2022/01/20/20-Multicast/'
    this.page.identifier = '2022/01/20/20-Multicast/'
    this.page.title = '20-Multicast'
  };

  window.disqusReset = () => {
    DISQUS.reset({
      reload: true,
      config: disqus_config
    })
  }

  if (window.DISQUS) disqusReset()
  else {
    (function() { 
      var d = document, s = d.createElement('script');
      s.src = 'https://newnotebook.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  }
}

if ('Disqus' === 'Disqus' || !false) {
  if (false) btf.loadComment(document.getElementById('disqus_thread'), loadDisqus)
  else loadDisqus()
} else {
  function loadOtherComment () {
    loadDisqus()
  }
}
</script></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --><script data-pjax>
  function butterfly_clock_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = '/posts/,/about/'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_injector_config();
  }
  </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-butterfly-clock/lib/clock.min.js"></script><script data-pjax src="https://unpkg.zhimg.com/hexo-filter-gitcalendar/lib/gitcalendar.js"></script><script data-pjax>
  function gitcalendar_injector_config(){
      var parent_div_git = document.getElementById('recent-posts');
      var item_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><style>#git_container{min-height: 280px}@media screen and (max-width:650px) {#git_container{min-height: 0px}}</style><div id="git_loading" style="width:10%;height:100%;margin:0 auto;display: block;"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animatetransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animatetransform></path></svg><style>#git_container{display: none;}</style></div><div id="git_container"></div></div>';
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
      console.log('已挂载gitcalendar')
      }

    if( document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
        gitcalendar_injector_config()
        GitCalendarInit("https://gitcalendar.akilar.top/api?renyuan431",['#ebedf0', '#fdcdec', '#fc9bd9', '#fa6ac5', '#f838b2', '#f5089f', '#c4067e', '#92055e', '#540336', '#48022f', '#30021f'],'renyuan431')
    }
  </script><!-- hexo injector body_end end --></body></html>