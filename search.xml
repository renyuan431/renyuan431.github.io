<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10、设备管理及cisco IOS基础配置</title>
    <url>/2020/04/14/10-cisco-ios/</url>
    <content><![CDATA[<h2 id="CISCO路由器及启动过程"><a href="#CISCO路由器及启动过程" class="headerlink" title="CISCO路由器及启动过程"></a>CISCO路由器及启动过程</h2><h3 id="路由器组件"><a href="#路由器组件" class="headerlink" title="路由器组件"></a>路由器组件</h3><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-14_16-22-14.jpg" alt="Snipaste_2020-04-14_16-22-14"></p>
<p>CPU：中央处理器，CPU执行操作系统的指令，例如启动，路由功能和交换功能。</p>
 <span id="more"></span>  

<p>RAM（random access memory）：随机访问存储器，RAM是一种易失性内存，需要持续供电才能保留其内容，如果重启或电源断电的话，该存储器上的内容会全部丢失。RAM上存储那些需要被运行的数据，比如路由器的操作系统、目前正在运行的配置文件（Running Configuration File）、路由表（IP Routing Table）、ARP缓存表（ARP Cache）、缓存数据（Packet Buffer）等。思科设备上运行的操作系统叫做“Cisco IOS”，IOS是Internetwork Operating System的简写，和苹果运行的IOS系统简写一样，话说貌似苹果给了思科授权费才能也用这个简写；Running Configuration File，它是存储了路由器IOS系统目前运行的配置命令，路由器上几乎所有配置命令都存储在running configuration file中，一般叫做running configuration；ARP缓存表（ARP Cache），缓存表中包含了IPV4地址和MAC地址对应的表项，当路由器上有以太网接口时才会有ARP缓存表；缓存数据（Packet Buffer），当接口收到或发出数据前会暂时存储在缓存中，这些暂时存储的数据叫做数据缓存。</p>
<p>ROM（read-only memory），ROM是一种永久性存储，即使断电重启，其中的数据也不会丢失。思科设备中的ROM存储的是，POST，bootstrap，ROMMON，mini-IOS。</p>
<ul>
<li>POST：Power on self test，开机自检程序，用来确定所有必备开机的组建都能正常运行；</li>
<li>bootstrap：开机指令，负责启动路由器并找到IOS系统的位置将其加载到RAM中；</li>
<li>ROMMON：ROMMON是一个精简版IOS程序，在ROMMON上可以进行各种系统检测和进行密码恢复，如果bootstrap成功找到IOS系统则不会进入ROMMON模式，如果bootstrap找不到系统则会进入ROMMON模式；</li>
<li>mini-IOS：Mini-IOS是一个备用工具，它包含了一个剥离版的IOS。它适用于找不到IOS映像的关键情况。Mini-IOS只包含IP代码，允许你从其他资源（如TFTP Server）加载IOS。</li>
</ul>
<p>Flash Memory，Flash Memory是一种非易失性存储，可以通过电子方式进行存储和擦除数据，主要用来存放IOS操作系统。</p>
<p>NVRAM，NVRAM是Nonvolatile RAM的简写，中文是非易失性RAM存储，这种存储在断电或重启时也不会丢失其中的数据，主要用来存放startup configuration，也就是设备的启动配置。</p>
<h3 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h3><h4 id="理论步骤"><a href="#理论步骤" class="headerlink" title="理论步骤"></a>理论步骤</h4><p><img src="/2020/04/14/10-cisco-ios/router-booting-process.jpg" alt="router-booting-process"></p>
<p><img src="/2020/04/14/10-cisco-ios/071613_2203_CCNAPrepInt4.png" alt="071613_2203_CCNAPrepInt4"></p>
<p>路由器开机后，先运行ROM中的POST，也就是进行硬件自检，看必备的开机部件（CPU, RAM和NVRAM）是否都工作正常，如果正常的话，将ROM中的Bootstrap程序拷贝到RAM中运行，当拷贝完毕且在RAM运行后，CPU执行bootstrap程序搜寻IOS操作系统的位置，搜索的过程依次为Flash — TFTP Server — ROM，如果都没有的话则进入ROMMON模式，如果找到操作系统则操作系统会加载到RAM中运行，并加载存储在NVRAM中的开机启动配置，当所有程序都在RAM中成功加载后，开机过程运行完毕。</p>
<h4 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a>实际分析</h4><p><strong>POST</strong> (Power On Self Test) - 首先 Router 会自我检查一下</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-41-19.jpg" alt="Snipaste_2020-05-04_10-41-19"></p>
<p><strong>载入Bootstrap</strong> - 然后会加载Bootstrap这个应用程序，功能是后面加载IOS操作系统。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-43-54.jpg" alt="Snipaste_2020-05-04_10-43-54"></p>
<p><strong>读取Configuration Register</strong> </p>
<p>接下来会读取配置寄存器的数值，预设为0X2102，换算成二进制就是0010 0001 0000 0010 ， 每位都有不同的作用，一般情况下不会改变这个数值，但如果要冲重新设置密码，需要看第六位，也就是从右往左数第七个数字，之所以是第七个数字，是因为右起第一个数字是第零位，右起第二个数字是第一位，以此类推第六位也就是尤其第七个数字：</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-54-08.jpg" alt="Snipaste_2020-05-04_10-54-08"></p>
<p>这个 Bit 可控制 Router 要不要跳过读取 Startup Configuration，预设 0 是不跳过 (即读取)，设成 1 则是跳过 (即不读取)。但开机时是看不到 Configuration Register 的值，只有在开机後用 Show Version 才可看到。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-56-05.jpg" alt="Snipaste_2020-05-04_10-56-05"></p>
<p><strong>载入 IOS</strong> - 依 Flash丶TFTP 和 ROM 的次序载入 IOS，即是我们常常看见很多 # 号那个时刻</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-57-34.jpg" alt="Snipaste_2020-05-04_10-57-34"></p>
<p><strong>载入 Startup Configuration</strong></p>
<p>跟据 Configuration Register 的值决定是否载入 Startup Configuration。如果没有载入或 Startup Configuration 不存在，就会询问是否进行 Initial Configuration，就像打开一台新机一样。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-58-34.jpg" alt="Snipaste_2020-05-04_10-58-34"></p>
<p>无论是 Console 密码丶Enable 密码都是储存在 Startup Configuration 之中，然後被载入至 Running Configuration。然而修改 Configuration 需要 Enable 密码，重设密码的哲学在於「如何在不用密码的情况下进入 Enable Mode (或称 Privilege Mode)</p>
<h3 id="忘记登陆密码如何进入系统"><a href="#忘记登陆密码如何进入系统" class="headerlink" title="忘记登陆密码如何进入系统"></a>忘记登陆密码如何进入系统</h3><h4 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h4><p>配置寄存器（Configuration Register）是一个16位的虚拟寄存器，用于指定路由器启动的次序、中断参数和设置控制台波特率等，不同的配置寄存器数值决定了路由器的启动顺序（比如是从ROM中寻找IOS系统还是直接进入ROMMON模式）以及启动时的一些选项。该寄存器的值通常是以十六进制来表示的。Cisco路由器默认的配置设置是0x2102，这意味着第13位、第8位和第1位是开启的(值为1)。在特权模式下用命令“show version”查看当前配置寄存器的数值为多少。<strong>通过修改该数值可以决定路由器如何启动和运行。</strong></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-30-08.jpg" alt="Snipaste_2020-04-27_10-30-08"></p>
<p>上图中的二进制的0010000100000010，是由0X2102这个16进制的数字换算而来的，换算过程是，分别将2，1，0，2四个16进制换算成2进制然后组合而成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-33-04.jpg" alt="Snipaste_2020-04-27_10-33-04"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-31-47.jpg" alt="Snipaste_2020-04-27_10-31-47"></p>
<p>配置寄存器的默认设置是0x2102。这表明路由器应该尝试从闪存装载Cisco IOS软件镜像和用9600波特的控制台速率装载启动配置。注意，show version命令显示当前配置寄存器的值，也显示路由器重载后配置寄存器新的值。对配置寄存器进行的任何修改在重载之前不会起作用。</p>
<h4 id="口令恢复"><a href="#口令恢复" class="headerlink" title="口令恢复"></a>口令恢复</h4><p>总体思路是，在开机时需跳过载入 Startup Configuration，在没有任何密码的情况下进入 Enable Mode，然後手动载入 Configuration 并修改密码。正如前面介绍过的，配置寄存器的第6位用于告诉路由器是否使用NVRAM中的内容来加载路由器的配置。默认的配置寄存器值是0x2102，即第6位是关闭的(值为0)。默认情况下，路由器会查找并加载存储在NVRAM(startup-config文件)中的路由器配置。若要恢复口令，需要开启第6位，告诉路由器忽略NVRAM的内容，二进制的话就是0010000101000010，换算成16进制就是0X2142，开启了第6位的配置寄存器值是0x2142，所以在口令回复的时候要将寄存器值从默认的0X2102改成0X2142，葫芦i额NVRAM的内容才能进行密码恢复。</p>
<p><strong>1.启动路由器</strong></p>
<p>在IOS系统被载入时按键盘的Ctrl 和 Break键， (如 Mac 可按 Ctrl-Delete) 中断载入，并进入 rommon 模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200504110154.jpg" alt="微信图片编辑_20200504110154"></p>
<p>如果用笔记本的话没有小键盘的Break键，可以试试如下方法：</p>
<p><img src="/2020/04/14/10-cisco-ios/721cbdd9882df4399175d0c93f7577218c8d74c28dcb01a7cecf1411683e66d5.jpg" alt="721cbdd9882df4399175d0c93f7577218c8d74c28dcb01a7cecf1411683e66d5"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-04-56.jpg" alt="Snipaste_2020-05-04_11-04-56"></p>
<p><strong>2.修改配置寄存器，开启第6位，值为0x2142</strong></p>
<p>按 ? 再按 <ENTER> 可以看到可用的指令。而我们想要做的是修改 Configuration Register，由 0x2102 改成 0x2142，指令是 <strong>confreg 2142</strong>，然後用指令 <strong>reset</strong> 重新开机。</ENTER></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-05-46.jpg" alt="Snipaste_2020-05-04_11-05-46"></p>
<p><strong>3.重载路由器</strong></p>
<p> rommon 2 &gt;reset    //Cisco 2600系列路由器</p>
<p> &gt;I    //初始化，Cisco 2500系列路由器</p>
<p><strong>4.进入特权模式将开机启动配置加载到内存</strong></p>
<p>这次开机让它载入 IOS，最後因为没有载入 Startup Configuration 而出现 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-08-36.jpg" alt="Snipaste_2020-05-04_11-08-36"></p>
<p><strong>4.查看明文口令、重设口令</strong></p>
<p> 由於刚才跳过了载入 Startup Configuration，现在手动把 Startup Configuration 抄写至 Running Configuration，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-10-40-1588561857223.jpg" alt="Snipaste_2020-05-04_11-10-40"></p>
<p><strong>5.设置配置寄存器值为默认值</strong></p>
<p>重新开机，再次按键盘 Ctrl-Break (如 Mac 可按 Ctrl-Delete) 进入 rommon 模式，把 Configuration Register 回复至 0x2102 并重新开机，重设密码的步骤便完成了。</p>
<p> <img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-11-43.jpg" alt="Snipaste_2020-05-04_11-11-43"></p>
<h2 id="Cisco-交换机"><a href="#Cisco-交换机" class="headerlink" title="Cisco 交换机"></a>Cisco 交换机</h2><h3 id="交换机启动过程"><a href="#交换机启动过程" class="headerlink" title="交换机启动过程"></a>交换机启动过程</h3><p><strong>POST</strong> (Power On Self Test) - 进行开机硬件自检</p>
<p><strong>flash_init</strong> - 载入 flash_init 的小程式，用作读取 flash 里的档案。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-16-25.jpg" alt="Snipaste_2020-05-04_12-16-25"></p>
<p><strong>载入 IOS</strong> - 依 Flash丶TFTP 和 ROM 的顺序搜索并载入 IOS。</p>
<p><strong>载入 Startup Configuration</strong> - 如 Flash 中有 config.text 这个档案则载入，否则进入 System Configuration Dialog 模式。思科2900及3500系列的交换机并没有Configuration Register，要跳过载入 Startup Configuration 只需在 flash 把 config.text 档名改掉便可。</p>
<h3 id="Switch密码重置步骤"><a href="#Switch密码重置步骤" class="headerlink" title="Switch密码重置步骤"></a>Switch密码重置步骤</h3><h4 id="2950-2960-3550-3560系列"><a href="#2950-2960-3550-3560系列" class="headerlink" title="2950/2960/3550/3560系列"></a>2950/2960/3550/3560系列</h4><p><strong>进入Password-recovery 模式</strong></p>
<p>Switch 没有开关按钮，一插电制便开机了，在插电制的同时按着面版上的 Mode 按钮，直至 Switch 进入 Password-recovery 模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200504122312.jpg" alt="微信图片编辑_20200504122312"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-23-50.jpg" alt="Snipaste_2020-05-04_12-23-50"></p>
<p><strong>更改启动配置文件名称</strong></p>
<p>输入 <strong>flash_init</strong> 挂载 flash 档案系统，然後输入 <strong>dir flash:</strong> 应可看到 flash 里面的档案列表，这里我们的启动配置文件的名称是：config.text，将该文件改名为 config.bak，rename flash:config.text flash:config.bak，然後用指令 <strong>boot</strong> 开始载入 IOS。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-24-44.jpg" alt="Snipaste_2020-05-04_12-24-44"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-29-24.jpg" alt="Snipaste_2020-05-04_12-29-24"></p>
<p>由於系统找不到 config.text，因而没法载入 Startup Configuration 而出现 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-30-18.jpg" alt="Snipaste_2020-05-04_12-30-18"></p>
<p>把 flash:config.bak 改回 flash:config.text，然後把 startup-config 抄至 running-config，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration。重设密码步骤完成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-31-18.jpg" alt="Snipaste_2020-05-04_12-31-18"></p>
<h4 id="3650-3850"><a href="#3650-3850" class="headerlink" title="3650/3850"></a><strong>3650/3850</strong></h4><p>从 3650 开始，Switch 的 IOS 改用 Linux Base，重设密码方法又有点不同，步骤如下：</p>
<p>1、在插电制时先按着面版上的 Mode 去中断正常开机程序。</p>
<p>2、输入指令 SWITCH_IGNORE_STARTUP_CFG=1 (全大写)，这样就会跳过载入 Startup Configuration。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-33-48.jpg" alt="Snipaste_2020-05-04_12-33-48"></p>
<p>3、输入指令 <strong>flash_init</strong> 和 <strong>boot</strong> 把 IOS 载入。</p>
<p>4、系统进入 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-35-10.jpg" alt="Snipaste_2020-05-04_12-35-10"></p>
<p>5、由於刚才跳过了载入 Startup Configuration，所以手动把 Startup Configuration 抄写至 Running Configuration，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-35-45.jpg" alt="Snipaste_2020-05-04_12-35-45"></p>
<p>6、重新开机，再次按住 mode 按钮去中断正常开机程序，把 SWITCH_IGNORE_STARTUP_CFG 的值改回 0，然後输入指令 <strong>flash_init</strong> 和 <strong>boot</strong> 继续开机程序。重设密码步骤完成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-36-13.jpg" alt="Snipaste_2020-05-04_12-36-13"></p>
<h2 id="设备管理及CISCO-IOS介绍"><a href="#设备管理及CISCO-IOS介绍" class="headerlink" title="设备管理及CISCO IOS介绍"></a>设备管理及CISCO IOS介绍</h2><h3 id="CISCO-IOS概述"><a href="#CISCO-IOS概述" class="headerlink" title="CISCO IOS概述"></a>CISCO IOS概述</h3><p>Cisco互联网络操作系统，Cisco私有的网络设备操作系统。它是Cisco 的一项核心技术，该操作系统应用于Cisco路由器、局域网交换机、小型无线接入点等设备。</p>
<p>cisco IOS 可为设备提供下列网络服务：</p>
<ul>
<li>基本的路由和交换功能 </li>
<li>安全可靠地访问网络资源 </li>
<li>网络可伸缩性</li>
</ul>
<h3 id="设备管理方法"><a href="#设备管理方法" class="headerlink" title="设备管理方法"></a>设备管理方法</h3><p>可以通过多种方法访问CLI（Command Line Interface，命令行界面） 环境，CLI是一种基于字符（文本）的界面，要与CLI交互，只需要输入命令，就像在文本编辑器中输入文章那样，在CLI中也可以使用复制黏贴等功能，。最常用的方法有：</p>
<ul>
<li>通过Console接口管理设备 </li>
<li>通过Telnet或SSH远程管理设备 </li>
<li>辅助端口 </li>
</ul>
<h4 id="带内-外管理"><a href="#带内-外管理" class="headerlink" title="带内\外管理"></a>带内\外管理</h4><p>管理网络设备可以分为带外网管(out-of-band)和带内网管（in-band）两种模式。</p>
<h5 id="带外管理"><a href="#带外管理" class="headerlink" title="带外管理"></a>带外管理</h5><p>带外管理是指通过专门的网络通道实现对网络的管理，将网络数据与业务数据分开，为网管数据建立独立通道，只传输管理数据、统计信息、计费信息等，网管数据与业务数据分离，可以提高网管的效率与可靠性，也有利于提高网管数据的安全性。说简单一些，就是另外建立一张网络，只用于网络设备的远程管理，当业务网络出现问题的时候，不会影响到网络设备的远程管理。</p>
<h5 id="带内管理"><a href="#带内管理" class="headerlink" title="带内管理"></a>带内管理</h5><p>带内管理使得网络中的网管数据和业务数据在相同的链路中传输，当管理数据（包括SNMP、Netflow、Radius等）较多时，将会影响到整个网络的性能；管理数据的流量较少时，对整个网络的性能影响不明显，可以采用带内管理。</p>
<p>像是Openview，CiscoWorks、Tivoli这种网络管理软件系统都是带内网管，如果无法通过网络访问被管理对象，则带内管理系统就失效了，这时候就需要使用带外管理。</p>
<p>带内网管的实现有以下几种方式：</p>
<ul>
<li>直接使用物理接口或者Interface VLAN（SVI）的地址就可以实现带内网管。比如一个路由器上G0/0接口的IP地址是10.41.222.13，G0/1的地址是10.41.222.21，那么10.41.222.13、10.41.222.21都可以作为这个路由器的远程管理地址。这种管理方式直接使用业务地址或者互联地址进行管理，是不符合网络安全规范的，很多企业都禁止使用这种管理方式，在一些不是特别严谨的场合使用倒也无妨。</li>
<li>使用Loopback接口进行管理，这种管理方式通常用于骨干网或者配置了OSPF、EIGRP等动态路由协议的网络，如果网络中配置了冗余链路，使用Loopback接口进行管理，也不用担心一条链路中断，这种管理方式也算是最为常见的网管方式了。</li>
<li>使用管理VLAN进行管理，这种管理方式应用于局域网或交换机较多的网络中。通常做法是创建一个专门的管理VLAN，给这个VLAN内配置上管理地址即可。在接入层交换机中，二层交换机不支持三层路由功能，要想实现远程管理就只能使用管理VLAN的方式了。</li>
</ul>
<p>带内网管的优缺点：</p>
<p>优点：直接利用现有的网络资源就可实现网络管理，节约成本，经济性好，带内网管会占用一定资源，但对于正常网络业务来说影响十分有限；</p>
<p>缺点：过分依赖于业务网络的稳定性，当业务网络出现中断的时候会影响到网络设备的远程管理。</p>
<h4 id="通过Console接口管理网络设备"><a href="#通过Console接口管理网络设备" class="headerlink" title="通过Console接口管理网络设备"></a>通过Console接口管理网络设备</h4><p><img src="/2020/04/14/10-cisco-ios/Cisco+console+port.jpg" alt="Cisco+console+port"></p>
<p><img src="/2020/04/14/10-cisco-ios/console.jpg" alt="console"></p>
<p>Console，翻译成中文就是控制台，Console口就是专门用来配置设备的接口，用Console线和电脑连接，常见的Console线有以下几种：</p>
<p>一种是RJ-45（连接设备的Console口） —— DB-9（连接计算机）线，但由于现在很多电脑已经没有了DB-9接口，所以大多情况下需要额外的转接口才能和电脑连接：</p>
<p><img src="/2020/04/14/10-cisco-ios/usb-to-serial-adapter-with-console-cable.jpg" alt="usb-to-serial-adapter-with-console-cable"></p>
<p>另一种是RJ-45（连接设备的Console口） —— USB（连接计算机）线，所有电脑上都有USB接口，所以不用额外的设备即可连接计算机，比较方便，更推荐使用这种线连接设备：</p>
<p><img src="/2020/04/14/10-cisco-ios/AJV5_131962502847611197bIdYqdnY8K.jpg" alt="AJV5_131962502847611197bIdYqdnY8K"></p>
<p>还有一种蓝牙Console线，不受线长约束，非常方便：</p>
<p><img src="/2020/04/14/10-cisco-ios/O1CN011d84wI1b0cM5C4Gqs_!!52403403.jpg" alt="O1CN011d84wI1b0cM5C4Gqs_!!52403403"></p>
<p>用Console先连接好设备与计算机后，可以用超级终端或Secure CRT连接设备</p>
<h5 id="超级终端（HyperTerminal）"><a href="#超级终端（HyperTerminal）" class="headerlink" title="超级终端（HyperTerminal）"></a>超级终端（HyperTerminal）</h5><p>连接上Console线并装好驱动后，设备管理器中的端口选项中会多出一个设备，记住连接的是哪个COM口</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_13-52-21.jpg" alt="Snipaste_2020-04-16_13-52-21"></p>
<p>Win XP系统自带超级终端，可以再附件中找到该工具，其他系统的话需要自行下载。打开超级终端后，有个对话框提示要填写位置电话号码，点击取消关闭该对话框，然后进入连接配置界面，名称随便输入即可。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_13-55-22.jpg" alt="Snipaste_2020-04-16_13-55-22"></p>
<p>确定使用端口为上面设备管理器中的设备后，点击确定。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-40-15.jpg" alt="Snipaste_2020-04-16_14-40-15"></p>
<p>参数建议直接选择还原默认值，注意核对“位/秒”一项的值为9600即可点击确定，成功通过Console口登入设备。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-42-16.jpg" alt="Snipaste_2020-04-16_14-42-16"></p>
<h5 id="Secure-CRT"><a href="#Secure-CRT" class="headerlink" title="Secure CRT"></a>Secure CRT</h5><p>Secure CRT是网工常用的登录并对设备进行配置的强大工具，它支持SSH、Telnet和rlogin等协议，也可运行VBScript 和 JScript 脚本。该软件是一款商业软件，可以免费试用30天。安装好软件后，点击“New Session”新建连接。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-48-36.jpg" alt="Snipaste_2020-04-16_14-48-36"></p>
<p>协议（Protocol）使用Serial，端口（Port）使用设备管理器中显示的COM口号码，波特率（Baud rate）选择9600，其他用默认选项即可，连接名称可以自定义，此处用 “Cisco serial Console”，设置完毕后即可用Secure CRT通过Console口连接到设备。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-48-59.jpg" alt="Snipaste_2020-04-16_14-48-59"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-51-54.jpg" alt="Snipaste_2020-04-16_14-51-54"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-53-48.jpg" alt="Snipaste_2020-04-16_14-53-48"></p>
<p>下次使用时，该连接在Connect标签中会有保存，可直接点击Connect使用进行连接，不用重新配置参数。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-54-08.jpg" alt="Snipaste_2020-04-16_14-54-08"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-55-10.jpg" alt="Snipaste_2020-04-16_14-55-10"></p>
<h3 id="IOS系统的备份与升级"><a href="#IOS系统的备份与升级" class="headerlink" title="IOS系统的备份与升级"></a>IOS系统的备份与升级</h3><h4 id="IOS系统备份"><a href="#IOS系统备份" class="headerlink" title="IOS系统备份"></a>IOS系统备份</h4><p>1、设置TFTP服务器，记住该服务器的IP地址。</p>
<p>2、连接需要备份系统的设备，并登陆到特权模式，然后用show Flash命令查看Flash中有哪些文件：</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_14-01-01.jpg" alt="Snipaste_2020-05-04_14-01-01"></p>
<p>上面这个.bin后缀的文件就是我们要备份的IOS，根据你选择的路由器的不同，这个文件名称也会有所不同，复制这个名称，等会要用到。</p>
<p>3、使用<code>copy</code>命令将flash中的文件备份到tftp服务器。copy<code> </code>flash tftp，然后输入之前记住的TFTP服务器的IP地址，确保服务器与本设备可以正常通信，备份文件名可以进行更改也可以直接回车用IOS的原名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Address or name of remote host []? 192.168.1.100</span><br><span class="line">Destination filename [c2800nm-advipservicesk9-mz.124-15.T1.bin]?</span><br><span class="line">Writing c2800nm-advipservicesk9-mz.124-15.T1.bin...</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">[OK - 50938004 bytes]</span><br><span class="line">50938004 bytes copied in 30.561 secs (1666000 bytes/sec)</span><br></pre></td></tr></table></figure>

<h4 id="IOS系统升级"><a href="#IOS系统升级" class="headerlink" title="IOS系统升级"></a>IOS系统升级</h4><p>当路由器的IOS有了新的版本，可以通过下面的命令来升级，升级前可以使用show flash来查看一下flash空间大小，看看是否可容纳新的IOS文件。</p>
<p>1、从TFTP服务器上拷贝需要升级的IOS文件到Flash上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#copy tftp flash</span><br><span class="line">Address or name of remote host []? 192.168.1.100</span><br><span class="line">Source filename []? c2800nm-advipservicesk9-mz.124-15.T1.bin             /输入TFTP上的新IOS文件名    </span><br><span class="line">Destination filename [c2800nm-advipservicesk9-mz.124-15.T1.bin]?         /输入存放到Flash中的名称</span><br></pre></td></tr></table></figure>

<p>2、路由器询问是否在拷贝新的IOS前删除旧的IOS系统，如果按回车则会删除旧的IOS系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Erase flash: before copying? [confirm]</span><br><span class="line">Erasing the flash filesystem will remove all files! Continue? [confirm]</span><br><span class="line">Erasing device... eee ...erased                                                /删除旧IOS系统中</span><br><span class="line">Erase of flash: complete                                                       /旧IOS系统删除成功</span><br></pre></td></tr></table></figure>

<p>3、删除旧IOS系统后开始拷贝新IOS系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accessing tftp://192.168.1.100/c2800nm-advipservicesk9-mz.124-15.T1.bin...</span><br><span class="line">Loading c2800nm-advipservicesk9-mz.124-15.T1.bin from 192.168.1.100:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">[OK - 50938004 bytes]</span><br></pre></td></tr></table></figure>

<p>4、如果Flash中有多个IOS系统，可以使用下面的命令让这个新的IOS作为默认系统使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#boot system flash flash:c2800nm-advipservicesk9-mz.124-15.T1.bin</span><br></pre></td></tr></table></figure>

<h4 id="IOS系统恢复"><a href="#IOS系统恢复" class="headerlink" title="IOS系统恢复"></a>IOS系统恢复</h4><p>如果IOS文件被不小心删除，或者在升级IOS的过程中突然断电，则可能造成路由器IOS文件的丢失，路由不能正常启动，假设服务器上备份好了路由器的IOS文件，这里手动删除路由器的IOS来模拟IOS丢失的情况，因为IOS文件被删除，重启以后路由器进入了ROM monitor模式，在这个模式下配置下面的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rommon 1 &gt;</span><br><span class="line">rommon 1 &gt; IP_ADDRESS=192.168.1.1               /设置路由器的临时IP，只要和TFTP服务器在同一网段就可以了</span><br><span class="line">rommon 2 &gt; IP_SUBNET_MASK=255.255.255.0         /设置路由器的子网掩码</span><br><span class="line">rommon 3 &gt; DEFAULT_GATEWAY=192.168.1.1          /设置网关，由此可见IOS文件的恢复支持跨网段进行</span><br><span class="line">rommon 4 &gt; TFTP_SERVER=192.168.1.100            /设置TFTP服务器的IP地址</span><br><span class="line">rommon 5 &gt; TFTP_FILE=c2800nm-advipservicesk9-mz.124-15.T1.bin               /设置服务器上IOS的文件名</span><br><span class="line">rommon 6 &gt; tftpdnld                             /开始下载TFTP服务器上指定的IOS文件</span><br><span class="line">Do you wish to continue? y/n [n]: y</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">rommon 7 &gt; reset                                /传输完成后使用reset重启路由</span><br></pre></td></tr></table></figure>

<p><span style="color:red">注意：使用这种方法时，必须连接路由器接口号最小的那个以太网接口</span></p>
<h3 id="CISCO-IOS配置模式"><a href="#CISCO-IOS配置模式" class="headerlink" title="CISCO IOS配置模式"></a>CISCO IOS配置模式</h3><p><strong>用户模式</strong>（User Mode），显示为：cisco&gt; </p>
<p>– 正常登陆设备CLI后的第一个配置模式，只具备最基本的查看权限，输入“？”查询能使用的命令后发现可用命令十分有限。 </p>
<p><img src="/2020/04/14/10-cisco-ios/cisco_cli.png" alt="cisco_cli"></p>
<p>输入命令：enable后即可进入特权模式。</p>
<p><strong>特权模式</strong>（Privilege execute mode），显示为：cisco#</p>
<p>– 从用户模式通过认证（如果设置了密码）后即可进入特权模式，从截图中可以看到，输入“？”查询能使用的命令后发现可用命令相比用户模式多了很多。 </p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-04-54.jpg" alt="Snipaste_2020-04-16_15-04-54"></p>
<p><strong>全局配置模式</strong>（Global Configuration mode），在特权模式中输入config terminal 命令后即可进入全局模式，这个模式主要是针对网络整体参数进行的设置，例如DNS地址或接口IP地址等。从截图中可以看到，输入“？”查询能使用的命令后发现，命令相比前两个模式并不相同。</p>
<p>– 可配置设备全局参数，开启或关闭设备全局特性或功能； </p>
<p>– 从全局配置模式可进入多种不同的其他子配置模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-09-46.jpg" alt="Snipaste_2020-04-16_15-09-46"></p>
<h3 id="CISCO-IOS命令"><a href="#CISCO-IOS命令" class="headerlink" title="CISCO IOS命令"></a>CISCO IOS命令</h3><h4 id="IOS命令结构"><a href="#IOS命令结构" class="headerlink" title="IOS命令结构"></a>IOS命令结构</h4><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-31-37.jpg" alt="Snipaste_2020-04-16_15-31-37"></p>
<ul>
<li>每个IOS 命令都具有特定的格式或语法，并在相应的提示符下执行。 </li>
<li>常规命令语法为命令后接相应的关键字和参数。 </li>
<li>某些命令包含一个关键字和参数子集，此子集可提供额外功能。 </li>
</ul>
<h4 id="CLI的帮助"><a href="#CLI的帮助" class="headerlink" title="CLI的帮助"></a>CLI的帮助</h4><h5 id="命令提示及补全"><a href="#命令提示及补全" class="headerlink" title="命令提示及补全"></a>命令提示及补全</h5><p><strong>命令提示</strong>：输入一半或未输入命令时，在命令行中输入“？”后系统会提示接下来可能存在的补全命令，例如输入rout 然后输入？ 后，系统会告诉用户所有以“ rout ”开头的命令，在本例中有两个，一个是route-map，一个是router，如果没有任何以这个开头的命令则系统会提示用户知道。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-32-57.jpg" alt="Snipaste_2020-04-16_15-32-57"></p>
<p>如果在命令行中不输入任何命令直接输入“？”，则系统会将所有可能运行的命令告知用户。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-04-54-1587022600316.jpg" alt="Snipaste_2020-04-16_15-04-54"></p>
<p><strong>命令补全：</strong>在输入部分命令后，直接按键盘上的TAB键，如果此时用户输入的命令只存在一种可能，则按完TAB键后该命令会自动补全。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-38-17.jpg" alt="Snipaste_2020-04-16_15-38-17"></p>
<h5 id="命令语法检查"><a href="#命令语法检查" class="headerlink" title="命令语法检查"></a>命令语法检查</h5><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-39-40.jpg" alt="Snipaste_2020-04-16_15-39-40"></p>
<h5 id="热键和快捷方式"><a href="#热键和快捷方式" class="headerlink" title="热键和快捷方式"></a>热键和快捷方式</h5><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-40-11.jpg" alt="Snipaste_2020-04-16_15-40-11"></p>
<h4 id="cisco-IOS-基础配置"><a href="#cisco-IOS-基础配置" class="headerlink" title="cisco IOS 基础配置"></a>cisco IOS 基础配置</h4><h5 id="修改设备名称"><a href="#修改设备名称" class="headerlink" title="修改设备名称"></a><strong>修改设备名称</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# hostname AS_SSL_1F_S3640 </span><br><span class="line"></span><br><span class="line">AS_SSL_1F_S3640(config)#</span><br></pre></td></tr></table></figure>

<h5 id="配置用户登录密码："><a href="#配置用户登录密码：" class="headerlink" title="配置用户登录密码："></a><strong>配置用户登录密码</strong>：</h5><p>Console Password</p>
<p>用于限制人员通过控制台（Console）连接访问设备 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#line console 0                                在全局配置模式下进入console口</span><br><span class="line"></span><br><span class="line">R1(config-line)#password  cisco                          将console口登录密码设置成&quot;cisco&quot;</span><br><span class="line"></span><br><span class="line">R1(config-line)#login                                    确认启用该密码</span><br></pre></td></tr></table></figure>

<h5 id="特权模式密码"><a href="#特权模式密码" class="headerlink" title="特权模式密码"></a><strong>特权模式密码</strong></h5><p>限制人员使用特权模式配置设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#enable password cisco          设置非加密的特权模式密码，在查看命令时会显示密码，不安全</span><br><span class="line"></span><br><span class="line">Router(config)#enable secret cisco            设置经过加密的特权模式密码，在查看命令时不会显示密码</span><br></pre></td></tr></table></figure>

<h5 id="VTY-口令"><a href="#VTY-口令" class="headerlink" title="VTY 口令"></a><strong>VTY 口令</strong></h5><p>用于限制人员通过Telnet 远程访问设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#line vty0 4                                   进入编号为0-4的这5条VTY线路中</span><br><span class="line"></span><br><span class="line">Router(config-line)#password cisco                           将VTY远程Telnet登录的密码设置为cisco                    </span><br><span class="line">Router(config-line)#login                                    确认启用该密码</span><br></pre></td></tr></table></figure>

<h5 id="管理配置文件"><a href="#管理配置文件" class="headerlink" title="管理配置文件"></a>管理配置文件</h5><p>将当前配置写入启动配置文件，这样当前运行的配置（running-config）会保存在NVRAM中变成开机配置（startup-config），即使重启或断电后开机后依然会是该配置，下面两条命令均可实现此功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# write                                                    也可简写做wr</span><br><span class="line"></span><br><span class="line">R1# copy running-config startup-config                       将运行配置保存为开机配置</span><br></pre></td></tr></table></figure>

<p>删除启动配置文件，删除开机启动的所有配置，务必谨慎使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# erase startup-config                                     删除</span><br><span class="line"></span><br><span class="line">R1# delete flash:config.text </span><br></pre></td></tr></table></figure>

<h5 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h5><p><strong>TFTP备份</strong></p>
<p>1、通过TFTP软件工具备份公司Cisco2960交换机的配置，用软件建立TFTP服务器，Server interfaces填入启动软件的电脑IP：172.18.1.88，备份文件存放地址E:\Cisco_bak</p>
<p><img src="/2020/04/14/10-cisco-ios/wKioL1i49degZT-jAAA7S9-CkBA600.png-wh_500x0-wm_3-wmp_4-s_13402697.png" alt="wKioL1i49degZT-jAAA7S9-CkBA600.png-wh_500x0-wm_3-wmp_4-s_13402697"></p>
<p>2、用Secure CRT 通过telnet登录2960交换机，使用命令，copy running-config tftp ，然后输入TFTP的IP地址，172.18.1.88，输入备份的文件名为：djjs-as-c2960x-2-config</p>
<p><img src="/2020/04/14/10-cisco-ios/wKiom1i49dex1enpAAAk-J4bNxI721.png-wh_500x0-wm_3-wmp_4-s_1645361981.png" alt="wKiom1i49dex1enpAAAk-J4bNxI721.png-wh_500x0-wm_3-wmp_4-s_1645361981"></p>
<p>3、在E:\Cisco_bak下查看备份的配置文件，确认备份成功。</p>
<p><strong>复制黏贴备份</strong></p>
<p>在全局配置模式下，输入show run，然后将输出的命令行复制黏贴到文本文档中保存起来。</p>
<h5 id="接口相关配置"><a href="#接口相关配置" class="headerlink" title="接口相关配置"></a>接口相关配置</h5><h6 id="进入接口"><a href="#进入接口" class="headerlink" title="进入接口"></a>进入接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)# interface ethernet 0/0             进入Ethernet 0/0接口</span><br><span class="line"></span><br><span class="line">R1(config-if)# </span><br></pre></td></tr></table></figure>

<p>Ethernet是一种接口类型，全称是Fast Ethernet，速率为100M，除此之外还有Gigabit Ethernet，千兆接口。</p>
<p>Ethernet 后面这个0/0，一般命名规则是：模块号/接口序号，0/0就是第0个模块板的第0个编号的接口</p>
<h6 id="设备接口规则："><a href="#设备接口规则：" class="headerlink" title="设备接口规则："></a>设备接口规则：</h6><ul>
<li>固定配置或者低端路由器。其接口编号使用单个数字，如1600路由器的接口编号可以是e0（以太网接口），s0(串行接口0)</li>
<li>中低端模块化路由器，其接口编号使用两个数字，中间用“1”格开，斜杠前面的是模块号，后面是模块接口编号，如2600路由器上的fa0/1表示第1个槽位的第2个接口，该接口是快速以太网接口。</li>
<li>高端模块化路由器，其接口编号有时是三个数字，中间用“/”格开，第一个数字是模块号，第二个数字是该模块上的子卡号，第三个数字是该子卡上的接口模块号。如2800路由器上的G0/0/0表示0槽位第1个子模块上的第一个接口，该接口是 千兆位以太网口。</li>
</ul>
<h6 id="为接口配置IP地址"><a href="#为接口配置IP地址" class="headerlink" title="为接口配置IP地址"></a>为接口配置IP地址</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)# ip address 192.168.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<h6 id="激活接口"><a href="#激活接口" class="headerlink" title="激活接口"></a>激活接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)# no shutdown                   CISCO设备接口默认shutdown状态，必须将接口开启才能使用</span><br></pre></td></tr></table></figure>

<h6 id="配置serial接口"><a href="#配置serial接口" class="headerlink" title="配置serial接口"></a>配置serial接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)# interface serial 0/0                            进入serial 0/0接口</span><br><span class="line">R1(config-if)# ipaddress 192.168.1.1 255.255.255.0          为接口配置IP地址和子网掩码</span><br><span class="line">R1(config-if)# no shutdown                                  将默认为关闭的接口开启</span><br><span class="line">R1(config-if)# clock rate 64000                             在DCE端配置serial接口的时钟信号 </span><br></pre></td></tr></table></figure>

<h5 id="show命令"><a href="#show命令" class="headerlink" title="show命令"></a>show命令</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ? </span><br><span class="line">show version                                                 查看当前操作系统版本 </span><br><span class="line">show running-config                                          查看运行配置 </span><br><span class="line">show startup-config                                          查看启动配置 </span><br><span class="line">show flash                                                   查看FLASH </span><br><span class="line">show cpu                                                     查看CPU利用率 </span><br><span class="line">show memory                                                  查看内存使用情况 </span><br><span class="line">show interface                                               查看端口</span><br><span class="line">show ip interface brief                                      查看所有端口简要情况</span><br></pre></td></tr></table></figure>

<h5 id="设置命令输入同步模式"><a href="#设置命令输入同步模式" class="headerlink" title="设置命令输入同步模式"></a>设置命令输入同步模式</h5><p>输入命令的时候，经常会有路由返回的各种消息打断了你的输入，虽然可以使用”Ctrl+R”来将当前输入转移到新行继续输入，但是这样非常不方便，可以通过下面的命令来让路由返回的消息不影响你的输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#line console 0              /进入console线路，</span><br><span class="line">R1(config-line)#logging synchronous   /设置console线路同步模式，返回的消息就不会打断输出了</span><br><span class="line">R1(config-line)#exec-timeout 0 0     /设置console线路命令输入永不超时，一段时间没有输入以后也不断开连接</span><br></pre></td></tr></table></figure>

<h5 id="返回上级命令"><a href="#返回上级命令" class="headerlink" title="返回上级命令"></a>返回上级命令</h5><p>exit命令是一次退一级的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-line)#exit</span><br><span class="line">R1(config)#</span><br></pre></td></tr></table></figure>

<p>end命令是一次性退到特权模式最外层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-line)#end</span><br><span class="line">R1#</span><br></pre></td></tr></table></figure>

<h5 id="命令缩写"><a href="#命令缩写" class="headerlink" title="命令缩写"></a>命令缩写</h5><p>命令可以缩写，缩写从要求是设备必须能够将缩写命令与其他命令区分开，比如在用户模式下要进入特权模式的命令enable可以缩写成en，因为以en开头的命令只有enable，设备不会将缩写的en错认为是其他命令。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-05_16-22-06.jpg" alt="Snipaste_2020-05-05_16-22-06"></p>
<p>但当缩写的命令有两种及两种以上可能时，缩写则不能使用，如下图中，interface 后面以v开头的命令有多个，这时如果直接回车输入的话，设备并不知道用户要输入具体哪个命令，所以返回一个“命令不完整”的信息。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-05_16-23-54.jpg" alt="Snipaste_2020-05-05_16-23-54"></p>
<h4 id="Running-config-VS-Startup-config"><a href="#Running-config-VS-Startup-config" class="headerlink" title="Running-config VS Startup-config"></a>Running-config VS Startup-config</h4><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-23_16-26-51.jpg" alt="Snipaste_2020-04-23_16-26-51"></p>
<h4 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h4><p>实验1：</p>
<p>结果使R1和R2之间可以连通</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-23_16-28-02.jpg" alt="Snipaste_2020-04-23_16-28-02"></p>
<p>拓扑如上图所示，为两台直连路由器配置直连接口参数，使二者能够通信。</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router# configure terminal                                            进入全局配置模式</span><br><span class="line">Router(config)# hostname R1                                           将路由器名字改为R1</span><br><span class="line">R1(config)#enable secret 123456                                       为特权模式设置密码</span><br><span class="line">R1(config)#line console 0                                             进入console线路</span><br><span class="line">R1(config-line)#logg synchronous </span><br><span class="line">                设置console线路同步模式，返回的消息就不会打断输出了               </span><br><span class="line">R1(config-line)#exec-timeout 0 0     </span><br><span class="line">                设置console线路命令输入永不超时不断开连接   </span><br><span class="line">R1(config-line)#password test                                         设置console线路密码</span><br><span class="line">R1(config)# interface fastethernet 0/0                                进入E0/0接口</span><br><span class="line">R1(config-if)# ip address 192.168.12.1 255.255.255.0                  为E0/0接口配置IP地址</span><br><span class="line">R1(config-if)# no shutdown                                            激活E0/0接口</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router# configure terminal </span><br><span class="line">Router(config)# hostname R2 </span><br><span class="line">R2(config)# interface fastethernet 0/0 </span><br><span class="line">R2(config-if)# ip address 192.168.12.2 255.255.255.0 </span><br><span class="line">R2(config-if)# no shutdown </span><br></pre></td></tr></table></figure>

<p>验证配置：</p>
<p>ping 命令，看两者之间通信是否畅通</p>
<p>ping 192.168.12.2</p>
<p>traceroute 命令，追踪两个IP之间的通信路径</p>
<p>traceroute 192.168.12.2</p>
<p>R2telnet 远程连接R1，看设置是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#telnet 192.168.12.1</span><br><span class="line">Trying 192.168.12.1 ... Open</span><br><span class="line">User Access Verification</span><br><span class="line">Password: /*输入远程访问密码123456*/</span><br><span class="line">R1&gt;en</span><br><span class="line">Password: /*输入R1上的特权密码test*/</span><br><span class="line">R2# /*这样就进入了R2的特权模式了*/</span><br></pre></td></tr></table></figure>

<h2 id="CRT软件使用简介"><a href="#CRT软件使用简介" class="headerlink" title="CRT软件使用简介"></a>CRT软件使用简介</h2><h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><p><a href="http://vmnf.no-ip.org/itblog/how-to-setup-a-serial-console-connection/">How to Setup a serial Console connection</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_635e1a9e0101172t.html">管理配置寄存器和路由器口令恢复</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/password-recovery/">Password Recovery 重设密码</a></p>
<p><a href="https://www.qingsword.com/qing/707.html#CCNA-ios-manager-6">[CCNA图文笔记]-27-Cisco设备文件管理与密码恢复</a></p>
<p><a href="https://www.qingsword.com/qing/490.html">[CCNA图文笔记]-8-Cisco路由CLI基础命令</a></p>
<p><a href="https://blog.51cto.com/u_9691128/4568696">带内网管与带外网管</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>12、RIP</title>
    <url>/2020/06/18/12-RIP/</url>
    <content><![CDATA[<h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>RIP（Routing Information Protocol，路由信息协议），是早期应用比较普遍的内部网关协议，是典型的距离矢量路由协议，适用于小型网络，最大的缺点是无法在具有冗余链路的网络中有效的运用。RIP一共有3个版本的协议，分别是RIP V1，RIP V2以及RIPNG。</p>
<p>RIP定义了请求信息和响应消息两种类型。请求信息：可以请求整张路由表，也可以请求具体的路由信息。</p>
<ul>
<li>请求整张路由表：请求消息含有一个地址族标识字段为0（地址为0.0.0.0），度量值为16的单条路由，收到这个请求的设备将通过单播方式向发出请求的地址回送它的整个路由表。</li>
<li>请求具体路由信息：当需要获知某个或某些具体路由的信息时，请求消息将与特定地址的路由条目一起发送。接受到请求的设备将根据请求消息逐个处理这些条目，并构成一个响应消息。</li>
</ul>
 <span id="more"></span>  

<h3 id="V1和V2的相同点"><a href="#V1和V2的相同点" class="headerlink" title="V1和V2的相同点"></a>V1和V2的相同点</h3><ol>
<li>RIP V1和V2协议的算法均为贝尔曼福特算法。</li>
<li>采用相同的防环机制，这六大机制为水平分割，路由中毒，毒性反转，触发更新，最大跳数，占用时间Hold Time。</li>
<li>端口号、协议号、管理距离和度量值相同。UDP端口号520，协议号17，管理距离（AD）是120，度量值均为跳数。</li>
<li>收敛速度和更新机制相同。更新机制均为周期更新、触发更新或完全更新、增量更新。RIP默认每隔30秒周期性的发送整个路由表给邻路由。</li>
<li>没有邻居机制，但有数据库。</li>
</ol>
<h3 id="V1和V2的不同点"><a href="#V1和V2的不同点" class="headerlink" title="V1和V2的不同点"></a>V1和V2的不同点</h3><ol>
<li><p>RIP V1是有类路由协议，发送路由更新<strong>不携带</strong>子网掩码，默认在有类边界自动汇总，不可关闭；RIP V2使用无类路由，发送路由更新要携带子网掩码，默认在有类边界自动汇总，但可以关闭。</p>
</li>
<li><p>V1不支持认证，V2支持认证。</p>
</li>
<li><p>V1采用广播更新路由，V2采用组播更新路由，组播地址为224.0.0.9。</p>
</li>
</ol>
<h3 id="V1的缺陷"><a href="#V1的缺陷" class="headerlink" title="V1的缺陷"></a>V1的缺陷</h3><p>RIPv1是一个有类路由协议，可以支持带子网的网络地址，但是必须是连续的，中间不被其他主类网络分隔，并且子网掩码长度必须相同。所以后面RIP 又推出了V2版本对此进行了一些改进。</p>
<h3 id="V2的改进"><a href="#V2的改进" class="headerlink" title="V2的改进"></a>V2的改进</h3><ol>
<li>外部路由标记。通过在RIP中使用路由标记，就能在其他协议中，控制相关路由的重发布，当重发布到其他协议时，RIP路由只需要比较赋予他们的标记而不用比较整个路由。</li>
<li>在路由更新中携带有子网掩码的路由选择信息，所以支持了VLSM和CIDR。</li>
<li>组播能力。使用224.0.0.9的组播地址发送路由更新，代替了V1的广播更新。</li>
<li>提供身份验证功能，支持明文和MD5认证。</li>
<li>支持连续子网以及不连续子网。</li>
<li>可以关闭自动汇总，并支持手动汇总。</li>
</ol>
<h3 id="V1和V2兼容性"><a href="#V1和V2兼容性" class="headerlink" title="V1和V2兼容性"></a>V1和V2兼容性</h3><p>默认情况下CISCO路由器上运行的 RIP发送v1，接收v1 v2， 如果显示声明为v1（在RIP进程中使用version 1命令）则只发送和接受v1报文，v2默认只发送和接收v2报文。</p>
<h3 id="RIP的计时器"><a href="#RIP的计时器" class="headerlink" title="RIP的计时器"></a>RIP的计时器</h3><p>Update timer更新计时器：RIP默认路由信息交换的时间为30秒一次。</p>
<p>Invalid timer无效计时器：当一条路由条目被加进路由表后，如果它在路由表中超过180秒未被更新，则路由器认为这条路由无效，在这种情况下，路由器会将该路由的跳数标记为16跳，也就是不可达。</p>
<p>hold down timer抑制计时器：一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。大概过程是如果一个路由器从邻居路由器收到一条更新，提示以前可达的网络现在不可达了，或有一个更大跳数的路由，则路由器标识该路由为不可达并启动一个抑制计时器，如果在定时器到时之前收到该路由又可达的更新，或者新度量值比之前的度量值更好，则路由器标识这个路由可达并删除定时器。路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。RIP的抑制计时器默认为6个更新的周期，也就是6X30，为180秒。</p>
<p>Flush time清除计时器：清除计时器的默认时间为240秒，也就是说如果240秒内一条路由如果始终没有相应，则该路由条目被标记为不可达并从路由表中移除。</p>
<h2 id="RIP-V2"><a href="#RIP-V2" class="headerlink" title="RIP V2"></a>RIP V2</h2><h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p><img src="/2020/06/18/12-RIP/RIP_msgformat.PNG" alt="RIP_msgformat"></p>
<p><img src="/2020/06/18/12-RIP/Snipaste_2020-06-21_15-54-09.jpg" alt="Snipaste_2020-06-21_15-54-09"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#router rip</span><br><span class="line">/*使用RIPv2，如果不使用这条命令默认是使用RIPv1*/</span><br><span class="line">Router(config-router)#version 2</span><br><span class="line">/*和RIPv1相同，都是宣告主类网络号*/</span><br><span class="line">R1(config-router)#no auto-summary  </span><br><span class="line">/*关闭自动汇总*/</span><br><span class="line">Router(config-router)#network 主类网络号</span><br><span class="line">Router(config-router)#int s0/0</span><br><span class="line">/*关闭自动汇总后，配置手动汇总的话需要在接口上进行配置，汇总是在路由的外出接口上面做的*/</span><br><span class="line">R1(config-if)#ip summary-address rip 汇总网络号  汇总掩码</span><br><span class="line">/*等待路由收敛后，查看路由表，就只能看到汇总路由的条目了*/</span><br></pre></td></tr></table></figure>

<h3 id="被动接口"><a href="#被动接口" class="headerlink" title="被动接口"></a>被动接口</h3><p>当一个运行RIP协议的接口被配置为被动接口后，这个接口不发出路由的更新信息但接受路由的更新信息。</p>
<p>配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#router rip </span><br><span class="line">R1(config-router)#passive-interface s1/1</span><br><span class="line">/*将S 1/1接口配置为被动接口*/</span><br></pre></td></tr></table></figure>

<h2 id="RIP-综合实验"><a href="#RIP-综合实验" class="headerlink" title="RIP 综合实验"></a>RIP 综合实验</h2><p><img src="/2020/06/18/12-RIP/Snipaste_2020-06-21_17-13-05.jpg" alt="Snipaste_2020-06-21_17-13-05"></p>
<h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><ol>
<li>网络拓扑如上图所示。 PC1 使用模拟器模拟，R3 下联的网段使用 Loopback 接口来模拟，一共开设三个 Loopback 接口，用于模拟 R3 下联的三个网段；</li>
<li>要求 R1、R2、R3 运行 RIPv2，并实现全网可达；</li>
<li>在 R3 上部署 RIP 手工路由汇总，使得 R1、R2 学习到 R3 下联 Loopback 的汇总路由。 </li>
</ol>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>PC1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname PC1</span><br><span class="line">PC1(config)#ip default-gateway 172.16.1.254</span><br><span class="line">/*配置默认网关为172.16.1.254，也就是和本社设备链接的R1的G0/1接口*/</span><br><span class="line">PC1(config)#no ip routing</span><br><span class="line">/*关闭路由功能，当成PC设备使用*/</span><br><span class="line">PC1(config)#int G0/0</span><br><span class="line">PC1(config-if)#no sh</span><br><span class="line">/*路由器接口默认关闭，这里打开该接口*/</span><br><span class="line">PC1(config-if)#ip add 172.16.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R1</span><br><span class="line">R1(config-line)#int g0/1</span><br><span class="line">R1(config-if)#no sh</span><br><span class="line">R1(config-if)#ip add 172.16.1.254 255.255.255.0</span><br><span class="line">R1(config-if)#int g0/0</span><br><span class="line">R1(config-if)#no sh</span><br><span class="line">R1(config-if)#ip add 192.168.12.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R2</span><br><span class="line">R2(config)#int g0/0</span><br><span class="line">R2(config-if)#no sh</span><br><span class="line">R2(config-if)#ip add 192.168.12.2 255.255.255.0</span><br><span class="line">R2(config-if)#int g0/1</span><br><span class="line">R2(config-if)#no sh</span><br><span class="line">R2(config-if)#ip add 192.168.23.2 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R3</span><br><span class="line">R3(config)#int g0/0</span><br><span class="line">R3(config-if)#no sh</span><br><span class="line">R3(config-if)#ip add 192.168.23.3 255.255.255.0</span><br><span class="line">R3(config)#int loop 1</span><br><span class="line">R3(config-if)#ip add 172.16.32.1 255.255.255.0</span><br><span class="line">R3(config-if)#int loop 2</span><br><span class="line">R3(config-if)#ip add 172.16.33.1 255.255.255.0</span><br><span class="line">R3(config-if)#int loop 3</span><br><span class="line">R3(config-if)#ip add 172.16.34.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="配置RIP"><a href="#配置RIP" class="headerlink" title="配置RIP"></a>配置RIP</h3><p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)#router rip</span><br><span class="line">R1(config-router)#version 2</span><br><span class="line">R1(config-router)#no auto-summary</span><br><span class="line">R1(config-router)#network 172.16.0.0</span><br><span class="line">R1(config-router)#network 192.168.12.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-if)#router rip</span><br><span class="line">R2(config-router)#version 2</span><br><span class="line">R2(config-router)#no auto-summary</span><br><span class="line">R2(config-router)#network 192.168.12.0</span><br><span class="line">R2(config-router)#network 192.168.23.0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#router rip</span><br><span class="line">R3(config-router)#version 2</span><br><span class="line">R3(config-router)#no auto-summary</span><br><span class="line">R3(config-router)#network 172.16.0.0</span><br><span class="line">/*RIP 在使用 network 命令指定网段时，只支持通告主类网络。R3 有三个 Loopback接口，将这三个接口激活RIP时，只需network 172.16.0.0即可，实际上即使你输 入诸如network 172.16.32.0这样的命令， 系统也会按network 172.16.0.0生效*/</span><br><span class="line">R3(config-router)#network 192.168.23.0</span><br></pre></td></tr></table></figure>

<h3 id="优化路由"><a href="#优化路由" class="headerlink" title="优化路由"></a>优化路由</h3><p>R3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#int g0/0</span><br><span class="line">R3(config-if)#ip summary-address rip 172.16.32.0 255.255.252.0</span><br><span class="line">/*把三个loopback接口的网段汇总以后是172.16.32.0 255.255.255.252。</span><br><span class="line">RIP 的手工汇总，需要 RIP 版本 2 的支持，另外需要先在 RIP 进程中 no  auto-summary 关闭自动汇总功能，然后再在接口上配置手工汇总命令，注意，该命令配置在汇总 路由欲对外发布的那个接口上。*/</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://ccietea.com/">红茶三杯CCNA实验手册</a></p>
<p><a href="http://ccietea.com/">红茶三杯Ip routing</a></p>
<p><a href="https://www.qingsword.com/qing/570.html#Cisco-CCNA-RIPv1-defect-9">[CCNA图文笔记]-14-RIPv1协议缺陷详解</a></p>
<p><a href="https://www.qingsword.com/qing/576.html">[CCNA图文笔记]-15-RIPv2协议详解</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>11、路由基础及静态路由</title>
    <url>/2020/05/04/11-route-basic/</url>
    <content><![CDATA[<h1 id="路由的基本概念"><a href="#路由的基本概念" class="headerlink" title="路由的基本概念"></a>路由的基本概念</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><blockquote>
<p>Routing is the process of selecting a path for traffic in a network or between or across multiple networks.</p>
<p>In packet switching networks, routing is the higher-level decision making that directs network packets from their source toward their destination through intermediate network nodes by specific packet forwarding mechanisms.</p>
</blockquote>
<p>路由是指在一个网络中或多个网络之间或跨多个网络的流量选择路径的过程。路由是指通过特定的数据包转发机制，将网络数据包从源头通过中间网络节点向目的地方向引导网络数据包的高级决策。路由过程通常根据路由表指导转发。<strong>路由是一个三层（网络层）的概念</strong>。</p>
<p>当路由器（或者其他三层设备）收到一个 IP 数据包，路由器会找出 IP 包三层头中的目的 IP地址，然后拿着目的IP地址到自己的路由表中进行查找，找到“最匹配”的条目后，将数据包根据路由条目所 指示的出接口或下一跳 IP 转发出去，这就是 IP 路由（IP routing） 。而每台路由器都会在本地维护一个路由表 （Routing Table） ，路由表中装载着路由器获知的路由条目（Routes） ，路由条目由路由前缀（路由所关联的目的 地） 、路由信息来源、出接口或下一跳 IP 等元素构成。路由器通过静态的或者动态的方式获取路由条目并维护自 己的路由表。</p>
 <span id="more"></span>  

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_12-17-05.jpg" alt="Snipaste_2020-05-05_12-17-05"></p>
<p>具体到这张图上来说，PC1要和PC2进行通信，路由“指挥”着数据沿着红色箭头的路径一路传到了PC2。但路由器如何知道该如何传递数据呢？是因为路由器在收到数据以后查询了本机的路由表。</p>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><h4 id="路由收敛"><a href="#路由收敛" class="headerlink" title="路由收敛"></a>路由收敛</h4><p>路由收敛指网络的拓扑结构发生变化后，路由表重新建立到发送再到学习直至稳定，并通告网络中所有相关路由器都得知该变化的过程。也就是网络拓扑变化引起的通过重新计算路由而发现替代路由的行为。路由的收敛时间是指从网络的拓扑结构发生变化到网络中所有路由设备中路由表重新保持一致的状态转换过程。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-27-23.jpg" alt="Snipaste_2020-05-14_17-27-23"></p>
<p>比如之前R4发送到R6数据是通过两者的G0/0直接发送，如果当两者之间G0/0直连的线路出现故障：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-29-41.jpg" alt="Snipaste_2020-05-14_17-29-41"></p>
<p>也就是网络的拓扑结构发生了变化，那么R4之前的路由表要发生变化，并且要重新查找去往R6的路由，最后发现可以通过R4-R5然后到达R6，然后R4重新构筑路由表，把前往R6网段的路径由R4-R6变更为R4-R5-R6，当链路上所有路由器的路由表都包含相同的网络可达信息，路由表不再发生变化进入一个稳定状态后，说明路由器的路由表收敛完毕。</p>
<h4 id="通信是双向的"><a href="#通信是双向的" class="headerlink" title="通信是双向的"></a>通信是双向的</h4><p>绝大部分的通信是双向的，这是由应用层的程序的功能决定的，所以在传输数据时要有来回的路由，比如R1-R2-R3三台路由器，R1需要和R3通信，R1需要有R3的路由这个大多数人都明白，因为没有R3的路由表R1不知道将数据如何发送，但R3也需要有R1的路由这个可能有一些人会忽略或不理解，这是因为常见的绝大多数应用层的应用程序是需要双向交互的，比如常用的检测链路是否通常的ICMP中的PING命令，当R1   ping  R3时，你发送出去了ICMP request（需要R1到R3的路由），对方要回复ICMP reply（需要R3到R1的路由），如果没有这个ICMP reply，R1就不知道ping通与否，所以这个通信是需要来回双向通信的。还有很多软件在传输层用TCP协议，又因为TCP的三次握手是双向的，所以这种情况下同时需要双向的路由，既要能去也要能回。当然也有少数的应用，比如IPTV，纯单向应用，单纯的把节目的流量推送给用户即可，不需要返回什么东西，这种情况下只有单项路由就可以了。</p>
<h4 id="动态路由协议端口号或协议号"><a href="#动态路由协议端口号或协议号" class="headerlink" title="动态路由协议端口号或协议号"></a>动态路由协议端口号或协议号</h4><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-10_11-08-18.jpg" alt="Snipaste_2020-06-10_11-08-18"></p>
<h4 id="有类路由、无类路由"><a href="#有类路由、无类路由" class="headerlink" title="有类路由、无类路由"></a>有类路由、无类路由</h4><p>CISCO 路由器在路由的全局查找上有两种方式：有类（Classful）查找方式及无类（Classless）查找方式。 当路由器执行无类别路由查找时（默认，ip classless），它不会注意目的地址的类别，它会在目的地址和所有 己知的路由之间逐位(bit by bit)执行最长匹配； 而如果是有类路由查找（no ip classless 且关闭ip cef） ，那么收到一个数据包时，路由器先查找目的地址所 属主类，如果路由表中有主类路由，则再去找子网，如果有子网路由，则查询被限定在这些子网中，并进一步查 找，如果最终查找失败（没有任何子网匹配这条路由） ，则丢弃数据包，即使有默认路由存在；如果本地没有该主 类路由，则看是否有默认路由，如果有，则按默认路由转发，如果无，则丢弃数据包。</p>
<p>目前基本所有在用的网络设备都是无类方式，有类如果看一遍不太懂可以暂时不看。</p>
<h4 id="loopback接口"><a href="#loopback接口" class="headerlink" title="loopback接口"></a>loopback接口</h4><ol>
<li>Loopback接口，也叫环回口，是一个逻辑的、虚拟的接口；</li>
<li>使用全局配置命令interface loopback 加上接口编号可创建一个Loopback接口，创建完成后即可为接口配置IP地址； </li>
<li>Loopback接口在手工创建后，除非人为shutdown，否则不会DOWN掉；</li>
<li>Loopback接口常用于： </li>
</ol>
<ul>
<li>模拟路由器的直连网段，可用于测试； </li>
<li>可用于设备管理（Loopback接口比较稳定，如果用其他接口的话，如果路由器的某一个接口由于故障down 掉了，但是其他的接口却仍旧可以telnet ，也就是说，到达这台路由器的TCP连接依旧存在，用Loopback接口就能成功Telnet这台设备。）； </li>
<li>供其他协议使用，例如OSPF、BGP、MPLS等，通常用作Router ID；</li>
<li>SNMPTraps消息的源地址； </li>
</ul>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><h3 id="路由表的概念"><a href="#路由表的概念" class="headerlink" title="路由表的概念"></a>路由表的概念</h3><blockquote>
<p>In computer networking a routing table, or routing information base (RIB), is a data table stored in a router or a network host that lists the routes to particular network destinations, and in some cases, metrics (distances) associated with those routes. The routing table contains information about the topology of the network immediately around it.</p>
</blockquote>
<p>在计算机网络世界中，路由表，或者路由信息表（RIB），是存储在路由器或网络主机上的数据表，数据表中列出了去往特定网络目的地的路由，在某些情况下，还列出了与这些路由相关的度量值（距离）。路由表包含有关其周围网络拓扑的信息。</p>
<ul>
<li>每一台<strong>路由器、防火墙或三层交换机等三层设备</strong>都会维护一个路由表，在路由表中包含着路由器发现的路由（路由条目、路由表项）； </li>
<li>路由表相当于路由器的地图，路由器能够正确转发IP报文的前提是在其路由表中存在匹配该数据包目的IP地址的路由条目； </li>
<li>路由表中的路由条目获取来源有多种：直连路由、静态路由及动态路由协议。</li>
<li>路由表储存在RAM中，一般包括–源信息, 网络地址和子网掩码, 下一跳路由的IP地址</li>
</ul>
<p>举一个不太严谨的例子，路由表有点像我们去一个不认识地方时候问那附近的人路该怎么走，知道下一步如何走的这个人的功能类似于路由表。</p>
<h3 id="路由表的构成"><a href="#路由表的构成" class="headerlink" title="路由表的构成"></a>路由表的构成</h3><p>每个路由表项最少必须包括下面三个项目： </p>
<ul>
<li>目标地址（路由前缀） ： 这是路由条目所关联的目的网络号。一条完整的路由前缀由：网络号+前缀长度构成，两者缺一不可，例如 192.168.1.0/24 与 192.168.1.0/25，虽然两者的网络号相同，都是 192.168.1.0，但 是两者绝对是两条不同的路由、两个不同的路由前缀，因为他们的前缀长度不相同。 </li>
<li>指向目标的指针： 指针不是指向路由器的直连目标网络就是指向直连网络内的另一台路由器地址,或者是到这个链路的本地接口。更接近目标网络一跳的路由器叫下一跳(next hop)路由器。 </li>
<li>路由信息的来源： 本条路由是通过什么途径学习到的，例如是静态的，或者是通过 OSPF、IS-IS、 EIGRP、BGP 等动态路由学习到的。 </li>
</ul>
<h3 id="如何查看路由表"><a href="#如何查看路由表" class="headerlink" title="如何查看路由表"></a>如何查看路由表</h3><p>查看路由表的命令为：show ip route</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-50-46.jpg" alt="Snipaste_2020-05-04_19-50-46"></p>
<p>上图中的C表示直连路由，S表示静态路由。其他常用的路由获取来源还有O，也就是通过OSPF协议获得的，以及D，通过EIGRP协议获得。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-57-10.jpg" alt="Snipaste_2020-05-04_19-57-10"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-58-52-1588593580832.jpg" alt="Snipaste_2020-05-04_19-58-52"></p>
<p>思科路由器接口开机以后默认是关闭状态，必须到接口中使用“no shutdown”命令将接口开启，路由表才能更新该路由。</p>
<h2 id="路由条目获取的来源"><a href="#路由条目获取的来源" class="headerlink" title="路由条目获取的来源"></a>路由条目获取的来源</h2><h3 id="直连路由"><a href="#直连路由" class="headerlink" title="直连路由"></a>直连路由</h3><h4 id="直连路由定义"><a href="#直连路由定义" class="headerlink" title="直连路由定义"></a>直连路由定义</h4><p>路由器的直连接口所在网络的信息。这种路由不需要手工进行添加，只要端口连通信正常即可自动加入路由表。</p>
<h4 id="直连路由产生条件"><a href="#直连路由产生条件" class="headerlink" title="直连路由产生条件"></a>直连路由产生条件</h4><ol>
<li>接口配置IP地址</li>
<li>接口状态是UP</li>
</ol>
<p><strong>在满足以上两个条件时，直连路由自动产生，自动填充到路由表中。</strong></p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-02-48.jpg" alt="Snipaste_2020-05-05_13-02-48"></p>
<p>R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-04-11.jpg" alt="Snipaste_2020-05-05_13-04-11"></p>
<p>R1的路由表中有两条路由，一条前缀为C的路由表示这条路由的性质是connect，也就是靠直连获得的，这条路由是通往192.168.12.0/24这个网段的，出口是G0/0，也就是说如果收到一个目标IP地址是属于192.168.12.0网段的消息，将它从G0/0接口发出即可，这条直连路由是由R2的G0/1接口提供的，图中R1的G0/0接口和R2的G0/1接口直接连接；另一条前缀为L表示这条路由的性质为local，也就是本地路由，这条路由目的地址是192.168.12.1/32这个IP地址，连接到G0/0接口，这条路由是由本地的G0/0接口提供的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-13-09.jpg" alt="Snipaste_2020-05-05_14-13-09"></p>
<p>要注意的是，R2的G0/1接口和R1的G0/0接口直接连接，所以R1只有R2的G0/1这个直连接口，也就是192.168.12.0/24这个网段的路由，但并没有R2的G0/0，192.168.23.0/24这个网段的路由，因为R2的G0/0接口和R1不直接连接。</p>
<p>R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-06-22.jpg" alt="Snipaste_2020-05-05_13-06-22"></p>
<p>R2的路由表中有四条路由，两条本地路由两条直连路由。两条本地路由分别由G0/1和G0/0提供，目的地址分别是192.168.12.2/32以及192.168.23.2/32这两个IP地址。两条直连路由其中一条是由R1的G0/0提供的192.168.12.0/24网段的路由，因为R1的G0/0和R2的G0/1直连；另一条直连路由是由R3的G0/0提供的192.168.23.0/24网段的路由，因为R3的G0/0接口和R2的G0/0接口直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-14-58.jpg" alt="Snipaste_2020-05-05_14-14-58"></p>
<p>R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-07-45.jpg" alt="Snipaste_2020-05-05_13-07-45"></p>
<p>R3的路由表中有两条路由，一条本地路由一条直连路由，本地路由是到192.168.23.3/32这个IP地址的，由G0/0接口提供；直连路由时由R2的G0/0接口提供的到192.168.23.0/24这个网段的路由，因为R2的G0/0和R3的G0/0直连。</p>
<p>这里也要注意，R3只有R2的G0/0这个接口IP地址所处的网段，192.168.23.0/24的路由因为两者直连，但并没有R2的G0/1接口IP地址所处网段192.168.12.0/24的路由，因为R2的G0/1接口不和R3直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-24-19.jpg" alt="Snipaste_2020-05-05_14-24-19"></p>
<p>如果其中一个接口和对端的连通性出了问题，比如R2的G0/0或对端对应的接口（R3的G0/0）如果被shutdown或中间网线断开连接，则192.168.23.0这条路由会在R2的路由表中消失。直连的网络是指R1和R2之间，R2和R3之间这种中间没有其他三层设备的情况，R1和R3之间因为有R2路由器隔离了三层，不处于相同的广播域所以不算直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_20-32-23.jpg" alt="Snipaste_2020-05-04_20-32-23"></p>
<p> <a href="/download/static-route.zip">实验文件下载</a></p>
<p>此文件在EVE模拟器中使用，IOS如下图，我这个实验用的是VIOS，如果你的EVE里没有这个IOS记得在设备开机前对设备点击右键将设备的IOS换成其他的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-08-48.jpg" alt="Snipaste_2020-05-05_13-08-48"></p>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>静态路由就是由手工为路由器添加的静态路由条目。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>通过在路由器上运行动态路由协议，使得路由器之间能够交互“用于路由计算的信息”，从而路由器动态的“学习”到网络中的路由。</p>
<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="路由协议的定义"><a href="#路由协议的定义" class="headerlink" title="路由协议的定义"></a>路由协议的定义</h3><blockquote>
<p>A routing protocol specifies how routers communicate with each other to distribute information that enables them to select routes between any two nodes on a computer network. Routers perform the “traffic directing” functions on the Internet; data packets are forwarded through the networks of the internet from router to router until they reach their destination computer. Routing algorithms determine the specific choice of route. Each router has a prior knowledge only of networks attached to it directly. A routing protocol shares this information first among immediate neighbors, and then throughout the network. This way, routers gain knowledge of the topology of the network. The ability of routing protocols to dynamically adjust to changing conditions such as disabled data lines and computers and route data around obstructions is what gives the Internet its fault tolerance and high availability.</p>
</blockquote>
<p>路由协议规定了路由器之间如何交换选路信息，这些选路信息使得路由器能够在计算机网络上的任意两个节点之间选择路径，并利用选择出的路径发送数据。路由器在互联网上承担了“流量指挥”的功能。数据在互联网上从一个路由器传递到另一个路由器直到到达目的计算机。路由算法决定了选择路径的方式。正常连接情况下每个网段只知道自己直连的网段。路由协议首先会在直连的邻居之间共享路由信息，然后在整个网络中共享这些信息，这样一来路由器就获得了网络拓扑的结构。路由器能够根据不断变化的网络情况（如线路中断或计算机宕机）进行动态调节，使得被路由数据传输能绕开障碍设备传递，这就是互联网具有容错性和高可用性的原因。</p>
<h3 id="路由协议的分类"><a href="#路由协议的分类" class="headerlink" title="路由协议的分类"></a>路由协议的分类</h3><p><img src="/2020/05/04/11-route-basic/Cisco-CCNA-static-routing-2.jpg" alt="Cisco-CCNA-static-routing-2"></p>
<h4 id="静态路由协议"><a href="#静态路由协议" class="headerlink" title="静态路由协议"></a>静态路由协议</h4><p>根据数据访问需求手工在每台设备上进行静态路由条目的创建。静态路由协议只能知道局部地点的静态信息，因为运行了静态路由协议的路由器之间<strong>不会</strong>互相交换网络信息，所以它不知道网络整体是如何连接的，只知道手动添加的那些局部地点的路由。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_12-41-09.jpg" alt="Snipaste_2020-05-05_12-41-09"></p>
<p>从前一节的知识可知，R1和R2之间是直连的，因为中间没有其他三层设备，所以R1只知道和它直连的R2的路由信息，192.168.12.0网段如何去，但由于R2的另一个接口2.2.2.0/24并未和R1直连，所以R1的路由表中并没有该网段的信息，R1即使收到去往2.2.2.0/24网段的数据也不知道如何处理只能丢弃，因为路由表中并没有去往该网段的路由条目。这时候为了让数据在R1上被正确发送，我们可以手工添加一条静态路由到路由表中，让路由器知道如何处理，添加完静态路由后，路由表中即会出现2.2.2.0/24这个网段的路由条目。</p>
<p>举一个不太恰当的例子说明一下加深理解，静态路由生成的路由条目有点类似咱们看到的静态的指路牌，每个路标相当于静态路由中的一个路由条目，这些路牌的信息都是静态的，不能自己动态更新必须由人工添加或修改，静态路牌没有路况状态的实时信息，不知道所指出的路径是畅通还是拥堵，也不知道指出的路还能否到达目的地，比如你想下山，这个路牌上指出了下山的方向，只要不人为的翻修、更新这个路牌的信息，它会一直指着同一个方向，但按静态路牌走能不能下山，下山这条路上是否拥堵，一概不知道，因为静态路牌没法动态的知道这条路上的路况以及这条路情况是否现在还能够通往下山。这就是前面说的静态路由只知道局部地点的静态信息的大概比喻。</p>
<p><img src="/2020/05/04/11-route-basic/65498746456-1589792877010.jpg" alt="65498746456"></p>
<h4 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a>动态路由协议</h4><p>路由器自动进行路由或用于路由计算的相关信息的更新和同步，并且当网络拓扑变更时，能够动态收敛。 </p>
<p>由于静态路由协议需要手工配置每一条路由条目，使得静态路由协议在大规模的网络中（例如跨国企业的网络、ISP运行商网络）使用起来十分困难，为了解决这个问题动态路由协议应运而生，动态路由协议可以让路由器自动学习到其他路由器的网络信息，每台路由器根据所掌握的全网的网络信息，<strong>以自我为中心计算出</strong>去往网络中各网段应如何转发生成相应路由表（和别的设备交换的只是网络的信息，根据这些信息每台路由器独立计算出本路由器的路由表，计算出路由表的这个过程不会和别的路由器协商），并且在网络拓扑发生改变后能自动获取变化后的网络信息，并根据之前获取和新获取的信息自动重新计算更新路由表。网络管理员只需要配置动态路由协议即可，相比人工指定转发策略，工作量大大减少。常见的动态路由协议有：OSPF，BGP，IS-IS，RIP，EIGRP等。</p>
<p>在动态路由中，管理员不再需要与静态路由一样，手工对路由器上的路由表进行维护，而是在每台路由器上运行一个路由协议。这个路由协议会根据路由器上的接口的配置（如IP地址的配置）及所连接的链路的状态信息，计算并生成路由表中的路由表项。当网络拓扑结构改变时动态路由协议可以自动更新路由表，并负责决定数据传输最佳路径。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_15-37-51.jpg" alt="Snipaste_2020-05-05_15-37-51"></p>
<p>当R1和R2的所有接口都运行了动态路由协议时，R1和R2就能互相交互路由信息，使得路由器动态的“学习”到网络中其他运行了相同动态路由协议设备上的路由信息，并更新自己的路由表。上图中的R1和R2在运行相同动态路由协议的情况下，R1就能“学习”到R2上2.2.2.0/24的信息，然后独立计算出前往该网段的最佳路由添加到自身的路由表中以便以后使用。</p>
<p>举个不太恰当的例子方便理解，动态路由协议有点像底下视频中这个动态指路牌，首先动态路牌里的系统会学习并掌握到整个城市的地图以及实时的路径拥堵情况，而且是动态更新的，不管道路是拥塞、中断或畅通，这个电子动态路牌中的系统都会掌握并实时更新，并根据这些动态更新的路况计算出去往目的地最佳的路径，然后动态更新路牌的指路方向。这个动态路牌获取的是一个动态的全城的路径数据信息或者叫数据库更为准确一些，然后基于这个动态数据库自己计算出自己的动态路标。</p>
<iframe src="//player.bilibili.com/player.html?aid=5842876&bvid=BV1Fs411k7B8&cid=9488192&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h5 id="距离矢量路由协议"><a href="#距离矢量路由协议" class="headerlink" title="距离矢量路由协议"></a>距离矢量路由协议</h5><h6 id="距离矢量的概念"><a href="#距离矢量的概念" class="headerlink" title="距离矢量的概念"></a>距离矢量的概念</h6><p>距离矢量（distance vector）：距离矢量路由协议根据距离确定数据包的最佳路由。距离矢量路由协议用数据包经过路由器的数量来定义距离，当数据传递经过一个路由器时，算作一跳。有些距离矢量路由协议也加入了延迟或其他因素来决定路由的传递（eigrp协议）。为了确定通往一个网络号的最佳路径，运行了距离矢量路由协议的路由器会互相交换信息，它们交换的信息通常是路由表加上到目标网络的跳数，有时候还有一些其他的流量信息，比如上面提到的延迟。距离矢量路由协议通常还要求路由器定期通知其邻居关于网络拓扑的变化。距离矢量协议使用<a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman–Ford</a>算法和<a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford–Fulkerson</a>算法来计算最佳路径。</p>
<p>距离矢量路由协议是“基于传闻的路由协议”，A发路由信息给B，B加上自己的度量值又发给C，路由表里的条目是听来的，每个路由器都不知道整个网络的拓扑是什么样，只知道自身与目标网络之间的距离，以及应该往哪个方向或使用哪个接口转发数据包。距离矢量路由协议选出最优路径的同时也可能会引发环路问题，它使用水平分割、毒性逆转以及触发更新等机制来避免环路。距离矢量路由协议一般采用定期更新、广播更新、路由表更新的方式更新路由表。</p>
<p>做一个不太恰当的比喻，距离矢量路由协议的工作过程有点类似于你到上海旅游想去迪士尼公园，出了旅馆的门到一个十字路口不知道该怎么走了，你就在十字路口附近问别人，要去迪士尼乐园我应该在这个路口怎么拐？被问的这个人告诉你，他也不是本地人不认识上海也没去过迪士尼，但他听别人（基于传闻的路由）说从这右拐（左拐）这个方向就是去迪士尼。距离矢量协议的工作特点就是路由一跳一跳的传递，到了一个路由器（十字路口）查了路由表（问别人如何去迪士尼）才知道下一跳应该从哪个接口发送出去是去迪士尼的大致方向（左拐或右拐），但路上被问路的人除了最后一个人确切知道迪士尼公园肯定是在哪以外，其他人既不知道迪士尼公园的确切位置，也不知道上海整体的地图是什么样，它们唯一知道的只是别人告诉他去迪士尼大概的方向是哪，应该怎么走。</p>
<p>距离矢量协议除了BGP、EIGRP可能在现网中有部署以外，其他的比如RIP协议已经几乎不可能在现网中看到了。</p>
<h6 id="最大跳数"><a href="#最大跳数" class="headerlink" title="最大跳数"></a>最大跳数</h6><p>距离矢量协议中的“距离”也称为“跳数”（hop），每经过一个路由器，跳数就增加1，距离矢量协议使用最大跳数来避免环路，超过最大跳数则说明该路由不可达。例如在RIP协议中，一条路径只能包含15个路由器，也就是一条路由最大只能经过15跳，当距离（跳数）为16时，则说明这条路由不可达。</p>
<h6 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h6><p>水平分割（Split horizon route advertisement）是在距离矢量路由协议中<strong>防止环路</strong>的一种方式，是通过禁止路由器将所学到的路由条目通告给学到该路由条目的接口的方式实现的。用人话说就是从这个接口收到的路由，就不会再从这个接口发回去。</p>
<p>举个例子：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>有R1、R2、R3三台路由器如上图所示连接好，全部运行距离矢量协议，根据水平分割原则，路由器R1不会将收到的关于R3的8.8.8.8的路由条目通告给R2，因为8.8.8.8的路由是由R3通告给R2，然后R2通告给R1的，R1是从R2学到的该路由，所以不会通告回R2，为了防止产生环路。我们来看看如果没有水平分割原则会如何，如果R2和R3的链路发生故障，R2没有了去往8.8.8.8网段的路由，如果没有水平分割原则，则R1会将8.8.8.8的路由回告给R2，这种情况下，R2通过R3去往8.8.8.8的路由条目此时消失了，因为G0/0口已经down了，获取的所有路由就会从路由表中消失，而R2收到了R1能去往8.8.8.8的路由，认为通过R1能到达8.8.8.8，所以此时R2会把发往8.8.8.8的路由发给R1，但R1的路由表上去往8.8.8.8的下一跳是R2，也就是要把去往8.8.8.8的数据发给R2，然后R2收到目的IP地址为8.8.8.8的数据后，路由表上去往8.8.8.8的下一跳是R1，数据又发给了R1，循环往复，就形成了环路，所以水平分割原则十分重要。</p>
<h6 id="路由中毒"><a href="#路由中毒" class="headerlink" title="路由中毒"></a>路由中毒</h6><p>路由中毒（Route poisoning）。路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值为无穷大明白该路由是无效的。</p>
<p>距离矢量路由协议使用路由中毒来告诉其他路由器，某条路由已经失效无法传送数据到目的地址，不要将该路由加入其他路由器的路由表。和具有毒性反转的水平分割不同，路由中毒会立刻向网络中所有节点发送某条路由的路由更新，这条路由更新中该路由的跳数为不可到达。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36-1589447716551.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>依旧用这个拓扑来说明路由中毒，三台路由器依旧运行距离矢量路由协议，这里用RIP举例，在RIP协议中，不可达的metric为16跳，R1的8.8.8.8的路由是R3发送给R2然后再传递给R1的，如果R3到8.8.8.8的链路中断，那么在下次发送给其他路由器更新RIP的路由表中就不会有8.8.8.8这个网络，而R2 和R1由于RIP路由的过期时间为180秒，这两个路由器的路由表中依旧有8.8.8.8这个路由条目因为还没到老化删除该条目的时间所以依旧会存在。但除了R3以外其他路由器不会知道此时R3已经没法去往8.8.8.8了，在R1、R2收到发往8.8.8.8的数据时，还会发给R3，可能会导致环路的产生。路由中毒的做法是，当R3发现前往8.8.8.8的网络中断后，在下次发送路由更新时，依旧会有8.8.8.8这个条目并将其跳数变更为不可达的metric，在RIP中就是协议跳数最大值+1，15+1也就是16，因为16超过了跳数的协议最大值15，所以R2收到路由更新时会发现去往8.8.8.8的路由条目中的metric变为了16跳，也就是不可达，R2会立刻知道8.8.8.8网络不可达，无需等待180秒RIP条目老化才将其删除。</p>
<h6 id="毒性反转"><a href="#毒性反转" class="headerlink" title="毒性反转"></a>毒性反转</h6><p>毒性反转（Poison Reverse），和水平分割功能类似，也是在网络中避免环路的原则。它是指收到路由中毒消息的路由器，不遵守水平分割原则将中毒的路由消息转发给所有的相邻路由器，也包括发送中毒信息的源路由器，也就是通告相邻路由器这条路由信息己失效了。主要目的是达到快速收敛的目的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36-1589447716551.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>依旧用上面的拓扑来解释毒性反转，三台路由器依旧运行距离矢量路由协议，这里用RIP举例，在RIP协议中，不可达的metric为16跳，R1的8.8.8.8的路由是R3发送给R2然后再传递给R1的，如果R3到8.8.8.8的链路中断，那么在下次发送给其他路由器更新RIP的路由表中就不会有8.8.8.8这个网络，而R2 和R1由于RIP路由的过期时间为180秒，这两个路由器的路由表中依旧有8.8.8.8这个路由条目因为还没到老化删除该条目的时间所以依旧会存在。但除了R3以外其他路由器不会知道此时R3已经没法去往8.8.8.8了，在R1、R2收到发往8.8.8.8的数据时，还会发给R3，可能会导致环路的产生。前面说过此时就该路由中毒出场了，路由中毒做法是，当R3发现前往8.8.8.8的网络中断后，在下次发送路由更新时，依旧会有8.8.8.8这个条目并将其跳数变更为不可达的metric，在RIP中就是协议跳数最大值+1，15+1也就是16，因为16超过了跳数的协议最大值15，所以R2收到路由更新时会发现去往8.8.8.8的路由条目中的metric变为了16跳，也就是不可达，R2会立刻知道8.8.8.8网络不可达，无需等待180秒RIP条目老化才将其删除。此时路由中毒已经完成任务了，接下来毒性反转原则，是将带有无穷大metric的这条8.8.8.8的路由发送给R1而且会不遵守水平分割原则，这样会大大加快网络的收敛速度。</p>
<h6 id="水平分割、毒性反转、路由中毒"><a href="#水平分割、毒性反转、路由中毒" class="headerlink" title="水平分割、毒性反转、路由中毒"></a>水平分割、毒性反转、路由中毒</h6><p>再用个例子来更好的说明这三个概念。R1和R2运行RIP V2，均宣告了自己的loop0接口和G0/0接口网段进RIP，彼此路由表中均有对方loop0的路由条目。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-45-46.jpg" alt="Snipaste_2020-06-17_15-45-46"></p>
<p><strong>水平分割原则</strong>（Split Horizon）是从这个接口收到的路由，就不会再从这个接口发回去。R2通过G0/0从R1处学到了1.1.1.1的路由，根据水平分割原则，R2从G0/0学到的1.1.1.1的路由不会再通过G0/0发送回R1，抓包也能看出来，R2只向R1发送了自身2.2.2.2的路由条目：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-52-50.jpg" alt="Snipaste_2020-06-17_15-52-50"></p>
<p><strong>路由中毒</strong>（Route Poisoning）是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值为无穷大明白该路由是无效的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-45-46.jpg" alt="Snipaste_2020-06-17_15-45-46"></p>
<p>在这个例子中，我们将R1的loop1接口shutdown，这样这条1.1.1.1的RIP路由就在路由表中失效了，来抓包看看结果如何：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_17-02-36.jpg" alt="Snipaste_2020-06-17_17-02-36"></p>
<p>此时R1在得知1.1.1.1的路由失效后，并没有删除该条路由而是立刻将该条路由的度量值变为无穷大，在RIP中就是16跳，并发送出去。</p>
<p><strong>毒性反转</strong>（Poison Reverse）指的是收到路由中毒消息的路由器，不遵守水平分割原则将中毒的路由消息转发给所有的相邻路由器，也包括发送中毒信息的源路由器，也就是通告相邻路由器这条路由信息己失效了。在这里收到中毒消息的路由器是R2，按照毒性反转的定义，它应该违反水平分割原则，将带有中毒的路有消息发送给R1，现在来抓包看看：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_17-07-54.jpg" alt="Snipaste_2020-06-17_17-07-54"></p>
<h6 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h6><p>触发更新（trigger update）。当路由表发生变化时，更新报文立即广播给相邻的所有路由器，而不是等待30秒的更新周期。同样，当一个路由器刚启动RIP时，它广播请求报文。收到此广播的相邻路由器立即应答一个更新报文，而不必等到下一个更新周期。这样，网络拓扑的变化会最快地在网络上传播开，减少了路由循环产生的可能性。</p>
<h6 id="抑制计时器"><a href="#抑制计时器" class="headerlink" title="抑制计时器"></a>抑制计时器</h6><p>抑制计时器（hold-down timer）。一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。大概过程是如果一个路由器从邻居路由器收到一条更新，提示以前可达的网络现在不可达了，或有一个更大跳数的路由，则路由器标识该路由为不可达并启动一个抑制计时器，如果在定时器到时之前收到该路由又可达的更新，或者新度量值比之前的度量值更好，则路由器标识这个路由可达并删除定时器。路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。 </p>
<h5 id="链路状态路由协议"><a href="#链路状态路由协议" class="headerlink" title="链路状态路由协议"></a>链路状态路由协议</h5><p>链路状态路由协议的工作流程是，发现其他同样运行了该链路状态路由协议的设备——所有设备交换相关链路信息——每个设备自己形成整体的连接图——每个设备独立计算最短路径形成路由表。首先运行了链路状态协议的所有节点共同构建一个连接图，这个连接图显示了网络上设备相互连接的情况。运行了该路由协议的节点会从本设备上所有可能的路径中，计算出本设备上的最佳下一跳是哪条路径，每个设备上最佳的路径构成了每个设备的路由表。</p>
<p>链路状态路由协议有点像你用导航去迪士尼乐园，导航软件从一开始就知道整个上海的地图以及从你所在的地点到迪士尼乐园有哪些可能存在的路线，然后对这些潜在的路线进行比较，看看哪条路线拥堵哪条路径通畅，最后选择出一条最优的路线告诉你应该怎么走。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol>
<li>形成的路由表更加精确。链路状态路由协议是根究互相交换的LSA构成LSDB，在构成路由表，且路由表是在充分了解全网状况的条件下形成的，而距离矢量路由协议仅根据邻居路由宣告的信息生成自己的路由表。</li>
<li>触发更新，收敛更快。链路状态路由协议采用触发更新机制，当网络发生变化时，路由器收到LSA后，立刻向除了接收到此LAS接口的其他接口泛洪出去，然后执行算法更新路由表，而距离矢量路由表采用周期性更新路由表。</li>
<li>分层设计。链路状态路由协议都采取了区域设计，为链路状态更新范围设定了边界。LSA的传播和SPF的计算被限制在一个区域内，同一区域内路由器具有相同的LSDB，区域间路由信息的交换由区域边界路由器完成，因此路由表更小，并降低了链路状态更新的开销。</li>
</ol>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>内存需求更大，处理器要求更高，带宽需求更大。</p>
<h2 id="度量值及管理距离"><a href="#度量值及管理距离" class="headerlink" title="度量值及管理距离"></a>度量值及管理距离</h2><h3 id="管理距离"><a href="#管理距离" class="headerlink" title="管理距离"></a>管理距离</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>管理距离（Administrative Distance，AD）是指一种路由协议的路由可信度。每一种路由协议按可靠性从高到低，依次分配一个信任等级，这个信任等级就叫管理距离。管理距离是一个从0~255的整数值，0是最可信赖的，而255意味着不会有业务量从这个路由通过。<strong>管理距离仅在本设备具有重要意义，因此不会在路由更新中进行通告。</strong></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>当去往同一网段有两个或多个不同路由协议的路由表项时，管理距离用来选择使用哪种路由协议去往该网段。正常情况下，管理距离越小，它的优先级就越高，也就是可信度越高。也就是说，当到达一个目的地有多个不同的路由协议时，路由器根据管理距离来决定相信哪一个协议，AD是用于不同路由协议之间比较的参数。</p>
<h4 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h4><p>如果路由器分别收到使用开放最短路径优先 (OSPF)（默认管理距离为110）和 Interior Gateway Routing Protocol (IGRP)（默认管理距离为100）通往特定网络的路由，则路由器将选择 IGRP，因为 IGRP 更可靠。这意味着路由器将路由的 IGRP 版本添加到路由表。</p>
<p>如果丢失了 IGRP 协议的设备信息（例如，由于电源关闭），则会使用 OSPF 协议的路由表进行数据转发，一直到 IGRP 的路由信息再次出现。</p>
<h4 id="设备默认AD值"><a href="#设备默认AD值" class="headerlink" title="设备默认AD值"></a>设备默认AD值</h4><p>不同厂家对于设备的默认AD值规定不相同，具体参见下表。</p>
<h5 id="思科设备默认AD值"><a href="#思科设备默认AD值" class="headerlink" title="思科设备默认AD值"></a>思科设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_15-51-14.jpg" alt="Snipaste_2020-05-05_15-51-14"></p>
<h5 id="juniper设备默认AD值"><a href="#juniper设备默认AD值" class="headerlink" title="juniper设备默认AD值"></a>juniper设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-01-24.jpg" alt="Snipaste_2020-05-05_16-01-24"></p>
<h5 id="华为设备默认AD值"><a href="#华为设备默认AD值" class="headerlink" title="华为设备默认AD值"></a>华为设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-14-46.jpg" alt="Snipaste_2020-05-05_16-14-46"></p>
<h3 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h3><p>度量值（metrics），是网络上路由的参数之一，用来在多个可行的路由路径中选出最佳的一条路径，路由器会选择metric值最小的那一条路径。度量值包括了被路由算法使用来决定哪一条路径较另一条路径好的所有数值。度量可能包括许多资讯，例如带宽、延迟、经过节点数、路径成本、负载、最大传输单元（MTU）、可靠性及传输成本等。路由表只储存最佳的可能路径，但拓扑表或邻接表数据库可能储存其他相关的资讯。</p>
<p><strong>当同一个路由协议</strong>到达某一个网段有两条或以上的路径时，用metric决定选用哪条路径，路由会选择最低度量值的路径转发数据。如果度量值为0，代表该路径的目的地，与本地端界面是连接在同一个网络上。如果度量值大于零，该路径的目的地会被认为外部位址，必须通过转发才能抵达目的地。</p>
<p>IP 路由协议中使用的度量如下：</p>
<ul>
<li>带宽   —EIGRP</li>
<li>开销   —OSPF&amp;IS-IS</li>
<li>延迟   — EIGRP</li>
<li>跳数   —-RIP</li>
<li>负载   —- EIGRP</li>
<li>可靠性  — EIGRP</li>
</ul>
<h3 id="度量值VS管理距离"><a href="#度量值VS管理距离" class="headerlink" title="度量值VS管理距离"></a>度量值VS管理距离</h3><p>度量值metirc是<strong>相同路由协议内部到达同一目的网段有多条路径时，比较最佳路径的参数</strong>，<strong>管理距离AD是不同路由协议之间比较选路的参数</strong>。如果前往一个网段，有既有OSPF，也有BGP等其他路由协议，每个协议中也有多个打到该网段的路径，是应该先是各自的路由协议内部用metric（BGP用自己那套13条选路原则）选出各自路由协议中最优的路径，然后这些不同的路由协议之间，用AD比较选出最终的最优路径。</p>
<h2 id="路由的负载均衡"><a href="#路由的负载均衡" class="headerlink" title="路由的负载均衡"></a>路由的负载均衡</h2><p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/5212-46.html#perper">路由负载均衡（Load Balancing）</a>，是一种技术解决方案。用来在多个资源中分配负载，达到最优化资源使用，避免过载。具体到路由中，就是到某个网段有两个或多个路径，负载均衡使路由器在转发数据包时可以使用到目标的多个路径。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-17_16-53-16.jpg" alt="Snipaste_2020-05-17_16-53-16"></p>
<p>当R4要发送数据到R7身后的7.7.7.0网段时，如果所有路由器之间链路状态良好，路由协议配置相同且开启了负载均衡的话，很可能形成负载均衡，也就是路由表中到该网段有两条路径，类似下图所示：</p>
<p><img src="/2020/05/04/11-route-basic/053014_1250_TrafficLoad9.png" alt="053014_1250_TrafficLoad9"></p>
<h3 id="基于目的地地址"><a href="#基于目的地地址" class="headerlink" title="基于目的地地址"></a>基于目的地地址</h3><h4 id="简化过程："><a href="#简化过程：" class="headerlink" title="简化过程："></a>简化过程：</h4><p>基于目的地的负载均衡（Per-destination load balancing）的含义是，路由器基于目的地的IP地址分配数据包，例如当前往同一网段有两条路径时，当去往该网段的IP地址1走路径1，前往该网段IP地址2走路径2。例如如果去往192.168.1.0/24网段有两条负载相同的路径，G1/0和G2/0，前往192.168.1.X这个地址的流量走G1/0接口，前往192.168.1.Y这个地址的流量走G2/0接口。基于目的地址的负载均衡可能导致链路使用的不平衡，如果只有一个地址使用负载均衡的线路，那么它只使用了两条负载均衡线路中的一条，另一条如果没有另一个地址通信的话，则完全不会使用。</p>
<h4 id="实际过程"><a href="#实际过程" class="headerlink" title="实际过程"></a>实际过程</h4><p>实际上这种基于目的地的负载均衡其实是基于flow的，也就是基于流的，每个数据流进行哈希然后根据哈希值决定下一跳走哪条路径，相同哈希值走的路径是固定的。如何定义一个flow的话，juniper一般是基于源目地IP地址，源目地MAC地址再加上协议，这个五元组去确定一个flow，也叫5个key，让这5个key去计算一个哈希结果，根据哈希结果不同发送到不同的下一跳，如果这个哈希结果相同就会走固定的下一跳，不会乱序。用哪几个key去计算哈希结果可以在设备上自行设置，比如在MPLS中可以加入MPLS的label当作key，使得负载更加均衡，厂家也有自动检测下一跳流量是否均衡，如果出现大量流量去往同一个下一跳而另一个负载均衡的目的地流量较少的情况，则系统会自动改哈希的key，使得流量负载自动均衡，个人感觉这个自动调节的技术好牛X。</p>
<h3 id="基于数据包"><a href="#基于数据包" class="headerlink" title="基于数据包"></a>基于数据包</h3><p>基于数据包的负载均衡（Per-packet load-balancing）的含义是，路由器发送数据到一个目的地时，第一个数据走路径1，第二个数据走路径2，以此类推。基于数据包的负载均衡保证所有链路上负载相等。</p>
<h1 id="静态路由-1"><a href="#静态路由-1" class="headerlink" title="静态路由"></a>静态路由</h1><h2 id="静态路由的概念"><a href="#静态路由的概念" class="headerlink" title="静态路由的概念"></a>静态路由的概念</h2><p>静态路由（英语：Static routing），一种路由的方式，路由条目（routing entry）由手动配置，而非动态决定。与动态路由不同，静态路由是固定的，不会改变，即使网络状况已经改变或是重新被组态。一般来说，静态路由是由网络管理员逐项加入路由表。</p>
<p>路由器的天职，就是维护路由表以及利用路由表进行数据转发。而路由表中包含通过各种途径学习到的路由表项或路由条目，其中最简单最直接的方法，就是使用静态手工配置的方式，为路由器创建路由条目，这种方式最直接，可控性最高，配置也最简单。在小型的网络中，全网静态路由似乎没有什么问题，但是在一个大型网络中，如果纯用静态路由来做，工作量就非常大了，不仅仅工作量大，另外一个更重要的缺陷是静态路由无法根据网络拓扑结构的变更而做出调整，因此，在大规模网络中，我们往往采用静态+动态路由协议的方式来完成路由的部署。</p>
<h2 id="静态路由的特点"><a href="#静态路由的特点" class="headerlink" title="静态路由的特点"></a>静态路由的特点</h2><p>需要通过手工的方式进行添加及维护，适用于组网规模较小的场景，如果网络规模较大，配置和维护的成本就会较高，所以一般网络中都采用动态、静态路由相结合的方式进行部署。</p>
<p>优点：对CPU、内存等硬件的需求不高；不占用带宽，因为静态路由不会产生更新流量。</p>
<p>不足：必须手动添加配置工作量大且容易出错；适应拓扑变化的能力较差，当网络拓扑发生变化时必须手动对静态路由进行维护。</p>
<p>重复一下上面那个不太恰当的例子说明一下加深理解，静态路由生成的路由条目有点类似咱们看到的静态的指路牌，每个路标相当于静态路由中的一个路由条目，这些路牌的信息都是静态的不能自己动态更新必须人工添加或修改，也没有路况状态信息，不知道所指出的路径是畅通还是拥堵，更不知道指出的路还能否到达目的地，比如你想下山，这个路牌上有，能指引去往这个地方的方向，只要不人为的翻修这个路牌，它会一直指着同一个方向，但按静态路牌走能不能下山，下山这条路上是否拥堵，一概不知道，因为静态路牌没法动态的知道这条路上的路况以及这条路情况是否现在还能够通往下山。这就是前面说的静态路由只知道局部地点的静态信息的大概比喻。</p>
<p><img src="/2020/05/04/11-route-basic/65498746456.jpg" alt="65498746456"></p>
<h2 id="静态路由的配置"><a href="#静态路由的配置" class="headerlink" title="静态路由的配置"></a>静态路由的配置</h2><h3 id="基础配置命令"><a href="#基础配置命令" class="headerlink" title="基础配置命令"></a>基础配置命令</h3><p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface } </p>
<p>IP route 表示该路由是一条静态路由；network-address   subnet-mask  是目标网络的网络号和网络掩码，前缀和掩码配合主机位不能有1，也就是不能配置成：ip route 10.10.20.1 255.255.255.0 10.12.12.2，因为10.10.20.1和255.255.255.0做与运算以后，主机位是1，不是一个网络号，违反了配置的规则；{ Next hop ip-address  |  exit-interface } 是到达前面网络号的出口IP地址或出接口，当配置IP地址最好是路由器所直连的地址，否则还要进行递归查询，消耗路由器资源，当配置出接口时，是配置的自身路由器的一个接口而这个接口能将数据发送给目标网络号。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-18_10-11-27.jpg" alt="Snipaste_2020-06-18_10-11-27"></p>
<p>例如，ip route  192.168.1.0   255.255.255.0   192.168.12.2，表示去往网络地址为192.168.1.0/24这个网络号，要将数据交给192.168.12.2发出；ip route 192.168.1.0 255.255.255.0 serial 0，表示去往网络地址为192.168.1.0/24这个网络号，要将数据从Serial 0 接口发出；后面也可以同时配置上出口IP地址和出接口：ip route  192.168.1.0  255.255.255.0  G0/0  192.168.12.2，具体讲解参见后面“静态路由的下一跳”部分。</p>
<h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><p>show   ip   static-route</p>
<h3 id="配置要点"><a href="#配置要点" class="headerlink" title="配置要点"></a>配置要点</h3><p>路由要配置来回路由，不能有去无回，且沿途所有路由器必须有到达目的网络的路由。</p>
<h3 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h3><h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><h5 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h5><p>共有3台路由器，R1，R2，R3，现在需要让R1和R3之间能够通信，请用静态路由完成此实验。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<h5 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h5><p>配置静态路由前R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-07.jpg" alt="Snipaste_2020-05-10_14-58-07"></p>
<p>R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-44.jpg" alt="Snipaste_2020-05-10_14-58-44"></p>
<p>R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_15-14-05.jpg" alt="Snipaste_2020-05-10_15-14-05"></p>
<p>如果要从R1发送数据给R3，通过查看R1和R3的路由表我们发现，两者均没有去往对方网段的路由条目，为什么这里需要看R1和R3是否有<strong>彼此</strong>的路由条目呢，是因为<a href="https://renyuan431.github.io/2020/05/04/11-route-basic/#%E9%80%9A%E4%BF%A1%E6%98%AF%E5%8F%8C%E5%90%91%E7%9A%84">路由是双向的</a>，所以我们需要在R1和R3上分别配置到对方的静态路由，路由有来有回这个要求满足了，下面来看沿途的所有路由器是否都有到达目标网络的路由。沿途的路由器只有R2，由于路由是双向的，所以R2既要有去往R1，192.168.12.0这个网段的路由，又要有去往R3，192.168.23.0这个网段的路由，经过查看R2的路由表，我们看到R2确实有这两条路由，所以这个要求也满足了。</p>
<p>在封装数据时有几个重要的常用参数，三层封装中的源、目的IP地址以及二层封装中的源、目的MAC地址，也就是二层和三层的地址。</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200507184145.jpg" alt="微信图片编辑_20200507184145"></p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200507184549.jpg" alt="微信图片编辑_20200507184549"></p>
<h5 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<p>R1：</p>
<p><strong>配置前的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-07-1589450121599.jpg" alt="Snipaste_2020-05-10_14-58-07"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#config t                                            进去全局配置模式</span><br><span class="line">R1(config)#ip route 192.168.23.0 255.255.255.0 192.168.12.2</span><br><span class="line">               去往192.168.23.0网段的数据，交给192.168.12.2这个IP地址</span><br></pre></td></tr></table></figure>

<p>R1和R3通信，也就是192.168.12.0网段和192.168.23.0这两个网段通信，但此时路由表中并没有这条路由，这里我们配置上这条静态路由，告诉R1如果想发送数据到192.168.23.0这个网段将数据发送给R2即可，因为R2的路由表中有该条路由。在这条静态路由中，配置的是192.168.23.0 255.255.255.0 ，IP地址和子网掩码做与运算以后，得出的是192.168.23.0/24这个网段，也就是只要以后R1发往23.0这个网段的数据，不管是ping 192.168.23.1 - 192.168.23.254这些地址，都会匹配到这条静态路由，因为他们都属于192.168.23.0/24网段。 在查看路由表时，之所以用do show ip route是因为此时在全局模式下，并没有show ip route这个特权模式下的命令，但前面加上do以后就可以正确运行了，其他命令也是如此，比如后面的do ping 192.168.23.3。</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-56-56.jpg" alt="Snipaste_2020-05-14_17-56-56"></p>
<p>发送给192.168.23.0/24网段的路由条目，S表示是静态路由，[ 1 / 0 ]，1是这条路由的管理距离AD值，因为思科默认静态路由的管理距离为1。后面的0是静态路由的metric值，192.168.12.2是这条路由的下一跳，表示去往192.168.23.0/24网段的数据发送给192.168.12.2，在路由表上192.168.12.0网段的路由是一条直连路由，表示去往该网段从G0/0发出即可，所以去往192.168.23.0/24的数据从G0/0接口发出。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<p>R3：</p>
<p><strong>配置前的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_15-14-05-1589878743252.jpg" alt="Snipaste_2020-05-10_15-14-05"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#config t</span><br><span class="line">R3(config)#ip route 192.168.12.0 255.255.255.0 192.168.23.2</span><br><span class="line">               去往192.168.12.0网段的数据，交给192.168.23.2这个IP地址</span><br></pre></td></tr></table></figure>

<p><strong>配置后的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-53-53.jpg" alt="Snipaste_2020-05-14_17-53-53"></p>
<p>因为前面分析过，绝大多数通信都是双向的，所以R3上也要有去往R1的回程路由，所以需要配置去往192.168.12.0网段的静态路由。配置完静态路由后查看路由表，S是Static的缩写，表示静态路由，192.168.23.0/24是目标网段，192.168.12.2是下一跳地址，表示如果要发送数据去往192.168.23.0/24网段，需要将数据发送给192.168.12.2这个IP地址，路由表中去往192.168.12.0/24这个网段从G0/0接口发出，也就意味着发往192.168.12.0/24这个网段的数据从G0/0接口发出即可。</p>
<h5 id="数据传递分析"><a href="#数据传递分析" class="headerlink" title="数据传递分析"></a>数据传递分析</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-19_16-18-54.jpg" alt="Snipaste_2020-05-19_16-18-54"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p>在控制层面的路由表中有了所需要的路径后，开始进行数据层面的发送，按照上面的流程图，当R1要发送数据给192.168.23.0网段发送数据时，首先看对方是否和自己处于相同网段，192.168.12.0/24网段和192.168.23.0/24处于不同网段，由于是第一次和该网段通信，所以要先把数据发给网关，由于是R1和R3通信，R1自身的G0/0口就是网关也就不用把数据发给网关了，这时候查R1路由表上关于23.0网段的路由条目：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-19_16-51-51.jpg" alt="Snipaste_2020-05-19_16-51-51"></p>
<p>前面的S表示静态路由，192.168.23.0/24是目标网段，[ 1 / 0 ]中的1是AD值，因为思科静态路由默认的管理距离AD值为1，后面的0是度量值metric。封装数据所需的四个地址分别是，源目地IP地址和源目地MAC地址，源IP地址为R1的G0/0的IP地址，192.168.12.1，目的地址为R3上G0/0接口的IP地址，192.168.23.3，因为是12.0和23.0两个网段通信；源MAC地址是R1的G0/0接口的MAC地址，因为数据从这个接口发出，目的MAC地址是下一跳的MAC地址，根据路由表中的信息，下一跳是192.168.12.2，所以目标MAC地址是R2的G0/1口的MAC地址，此时用show ip arp命令查看arp缓存表中是否有该缓存：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-34-28.jpg" alt="Snipaste_2020-05-21_15-34-28"></p>
<p>可以看到，此时R1有目的地址的ARP缓存，所以可以直接封装，这里用ping包去测试连通性并抓取数据包：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-41-02.jpg" alt="Snipaste_2020-05-21_15-41-02"></p>
<p>封装需要的二层、三层地址已经都有了，三层、二层封装后交给一层也就是物理层，R1的物理层将上层的数据转换成电磁信号通过网线发送给R2。</p>
<p>当R1发送的数据到达R2的G0/1接口后，R2将电磁信号还原成帧，然后对二层（数据链路层）进行解封装，首先查看数据帧的CRC Checksum部分，看数据帧在传输过程中是否有损坏：</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704.jpg" alt="微信图片编辑_20200611145704"></p>
<p>确定数据帧无损坏以后，开始对二层进行解封装，看看数据帧中目的MAC地址和收到这个数据帧的G0/1口是否一致，发现目的MAC地址和收到该数据的G0/1接口一致，然后查看数据帧头部的Ether Type字段，发现类型为0X0800，表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<p>三层（网络层）收到来自二层的数据后，继续对三层进行解封装，首先校验一下在传输过程中IP报头部分是否损坏：</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749.jpg" alt="微信图片编辑_20200611150749"></p>
<p>查看IP报头的数据没有损坏以后，继续查看三层报头中的目的IP地址，此时发现目的IP地址并不是自身的IP地址，于是根据目的IP地址按照最长匹配原则查询路由表中是否有对应的路由：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-52-39.jpg" alt="Snipaste_2020-05-21_15-52-39"></p>
<p>经过查询，路由表中去往23.0网段从G0/0口发出，所以不对三层报头进行其他操作（由于没有剥离三层报头所以不需要重新封装三层报头），发送回给二层继续封装。封装需要的四个地址中，源目地IP地址已经有了，依旧是之前的192.168.12.1和192.168.23.3，源MAC地址是R2的G0/0接口MAC地址，目的MAC地址是G0/0接口对端R3的G0/0接口的MAC地址，查看ARP缓存中是否有该ARP缓存：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-56-56.jpg" alt="Snipaste_2020-05-21_15-56-56"></p>
<p>有所需的MAC地址后，由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给物理层转换成电磁信号发送给R3，封装好后的数据抓包为：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_16-01-31.jpg" alt="Snipaste_2020-05-21_16-01-31"></p>
<p>R3将收到的数据还原成帧后，对二层进行解封装，发现目标MAC地址和收到该数据的G0/0接口的MAC地址相同，然后交给上层处理，网络层收到该数据后，对三层进行解封装发现目标IP地址为自己，进行进一步解封装后，根据三层的Protocol字段交给相应的上层应用进行处理。R3收到该ICMP request（ping）后，根据ICMP协议要回复一个reply，reply中的源地址为自身G0/0口的IP地址，192.168.23.3，目标IP地址为R1的G0/0接口，192.168.12.1，通过查询路由表可知，发往12.0网段的数据应发往192.168.23.2，而在路由表中，去往192.168.23.0的数据应从G0/0口发出，所以源MAC地址为G0/0接口的MAC地址，目的MAC地址为R2的G0/0接口的MAC地址，经过查询源目地MAC地址在ARP缓存表中均有相应条目，所以可以直接封装，将数据从G0/0口发出，由物理层将数据帧转化成电磁信号经由网线发送给R2。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_17-16-48.jpg" alt="Snipaste_2020-05-21_17-16-48"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_17-20-39.jpg" alt="Snipaste_2020-05-21_17-20-39"></p>
<p>R2收到R3发送的ICMP reply后，将电磁信号还原成帧，然后对二层进行解封装，发现目标MAC地址和收到该数据的G0/0口的MAC地址相同后，交给上层应用。三层收到二层发送的数据后，对三层进行解封装，发现目标IP地址不是自身的，经查询路由表后发现应从G0/1口将数据发出，所以在三层重新封装好原来的源目地IP地址后，将数据发给二层继续处理，二层收到上层发送来的数据后，由于要将数据从G0/1口发出，所以源MAC地址为G0/1口的MAC地址，目标MAC地址为R1的G0/0口MAC地址，查询ARP表后封装好数据，由物理层将数据帧转化成电磁信号经由网线发送给R1。</p>
<p>R1收到数据后对电磁信号还原成帧，而后进行二层解封装发现目标MAC地址和接收到该数据的G0/0的MAC地址相同，于是将该数据交给上层处理。三层收到下层交给的数据后对三层进行解封装，发现目标IP地址为自身的IP地址，于是根据三层中的Type字段交给相应的上层应用处理。整个数据双向的发送——接收过程结束。</p>
<h4 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h4><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>PC1希望和PC2能正常通信，使用静态路由完成此实验，相关IP地址在图中已标出。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-15-21.jpg" alt="Snipaste_2020-05-26_11-15-21"></p>
<h5 id="实验分析-1"><a href="#实验分析-1" class="headerlink" title="实验分析"></a>实验分析</h5><p>为了更直观的看到路由的走向，此处用路由器代替PC，在配置时用路由器的IOS，然后PC1配置默认网关ip default-gateway 192.168.1.254，PC2配置默认网关ip default-gateway  192.168.2.254，并关闭路由器的路由功能，no ip routing。此时该设备就和PC一样。</p>
<p>配置前R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-43-53.jpg" alt="Snipaste_2020-05-26_11-43-53"></p>
<p>由于PC1要和PC2通信，两者处于不同网段（192.168.1.0网段和192.168.2.0网段），按照通信流程，PC1要把发往不同网段的数据发送给网关，也就是R1的G0/1接口，进行下一步的发送，由于数据的目的网段为192.168.2.0所以R1的路由表中应有去往192.168.2.0网段的路由才能顺利发送数据，所以R1上应该配置一条去往2.0网段的静态路由。根据通信大多是双向的这个原则，R1既要有去往2.0网段的去向路由，又要有去往1.0网段的回向路由，这里回向路由是有的，因为R1和PC1直连，有彼此的路由。</p>
<p>配置前R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-52-55.jpg" alt="Snipaste_2020-05-26_11-52-55"></p>
<p>收到R1发送的由1.0网段发往2.0网段的数据后，由于路由是双向的，R2必须有这两个网段的路由条目才能成功的发送数据，所以此处应该配两条路由，分别是发送数据的出向路由，也就是去往2.0网段的路由，以及回向路由，去往1.0网段的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-15-21.jpg" alt="Snipaste_2020-05-26_11-15-21"></p>
<p>配置前R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-58-13.jpg" alt="Snipaste_2020-05-26_11-58-13"></p>
<p>收到R2发送来的由1.0网段发往2.0网段的数据后，由于路由是双向的，所以R3必须有去往1.0和2.0的路由，由于R3和PC2直连已经获得了去往2.0网段的路由，此处只配置去往1.0网段的路由即可。</p>
<h4 id="实验配置-1"><a href="#实验配置-1" class="headerlink" title="实验配置"></a>实验配置</h4><p>R1</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.2.0 255.255.255.0 192.168.12.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-47-46.jpg" alt="Snipaste_2020-05-26_15-47-46"></p>
<p>R2</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.2.0 255.255.255.0 192.168.23.3</span><br><span class="line">ip route 192.168.1.0 255.255.255.0 192.168.12.1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-49-48.jpg" alt="Snipaste_2020-05-26_15-49-48"></p>
<p>R3</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.1.0 255.255.255.0 192.168.23.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-50-51.jpg" alt="Snipaste_2020-05-26_15-50-51"></p>
<p>PC1如何用路由器的IOS配置成PC用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip default-gateway 192.168.1.254                      配置默认网关为R1的G0/1接口</span><br><span class="line">no ip routing                                         关闭路由功能</span><br><span class="line">interface g0/0                                        进入G0/0口配置</span><br><span class="line">no shutdown                                           打开G0/0接口</span><br><span class="line">ip address 192.168.1.1 255.255.255.0                  配置G0/0的IP地址</span><br></pre></td></tr></table></figure>

<p>PC2如何用路由器的IOS配置成PC用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip default-gateway 192.168.2.254                      配置默认网关为R3的G0/1接口</span><br><span class="line">no ip routing                                         关闭路由功能</span><br><span class="line">interface g0/0                                        进入G0/0口配置</span><br><span class="line">no shutdown                                           打开G0/0接口</span><br><span class="line">ip address 192.168.2.1 255.255.255.0                  配置G0/0的IP地址</span><br></pre></td></tr></table></figure>

<h5 id="数据传递分析-1"><a href="#数据传递分析-1" class="headerlink" title="数据传递分析"></a>数据传递分析</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2019-12-10_16-36-13-1590479894157.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p>当PC1要和PC2通信时，假设这个通信是ping也就是ICMP协议的通信，由于发生通信的两个IP地址分别在192.168.1.0和192.168.2.0两个不同的网段，所以PC1会将该数据发送给网关所以要查询ARP缓存表中是否有网关的ARP表项，如果没有该ARP表项则用ARP协议发送ARP请求去获取网关的MAC地址然后封装的四个地址分别为：源IP地址为192.168.1.1，目的IP地址为192.168.2.1，源MAC地址为G0/0的MAC地址，目的MAC地址为网关192.168.1.254的MAC地址。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_16-01-54.jpg" alt="Snipaste_2020-05-26_16-01-54"></p>
<p>从ARP表中可以看到1.1和1.254的ARP，1.254的ARP表项中的age表示该ARP条目进入ARP表中以来的时间，也就是3分钟，距离ARP超时的4小时（思科普通交换机过期时间为4小时，Nexus系列交换机为25分钟）还有很长的时间。</p>
<p>封装好该数据以后，PC1的物理层将该数据转换成电磁信号然后发送给网关，也就是R1的G0/1接口，R1的G0/1口抓到的ping包数据为：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-56-28.jpg" alt="Snipaste_2020-05-26_15-56-28"></p>
<p>R1收到该数据后，物理层将该数据还原成帧，检查完二层的CRC字段确认数据无所坏后，数据链路层解二层封装后发现该数据的目的MAC地址和自身接口G0/1的MAC地址一致，于是将二层报头剥离后交给上层继续处理；网络层收到数据链路层发来的数据后继续对三层解封装发现目标IP地址不在本路由器上，于是根据目的IP地址按照最长匹配原则查询路由表中是否有对应的路由：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_17-17-58.jpg" alt="Snipaste_2020-05-26_17-17-58"></p>
<p>根据路由表中的路由，递归出要将数据发送给192.168.2.0的目标网段，需要将数据从G0/0口发出，R1将数据交给下层数据链路层继续封装，数据链路层封装源MAC地址为R1的G0/0接口，目标MAC地址为R2的G0/1接口的MAC地址：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_17-20-20.jpg" alt="Snipaste_2020-05-26_17-20-20"></p>
<p>R1的数据链路层封装好后交给物理层，由物理层转换成电磁信号发送给R2的G0/1接口。</p>
<p>R2收到数据后物理层还原成帧——解二层封装、剥离二层报头交给上层——解三层封装——查找路由——封装二层——发送给R3，R3依旧也是同样的步骤处理数据，然后发给PC2，PC2解二层封装、剥离二层报头——解三层封装后发现目标IP地址是自己，于是将该数据交给上层继续处理，整个ICMP request的发送过程完毕。</p>
<p>ICMP reply过程和上面的情况类似，就不再赘述了。</p>
<h2 id="静态路由的下一跳"><a href="#静态路由的下一跳" class="headerlink" title="静态路由的下一跳"></a>静态路由的下一跳</h2><p>在配置静态路由时，下一跳既可以使用下一路由器的IP地址，也可以使用本地路由器的出接口，在点对点网络中，无论是哪种配置并没有影响，但在以太网multiple access多路访问环境中，两者有所差别。</p>
<p>在以太网中，两个邻居接口之间的通信是依靠MAC地址，因为二者处于同一网段。这两个接口互相通信时就必须知道彼此的MAC地址，因为根据MAC地址才能将数据帧交给对方进行进一步处理，如何获得对方的MAC地址呢？就是之前提到过的ARP协议。</p>
<p>为了比较直观的说明下一跳用IP地址和出接口的区别，这里用实验来对比二者的差别。</p>
<h3 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-03-51.jpg" alt="Snipaste_2020-06-04_15-03-51"></p>
<p>R4要和R5身后的5.5.5.5/32通信，这里用R5的loop back0接口来代替这个IP地址。</p>
<h4 id="配置为下一跳"><a href="#配置为下一跳" class="headerlink" title="配置为下一跳"></a>配置为下一跳</h4><p>在R4上配置下一跳为IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 5.5.5.5 255.255.255.255 192.168.45.5</span><br></pre></td></tr></table></figure>

<p>此时ping5.5.5.5可以ping通，通过抓包发现，该数据包封装的源目地IP地址分别位192.168.45.4和5.5.5.5，源目地MAC地址分别位R4的G0/0接口的MAC地址以及R5的G0/0接口的MAC地址，具体过程和之前上面静态路由实验中的结果类似，这里就不赘述了。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_17-20-08.jpg" alt="Snipaste_2020-06-04_17-20-08"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-07-44.jpg" alt="Snipaste_2020-06-04_15-07-44"></p>
<h4 id="配置为出接口"><a href="#配置为出接口" class="headerlink" title="配置为出接口"></a>配置为出接口</h4><p>在R4上配置下一跳为出接口：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-12-22.jpg" alt="Snipaste_2020-06-04_15-12-22"></p>
<p>将下一跳配置成出接口以后，发现ARP表中多出了5.5.5.5的ARP缓存条目，而这个缓存条目和192.168.45.5，也就是路由表中去往5.5.5.5这个目标IP地址出接口G0/0的下一跳的MAC地址相同，这是为什么呢？我们继续来看路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-13-20.jpg" alt="Snipaste_2020-06-04_15-13-20"></p>
<p>路由表中去往5.5.5.5的路由条目后面有一个“directly connected”也就是直连的意思，但5.5.5.5在R5身后，和R4并未直连，为什么路由条目中显示直连呢？因为在配置静态路由时，后面的下一跳跟的是出接口，在这种情况下，路由器会认为去往5.5.5.5从G0/0接口发出就行了，所以路由器认为这个5.5.5.5和路由器直连，而在直连的情况下，路由器认为源目地IP地址在同一网段，所以会直接用ARP协议请求目标IP地址，5.5.5.5的MAC地址，这个ARP的源IP地址为192.168.45.4，目的IP地址为5.5.5.5，源MAC地址为G0/0对应的MAC地址，目的MAC地址为全F的广播，去请求5.5.5.5的MAC地址，这个广播到R5的G0/0接口后，我们知道三层设备不转发广播，也就是隔绝了该广播，这个广播是没法到达5.5.5.5的，所以R5怎么处理呢？R5将电磁信号还原成帧然后对二层进行解封装，发现是个目的MAC地址为全F的广播包，type字段为0X8060，所以这是一个ARP的广播包，于是交给上层继续处理，网络层收到下层交给的数据后，对三层解封装，发现ARP请求（通过operation code字段为1得知是ARP请求，如果该字段为2时为ARP reply）目的IP地址为5.5.5.5，经查询路由表发现有这个网段的路由信息，此时由于R5打开了代理ARP功能（思科设备默认开启该功能，如果关闭了此功能则这个场景下无法通信），因此会回复R4一个善意的“谎言”，告诉R4说5.5.5.5的MAC地址就是我G0/0的MAC地址，让R4把发往5.5.5.5的数据发给自己的G0/0接口，然后R5再将数据转发给5.5.5.5这个地址。</p>
<h3 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_09-35-49.jpg" alt="Snipaste_2020-06-15_09-35-49"></p>
<p>在这个拓扑环境中，R1和R2均连接到2.2.2.0/24网段，当R3用出接口配置静态路由时，R3会认为2.2.2.0/24网段和本路由器直连，当有数据发送到该网段时，假设是R3ping2.2.2.2，R3会发送ARP请求来获取该IP地址的MAC地址，这时如果R1和R2下联的端口启用了ARP代理功能，则两者都会把自身和R3相连接口的MAC地址发送给R3，这也是一种变相的ARP欺骗，如果R1的ARP回应报文先到，R2的ARP回应报文后到，则R3会将晚到的R2的ARP回应报文放入ARP缓存中使用。此后凡是去往2.2.2.2的数据包，均使用R2的F0/0口的MAC地址进行封装，不在发送ARP请求，如果R2的F0/0口DOWN掉，在R3上关于2.2.2.2的ARP条目超时之前（思科默认ARP超时时间，Nexus系列为25分钟，其他的交换机如6XXX系列交换机为4小时）或手动清除2.2.2.2的ARP条目之前，R3无法再PING通2.2.2.2，因为此时ARP缓存表中的MAC地址是错的是R2的，而R2此时DOWN了。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_10-12-53.jpg" alt="Snipaste_2020-06-15_10-12-53"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了将数据包<strong>转发到目的地</strong>，路由器必须先确定出口接口并在数据链路层重写2层头部（主要参数为源MAC地址、目的MAC地址以及type），然后再将数据通过物理层传递出去，在以太网环境中为了重写2层头部，路由器使用ARP协议通过已知的IP地址获得相对应的MAC地址。在配置静态路由时，既可指定发送接口，也可指定下一跳地址，<strong>在点对点环境下，无论是指定下一跳地址还是出接口，其效果都是一样的。但是在广播网络环境下，指定下一跳地址和指定出接口将会达到不同的效果。</strong></p>
<p><strong>在点对点的情况下</strong>，不论指定下一跳地址还是出接口都是一样的，因为两个设备直接相连，下一跳只可能是彼此，是固定的，下一跳二层报头的MAC地址也是固定的。</p>
<p><strong>在以太网环境下，当下一跳配置为出接口时</strong>，首先只有当该出接口状态为UP时该条路由才会加入路由表；其次路由器会认为该路由的目的IP地址和本地直连，由于二层封装需要目标IP地址的MAC地址，所以在这种情况下在以太网环境中，每次发送数据前往目的网段中的任一IP地址时，路由器都会尝试从静态路由配置的下一跳出接口发送ARP去获取目标IP地址所对应的MAC地址，而不会去请求网关的MAC地址。比如配置成：ip route 5.5.5.0 255.255.255.0 G0/0的时候，当发送数据去5.5.5.5时，路由器会认为5.5.5.5和G0/0接口直连，它会从G0/0口发出ARP去请求5.5.5.5的MAC地址，当发送数据去5.5.5.6时，路由器依旧会从G0/0口发出ARP去请求5.5.5.6的MAC地址，使得ARP表项过于庞大影响设备性能。当通过中间的代理ARP设备收到“善意欺骗”的MAC地址（假设该MAC地址为AA.AA.AA.AA）后，路由器会将该善意欺骗的MAC地址放入ARP缓存中，ARP缓存过期时间在思科设备上默认为25分钟，在这段时间里即使更换了新代理ARP设备，新的ARP代理设备的MAC地址为BB.BB.BB.BB，路由器中的ARP缓存条目还是之前的AA.AA.AA.AA，无法正确发送数据。</p>
<p><strong>在以太网环境下，当静态路由的下一跳配置为IP地址时</strong>，发送数据去往目的网段需要用到下一跳IP地址对应的MAC地址，比如上面配置的：ip route 5.5.5.0 255.255.255.0 192.168.45.5，当封装去往目标网段的数据时，路由器只需要请求下一跳IP地址的MAC地址，也就是192.168.45.5的MAC地址去构建二层头部，发送数据去往该网段的所有IP地址只需要192.168.45.5的MAC地址，一条ARP条目即可完成整个网段的二层封装。</p>
<p><strong>所以在广播或多路访问情况下，静态路由的下一跳用IP地址更为合适，因为这样可以避免每次发送数据时频繁请求目标IP地址对应的MAC地址，既能减少ARP缓存条目，也防止中间代理ARP设备更换但ARP缓存没到期没刷新引发的无法访问情况。</strong></p>
<h2 id="缺省（默认）路由"><a href="#缺省（默认）路由" class="headerlink" title="缺省（默认）路由"></a>缺省（默认）路由</h2><p>默认路由是当没有其他路由与目标IP地址匹配时最后生效的路由。一般来说，路由表会根据最长匹配原则，先明细路由，而后汇总路由，最后使用默认路由。</p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ip route 0.0.0.0 0.0.0.0 &#123;ip-address | exit-interface&#125;</span><br></pre></td></tr></table></figure>

<p>0.0.0.0  0.0.0.0 前面的网络号和后面子网掩码都是0，表示所有的网络和指定网络中所有的主机，后面可以跟出接口或者下一跳IP地址，比如可以配置成：ip route 0.0.0.0 0.0.0.0  G0/0，表示所有不知道该怎么走的数据均从G0/0口发出，当然上面章节中写过，静态路由的下一跳最好还是配置成和运营商直连的IP地址，以防止ARP导致的问题。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般常见于内网的出口路由器上，避免维护过多的路由表加重路由器负担。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-27_15-39-53.jpg" alt="Snipaste_2020-05-27_15-39-53"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-27_15-40-06.jpg" alt="Snipaste_2020-05-27_15-40-06"></p>
<h3 id="静态路由进阶配置"><a href="#静态路由进阶配置" class="headerlink" title="静态路由进阶配置"></a>静态路由进阶配置</h3><h4 id="浮动静态路由"><a href="#浮动静态路由" class="headerlink" title="浮动静态路由"></a>浮动静态路由</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>浮动静态路由是指管理距离大于其他静态路由或动态路由的管理距离的静态路由。通过配置一个比主路由的管理距离更大的静态路由，保证网络中主路由失效的情况下，提供备份路由。 但在主路由存在的情况下它不会出现在路由表中。</p>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p>用静态路由作为动态路由协议的备份路由手段。静态路由的AD（Administrative Distance，管理距离）在思科设备上的默认值为1，这意味着路由器在选择路径时，相对于管理距离更高的动态路由选择协议（OSPF的AD为110，EIGRP的AD为90）来说，会优先选择AD值更小的静态路由协议，当我们希望使用静态路由作为动态路由协议的备份路由手段时，我们得使用浮动静态路由。</p>
<p>配置多条静态路由只希望有一条静态路由工作。当设备有多出口时，比如分别有电信和联通两个互联网出口，但希望联通作为主用出口，当联通线路中断时再使用备份的电信路径作为出口，浮动静态路由也非常有用。对于主用路径，可以使用默认管理距离，对于备用路径，使用更大的管理距离（管理距离越小路径越优先，越大越不优先），当主用路径的接口或链路出现故障时，主用路径从路由表中消失，路由器使用备用路径进行通信。</p>
<h5 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h5><p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface }   AD值</p>
<p>比如配置成 ip route  0.0.0.0  0.0.0.0  192.168.12.2  10，意味着配置一条管理距离为10的，下一跳是192.168.12.2的默认静态路由。由于管理距离是10，比一般静态路由的AD值大，所以如果同时有一条 ip route  0.0.0.0  0.0.0.0  192.168.34.4  的静态路由时，AD为10的静态路由由于AD值大不会加入路由表，当没配置浮动静态路由的默认路由线路中断从路由表中消失后，AD为10的静态路由加入路由表，作为备份路由发挥作用。</p>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-32-08.jpg" alt="Snipaste_2020-06-15_11-32-08"></p>
<p>在一个典型的教育园区网中，我们往往有两条以上的外网出口线路，假设一条为电信， 一条为教育网出口。那么我们一般为出口路由器添加一条默认路由，指向电信的下一跳地址，为的是让内网用户能够通过电信线路访问Internet资源。然而，如果电信出口出现故障呢？我们可以在路由器上增加一条默认路由， 我们知道，如果你配置两条默认路由，分别关联两个不同的下一跳，那么这两条路由将会在路由表中进行负载均 衡，但是这里我们并不希望出现这个现象，我们希望一主一备，那么这条新增的默认路由就可以这么来配置： Ip route 0.0.0.0  0.0.0.0  教育网下一跳IP   10   。我们知道静态路由的AD值是1，上面的配置方法，实际上是将该条静态路由的AD值修改为10。这样一来我们有两条默认路由，一条指向电信出口，AD 值为默认的 1；另一条指向教育网出口，AD 值为 10。那么经过 PK 之后，毫无疑问指向电信的默认路由出现在了路由表里，而指向教育网这条默认路由， “猥琐”的躲了起来。 当指向电信的默认路由失效的时候它就从路由表里消失了，那么这时候，指向教育网的这条默认路由，就“浮” 了出来。</p>
<h4 id="permanent参数"><a href="#permanent参数" class="headerlink" title="permanent参数"></a>permanent参数</h4><p>当静态路由后面使用permanent参数时，即使该静态路由使用的接口出现故障，它也将停留在路由表中，如果不配置permanent参数，则静态路由使用的接口出现故障时，路由器将把该路由条目从路由表中删除，尝试寻找替代路由条目加入路由表。因此如果不希望数据包经其他路径前往目标网络（通常是基于安全考虑），应使用permanent参数。</p>
<p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface }   permanent</p>
<h1 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h1><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-37-18.jpg" alt="Snipaste_2020-06-15_11-37-18"></p>
<p>这台出口路由器由于和三层交换机之间是三层链路，因此需配 置到内网的回程路由，也就是上图中红色字体部分，这个场景中内网只有三个网段，因此配置了三条静态路 由，但是如果有100个网段呢？岂不是要配100条路由？如此一来路由表就变的非常庞大和臃肿，维护和管理和非常不方便，更重要的是，这无疑浪费了设备的资源。因此从网络优化的角度，不管是何种网络场景何 种网络模型，我们都需时刻关心网络中路由器路由表里的路由条目数量，是否足够优化，是否有可优化的空间。应该如何优化？</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-39-15.jpg" alt="Snipaste_2020-06-15_11-39-15"></p>
<p>答案是使用路由汇总，在这个场景中，如果使用单独的静态路由，一共需要3条，但此时可以使用一条汇总路由就能达到同样的效果，配置汇总路由的好处是，路由器的条目大大减少，能够降低路由器的负载。</p>
<h2 id="路由汇总的计算"><a href="#路由汇总的计算" class="headerlink" title="路由汇总的计算"></a>路由汇总的计算</h2><p>路由的汇总实际上是通过对子网掩码的操作来完成的。</p>
<p>假设我们有192.168.1.0/24，192.168.2.0/24……..192.168.8.0/24这几个子网，现在需要经过计算，得出刚好包括这几个明细的汇总网段。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-46-27.jpg" alt="Snipaste_2020-06-15_11-46-27"></p>
<ol>
<li>将他们写成二进制形式，实际上，我们只要考虑第三个8位组即可，因为这几个明细子网中只有第三个八位组是不同的。</li>
<li>现在，我们要画一根竖线，这根线的左侧，每一个列二进制数都是一样的，线的右侧则无所谓，可以是不同的，注意这根竖线，可以从默认的掩码长度，也就是/24开始，一格一格的往左移，直到你观察到线的左端每一列数值都相等，即可停下，这时候，这根线，所处的位置就是刚刚好。</li>
<li>如上图，线的位置是16+4=20，所以我们得到汇总地址：192.168.0.0/20，这就是一个最精确的汇总地址。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-52-13.jpg" alt="Snipaste_2020-06-15_11-52-13"></p>
<p>路由汇总虽然确实是一个非常非常重要的思想和工具，但是使用起来要持谨慎态度，毕竟减少路由条目 的同时，也降低了路由的颗粒度和精确性。看上图，在出口路由器上配置了静态汇总路由，下一跳是三层交 换机。而三层交换机为了将访问外网的流量送到出口路由器，配置了一条默认路由，下一跳是出口路由器。 这个网络在流量正常的情况下不会有问题，但是，现在内网用户中毒了，于是这些 PC 开始疯狂的发送 内网的扫描报文，这些报文的目的地址是一些192.168打头的不知名地址，甚至根本不存在的地址。数据包 被送到了网关也就是三层交换机上，由于三层交换机配置了默认路由，因此这些数据包目的地被默认路由匹 配并被引导到了出口路由器上，而出口路由器上部署了汇总路由，这些数据包的目的地址虽然在内网中不存 在，但是却是这个汇总路由里的一个IP，因此又被出口路由器转发回给三层交换机，接下去三层交换机又根 据默认路由，将数据包转发回出口路由器，这就形成了数据的环路。 因此，从这里我们可以看出来，路由汇总，是有产生环路的风险的，解决上述问题的一个办法就是，我 们在三层交换机上，增加一条静态路由：ip route 192.168.0.0 255.255.0.0 null 0，这样一来，当它收到访问 192.168开头的、不存在的目的地址的数据包，就会直接丢弃。而正常的访问192.168内网其他子网的流量会根据最长匹配原则被正常转发。 这个思想被应用到了诸如OSPF等这类动态路由协议上，细心的童鞋会发现，你在OSPF中部署了路由 汇总后，它会自动在本地产生一条指向 null0 的汇总路由，道理跟上面讲解的是一样的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-52-37.jpg" alt="Snipaste_2020-06-15_11-52-37"></p>
<p>有些时候，路由汇总的颗粒度不够细的话，可能会包含一些不必要的网段，比如在R2上， 为了到达R1下联的网络， R2配置了使用路由汇总的工具， 指了一条汇总路由： 192.168.0.0/16 到R1，虽然这确实起到了网络优化的目的，但是，这条汇总路由太“粗犷”了，它甚至将R3这一侧的网段也囊括在内，在使用路由汇总时一定要注意避免发生这种情况。</p>
<h1 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h1><h2 id="路由器的基本概念"><a href="#路由器的基本概念" class="headerlink" title="路由器的基本概念"></a>路由器的基本概念</h2><p>路由器工作在OSI参考模型的第三层网络层，利用网络层定义的”逻辑地址”（IPV4或IPV6地址）来区别不同网络，它不转发广播消息，并将广播消息限制在每个网络内部，也就是之前笔记曾经提到的隔绝广播域，每个接口是一个广播域；发往其他网段的数据根据路由表转发。</p>
<p>目前在Internet网络中采用子网掩码来确定IP地址中的网络号和主机号；并规定，子网掩码（二进制形式）中数字”1”对应的IP地址中的部分为网络号，子网掩码中数字”0”所对应的IP地址中的部分为主机号，相同网络号的主机可以直接通信，不同网络号的主机需要通过网络中某个路由（网关）使他们能够通信。</p>
<p>路由上不同端口对应不同IP子网，不同端口的网络号必须不同。</p>
<h2 id="路由器转发原则"><a href="#路由器转发原则" class="headerlink" title="路由器转发原则"></a>路由器转发原则</h2><h3 id="转发IP包的条件"><a href="#转发IP包的条件" class="headerlink" title="转发IP包的条件"></a>转发IP包的条件</h3><ol>
<li>目的网络可达(路由表中必须存在到达目的网络的路由).</li>
<li>下一跳的接口地址必须可达.</li>
<li>重写源MAC地址使得成功到达下一跳.–应该是ARP获得MAC地址更新ARP表然后才可正常转发.</li>
</ol>
<h3 id="数据处理步骤"><a href="#数据处理步骤" class="headerlink" title="数据处理步骤"></a>数据处理步骤</h3><p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704-1592451122884.jpg" alt="微信图片编辑_20200611145704"></p>
<p>首先将物理层的比特流还原成帧，然后对数据帧尾部的FCS进行校验看数据是否损坏，如果损坏就丢弃，如果没损坏则进行解封装，检查二层帧头中的目的MAC地址是否是收到此数据接口的MAC地址，如果不是则丢弃，如果目的MAC地址和接口MAC地址相同则说明这个数据是发给自己的，而后查看数据帧头部的Ether Type字段，发现类型为0X0800（一般情况为0X0800，但具体问题具体分析），表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4（或其他协议）封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749-1592451131369.jpg" alt="微信图片编辑_20200611150749"></p>
<p>当数据到了网络层后，继续解三层数据包的封装，继续对IP报头进行解封装，首先校验一下在传输过程中IP报头部分是否损坏，如果没损坏则继续查看目的IP地址是否是自身的IP地址，这个自身的IP地址不仅是收到数据那个接口的IP地址，而是要看和所有接口及环回接口的IP地址是否相同，如果相同的话，则将三层报头剥离将数据传递，然后根据Protocol字段内容给相应的上层继续处理，如果IP地址不是自身的IP地址，如果该IP地址的网段在路由表中有相应条目则修改源、目的MAC地址将数据包按路由表转发出去。</p>
<h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_15-26-04.jpg" alt="Snipaste_2020-06-15_15-26-04"></p>
<p>R1的路由表如图中所示，当数据发送到192.168.30.0网段的数据时，根据查询路由表的第一行可知，该数据需要发送给下一跳192.168.23.3，如何前往192.168.23.3呢？由路由表第二行可知，去往192.168.23.0网段需将数据发送给下一跳为192.168.12.2，所以去往192.168.30.0只要将数据发送给192.168.12.2即可，通过进一步查询路由表可知，去往192.168.12.0网段需要从S0/0口发送出去，所以经过上面的路由查询可知，去往192.168.30.0网段的数据从S0/0口发送出去即可。这个过程就叫递归查询。</p>
<h2 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>最长匹配原则是CISCO IOS路由器默认的路由查找方式。当路由器收到一个IP数据包时，会将数据包的目 的IP地址与自己本地路由表中的表项进行bit by bit的逐位查找， 直到找到匹配度最长的条目， 这叫最长匹配原。</p>
<h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><p>因为路由表中的每个表项都指定了一个网络，所以一个目的地址可能与多个表项匹配。最明确的一个表项——即子网掩码最长的一个——就叫做最长前缀匹配。之所以这样称呼它，是因为这个表项也是路由表中，与目的地址的高位匹配得最多的表项。</p>
<p>例如，考虑下面这个IPv4的路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.20.16/28</span><br><span class="line">192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>在要查找地址192.168.20.19的时候，这两个表项都“匹配”，因为192.168.20.16/28包含了从192.168.20.16-192.168.20.31这几个IP地址，而192.168.0.0/16包含了从192.168.0.1-192.168.255.254这所有的IP地址。也就是说，两个表项都包含着要查找的地址。这种情况下，前缀最长的路由就是192.168.20.16/28，因为它的子网掩码（/28）比其他表项的掩码（/16）要长，使得它更加明确，如果此时路由表中有一个192.168.20.19/32的路由，则这条路由比192.168.20.16/28要更加匹配，因为32/的掩码比28/要长。</p>
<p>路由表中常常包含一个默认路由。这个路由在所有表项都不匹配的时候有着最短的前缀匹配。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-10_11-35-48.jpg" alt="Snipaste_2020-06-10_11-35-48"></p>
<h4 id="主类网络"><a href="#主类网络" class="headerlink" title="主类网络"></a>主类网络</h4><p>如上图所示，灰色的空间 172.16.0.0/16，这个网络号，我们称为主类网络号，所谓主类网络号，意思是该网络号，按照其所属的 IP 地址类别区分后，对应上的默认的子网掩码长度后得到的网络号。如 172.16.0.0 这是一个 B 类地址，B 类地址的默认子网掩码长度是 16 位，因此 172.16.0.0/16 本身就是一个主类网络号。再举过一个例 子，10.1.12.0/24，首先 10 开头的，这是一个 A 类地址，A 类地址默认的掩码是 255.0.0.0，因此 10.1.12.0/24 它的主类网络号是 10.0.0.0/8。再举一个C类网络的例子，192.168.10.1/26，C类地址的默认网络掩码是255.255.255.0，所以192.168.10.1/26的主类网络号是192.168.10.0/24。</p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>继续如上图所示，从172.16.0.0/16 开始往里走，下一个我们看到的网络号是 172.16.10.0/24，这很明 显是应用了 VLSM 可变长子网掩码之后， 得到的一个 172.16.0.0/16 这个主类网络的一个子网。 所以所谓的子网，我们可以理解为是在网络号所属类别的默认掩码长度的基础上，将掩码“拉长”或者向主机位借位从而得到的一个网络号。实际上 172.16.0.0/16 是将 172.16.10.0/24 囊括在内的一个区间。</p>
<h4 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h4><p>如图中所示，172.16.0.0/16 这个主类网络号，然后我们向外走，看上图。172.0.0.0/8 实际上是将这个 B 类 地址的掩码向左移了 8bits，这样一来得到的这个网络号实际上是囊括了 172.16.0.0/16 在内的一个大的网络号， 我们称其为超网。 </p>
<h4 id="如何最长匹配"><a href="#如何最长匹配" class="headerlink" title="如何最长匹配"></a>如何最长匹配</h4><p>如果我们有一个 IP： 172.16.10.1，实际上这个 IP 既可以理解为在 172.16.0.0/16 网络内，也是在 172.16.10.0/24 网络内，当然，从图上我们能看出来，谁更精确呢？很明显是 172.16.10.0/24 更精确，因为172.16.0.0/16只匹配了16位，而172.16.10.0/24则匹配了24位，所以我们说，它的匹配长度相比 172.16.0.0 更长。</p>
<p>当然子网 172.16.0.0/16 还可以进一步划分子网，得到 172.16.10.0/30，甚至 172.16.10.1/32，那么如果这些 前缀都存在的情况下，当我要去找 172.16.10.1，谁的匹配度最高呢？很明显，是 172.16.10.1/32 这条主机前缀， 或者说，主机路由吧？这就是最长匹配原则。 </p>
<p>举个具体例子看一下最长匹配的过程：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-11_16-34-31.jpg" alt="Snipaste_2020-06-11_16-34-31"></p>
<p>例如上图，当 R3 收到一个数据包，去往 172.16.1.1，那么实际上，172.16.1.1 是“掉落”在 172.16.1.0/24 及 172.16.0.0/16 网络中的，两者貌似皆可，但是 172.16.1.0/24 显然，匹配度要更长，因此，最终这个数据包被 丢给了 R1。同理若有数据包去往 172.16.2.1 呢？由于根据最长匹配原则，172.16.2.0/24 这个条目匹配度最高， 因此数据被扔给了 R2。具体匹配过程如下：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-11_16-52-14.jpg" alt="Snipaste_2020-06-11_16-52-14"></p>
<p>当R2挂掉以后，172.16.2.0/24 的条目失效，去往 2.0 子网的数据此时匹配的路由条目是 172.16.0.0/16 这条路由，因此被送往了 R1。这也是利用最长匹配原则，实施的一种简单的数据分流及路径冗余的方法。</p>
<h2 id="路由所需的元素"><a href="#路由所需的元素" class="headerlink" title="路由所需的元素"></a>路由所需的元素</h2><p>目标网络和前缀、目的网络下一跳和/或出接口、管理距离、度量值和路由类型。其中目标网络和前缀以及下一跳和/或出接口是必须的，否则无法进行转发；管理距离及度量值用于比较路由的优先级，在一个目标网络有多种路由或多条路径时用于比较到底使用哪条路由转发。</p>
<h2 id="路由查找原则总结"><a href="#路由查找原则总结" class="headerlink" title="路由查找原则总结"></a>路由查找原则总结</h2><ul>
<li>不同的前缀（网络号+掩码，做与运算后得出前缀，网络号和掩码缺一不可） ，在路由表中属于不同的路</li>
<li>相同的前缀，通过不同的协议获取，一般情况下先比AD，后比metric，特殊情况具体问题具体分析</li>
<li>默认采用最长匹配原则，匹配，则转发；无匹配，则找默认路由，默认路由都没有，则丢弃 </li>
<li>路由器的行为是逐跳的，到目标网络的沿路径每个路由器都必须有关于目的地的路由，没有路由则丢弃数据</li>
<li>数据是双向的，考虑流量的时候，要关注流量的往返都有路由，数据才能进行传递。</li>
</ul>
<h2 id="路由器发送数据的方式"><a href="#路由器发送数据的方式" class="headerlink" title="路由器发送数据的方式"></a>路由器发送数据的方式</h2><h3 id="交换的概念"><a href="#交换的概念" class="headerlink" title="交换的概念"></a>交换的概念</h3><p>switching is the process of mapping layer 2 to layer 3 addresses and forwarding to a destination interface. </p>
<p>交换是一个将二层地址映射到三层地址互相关联并且转发到目标接口的过程。这里路由器这个三层设备的交换概念和之后二层的交换不是一个概念，注意区分。</p>
<h3 id="进程交换"><a href="#进程交换" class="headerlink" title="进程交换"></a>进程交换</h3><p>进程交换（process switching），在这种模式下，一条数据流(flow)中的第一个包(packet)将被置入系统缓存(system buffer)，其目的地址将会拿到路由表中去查询比对，路由器的处理器(CPU or Processer)同时将进行CRC校验,检查包是否正确。然后数据 包的二层 MAC 地址将会被重写,替换为下一跳接口的 MAC 地址，这样的过程将会继续,对这条数据流(flow) 中的第2个、第3个数据包……相同的操作，包括查询路由表、重写MAC地址,CRC校验等，也就是每个数据包都需要CPU进行处理。这种方式是最古老，占用CPU最多，速度最慢，延迟最大的，因为它要利用system buffer以及processor去处理每个收到的包，但是我们仍然有机会使用这种交换方式，比如在进行基于每个包的负载分担时,或是debug ip packet时。 </p>
<h3 id="快速交换"><a href="#快速交换" class="headerlink" title="快速交换"></a>快速交换</h3><p>进程交换由于CPU占用率高，转发速度慢，已经跟不上互联网发展的需要，于是出现了速度更快的转发技术，快速交换（Fast Switching）。</p>
<p>快速交换（Fast Switching）采用了route cache(路由缓存)来存储关于某条数据流(flow)的特定信息, 这个特定信息会包括诸如目的MAC地址，目的接口等内容，这时我们只需要对一条数据流(flow)中的第一个包做process switching（也就是上面的进程交换），大概过程就是对第一个数据包执行最长匹配查找算法获得下一跳IP地址，然后查找ARP缓存获得第二层的MAC地址信息，并把得出的信息存入cache（高速缓存），所有后续数据包，可以不必再中断system processor去执行查询等操作，直接从 cache（缓存） 中提取目的接口，目的 MAC 地址等，根据已经生成的高速缓存的条目直接重写MAC头信息完成交换操作，这样大大加速了包转发速度。</p>
<p>但进程交换也有自己的问题，其中比较严重的就是由于路由更改，路由缓存条目中在一开始是没有缓存的，有时必须通过进程交换转发，导致转发效率下降。</p>
<h3 id="思科CEF"><a href="#思科CEF" class="headerlink" title="思科CEF"></a>思科CEF</h3><p>由于快速交换的缓存机制原理问题，路由改变会导致之前的缓存无效，重建缓存的过程开销很大，而互联网中信息的大量增加导致缓存的负担增大，从而导致路由器性能的降低，此时快速交换已经不能适应需求了，所以CEF横空出世，该技术能解决进程交换存在的缓存无效问题，也能减少CPU消耗。其他厂家也有类似思科快速转发的技术，不过换了不同的名称，技术原理上都是类似的。</p>
<p>CEF转发主要好处是减少了CPU的占用，提升设备稳定性。CEF采用了基于硬件的平台，不仅仅是将数据都存入system buffer，而是将整个路由表、拓扑表，以及所有的下一跳地址、MAC地址全部进行“预存”，只要路由表、拓扑表中存在的条目，无论是否有数据请求发往该地址，都会提前预读取，设置缓存，采用这种方式，当有新的数据请求发送时，就不需要CPU去查询目的接口，目的MAC地址等信息，而是直接从缓存中读取，从而使得转发速度得以大大提高。</p>
<p>Cisco快速转发是最快的交换模式，这种方式比快速转发和进程转发交换使用更少的CPU，对于启用了CEF的路由器，其控制平面CPU会使用路由表和地址解析协议表中的3层和2层信息（IP地址、MAC地址），来创建两个基于硬件的表，这两个表分别是转发信息表（FIB）和邻接表（ADJ），<strong>当网络收敛时，FIB和ADJ表中会包含路由器在转发数据包时会使用的所有信息，两个基于硬件的表会用来转发数据包中的所有数据帧，包括第一个帧，FIB包含预先算出来的逆向查找和下一跳信息（包括2层信息和接口）</strong>。</p>
<p>查看CEF是否开启的命令是：show ip cef，如果想在未开启CEF的设备上开启CEF，命令是：ip cef distributed</p>
<p><img src="/2020/05/04/11-route-basic/CEF.png" alt="CEF"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-18_11-37-59.jpg" alt="Snipaste_2020-06-18_11-37-59"></p>
<h4 id="FIB表"><a href="#FIB表" class="headerlink" title="FIB表"></a>FIB表</h4><p>FIB（forwarding information base）是一个动态构建的数据库，位于路由器转发（数据）层面，路由器使用它来做出基于前缀的转发决策，也就说路由器按照FIB表来转发数据，真正指导数据转发的是FIB表。FIB表中数据往往被存储在一个ASIC专用集成电路中，这使得设备在FIB表中进行数据查询时，可以实现相当高的速度。当然，FIB表空间是有限的，因此要注意用各种机制来减小设备路由表的规模，比如上文提到的路由汇总。</p>
<p>FIB中的信息和IP路由表中的条目之间有一一对应的关系，FIB不仅有路由表的信息还提前对这些信息进行了路径的递归查询，节省了大量时间，提高了转发效率。由于FIB表存储存储在一个ASIC专用集成电路中，因此该表格不存在过期作废或定时刷新的问题，只有当网络拓扑或路由表发生变化时，IP路由表被更新，FIB也随之产生变化，重新进行递归等步骤生成FIB表。FIB表中一般包含IP前缀，递归的下一跳，出战接口，其他非转发核心的参数FIB表中并不包含，查看FIB（CEF）表的命令是show ip cef。</p>
<p>路由器启动时默认使用CEF进行转发，路由表中的所有路由传入FIB的维护进程，该进程根据收到的前缀描述项和路径生成FIB（转发信息库）项目，例如把需要递归的路由提前算好。当主路由表内容改变时，会通知FIB维护进程，根据新路由信息改变收到路由改变影响的FIB条目。</p>
<p><img src="/2020/05/04/11-route-basic/200807181216359487780.jpg" alt="200807181216359487780"></p>
<h4 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h4><p>邻居表的英文是Adjacency table，当两个节点之间只间隔二层意义上的一跳时，那么说这两个节点相邻。CEF在叫做邻居表的数据库中为相邻节点存储转发信息，转发信息主要包括出栈接口以及二层报头重写信息。CEF使用邻居表提前为数据包准备二层地址信息。</p>
<p>邻居发现的过程生成了邻居表，邻居表中的邻居条目可以由间接手动配置，也可以通过自动发现而自动添加进邻居表，例如由ARP协议自动添加邻居表的条目。邻居表还可以由路由协议（比如BGP或OSPF）在建立邻居时添加。邻居表每次创建一个相邻条目时，都会计算出该相邻节点的链路层报头，并存储在相邻表中。邻居表中的相关信息会在之后CEF转发过程中的封装步骤里使用到，也就是说二层帧的报头重写工作要根据邻接表中的信息来完成。</p>
<p>当路由器确定了目标网络的可达性及下一跳后，下一步是确定发出接口的二层封装信息（源、目的MAC地址）以及其他传输需要的信息，这些信息都储存在邻居表中。这些二层信息通过ARP、ATM、帧中继的映射状态，路由协议的邻居关系等方式学习到。</p>
<p>邻居表存储了与FIB条目中相关联的二层信息，避免了每次查找路由表都需要运行ARP协议。</p>
<p><img src="/2020/05/04/11-route-basic/200807181216359461673.jpg" alt="200807181216359461673"></p>
<h1 id="路由选择过程"><a href="#路由选择过程" class="headerlink" title="路由选择过程"></a>路由选择过程</h1><h2 id="需要路由选择的情况"><a href="#需要路由选择的情况" class="headerlink" title="需要路由选择的情况"></a>需要路由选择的情况</h2><p>当遇到类似于下图的情况，R2从两个不同的路由协议，OSPF和RIP同时获得了10.1.1.0/24的路由信息，或</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-33-58.jpg" alt="Snipaste_2020-05-05_16-33-58"></p>
<h2 id="选择最佳路由的步骤"><a href="#选择最佳路由的步骤" class="headerlink" title="选择最佳路由的步骤"></a>选择最佳路由的步骤</h2><p>根据最长匹配原则，最先使用匹配位数最多的明细路由，然后是汇总路由，最后才是默认路由。如果到达一个目标网段有多种路由协议且每种路由协议有多条路径，这种情况下，每种路由协议内部的多条路径先比较metric值（BGP由13条选路原则决定），决出本路由协议内的最优路径，然后不同路由协议之间再由AD值决出不同路由协议之间的最优协议。</p>
<p>1、比管理距离AD（可以是多种路由协议的比较；也可以是同种路由协议的比较，比如双线出口所配置的两条默认浮动路由比较）</p>
<p>2、比度量值metric（路由协议不同则度量值不能做比较，比如rip度量值为跳数；ospf度量值为带宽；eigrp度量值为带宽+延迟等。所以在不同种协议之间先比较管理距离）</p>
<h2 id="数据包的转发过程"><a href="#数据包的转发过程" class="headerlink" title="数据包的转发过程"></a>数据包的转发过程</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-11_16-19-39.jpg" alt="Snipaste_2020-05-11_16-19-39"></p>
<p>经过交换机，不会改变帧，源目MAC地址不会改变，源目IP地址不会改变</p>
<p>经过路由器，会改变帧，源目MAC地址会改变，源目IP地址不会改变</p>
<h1 id="控制平面和数据平面"><a href="#控制平面和数据平面" class="headerlink" title="控制平面和数据平面"></a>控制平面和数据平面</h1><h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://blog.csdn.net/chiyuwei1766/article/details/47334125">最佳路由选择的原则与步骤————管理距离和度量值</a></p>
<p><a href="https://blog.csdn.net/szcarewell/article/details/51246271">路由器数据转发过程</a></p>
<p><a href="https://www.qingsword.com/qing/520.html">[CCNA图文笔记]-9-静态路由与默认路由</a></p>
<p><a href="https://www.bilibili.com/read/cv575583/">Cisco交换方式理论+实践</a></p>
<p><a href="https://blog.csdn.net/zdh45222/article/details/3987577">cisco路由器 CEF,快速，过程交换</a></p>
<p><a href="https://www.networkurge.com/2020/04/process-switching-vs-fast-switching-vs.html">Process Switching Vs Fast Switching Vs CEF</a></p>
<p><a href="https://blog.51cto.com/389333/945282">进程交换 快速交换 CEF</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/63094377">动态路由选择原理（距离矢量路由协议RIP）</a></p>
<p><a href="https://blog.csdn.net/mypanlong/article/details/49000285">配置静态路由的下一跳使用出站接口和下一跳IP的差别</a></p>
<p><a href="http://ccietea.com/">IP routing（红茶三杯）</a></p>
<p><a href="https://forum.huawei.com/enterprise/zh/thread-272917-1-1.html">路由选择的最长匹配原则</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>13、ospf</title>
    <url>/2020/06/18/13-ospf/</url>
    <content><![CDATA[<h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>OSPF（Open Shortest Path First，开放最短路径优先，RFC2328）是一个被各厂商设备广泛支持的链路状态路由协议，也是现网中采用最多的路由协议，<strong>OSPF协议出现的原因</strong>是因为RIP协议限制比较多，在可扩展性方面以及协议性能上已经不适应网络发展现状的需要，例如最大跳数为15跳，大规模网络中的跳数超过了RIP所规定的15跳，而超过15跳在RIP中就表示不可达，所以RIP注定被淘汰。OSPF目前共有两个版本，为IPV4使用的OSPF V2以及为IPV6使用的OSPF V3。</p>
 <span id="more"></span>  

<p>OSPF采用SPF算法，不会产生环路；支持VLSM和CIDR；可以用于大型网络；采用层次化设计，容易扩展；区域化设计，减小路由更新给设备带来的负担；路由快速收敛，采用触发式更新；支持针对区域和链路的验证。执行OSPF的路由默认每隔30分钟会泛洪一次链路状态通告（LSA），成为链路状态刷新（并非周期性更新）；当一条LSA被接收并存储到链路状态数据库后，路由器会给这条记录增加一个老化时间标识，默认是一小时，所以为了防止一些正常的LSA被清除，这条LSA的路由会每隔30分钟泛洪一次这条LSA的一个新拷贝。</p>
<p>OSPF路由协议的管理距离为110，使用IP协议号89，采用COST作为度量标准（Metric），OSPF维护邻居表、拓扑表和路由表三张表项；OSPF的消息有Hello，DBD（Database Description），LSR（Link State Request），LSU（Link State Update），LSAck（Link State Acknowledge）；OSPF的网络类型有广播多路访问（BMA，Broadcast Multi Access），非广播多路访问（NBMA，None Broadcast Multi Access）。</p>
<p>SPF算法要求同一个OSPF区域中的每个路由器都有一致的LSDB，一个OSPF区域的每个路由器都以自己位根计算最短路径，到达每个目的地的最小Cost的路径最优，将最优的路径放入FIB中。  </p>
<h2 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h2><p>链路状态路由协议有点像你用导航去迪士尼乐园，导航软件从一开始就知道整个上海的地图以及从你所在的地点到迪士尼乐园有哪些可能存在的路线，然后对这些潜在的路线进行比较，看看哪条路线拥堵哪条路径通畅，最后选择出一条最优的路线告诉你应该怎么走。</p>
<p><img src="/2020/06/18/13-ospf/Cisco-CCNA-OSPF-1.jpg" alt="Cisco-CCNA-OSPF-1"></p>
<ul>
<li>首先向激活OSPF的接口发送Hello包，比较Hello包中的几个字段（Area ID，Hello Interval，Router Dead Interval、Authentication Type、Authentication），参数匹配后将对端放入自己的第一张表——邻居表（Neighbor Table，用show ip ospf neighbor命令查看）</li>
<li>第二步向邻居（Neighbor）发送本路由器的OSPF数据库（LSDB，Link-State DataBase）中所拥有的LSA，从各个邻居收来的LSA放入自己的第二张表——拓扑表（Topology Table）也叫Database数据库，使用show ip ospf database查看。</li>
<li>第三步运行SPF算法，以自己为根计算出一棵最短路径树，这棵树有两个特点，一是最短，二是无环，最后将计算出来的最优路径放入第三张表，路由表（OSPF Routing Table，用show ip route ospf查看）</li>
</ul>
<h3 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h3><p>“以自己为根计算出一棵最短路径树”这句话有点难理解，来把这句话拆成两部分分别解释，先看前半句，什么叫“以自己为根”呢？例如在现网中有一个拓扑，假设在咱们的角度来看是按下面的形式连接的：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-06-40.jpg" alt="Snipaste_2020-09-27_12-06-40" style="zoom:80%;">

<p>但在OSPF中，当各个路由器构建以自己为根的最短路径树时，和现网中的拓扑不同，每个路由器不是以物理连接形式来构建的，而是以逻辑连接方式看这个连接形式的，具体倒OSPF中就是以“根”（也就是每个路由器自己）为出发点构建的，都会假设自己这个路由器就是拓扑的核心或中心，所以每个路由器视角中的路径树分别如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-08-24.jpg" alt="Snipaste_2020-09-27_12-08-24" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-08-46.jpg" alt="Snipaste_2020-09-27_12-08-46" style="zoom:80%;">

<p>后半句的“一棵最短路径树”这个最短路径树中的“树”，指的其实是一种数据结构，这种树状的数据结构有一个根以及去往其他节点的分支，该分支也会有其他分支，大概看上去类似下图：</p>
<p><img src="/2020/06/18/13-ospf/u=2971199997,2574875640&fm=26&gp=0.jpg" alt="u=2971199997,2574875640&amp;fm=26&amp;gp=0"></p>
<h3 id="LSA的泛洪"><a href="#LSA的泛洪" class="headerlink" title="LSA的泛洪"></a>LSA的泛洪</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_16-52-00.jpg" alt="Snipaste_2020-08-01_16-52-00" style="zoom:67%;">

<p>运行OSPF的路由器之间首先会建立一个协议的邻居关系。路由器之间交互的是LSA，Link State Advertisement，而不是路由，与网络或其他路由器连接的每条链路都用LSA表示，LSA可以简单的理解为，每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居之间的关系等）的通告。收到LSA以后首先看该条LSA是否在本地的LSDB链路状态数据库中（通过LSA ID、Advertising Router ID、Sequence number、Age这几个字段检查自己的LSDB链路状态数据库中是否有相同的LSA，避免重复将一条LSA加入LSDB链路状态数据库中），如果不存在的话先将该LSA加入本地LSDB（链路状态数据库），然后泛洪LSA给邻居路由器（因为SPF算法要求同一个OSPF区域中的每个路由器都有一致的LSDB，该LSA我这台路由器没有，可能其他路由器也没有，所以要发送给其他路由器，使得OSPF域中的所有路由器的LSDB数据库尽快一致）。如果本地LSDB动态链路数据库中存在该LSA的话要比较LSA的序列号，如果序列号相同则收到的LSA将被丢弃，因为本地已经有了相同的LSA，不需要再将其加入LSDB中；在序列号不同时，如果本地LSDB的序列号旧，则用较新的LSA替换本地的旧LSA，发给邻居LSAck表示收到了该LSU更新；如果本地LSA比收到的LSA新，则将本地的LSA泛洪给邻居。</p>
<h3 id="LSDB的组建"><a href="#LSDB的组建" class="headerlink" title="LSDB的组建"></a>LSDB的组建</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-02-02-1596272540780.jpg" alt="Snipaste_2020-08-01_17-02-02"></p>
<p>经过了上面的LSA交互过程，路由器之间会彼此交互完所有LSA并利用LSA去构建LSDB，也就是链路状态数据库，构建了LSDB后路由器就清楚了全网的拓扑，因为LSDB中所存储的每条LSA都是由网络中各个路由器产生并且描述其直连接口的各项信息的条目，知道了这些接口的连接情况就可以根据LSDB“画出”全网络的拓扑。</p>
<h3 id="SPF计算"><a href="#SPF计算" class="headerlink" title="SPF计算"></a>SPF计算</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-08-48.jpg" alt="Snipaste_2020-08-01_17-08-48"></p>
<p>接下去，每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法，每个设备独立计算出一棵以自己为跟的、无环的、拥有最短路径的“树”，有了这棵树，事实上路由器就已经知道了到达网络各个角落的最优路径。</p>
<h3 id="维护路由表"><a href="#维护路由表" class="headerlink" title="维护路由表"></a>维护路由表</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-10-55.jpg" alt="Snipaste_2020-08-01_17-10-55"></p>
<p>最后，路由器将计算出来的最优路径，加载进自己的路由表。如果网络拓扑发生变化，路由器之间的LSDB链路状态数据库相互之间就不会完全一样，要重复上面的LSA交互过程。例如R4的某个接口down掉，那么R4的LSDB和其他域内的路由器不相同，会通过LSA知道；如果R4整个路由器down掉，那么其他路由器会通过hello包知道R4已经down掉，因为运行OSPF的路由器每过一段时间（Hello interval，不同网络类型的该数值不同，常见的以太网是MA类型，hello时间为10秒也就是每过10秒发送一次hello包查看邻居是否还正常工作）发送一个hello包查看邻居是否还正常工作，如果该邻居没有在规定时间内回复hello包超过了规定时间（Dead interval，默认为4倍Hello interval时间，以太网中是40秒）那么说明该邻居已经挂掉，必须重新同步本区域Area内的LSDB链路动态数据库。</p>
<p>当然上面这一段的讨论只限于OSPF协议中，实际中如果一条链路物理上挂掉，那么如果等Dead interval的40秒才知道邻居挂了，才开始反映显然是有点慢了，OSPF协议会通过IOS系统交互的信息了解到一条链路的状态从UP变为了DOWN。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="自治系统（AS）"><a href="#自治系统（AS）" class="headerlink" title="自治系统（AS）"></a>自治系统（AS）</h2><p>自治系统（Autonomous system），采用同一种路由协议交换信息的路由器及其网络构成一个自治系统。具体到OSPF协议中，简单来说就是所有运行OSPF的路由器所组成的网络是同一自治系统。</p>
<h2 id="内部网关协议（IGP）"><a href="#内部网关协议（IGP）" class="headerlink" title="内部网关协议（IGP）"></a>内部网关协议（IGP）</h2><p>内部网关协议，IGP，Interior Gateway Protocol，常见的OSPF、EIGRP、RIP这种都叫内部网关协议，每个自治系统（AS）都有一个IGP。 单独的自治系统（AS）可能会使用不同的IGP。与内部网关协议相对应的有外部网关协议（Exterior Gateway Protocol），与内部网关协议不同，外部网关协议其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由。外部网关协议目前只有BGP这一种。</p>
<h2 id="链路（Link）"><a href="#链路（Link）" class="headerlink" title="链路（Link）"></a>链路（Link）</h2><p>相当于一个接口加入OSPF进程，就被当做是OSPF的一条链路。</p>
<h2 id="链路状态（Link-State）"><a href="#链路状态（Link-State）" class="headerlink" title="链路状态（Link-State）"></a>链路状态（Link-State）</h2><p>包括接口的IP、子网、网络类型、链路话费、链路上的邻居等。</p>
<h2 id="链路状态通告（LSA）"><a href="#链路状态通告（LSA）" class="headerlink" title="链路状态通告（LSA）"></a>链路状态通告（LSA）</h2><p>链路状态通告（LSA）是OSPF协议的一种基本通信手段，它将路由器的本地拓扑发送给同区域（Area）的其他路由器，待所有路由器的LSA彼此交换完毕后，所有路由器就能知道整个OSPF网络的连接情况，可以进行路由计算。OSPF协议设计之初考虑了可扩展性，所以有些LSA不会在所有接口上泛洪而是只在相应区域的接口上泛洪。LSA用来描述路由器的本地状态，LSA包括的信息有路由器接口的状态和所形成的邻接状态。</p>
<h2 id="泛洪"><a href="#泛洪" class="headerlink" title="泛洪"></a>泛洪</h2><p>在OSPF路由器之间发布并同步LSDB链路动态数据库的过程，叫做泛洪，由于LSA构成了LSDB，也可以将泛洪理解为路由器之间同步LSA。</p>
<h2 id="路由器ID（Router-ID，简称RID）"><a href="#路由器ID（Router-ID，简称RID）" class="headerlink" title="路由器ID（Router ID，简称RID）"></a>路由器ID（Router ID，简称RID）</h2><p>RID是一个用来标识路由器的IP地址，长度为32位，在AS中唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在OSPF路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。</p>
<h2 id="邻居路由器（Neighbor-routers）"><a href="#邻居路由器（Neighbor-routers）" class="headerlink" title="邻居路由器（Neighbor routers）"></a>邻居路由器（Neighbor routers）</h2><blockquote>
<p>Two routers that have interfaces to a common network.Neighbor relationships are maintained by, and usually dynamically discovered by, OSPF’s Hello Protocol.</p>
<p>​                                                                         ——RFC 2328 Page 10</p>
<p>In short, two OSPF routers are <strong>neighbors</strong> if they are connected to the same subnet and share a series of common configuration information:</p>
<ul>
<li>Same Area ID</li>
<li>Same Area type</li>
<li>Same subnet mask</li>
<li>Same timers</li>
<li>Same authentication</li>
<li>They see their own OSPF RID in each other’s Hello packet</li>
</ul>
<p>In essence, OSPF neighborhood is a relation of two routers that allows them to <strong>see and understand</strong> each other but <strong>nothing more</strong>. In particular, two OSPF neighbors <strong>do not exchange any routing information</strong> - the only packets they exchange is Hello packets.</p>
<p>​                                                                         ——<a href="https://community.cisco.com/t5/switching/ospf-neighbor-v-ospf-adjacency/td-p/1576785">出处</a></p>
</blockquote>
<p>OSPF的邻居（Neighbor）指的是两台运行OSPF协议的路由器彼此将对方置于2WAY状态，但2WAY状态只是知道还有个也运行OSPF切基本参数相匹配的路由器存在，并不交换任何的路由信息。从另一个角度来说，两台路由器如果允许彼此看到并且明白对方的信息，那么就可以说这两台路由器是OSPF邻居关系。</p>
<h2 id="邻接关系"><a href="#邻接关系" class="headerlink" title="邻接关系"></a>邻接关系</h2><p>简单来说就是到达了FULL状态的两台路由器之间的状态，如果想具体研究可以参考上面提到的<a href="https://community.cisco.com/t5/switching/ospf-neighbor-v-ospf-adjacency/td-p/1576785">帖子</a>及<a href="https://packetpushers.net/howdy-mr-neighbor-router-ospf-adjacency-vs-neighborship/">这篇文章</a>。</p>
<h2 id="邻居VS邻接"><a href="#邻居VS邻接" class="headerlink" title="邻居VS邻接"></a>邻居VS邻接</h2><p>是邻居关系不一定是邻接关系，但是邻接一定是已经建立起了邻居关系。因为邻居关系处在2WAY状态，而必须经过2WAY到达FULL以后才能叫邻接关系。说实话感觉二者的区别有点太咬文嚼字了，直接说2WAY和FULL不完了嘛，更精确，还整个neighbor和adjacency，用两个概念很相近容易混淆的词来概括。</p>
<h2 id="区域（Area）"><a href="#区域（Area）" class="headerlink" title="区域（Area）"></a>区域（Area）</h2><p>OSPF通过划分区域来实现分层设计，跨越两个或两个以上区域的路由被称作ABR（Area Border Router，区域边界路由）。所有的区域都和“Area 0”相连，“Area 0”被称作骨干区域（Backbone），骨干区域路由器具有整个自治系统用中所有路由条目，LSA的扩散进限制在本区域内，可以通过划分多个区域以减小LSA扩散过程中对硬件的负担。作为骨干区域的Area 0的存在是为了快速高效的传输数据包，通常不接用户，主要负责多个常规区域的流量传输。Area 0 之外的区域叫做Regular area普通区域或nonbackbone area非骨干区域，主要为了连接用户，且所有数据交互都要通过Area 0中转，所以常规区域必须和骨干区域连接。一般一个区域内的路由器数量是30-200台。</p>
<p>这种层次设计的好处有：</p>
<ol>
<li>减少了路由表的条目。</li>
<li>LSA的泛洪在网络边界停止，能加速汇聚速度。</li>
<li>缩小网络的不稳定性，一个区域的问题不会影响到其他区域。</li>
</ol>
<h3 id="单区域"><a href="#单区域" class="headerlink" title="单区域"></a>单区域</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-13-26.jpg" alt="Snipaste_2020-07-14_16-13-26"></p>
<p>单区域就是所有路由器都在同一个Area中，如果一个区域内的路由器过多，那么一旦出现变化，需要同步的LSA会非常多，LSA的泛洪会很严重，泛洪完LSA后还要重新用SPF算法根据庞大的LSDB进行复杂的计算，这样的话OSPF路由器的负担会很大，因为OSPF要求区域内的所有路由器的LSDB相同，以计算出一个统一的无环的拓扑。同时单区域内的路由器过多会导致LSDB庞大，资源消耗过多，设备性能下降，影响数据转发。一般情况下，思科建议一个Area内的路由器不超过50台。</p>
<h3 id="多区域"><a href="#多区域" class="headerlink" title="多区域"></a>多区域</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-16-42.jpg" alt="Snipaste_2020-07-14_16-16-42"></p>
<p>在部署OSPF时，可以采用多区域的方式部署，有且只能有一个Area 0，Area 0为骨干区域，骨干区域负责在非骨干区域之间发布由区域边界路由器汇总的路由信息，为避免区域间路由环路，非骨干区域之间不允许直接相互发布区域间路由，因此所有区域边界路由器都至少有一个接口属于Area 0，即每隔区域都必须连接到骨干区域。</p>
<h2 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>OSPF是一个“接口敏感”的协议，这句话非常值得细细品味，比如路由的Cost值实际上应累加上接口的cost值，下面的DR\BDR选举也是基于接口的，另外邻居的建立也是与接口有关，因此很多机制的着眼点都与接口有关。一旦我们在某个接口上激活了OSPF协议，那么这个接口将会根据接口的二层，也就是数据链路层的封装捆绑对应的的OSPF网络类型，不同的OSPF接口的网络类型所对应的操作有所不同用。例如如果接口二层封装为以太网，那么OSPF在这个接口的网络类型为Broadcast也就是广播，如果接口的二层封装是HDLC或PPP，那么OSPF的网络类型则是P2P。OSPF定义了以下几种网络类型：</p>
<ul>
<li>点到点，Point-to-Point，P2P</li>
<li>广播，Broadcast Multi access</li>
<li>非广播，Non-Broadcast，非广播中又有5种模式，分别是NBMA（non-broadcast multiple access network，RFC规定），P2MP（Point-to-Multipoint，RFC规定），P2MP nonbroadcas（Cisco），Broadcast（Cisco），P2P（Cisco）。</li>
</ul>
<p>常见的数据链路层协议对应的默认网络类型：</p>
<p><img src="/2020/06/18/13-ospf/53a3f6538de55.png" alt="53a3f6538de55"></p>
<p>在接口上使用命令show ip ospf interface X可以查看到接口的网络类型：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-31_17-15-02.jpg" alt="Snipaste_2020-07-31_17-15-02"></p>
<h3 id="点到点（P2P）"><a href="#点到点（P2P）" class="headerlink" title="点到点（P2P）"></a>点到点（P2P）</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-31_17-34-05.jpg" alt="Snipaste_2020-07-31_17-34-05"></p>
<ul>
<li>如果二层的协议为PPP、HDLC等，则OSPF的网络类型为P2P</li>
<li>如果帧中继子接口类型为P2P的，则OSPF网络类型也为P2P</li>
<li>不用选举BDR\DR</li>
<li>使用组播地址224.0.0.5</li>
<li>OSPF能够根据二层封装自动检测到P2P网络类型</li>
</ul>
<h3 id="多路访问（MA）"><a href="#多路访问（MA）" class="headerlink" title="多路访问（MA）"></a>多路访问（MA）</h3><blockquote>
<p>A <strong>multi access network</strong> is a <strong>network</strong> which can have <strong>multiple</strong> (more than 2) machines participating in the <strong>network</strong>. A point to point <strong>network</strong> can have only 2 and a <strong>multi access network</strong> can have more than 2. The most common example of a <strong>multi access network</strong> is Ethernet (and FastEthernet etc).</p>
</blockquote>
<p>多路访问网络是有多个（超过两个）设备参与通信的网络。点对点（P2P）网络有且只有2个设备，多路访问网络可以有超过2个设备。最典型的多路访问网络就是日常生活中最常见的以太网，Ethernet。OSPF在点到点网络上是不选取DR的，正常情况下，DR只在多路访问时选取。在多路访问类型网络中，所有路由器均与DR及BDR建立邻接关系，其他路由器（DR Other）之间处于2WAY状态。DR和BDR之间使用224.0.0.5的组播地址交换信息，其他路由器（DR Other）使用224.0.0.6和DR\BDR交换信息。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_16-58-10.jpg" alt="Snipaste_2020-06-25_16-58-10"></p>
<p>多路访问网络有两种类型：广播型多路访问网络（BMA）及非广播型多路访问网络（NBMA）。以太网是一种典型的广播型多路访问网络。在OSPF中使用show ip ospf interface查看接口类型。</p>
<h2 id="指定路由器（DR）"><a href="#指定路由器（DR）" class="headerlink" title="指定路由器（DR）"></a>指定路由器（DR）</h2><p>在广播多路访问网络中（Multi access）中，例如以太网接口，所有的路由器都是相同网段，处于同一个广播网络中，这些接口如果两两建立起OSPF邻接（Adjacency）关系，这就意味着，网络有：N（N-1）/2   这么多个邻接（Adjacency）关系，维护如此多的邻接关系不仅仅额外消耗设备硬件资源，更是增加了网络中LSA的泛洪数量，占用网络资源。所以为了减小多路访问网络中的OSPF流量和硬件消耗，OSPF会在每一个MA网络中选举出一个指定路由器和备用指定路由器，也就是DR和BDR。DR及BDR的身份是基于OSPF接口的，所以如果我们说“这台路由器是DR”的话，实际上这种说法是不严谨的，因为DR是接口的属性而不是路由器的属性，严格的说应该是“这台路由器的这个接口，在这个MA网络上是DR”。每台路由器都把拓扑变化发给DR和BDR，然后由DR通知多路访问网络中的其他路由器。在OSPF网络中，既不是DR也不是BDR的接口，它的角色是DR Other。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_11-59-29.jpg" alt="Snipaste_2020-06-25_11-59-29"></p>
<p>如上图中的四台路由器，R1、R2、R3、R4，运行OSPF协议且已经建立起了邻居且选举完DR\BDR，R1的接口为DR，R3的接口为BDR，R2和R4的接口为DR Other，此时，这四台设备并不是相互之间两两交互LSA，而是R2、R3、R4分别和R1交换LSA，然后由R1将其他路由器没有的LSA传送给它们。DR Other 只于DR和BDR建立完全邻接关系，其它路由器处于two-way状态。有了DR以后，MA网络中需要维护的OSPF邻接关系大幅减小，M=（n-2）X 2 +1，LSA的泛洪问题也能得到一定缓解：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-06_15-01-03.jpg" alt="Snipaste_2020-08-06_15-01-03"></p>
<p>假设网络已经完成了OSPF收敛，现在突然R3下挂的一个网络发生了故障，路由器R3使用224.0.0.6将这个情况通知DR及BDR，DR\BDR监听224.0.0.6获得这个情况，DR向组播地址224.0.0.5发送更新通知其他路由器，所有的OSPF路由器监听224.0.0.5这一组播地址获知携带LSA更新的LSU，更新自己的LSDB并发送LSAck确认收到该信息，经过一段时间后（SPF延迟），对更新的链路状态数据库执行SPF算法，必要时更新路由表。</p>
<p>之所以要选举DR是为了避免路由器之间建立完全邻接关系而引起的大量开销，OSPF要求在多路访问的网络中选举出一个DR，每个路由器都与DR建立邻接关系。选举出DR的同时也选举出一个BDR（Backup Designated Router），BDR也就是备份DR路由器，BDR在DR失效时承担起DR的职责，DR Other路由器只与DR和BDR建立邻接关系。DR和BDR通信的组播地址为224.0.0.6，<strong>DR的选举是一个路由器的接口特性而不是整个路由器的特性</strong>，也就是说，一个路由器如果有3个接口，G0/0、G0/1和G0/2，G0/0是DR，G0/1是BDR，G0/2是DR Other也是没问题的，可能在一个MA网络种存在多个DR。比如下图的R3，两个接口分别是BDR和DR Other：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_18-48-46.jpg" alt="Snipaste_2020-06-25_18-48-46"></p>
<h2 id="DR-BDR选举"><a href="#DR-BDR选举" class="headerlink" title="DR\BDR选举"></a>DR\BDR选举</h2><p>如果想了解完全版的具体过程请参见<a href="https://tools.ietf.org/html/rfc2328#page-75">RFC</a>，但因为我看了两遍也没搞明白所以然，故这里采用红茶三杯总结的方式加上一点自己的理解，如果哪天突然开窍了看明白了RFC再回来补上这部分的笔记。</p>
<h3 id="选举的前提"><a href="#选举的前提" class="headerlink" title="选举的前提"></a>选举的前提</h3><ul>
<li>DR和BDR的选举发生在每个网段上，也就是说，如果有4个网段运行了OSPF，那么这4个网段都要选举DR和BDR，最后会选举出4个DR和4个BDR。</li>
<li>参与选举并和选举出的DR\BDR建立邻接关系需要Hello包种的参数相一致（Hello\Dead 时间，Area ID也是同一区域，认证通过，Router ID具有唯一性不与其他路由器相同）。</li>
</ul>
<h3 id="选举的过程"><a href="#选举的过程" class="headerlink" title="选举的过程"></a>选举的过程</h3><p>当一台OSPF路由器有效（Active）并去发现它的邻居路由器时，它将去检查有效的DR和BDR路由器（如果路由器的Priority为0那么就意味着它是无效的，不能参与选举DR和BDR），如果DR路由器存在的话（网络中某台路由器发出的Hello包中的DR字段为其自身的Router ID时就说明DR存在），这台路由器将接受已经存在的DR和BDR（为什么要接受已经存在的DR和BDR呢，是因为DR具有非抢占性的，也就是说已经有了DR了，新加入的路由器接口的Priority再低也不会重新选举DR了，如果没有非抢占性，新加入一个Priority 更大的就被选举成新的DR，所有DR Other都和这个新DR再建立邻接关系达到Full状态，太消耗系统资源，所以当一台路由器发现已经存在DR和BDR时就会接受已经存在的DR和BDR），如果BDR和DR路由器都不存在（也就是Hello包种的DR以及BDR字段都为0.0.0.0），将执行一个选举<strong>BDR</strong>的过程，没错一开始是选举BDR而不是DR，选举出具有最高优先级的路由器作为BDR路由器，选举中如果存在多台路由器具有相同的优先级（Priority），那么在数值上具有最高路由器ID的路由器将被选举成<strong>BDR</strong>（如果两台运行OSPF路由器路由器的接口的Priority都是1，那么此时一台路由器的Router-ID为1.1.1.1，另一台的Router-ID为2.2.2.2，Router-ID为2.2.2.2的显然比1.1.1.1更大，这台Router-ID为2.2.2.2的路由器的接口将被选举成BDR）。<strong>如果没有有效的DR路由器存在，那么之前选举出的BDR路由器将被选举成（或者说成提升）DR路由器，然后再选举出来BDR路由器。</strong>至此BDR和DR选举完毕。</p>
<h3 id="选举的补充说明"><a href="#选举的补充说明" class="headerlink" title="选举的补充说明"></a>选举的补充说明</h3><h4 id="什么情况选举BDR-DR"><a href="#什么情况选举BDR-DR" class="headerlink" title="什么情况选举BDR\DR"></a>什么情况选举BDR\DR</h4><img src="/2020/06/18/13-ospf/123456.png" alt="123456" style="zoom:67%;">

<h4 id="BDR晋升成DR"><a href="#BDR晋升成DR" class="headerlink" title="BDR晋升成DR"></a>BDR晋升成DR</h4><p>选举BDR\DR的场景中，绝大多数情况下，选举出的BDR都能顺利晋升成DR，也有极端场景比如俩OSPF路由器R1 R2在2-way刚选出BDR，另一台OSPF路由器R3接入进来发的hello里 DR是自己，这样R1 R2不知道会咋办。</p>
<h4 id="已有DR-BDR"><a href="#已有DR-BDR" class="headerlink" title="已有DR\BDR"></a>已有DR\BDR</h4><p>什么情况下，一个路由器会发现链路中已经有DR或BDR出现呢，常见的一种情况是，一个路由器新加入已经运行了一段时间OSPF协议的网络，常见的另一种情况是，只有两台路由器相连，R1——R2，其中一台已经先行运行了OSPF协议而且在DR选举计时器结束前没有其他OSPF的Hello包出现，这时这台路由器会把接口设定为DR。当路由器的接口运行OSPF协议时，已经启动了一个DR选举的计时器，这个计时器时4倍的Hello时间，在以太网这个MA网络中也就是和Dead时间一样的40秒，RFC上对这个计时器的描述是“A single shot timer that causes the interface to exit the Waiting state, and as a consequence select a Designated Router on the network. The length of the timer is RouterDeadInterval seconds.”，可以用命令 show ip ospf interface XX | incl timer   查看，默认的计时器是：Timer intervals configured, Hello 10, Dead 40, <strong>Wait 40</strong>, Retransmit 5。这个Wait就是DR选举的计时器。当这个计时器到时的时候，也就是OSPF启动了40秒以后依旧没其他路由器发来Hello包进行选举时，这个路由器就会把自身这个接口设置为DR，因为思科规定即使MA网络中只有一台路由器运行OSPF协议也要选举DR。</p>
<h4 id="BDR-DR的抢占性"><a href="#BDR-DR的抢占性" class="headerlink" title="BDR\DR的抢占性"></a>BDR\DR的抢占性</h4><p>DR和BDR具有非抢占性，也就是说当DR\BDR选举完成后，新加入的路由器即使Priority再小，DR\BDR也不会发生变化，为的是维持网络的稳定性。当DR失效后，BDR会成为DR，同时产生新的BDR。DR与BDR，DR与DR Other，BDR与DR Other之间都是Full状态，DR Other相互之间是2-way状态。所有的DR Other都只和DR以及BDR建立全毗邻关系。</p>
<h4 id="如何重新选举BDR-DR"><a href="#如何重新选举BDR-DR" class="headerlink" title="如何重新选举BDR\DR"></a>如何重新选举BDR\DR</h4><p>由于DR选举是非抢占的，所以选举完毕后除非人工干预否则BDR\DR是不会改变的，重新选举方法有两种，一种是所有参与选举的路由器在短时间内（默认的BDR\DR选举等待的Wait计时器是40秒）重新启动；另一种是执行“clear ip ospf process”命令，如果在DR Other上执行则不会影响BDR\DR，如果在BDR上执行则会重新选举一个BDR，如果在DR上执行，则会重新执行整个BDR\DR选举过程。</p>
<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-02_15-30-35.jpg" alt="Snipaste_2020-07-02_15-30-35"></p>
<ul>
<li>R1、R2接口的Priority值均为0，则R1和R2之间不能建立邻居，因为在MA网络下必须选举出DR，而R1、R2相连接口的Priority值均为0，失去了选举资格，所以两者无法建立邻居。</li>
<li>R1接口优先级为0，R2接口优先级为1，则R2成为DR，且该多路访问网络中没有BDR。</li>
<li>在上一步已经选出DR的基础上，R1接口优先级改为100，对网络没有影响，因为DR的非抢占性。</li>
<li>在上一步已经选出DR且R1接口优先级改为100的基础上，如果身为DR的R2重启了OSPF进程（clear IP ospf process X，X为该OSPF进程号），则R1成为DR，R2成为BDR。因为R2重启进程后会重新建立邻居重新选举DR。</li>
<li>如果R1和R2接口优先等级相同，但R2的Router ID大，一般情况下，R2应成为DR，但如果R1已经先配置了OSPF，且R2在R1配置之后40秒菜配置，那么这时候即使R2的Router-ID更大，R1已经成为了DR，原因在于Wait timer 等待计时器，这个计时器是在开始选举DR\BDR之前，路由器等待邻居路由器Hello包通告DR\BDR的时长（收集所有候选人的信息），等待计时器的长度就是Router Dead Interval的时间，因此只要R2在40秒之后才配置的，那么R1就会认为自己是DR，并且在Hello包的Designated Router部分写上自己的地址。</li>
</ul>
<h3 id="选举的几个为什么"><a href="#选举的几个为什么" class="headerlink" title="选举的几个为什么"></a>选举的几个为什么</h3><h4 id="为什么选举DR-BDR"><a href="#为什么选举DR-BDR" class="headerlink" title="为什么选举DR\BDR"></a>为什么选举DR\BDR</h4><p>之所以选举DR\BDR是因为如果运行OSPF协议的路由器两两之间建立完全邻接关系会引起大量的开销，消耗大量资源，OSPF采取了每个DR Other路由器和DR以及BDR建立邻接关系的方法，来减少资源消耗。</p>
<h4 id="为什么除了DR也要有BDR"><a href="#为什么除了DR也要有BDR" class="headerlink" title="为什么除了DR也要有BDR"></a>为什么除了DR也要有BDR</h4><p>之所以除了选举DR以外还要选举出一个BDR是因为，DR Other要和DR以及BDR形成邻接关系，然后DR和BDR这两者也要形成邻接关系，如果DR由于某种情况挂掉，那么BDR就能接替DR的位置，因为所有DR Other和BDR也形成了邻接关系，DR掌握的关于网络的信息和BDR是一样的，所以BDR可以顺利完美接替DR，这样可以把DR挂掉对网络的影响降到最低。</p>
<h4 id="为什么先选举BDR"><a href="#为什么先选举BDR" class="headerlink" title="为什么先选举BDR"></a>为什么先选举BDR</h4><p>之所以先选举BDR再选举DR是因为：”The reason behind the election algorithm’s complexity is the desire for an orderly transition from Backup Designated Router to Designated Router, when the current Designated Router fails. This orderly transition is ensured through the introduction of hysteresis: no new Backup Designated Router can be chosen until the old Backup accepts its new Designated Router responsibilities.”——RFC 2328 - OSPF Version 2，section 9.4 - Electing the Designated Router。先选取BDR的原因是，当DR发生故障挂掉时，需要BDR来接替DR的位置和作用，如果先选举DR，则可能会在BDR接替之前挂掉的DR前，选举出一个不是之前BDR的新DR，这个新DR还得重新从224.0.0.6上学习信息才能执行DR的角色，重新学习信息可能使得网络无法顺利转发数据。而先选举BDR则不会出现上面的问题，DR掌握的网络信息BDR都掌握，BDR可以不经过信息交互直接接替DR的功能，待BDR完美接替挂掉的旧DR的功能成为新DR后，空出来BDR的角色以后再选取BDR，不会对网络有影响。</p>
<h3 id="选举的优化"><a href="#选举的优化" class="headerlink" title="选举的优化"></a>选举的优化</h3><p>由于所有DR Other要与DR\BDR交互LSA信息，会消耗一定系统资源，所以建议在接口上灵活使用ip ospf priority 避免一个路由器的多个接口成为DR，降低硬件开销，减小网络变化时产生的影响。因为如果不在接口上进行灵活配置，选举过程是先看Priority再看Router ID，默认情况下所有接口的Priority都为1，此时Router ID为最大的路由器上的所有接口都将为DR，不仅会使得路由器开销变大，也会使得万一Router ID最大的路由器一旦挂掉，会对网络造成比较大的影响，因为各网段都要重新选举BDR\DR。</p>
<h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a><a href="https://community.cisco.com/t5/routing/dr-bdr-communication/td-p/1142718">组播地址</a></h2><blockquote>
<p>All OSPF routers continue to <strong>multicast HELLOS</strong> to 224.0.0.5, so they can keep track of their neighbors.</p>
<p>DROTHERs will send <strong>multicast updates</strong> to 224.0.0.6 (DR/BDR listen). DR will flood <strong>multicast updates</strong> to DROthers on 224.0.0.5.</p>
<p>DR and BDR can listen 224.0.0.5 not only to 244.0.0.6. DR Other listen 224.0.0.5 but not 224.0.0.6.</p>
<p>Summary:</p>
<p>* All OSPF enabled routers listen to/send LSA’s on multicast address 224.0.0.5</p>
<p>* DR/BDR listens on multicast-address 224.0.0.6 in addition to 224.0.0.5. This allows DR/BDR in a particular segment to figure out status updates.</p>
</blockquote>
<p>OSPF通过发送Hello包到组播地址224.0.0.5来建立邻居，所以只要是运行了OSPF协议的路由器，不管是DR 、BDR还是DR Other都会监听这个地址用来建立邻居。DR Other使用224.0.0.6的组播地址，将LSU发送给DR和BDR，所以DR和BDR会监听224.0.0.6的组播地址。DR使用224.0.0.5的组播地址将LSU发送给DR Other路由器。综上所述，所有运行了OSPF的路由器都会监听224.0.0.5的组播地址，但只有DR和BDR在监听224.0.0.5地址的同时额外监听224.0.0.6的组播地址。</p>
<h2 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h2><p>OSPF协议使用Cost值当作Metric去衡量到达目标网络的远近，Cost值越小越优。接口的带宽越大，计算出的Cost值越小，接口的带宽越小，计算出的Cost值越大。在每一个运行OSPF协议的接口上，都维护着一个接口的Cost值，接口的Cost值=100M / 接口带宽，也就是：10的8次方/BW（bit），这个100M（10的8次方）指的是参考带宽。一条路由的Cost值，是该路由从来源一路过来的所有入口方向的接口Cost值的总和，也就是这条路由经过接口的Cost值的综合。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-06-26_16-36-41.jpg" alt="Snipaste_2020-06-26_16-36-41" style="zoom:67%;">

<p>例如1.1.1.0/24的路由，由于是loop back接口，所以相对于Router A来说，Cost值为1，对于Router B来说，B与A相连接的接口Cost值为64，所以1.1.1.0/24的路由相对B来说，Cost值就是1+64，也就是65。</p>
<p>修改Cost的方法：</p>
<ol>
<li>修改参考带宽，也就是修改10的8次方这个数值，因为计算Cost的公式是10的8次方/BW（bit），通过修改参考带宽也可以修改Cost值。命令在ospf进程下配置：auto-cost reference-bandwidth XXX ，该数值的设置范围是1-4294967。</li>
<li>修改接口带宽，带宽和Cost值成反比，带宽越大，cost值越小，通过修改带宽也可以达到修改Cost值的目的。修改接口带宽的命令是在接口下配置：bandwidth XXX。该数值设置的范围是1-10000000。</li>
<li>直接修改Cost值，在接口上使用ip ospf cost  XX，可以直接修改Cost值。</li>
</ol>
<h2 id="ospf数据包类型"><a href="#ospf数据包类型" class="headerlink" title="ospf数据包类型"></a>ospf数据包类型</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-26_11-34-24.jpg" alt="Snipaste_2020-06-26_11-34-24"></p>
<ul>
<li>Hello：发现直连链路上的OSPF邻居、维护邻居关系。</li>
<li>DBD：Database Description，数据库描述包，DBD一共有两种类型，一种是空的DBD，用于协商Master/Slave，另一种则包含LSA的头部信息（不是全部的LSA信息，相当于一个LSA的目录），用于描述LSDB的摘要。 </li>
<li>LSR：Link State Request，链路状态请求报文，用于向OSPF邻居请求链路状态信息。</li>
<li>LSU：Link State Update，链路状态更新报文，在LSU报文中包含完整的链路状态信息，也就是完整的LSA。</li>
<li>LSACK：Link State Acknowledge，链路状态确认报文，OSPF协议规定收到每个LSA后要进行确认，LSACK就是确认收到LSA的报文。</li>
</ul>
<h2 id="协议的三张表"><a href="#协议的三张表" class="headerlink" title="协议的三张表"></a>协议的三张表</h2><p>邻居表（Neighbor Table）：邻居表由临界数据库（Adjacency Database）生成，两台路由器的OSPF要协同工作，最基本的要求是两者要形成邻接（Adjacency）关系，邻居表储存了OSPF路由器邻居状态以及关于该邻居的其他数据，每台路由器的邻居表和其他路由器的不同，用 ‘show ip ospf neighbor ‘命令查看邻居表 。</p>
<p>拓扑表（Topology Table）：拓扑表由链路状态数据库（Link-State Database，LSDB）生成，储存着网络中其他路由器的信息，用于构建网络拓扑，同一个区域（Area）内的路由器中的拓扑表相同（因为拓扑表用于构建区域内的网络拓扑，每个路由器都在相同网络拓扑的区域内），LSDB的概念有点不太好理解，可以理解成LSDB中的这些数据相当于本AS内的网络拓扑图一样，用 ‘show ip ospf database ‘命令查看拓扑表。</p>
<p>OSPF路由表（OSPF Routing Table）：路由表由转发数据库（Forwarding Database）生成，在链路状态数据库（Link-State DataBase，LSDB）基础上运行SPF算法后得出路由表，用 ‘show ip route’查看路由表。</p>
<h2 id="路由种类"><a href="#路由种类" class="headerlink" title="路由种类"></a>路由种类</h2><p>OSPF的路由共有O、O IA、O E1、O E2、O N1和O N2这五种类型，其中O是某个区域的域内路由，由这个区域的1类和2类LSA生成；OIA是区域间路由，由3类LSA生成；OE1和OE2都是由5类LSA生成的，区别在于OE1是OSPF的域外路由，会累加Metric值，默认带的Metric也就是Cost值是20；OE2也是域外路由，不过不累加Metric值，默认Metric值也就是Cost值就是20，由外部重分布进OSPF的路由默认使用OE2类型；ON1和ON2由7类LSA生成。这几种路由之间优先级简单的来说是：O &gt; O IA &gt; N1 &gt; E1 &gt; N2 &gt; E2，但各厂家对这几种路由的理解不同，所以在不同品牌的网络设备中，这几种路由的优先级也不同，具体哪种路由更优先要结合设备的版本以及厂家规定来看。</p>
<h2 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h2><p>当路由器、链路或网段的状态在up-down之间切换时会引发触发更新。假设下图中的网络已经完成了OSPF路由收敛，突然R3下面的一个网络发生了故障，R3用224.0.0.6的组播地址通知DR及BDR，监听224.0.0.6的DR和BDR在得知该网段故障后向组播地址224.0.0.5发送更新通知其他路由器，由于除了DR及BDR的其他路由器都会监听224.0.0.5这一组播地址，路由器收到包含变化后的LSA的LSU后，更新本路由器的LSDB，待SPF延迟计时器到期后运行SPF算法，对更新后的链路状态数据库执行SPF算法必要时更新路由表。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-06-29.jpg" alt="Snipaste_2020-07-14_16-06-29"></p>
<h2 id="LSA的确认"><a href="#LSA的确认" class="headerlink" title="LSA的确认"></a><a href="https://community.cisco.com/t5/routing/ospf-lsack-packet/td-p/3220386">LSA的确认</a></h2><p>LSA的确认方式一共有两种，显示确认和隐式确认，显示确认通过LSAck完成；隐式确认通过发送回整个相同的LSA去确认该LSA完成的，隐式确认常见在OSPF的广播网络中，大概过程如下：</p>
<blockquote>
<ol>
<li>A non-DR router on an Ethernet segment detects a topology change and needs to inform other routers about it. It sends the LSU packet to the DR and BDR using the 224.0.0.6 destination IP address.</li>
<li>Both DR and BDR receive the packet. Normally, you would expect that the DR would send an LSAck acknowledging the successful receipt of the LSU. However, the DR needs to propagate the LSU back to the segment using the 224.0.0.5 destination IP address anyway, so it just does exactly that, without sending a standalone LSAck.</li>
<li>The original router receives the same update from the DR it sent it a moment ago, and it considers it as an implicit acknowledgement. No further LSAck from the DR is expected.</li>
<li>Other routers on the segment receive the LSU and acknowledge its receipt via an explicit LSAck message back to the DR. This is an explicit form of acknowledgement.</li>
</ol>
</blockquote>
<ol>
<li>当一个在以太网MA环境下的非DR路由器，路由器A发现拓扑变化后，它需要将这个拓扑变化通知给其他邻居，这时路由器A会使用LSU数据包并把数据包发送给224.0.0.6这个组播地址，因为DR和BDR监听着这个组播地址而其他DR Other只监听着224.0.0.5且DR Other只和DR、BDR建立了完全邻接关系，所有LSU都是先发给DR\BDR再由DR\BDR发送给其他DR Other的。</li>
<li>当DR和BDR都收到这个LSU后，通常情况下，DR会发送LSAck给路由器A告诉A此时DR已经接收到了这个LSU了，然而DR此时也需要将A发过来的LSU通过224.0.0.5泛洪出去，所以DR这时不会发送LSAck去确认那条A的LSA。</li>
<li>那么路由器A如何知道DR收到了那条LSA呢，假定它发送的这条LSU叫AA，A通过224.0.0.6发送特定的LSU-AA给DR，由于DR需要将这个变化通告给域内其他的路由器，所以DR再把这条LSU-AA通过224.0.0.5发送给域内其他包括A在内的路由器，A也就从DR收到了LSU-AA，A收到DR发来的相同的LSU就知道DR已经收到了之前的LSU-AA，也就不用再等待DR的LSAck了，如果没收到的话DR不可能会泛洪这条LSU-AA，这就是<strong>隐式确认</strong>。</li>
<li>在该网段的其他路由器会收到LSU-AA并返回给DR一个LSAck表示收到了这条LSU-AA，这是显示确认。</li>
</ol>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# router ospf process-id </span><br><span class="line">/*创建OSPF进程并进入OSPF进程配置模式，Process-id为OSPF进程号，</span><br><span class="line">范围必须在1-65535之间，进程号只具有本地意义，不同路由器之间的OSPF进程号可以相同也可以不同，</span><br><span class="line">互相之间不影响.例如：router ospf 1,也就是配置一个进程号为1的OSPF进程*/</span><br><span class="line"></span><br><span class="line">Router(config-router)# network  address  wildcard-mask  areaarea-id</span><br><span class="line">/*在特定网段上激活OSPF，例如：network 192.168.1.1 0.0.0.0 area 0</span><br><span class="line">就是在192.168.1.1所属网段上激活OSPF*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf neighbor </span><br><span class="line">/*查看OSPF邻居表*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf database</span><br><span class="line">/*查看OSPF的LSDB链路状态数据库*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf database router x.x.x.x</span><br><span class="line">/*查看OSPF中Link ID为x.x.x.x的1类LSA，router意味着查看1类LSA*/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/18/13-ospf/ospf-if-e-0-0-1593085167925.png" alt="ospf-if-e-0-0"></p>
<ul>
<li>show ip ospf interface E0/0，就是查看E0/0接口上关于OSPF的配置情况。</li>
<li>Process ID 1，也就是之前配置的router ospf 后面的process-id，这里可以看到该OSPF进程号为1。</li>
<li>Router ID 0.0.0.2，就是该路由器的ID。</li>
<li>Network Type BROADCAST，表示E0/0接口的OSPF网络类型为广播。</li>
<li>Cost ：10，OSPF使用开销来作为路由的度量值，一条路由的Cost值越小越优，可以在接口下使用ip ospf cost  XX命令来修改cost值。</li>
<li>State BDR，表示该E0/0接口的角色为BDR，也就是Backup Designated Router，备份指定路由器。</li>
<li>Priority 1，表示该接口的OSPF Priority值为1，这个值在决定接口性质，也就是链路在决定一个接口的DR、BDR或DR Other时使用。Priority 最高的为DR。</li>
</ul>
<img src="/2020/06/18/13-ospf/ospf-database-2.1-768x814.jpg" alt="ospf-database-2.1-768x814" style="zoom:67%;">

<p>show ip ospf database 命令及相关输出说明会在后面LSA类型中具体说，这里就不展开了。</p>
<p>clear ip route *是否会出发SPF算法的重新计算？</p>
<p>clear ip route *触发了SPF算法的重新计算，SPF算法运行的次数增加了，实验结果如下：</p>
<p><img src="/2020/06/18/13-ospf/dadadfad1234.png" alt="dadadfad1234"></p>
<h1 id="OSPF计时器"><a href="#OSPF计时器" class="headerlink" title="OSPF计时器"></a>OSPF计时器</h1><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_18-44-35.jpg" alt="Snipaste_2020-07-14_18-44-35"></p>
<ul>
<li>MaxAge：LSA的老化计时器，LSA在LSDB中能存在的最长时间，说白了就是LSA的寿命上限，到了这个时间就必须从LSDB动态链路数据库中删除，LSA的寿命上限为60分钟，也就是60分钟内没收到该LSA的刷新信息就会将其从LSDB中删除；</li>
<li>LSRefresh：LSA刷新计时器，定期1800秒刷新一次有效的LSA，让这些LSA继续在LSDB中存在，避免因到达Max Age而过期从LSDB中删除；</li>
<li>Hello interval：Hello包发送间隔，也就是运行OSPF协议的接口每隔多久发送一次Hello消息。进入接口后用命令：ip ospf hello-interval X 进行更改。Hello interval是接口属性，可以每个接口的Hello interval不同，只要和邻居相同能建立起邻居就可以；</li>
<li>Dead interval：失效间隔，表示如果多少秒后没收到邻居路由器的消息，会认为邻居路由器已Down掉进入接口后用命令：ip ospf dead-interval X 进行更改。Dead interval是接口属性，可以每个接口的Hello interval不同，只要和邻居相同能建立起邻居就可以；</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-07_17-52-20.jpg" alt="Snipaste_2020-10-07_17-52-20" style="zoom:67%;">

<p>OSPF协议根据接口的网络类型不同，Hello Interval、Dead Interval时间也不同，总结见下图：</p>
<img src="/2020/06/18/13-ospf/OSPF-Network-Interface-types.png" alt="OSPF-Network-Interface-types" style="zoom:80%;">

<ul>
<li>Wait：等待计时器（接口属性，各接口可以不同），和Dead interval的值相同，定义了路由器在到达2WAY状态时，等待多久后会宣告自己就是DR。比如如果Wait时间是40秒，那么当一台处于MA网络的路由器到达2WAY状态后，会等待40秒，如果40秒内都没有收到邻居的Hello跟本路由器一起选举DR，那么它就会宣告自己就是DR。</li>
<li>Retransmission：重传计时器（接口属性，各接口可以不同），表示发送完LSU以后，经过多久没收到ACK消息确认收到本设备发送的LSU，就认为这个LSU没成功发送到对方，会进行重新发送。</li>
</ul>
<h1 id="OSPF数据包"><a href="#OSPF数据包" class="headerlink" title="OSPF数据包"></a>OSPF数据包</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>OSPF数据包有邻居发现、形成邻接关系、泛洪LSA信息等功能，共有5种数据包，分别是Hello、DBD、LSR、LSU、LSAck。OSPF数据包的二层采用以太网封装，前面说过，OSPF使用的协议组播地址为224.0.0.5或224.0.0.6，所以以太网中的目标MAC地址字段为01-00-5E-00-00-05或01-00-5E-00-00-06；三层用IP封装（Protocol字段为89），目标IP地址为224.0.0.5或224.0.0.6.OSPF部分分为OSPF Header和OSPF Message两部分，Header决定了OSPF为5种类型种的哪种数据包，Message携带了该种类型包含的信息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-11_18-44-34.jpg" alt="Snipaste_2020-07-11_18-44-34" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-10-07_18-30-40.jpg" alt="Snipaste_2020-10-07_18-30-40" style="zoom:67%;">

<h3 id="OSPF-Header"><a href="#OSPF-Header" class="headerlink" title="OSPF Header"></a>OSPF Header</h3><p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200710115532.jpg" alt="微信图片编辑_20200710115532"></p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_14-32-10.jpg" alt="Snipaste_2020-07-10_14-32-10"></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_11-53-16.jpg" alt="Snipaste_2020-10-08_11-53-16" style="zoom:67%;">

<p>所有5种OSPF数据包都有着共同通用的24字节长度的OSPF报头，通用的报头让接收端路由器能进行后续的验证和处理。OSPF并不适用TCP或UDP作为四层的报头而是使用单独的协议，协议号为89。OSPF的5种数据包，Header部分只有Type字段有所区别，后面具体分析的时候就不再涉及Header部分而只说Message部分了。</p>
<ul>
<li>Version：版本，OSPF v2版本该字段为2，字段长度为8位。</li>
<li>Packet Type：类型，根据类型字段数值不同表示不同的OSPF数据包，1为Hello，2为DBD，3为LSR，4为LSU，5为LSAck，字段长度为8位。</li>
<li>Packet Length：OSPF报头总长度，字段长度为16位。</li>
<li>Router ID：产生该OSPF包的源路由器的Router ID，Router ID在AS中唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在OSPF路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。，字段长度为32位。</li>
<li>Area ID：用于标识该数据包所属的区域（Area），字段长度为32位。</li>
<li> Checksum：校验和，用来检查OSPF报头在传输中的完整性，这个校验和不包括后面的身份验证（Authentication）字段，也就是从Version到Authentication Type的部门，字段长度为16位。</li>
<li>Authentication Type：认证方式字段，定义该数据包的认证方式。0表示没有密码，1表示明文密码，2表示MD5认证，字段长度为16位。</li>
<li>Authentication：认证字段，共64位，之所以在图中占两行是因为一行是32位，两行才是64位。</li>
</ul>
<h3 id="OSPF-Message"><a href="#OSPF-Message" class="headerlink" title="OSPF Message"></a>OSPF Message</h3><p>OSPF Message部分根据Packet Type的不同携带不同的信息：</p>
<ul>
<li>Type 1：当Type为1时表示这是一个Hello包，携带的信息是已知的邻居。</li>
<li>Type 2：当Type为2时表示这是一个DBD包，携带的信息是LSDB的目录，目录中包括Router ID、序列号等。</li>
<li>Type 3：当Type为3时表示这是一个LSR包，携带的信息为需要的LSR以及需要LSR的路由器的Router ID。</li>
<li>Type 4：当Type为4时表示这是一个LSU包，携带的信息是完整的LSA条目，一个LSU种可携带多条LSA。</li>
<li>Type 5：当Type为5时表示这是一个LSAck包，携带的信息为空。</li>
</ul>
<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Hello数据包用于与邻居<strong>建立并维持</strong>毗邻关系、交互参数以及选举BDR/DR，当接口类型为广播和P2P时默认每10秒交换一次Hello包，其他接口类型时30秒发送一次Hello包，发送地址为组播的224.0.0.5。Hello包的Packet Type为1。Hello包会周期性的在运行了OSPF的接口上用组播发送出去。为了顺利建立起邻居，所有连接到网络种的路由器的相关参数必须<strong>互相相同</strong>，这些参数包括网络掩码、Hello时间和Dead时间等。</p>
<h3 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_15-08-07.jpg" alt="Snipaste_2020-07-10_15-08-07"></p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200710151006.jpg" alt="微信图片编辑_20200710151006"></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_15-08-40.jpg" alt="Snipaste_2020-07-10_15-08-40" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/add20392830280.jpg" alt="add20392830280" style="zoom:80%;">

<ul>
<li>Network Mask：网络掩码，指的是路由器要发送的网络的掩码，字段长度为32位。</li>
<li>Hello Interval：Hello包发送间隔，也就是运行OSPF协议的接口每隔多久发送一次Hello消息，字段长度为16位。</li>
<li>Opinion：选项，代表着路由器支持OSPF的哪些可选功能，字段长度为8位。</li>
<li>Router Priority：路由器优先级，在选举BDR\DR时使用，字段长度为8位。</li>
<li>Router Dead Interval：路由器失效间隔，表示如果多少秒后没收到邻居路由器的消息，会认为邻居路由器已Down掉，字段长度为32位。</li>
<li>Designated Router：指定路由器，在NBMA以及广播这两种类型的网络中，要选举DR路由器，选举后DR的IP地址在该字段，所有DR Other路由器和DR建立完全邻接关系并交换LSA，如果没有DR则该字段为全0，字段长度为32位。</li>
<li>Backup Designated Router：备份指定路由器，在NBMA以及广播这两种类型的网络中，要选举BDR路由器，BDR是DR的备份，先选举BDR然后将BDR晋升为DR，当DR Down掉后由BDR接替DR的位置并发挥DR的作用，如果没有BDR则该字段为全0，字段长度为32位。</li>
<li>Neighbor：邻居，当收到其他路由器发送来的Hello包时，将其他路由器的IP地址放在此字段，如收到多个路由器的Hello包时，会存放多个，收到一个其他路由器的Hello包占据32位，收到两个占据64位，以此类推，用Wireshark抓包时此字段为Active Neighbor，比如上图有两个Active Neighbor分别是1.1.1.1和3.3.3.3，表示该路由器分别收到了1.1.1.1和3.3.3.3这两个路由器发来的Hello包。</li>
</ul>
<p>Hello包中的Area ID，Hello Interval，Router Dead Interval、Authentication Type、Authentication几个字段在邻居建立时必须相同邻居才能成功建立。如果Hello 时间不同Debug时就会出现以下提示，说明两个路由器之间Hello时间Mismatch，也就是Hello时间不相匹配：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-12_13-46-07.jpg" alt="Snipaste_2020-07-12_13-46-07" style="zoom:80%;">

<h2 id="DBD"><a href="#DBD" class="headerlink" title="DBD"></a>DBD</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>DBD是DataBase Description的缩写，出现在邻居建立过程中的ExStart及Exchange阶段，DBD是链路状态数据摘要，也就是LSDB的摘要或者说它是LSDB中有什么LSA的简略列表，用于描述链路状态数据库（LSDB）的内容，一个域中所有路由器的LSDB必须相同，在交换LSA之前先通过比较DBD来知道需要交换哪些LSA，这个是DBD的主要作用。</p>
<h3 id="格式分析-1"><a href="#格式分析-1" class="headerlink" title="格式分析"></a>格式分析</h3><p>整体的DBD包：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-42-26.jpg" alt="Snipaste_2020-07-15_15-42-26" style="zoom:67%;">

<p>DBD数据包的<strong>Header部分</strong>中的Packet Type为2，表示这是一个DBD数据，其他字段之前分析过这里就不再赘述了，Header部分如下图：</p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200715120054.jpg" alt="微信图片编辑_20200715120054"></p>
<p><strong>Message部分</strong>：</p>
<p><img src="/2020/06/18/13-ospf/ospfdatabasedescriptionformat.png" alt="ospfdatabasedescriptionformat"></p>
<ul>
<li>Interface MTU：长度为16位，一个路由器的接口在不分片情况下，所能传递的IP信息的最大值。这个值两台路由器必须相等才能建立Full Adjacency的关系。</li>
<li>Option：长度为8位，本地路由器在此字段中告知其所支持的功能。</li>
<li>Flages：长度为8位，前5位保留值为0，后三位分别为I位（Initial位，当它置1时表示这是初始的第一个DBD包，用来协商Master\Slave关系；置0时表示这不是初始的第一个DBD包了，标志着Master\Slave选举结束）、M位（More位，当它置1时表示后续还有DBD包需要发送；置0时表示后续没有DBD包需要发送了）、MS位（Master\Slave位，当它置1时表示路由器认为自己的角色时Master；置0时表示对方为Master。）。</li>
<li>DD Sequence number：长度为32位，主从关系（Master\Slave）确定前，两台路由器各自用一个随机的大数字作为自己的DD Sequence；当主从关系确定后，Slave一方会用Master一方的DD Sequence作为自己的DD Sequence发送DBD给Master表示确认收到了Master的DBD，也就是隐式确认。</li>
<li>LSA Header：这部分包含了用来表述路由器LSDB的LSA头部。</li>
</ul>
<p>DBD的Wireshark抓包如下：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20DBD%20packet%20capture.png" alt="OSPF DBD packet capture"></p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>两台路由器的DBD包中的Interface MTU必须相等才能建立Full Adjacency的关系，如果不相等会出现如下的提示，提示10.1.1.2的Interface MTU更小使得Adjacency无法建立：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-17-34.jpg" alt="Snipaste_2020-07-15_15-17-34" style="zoom: 67%;">

<h2 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>LSR用于请求邻居路由器发送其链路状态数据库（LSDB）中的特定项。LSR一般用在两台路由器交换完DBD后，当然如果路由器发现彼此之间并不用交换LSA的话，则LSR不会出现。</p>
<h3 id="格式分析-2"><a href="#格式分析-2" class="headerlink" title="格式分析"></a>格式分析</h3><p>整体格式：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-43-35.jpg" alt="Snipaste_2020-07-15_15-43-35" style="zoom:67%;">

<p>Header部分中的OSPF Type为3，其他部分与其他包的Header部分相同这里就不再赘述了。</p>
<p>Message部分：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSR%20header%20format.png" alt="OSPF LSR header format"></p>
<ul>
<li>LS type：长度为32位，表示所传递的LSA的类型。</li>
<li>Link State ID：长度32位，传递的LSA的ID，通常来说是路由器的ID或链路的ID。</li>
<li>Advertising Router：长度32位，发送LSR请求的路由器的Router ID 。</li>
</ul>
<p>LSR的Wires hark抓包如下：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSR%20packet%20capture.png" alt="OSPF LSR packet capture"></p>
<h2 id="LSU"><a href="#LSU" class="headerlink" title="LSU"></a>LSU</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>LSU用于向邻居路由器发送其所需要的链路状态通告（LSA）。这些LSU实现了LSA的泛洪。每条LSA中包含着描述网络的一部分信息，这些信息包括路由、度量值和拓扑信息等。本地路由器的LSA通过LSU被发送到邻居路由器，邻居路由器通过LSR来回应LSU。</p>
<h3 id="格式分析-3"><a href="#格式分析-3" class="headerlink" title="格式分析"></a>格式分析</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-16_16-11-39.jpg" alt="Snipaste_2020-07-16_16-11-39" style="zoom: 67%;">

<p>Header部分中的OSPF Type为4，其他部分与其他包的Header部分相同这里就不再赘述了。</p>
<p>Message部分：</p>
<p><img src="/2020/06/18/13-ospf/ospf-lsu-lsa-packet-structure-lsa-types-overview-1234.png" alt="ospf-lsu-lsa-packet-structure-lsa-types-overview-1234"></p>
<p><img src="/2020/06/18/13-ospf/ospf-lsu-lsa-packet-structure-lsa-types-overview-2.png" alt="ospf-lsu-lsa-packet-structure-lsa-types-overview-2"></p>
<p>需要更新给邻居的LSA，是以上图的形式，也就是LSA包含在LSU中，以LSU的形式发送给邻居路由器的，下面来看字段具体含义。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-16_16-42-45.jpg" alt="Snipaste_2020-07-16_16-42-45" style="zoom:80%;">

<ul>
<li>Number of Link State Advertisments：长度32位，表示这条LSU携带了几条LSA；</li>
<li>LSAs：长度可变，表示所携带的LSA，具体报文格式参考后面的LSA部分。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_12-23-59.jpg" alt="Snipaste_2020-10-08_12-23-59" style="zoom: 67%;">

<p>下图中的LSU中包含着1条1类LSA，这条1类LSA中包含着3个链路，其中两个链路为Stub类型，一个链路为P2P类型。</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSU%20Packet%20Capture.png" alt="OSPF LSU Packet Capture"></p>
<h2 id="LSACK"><a href="#LSACK" class="headerlink" title="LSACK"></a>LSACK</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>LSAck用来向发送方确认收到特定的LSU，由于OSPF在四层不适用TCP或UDP，而协议又对可靠性有要求，因此增加LSAck包来保证可靠性。</p>
<h3 id="格式分析-4"><a href="#格式分析-4" class="headerlink" title="格式分析"></a>格式分析</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-47-05.jpg" alt="Snipaste_2020-07-17_10-47-05" style="zoom:80%;">

<p>OSPF的Header部分除了Type字段为5以外，其他部分之前已经写过，这里就不再赘述。</p>
<p>Message部分包含了已经确认收到的LSA的报头，如果收到N个LSA的话就会有N个LSA报头在其中，关于LSA的Header部分在下一节LSA中具体讨论。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-48-57.jpg" alt="Snipaste_2020-07-17_10-48-57" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-50-17.jpg" alt="Snipaste_2020-07-17_10-50-17" style="zoom: 67%;">

<h1 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h1><h2 id="LSA简介"><a href="#LSA简介" class="headerlink" title="LSA简介"></a>LSA简介</h2><p>LSA由路由器产生，路由器的角色不同会产生不同种类的LSA，LSA中包含着链路状态信息和路由信息，LSA构成了LSDB（Link-State DataBase，链路状态数据库），OSPF使用LSDB计算路由。每个区域（Area）中所有路由器的LSDB是相同的，也就是说这些路由器所掌握的LSA是相同的，LSA一共有11类，不同种类的LSA传播的范围各有不同，有些LSA只在本区域内传播，有些LSA可以跨区域传播。运行OSPF协议的路由器交换完LSA后，各自运行SPF算法，由于域内路由器的LSDB相同又采用同样的SPF算法，所以计算出的路由路径是相同的。LSA每30分钟全部刷新一次，60分钟内如果没刷新则会由LSA的始发路由器泛洪一条LSA已到达最大过期时间的LSA，让其他路由器删除该LSA。如果链路的状态因为某种原因产生了变化，那么直连该链路的路由器检测到变化后会触发关于该链路变化的更新。路由器只能对其产生的LSA进行修改，不能对其他路由器的LSA进行改动。当网络拓扑发生变化时，LSA会带着新的信息进行泛洪，如果网络收敛完毕后，拓扑没有变化则不会对LSA进行泛洪（除了30分钟的整体LSA刷新以外）。</p>
<h2 id="收到LSA后的动作"><a href="#收到LSA后的动作" class="headerlink" title="收到LSA后的动作"></a>收到LSA后的动作</h2><img src="/2020/06/18/13-ospf/Snipaste_2020-07-08_17-35-08.jpg" alt="Snipaste_2020-07-08_17-35-08" style="zoom:67%;">

<blockquote>
<p>Each LSA has an <strong>aging timer</strong> which carries the <strong>link-state age field.</strong> By default each OSPF LSA is only valid for <strong>30 minutes.</strong> If the LSA expires then the router that created the LSA will resend the LSA and increase the <strong>sequence number</strong>. </p>
<p>Let’s walk through this flowchart together. In this example a new LSA is arriving at the router and OSPF has to decide what to do with it:</p>
<ol>
<li>If the LSA isn’t already in the LSDB it will be added and a LSAck (acknowledgement) will be sent to the OSPF neighbor. The LSA will be flooded to all other OSPF neighbors and we have to run SPF to update our routing table.</li>
<li>If the LSA is already in the LSDB and the sequence number is the same then we will ignore the LSA.</li>
<li>If the LSA is already in the LSDB and the sequence number is different then we have to take action:<ol>
<li>If the sequence number is higher it means this information is newer and we have to add it to our LSDB.</li>
<li>If the sequence number is lower it means our OSPF neighbor has an old LSA and we should help them. We will send a <strong>LSU</strong> (<strong>Link state update)</strong> including the newer LSA to our OSPF neighbor. The LSU is an envelope that can carry multiple LSAs in it.</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="LSA的删除"><a href="#LSA的删除" class="headerlink" title="LSA的删除"></a>LSA的删除</h2><blockquote>
<p>in OSPF, no router is allowed to prematurely delete other router’s LSAs from its link-state database. LSAs may only be removed from the link-state database either if they reached their maximum age, or if their original advertising router has explicitly flushed them by flooding them with the age set to MaxAge. The loss of a neighbor does not result in its LSAs being flushed.——<a href="https://community.cisco.com/t5/switching/ospf-lsa-flooding/td-p/1964852">OSPF LSA Flooding</a></p>
</blockquote>
<p>在OSPF协议中，路由器不能过早的删除自身LSDB中由其他路由器产生的LSA，也就是说如果R1收到一条由R2始发的LSA并将其加入LSDB后，不能无缘无故的删除这条LSA，要删除该LSA，要么是该LSA的老化计时器到时间（60分钟）R1将其删除，要么是通告该LSA的原始路由器R2泛洪一条LSA已到达最大过期时间的LSA，让其他路由器比如R1删除该LSA。</p>
<h2 id="LSA的刷新"><a href="#LSA的刷新" class="headerlink" title="LSA的刷新"></a>LSA的刷新</h2><h3 id="为什么需要刷新LSA"><a href="#为什么需要刷新LSA" class="headerlink" title="为什么需要刷新LSA"></a>为什么需要刷新LSA</h3><p>RFC 2328中规定：Every LSA has to be reoriginated (that is, refreshed) every 1800 seconds.也就是说每一条LSA每隔1800秒（30分钟）必须重新起源或者说刷新一次，不管LSA的老化计时器是否到期都会刷新LSA，为的是在LSA老化计时器的3600秒到达前还能在区域内存在并传播，路由器只刷新它生成的LSA。</p>
<h3 id="刷新LSA的步骤"><a href="#刷新LSA的步骤" class="headerlink" title="刷新LSA的步骤"></a>刷新LSA的步骤</h3><p>OSPF的刷新步骤是“What OSPF routers do each 30 minutes is that each router takes all LSAs it has originated itself, increments their sequence (revision) number, resets the age and floods them. Basically, each router floods a refreshed version of its own LSAs. Note that this is not an entire database resynchronization.——<a href="https://community.cisco.com/t5/routing/why-in-ospf-lsa-refresh-time-is-set-as-30-minutes/td-p/2600233">出处点击</a>”，以及“This is the 30 minute interval which you are asking about. As the age of some self-originated LSA approaches 1800 seconds, the router will generate a refreshed version of the same LSA and flood it - an incremented sequence number, the age timer set to 0. That’s it. Nothing more. There is no some kind of resynchronization of entire link-state databases or something. You just flood a new LSA, just like you would flood an LSA if some topological event occured. The DBD packets have nothing to do here. As with all LSA flooding operations, LSAs are flooded within LSU packets, and they are confirmed with LSAck packets.——<a href="https://community.cisco.com/t5/switching/when-was-dbd-database-descriptor-packets-sent/td-p/2080784">出处点击</a>”。简单来说就是LSA的起源路由器会在30分钟的时候发送一条和之前LSA相同的新版本的LSA去刷新该条LSA，这个新版本的LSA相比之前的LSA来说，增加了序列号的数值且老化计时器为0。在LSA刷新的时候不会发送DBD，只是用LSA去刷新LSA（LSA包含在LSU中用LSU的形式泛洪），收到刷新LSA的LSU以后，路由器也会发送LSAck用来确认收到LSU。这里注意，在MA网络中由于所有DR Other只和DR\BDR建立完全邻接关系，所以在刷新LSA时，起源路由器的的LSU也是和DR\BDR交互的，由DR\BDR再泛洪给其他路由器。</p>
<h3 id="刷新的对路由器是否有影响"><a href="#刷新的对路由器是否有影响" class="headerlink" title="刷新的对路由器是否有影响"></a>刷新的对路由器是否有影响</h3><p>答案是没有影响，因为近年来设备的CPU性能已足以应付每30分钟刷新一次的LSA，而且每隔域（Area）中有多个DR\BDR而不是一个，每个MA网络都有其自己的DR\BDR，只负责本MA网络的LSA泛洪就行。而且即使是一个有N台路由器的MA网络也不意味着同一时间同时泛洪LSA，因为LSA的老化计时器是在每条LSA生成泛洪时开始计时的，每条LSA生成的时间不同。即使因为巧合，所有路由器在同一时间刷新LSA，假设MA网络中有N个路由器，那么此时同时刷新的1类LSA为N条，需要更新的2类LSA由于在为1条（由于2类LSA由DR产生用来通告掩码），如果再有ABR或ASBR的话也需要泛洪的LSA也不多，所以不会对路由器有什么影响。</p>
<h2 id="LSA的新旧"><a href="#LSA的新旧" class="headerlink" title="LSA的新旧"></a><a href="https://tools.ietf.org/html/rfc2328#page-146">LSA的新旧</a></h2><p>当一个路由器遇到两条LSA实例时，它必须分辨出哪一条更新一些，这种情况一般在收到一条和本地LSDB一样的LSA时出现，在两台路由器的LSDB交换过程中也会出现。</p>
<p>两条LSA是否相同由LS Type、Link-State ID和Advertising Router三个参数决定。一条LSA的两个实例由LS Sequence number、LS age和LS checksum决定哪个实例是更新一些的。</p>
<p>首先比较LS Sequence Number，有着更新LS Sequence Number的LSA更新；如果两个实例有着相同的LS Sequence Number且LS checksum不同，那么LS checksum更大的被认为是更新的LSA。其他情况参见RFC 2328的<a href="https://tools.ietf.org/html/rfc2328#page-146">section13.1</a></p>
<h2 id="路由器的角色"><a href="#路由器的角色" class="headerlink" title="路由器的角色"></a><a href="https://www.geeksforgeeks.org/link-state-advertisement-lsa/">路由器的角色</a></h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_11-36-07.jpg" alt="Snipaste_2020-07-17_11-36-07"></p>
<blockquote>
<ol>
<li><strong>Backbone router –</strong> The area 0 is known as backbone area and the routers in area 0 are known as backbone routers.</li>
<li><strong>Internal router –</strong> An internal router is a router which have all of its interfaces in a single area.</li>
<li><strong>Area Boundary Router (ABR) –</strong> The router which connects backbone area with another area is called Area Boundary Router. The ABRs therefore maintain multiple link-state databases that describe both the backbone topology and the topology of the other areas.</li>
<li><strong>Area Summary Border Router (ASBR) –</strong> When an OSPF router is connected to a different protocol like EIGRP, or Border Gateway Protocol, or any other routing protocol then it is known as AS. The router which connects two different AS (in which one of the interface is operating OSPF in area 0) is known as Area Summary Border Router. These routers perform redistribution. ASBRs run both OSPF and another routing protocol, such as RIP or BGP.</li>
</ol>
</blockquote>
<ol>
<li>Backbone Router：翻译成中文是骨干路由器，就是至少有一个接口在Backbone区域中的路由器。</li>
<li>Internal Router：翻译成中文是内部路由器，也就是所有接口都在同一个非骨干区域的路由器。</li>
<li>Area Boundary Router (ABR)：翻译成中文是区域边界路由器，用以连接区域0和非骨干区域，ABR路由器在Backbone区域有一个或多个接口并且在非骨干区域也有一个或多个接口。</li>
<li>Area Summary Border Router (ASBR)：翻译成中文是自治系统边界路由器，当一个路由器既运行了OSPF协议，也运行了其他路由协议，比如EIGRP或BGP协议的时候，该路由器连接了两个不同的AS（其中一个接口在区域0运行OSPF）的路由器被称为自治系统边界路由器。</li>
</ol>
<h2 id="LSA的格式"><a href="#LSA的格式" class="headerlink" title="LSA的格式"></a><a href="https://www.networkgalaxy.org/2013/07/understanding-ospf-link-state.html">LSA的格式</a></h2><p><img src="/2020/06/18/13-ospf/OSPF%20Header.PNG" alt="OSPF Header"></p>
<p>LSA的报文格式分成两部分，Header和Body，也就是报头和信息。不管是哪种类型的LSA，都有一个相同的20位的LSA报头，根据LS Type字段数值不同，LSA信息部分包括的内容也不同。</p>
<h3 id="LSA报头"><a href="#LSA报头" class="headerlink" title="LSA报头"></a>LSA报头</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-18_19-02-42.jpg" alt="Snipaste_2020-07-18_19-02-42" style="zoom:80%;">

<ul>
<li>LS age：链路状态计时器，也就是这条LSA生成的时间，单位为秒，当这个字段到3600s，也就是60分钟的时候，这条LSA会从LSDB中删除，因为到达了最大存在时间；</li>
<li>Options：选项，表示了路由器所支持的OSPF功能有哪些；</li>
<li>LS type：LS类型，表示了这条LSA是哪种类型的LSA。该字段为1的时候是1类LSA也就是Router-LSA；2为2类LSA也就是Network-LSA；3为3类LSA也就是ABR产生的Summary-LSA；4为4类LSA也就是ASBR产生的Summary-LSA；5为5类LSA也就是AS-External-LSA；</li>
<li>Link State ID：链路ID，该字段定义了这条链路，标识了LSA正在通告的内容，通常是链路代表的路由器或网段的IP地址。和Link ID概念不一样，Link ID是一条链路的标识，而Link State ID标识的是一条可能携带多条链路的LSA；</li>
<li>Advertising Router：该字段表示了生成这条LSA的路由器的ID；</li>
<li>LS Sequence Number：用来检测重复LSA或分清LSA新旧的序列号；</li>
<li>LS Checksum：LSA的校验和，用来检测LSA在传输过程中是否被更改，在LS Sequence Number相同时也用于比较两条LSA的新旧，Checksum值大的LSA更新一些。LS Checksum的校验和包括了LSA的Header部分但并不包括LS age部分，因为前面说过LS age是这条LSA的生成时间，随时在变化，如果包括了这部分校验和肯定是每个经过的路由器校验和都不一样；</li>
<li>Length：包括了20位LSA Header在内的LSA的长度。</li>
</ul>
<p>这些信息在使用show ip ospf database X.X.X.X的时候也可以看得到</p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200801213649.jpg" alt="微信图片编辑_20200801213649"></p>
<p>报头中的信息使用show ip ospf database也能看到：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_21-46-08.jpg" alt="Snipaste_2020-08-01_21-46-08" style="zoom: 50%;">

<h3 id="Options字段"><a href="#Options字段" class="headerlink" title="Options字段"></a>Options字段</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-16_16-56-25.jpg" alt="Snipaste_2020-09-16_16-56-25"></p>
<ul>
<li>E字段置1时表示它邻接的Area能处理5类LSA(ExternalRoutingCapability)；</li>
<li>MC字段置1时表示它支持多播扩展（MOSPF）；</li>
<li>N/P字段置1时表示它支持7类LSA；</li>
<li>EA字段置1时表示它有接收和转发外部LSA的能力；</li>
<li>DC字段置1时表示它支持demand circuits；</li>
</ul>
<p>Options字段常见的N/P及E字段，在后文7类LSA中有具体解释，这里就简单说一下各字段的作用。</p>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>看懂输出中关于Link State ID（有时是Link ID）的关键在于，该字段并不是一个IP地址，Link ID中的1.1.1.1不代表这个网络和1.1.1.1/32相连，它表示的是在LSDB的图中中有一个叫做1.1.1.1的路由器节点。</p>
<p>不同类型的LSA中的Link ID和ADV ID不同，在后文1类LSA部分中有具体说明。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_22-28-42-1596292138082.jpg" alt="Snipaste_2020-08-01_22-28-42"></p>
<h3 id="LSA信息"><a href="#LSA信息" class="headerlink" title="LSA信息"></a>LSA信息</h3><p>根据LS Type值的不同，LSA共有11类，每一类的message部分差别都比较大，具体见后文。</p>
<h2 id="LSA的分类"><a href="#LSA的分类" class="headerlink" title="LSA的分类"></a><a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">LSA的分类</a></h2><h3 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a><a href="https://www.packetflow.co.uk/ospf-areas-explained/">总览</a></h3><ul>
<li>所有运行了OSPF的路由器都会产生1类LSA，仅在本Area中传播，1类LSA用来通告，网络中的节点路由器和这些路由器之间的关系，直连接口的信息；</li>
<li>DR路由器产生2类LSA，仅在本Area中传播，2类LSA中用来通告掩码信息；</li>
<li>ABR路由器产生3类LSA，在除了特殊区域（Totally\Stub area、Totally\NSSA）以外的其他Area中传播，但传播范围仅为一个区域，就是从其他Area到骨干区域或从骨干区域到其他区域，通告了区域间路由；</li>
<li>ABR路由器在知道ASBR的情况下会产生4类LSA，在所有区域中传播，用来通告去往ASBR的路径；</li>
<li>5类LSA由ASBR产生，在所有区域中传播，用来描述ASBR从外部AS注入OSPF区域的重分布路由；</li>
<li>7类LSA也由ASBR产生，在NSSA区域内传播，用来描述外部路由，这个外部路由由ASBR发送给ABR并且由ABR转换成5类LSA后泛洪到其他区域。</li>
</ul>
<h3 id="Type-1"><a href="#Type-1" class="headerlink" title="Type-1"></a>Type-1</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-2.jpg" alt="ospf-lsa-types-explained-2"></p>
<p> 1类SLA的英文全称是：Router Link Advertisement，每台运行OSPF的路由器都会为其所属的每个Area产生1类LSA，1类LSA描述了该路由器在本区域内链路的状态，通告了直连这个区域接口的信息，1类LSA在本区域内泛洪。OSPF用1类LSA识别本链路为以下4种链路邻接方式的哪一种：</p>
<ol>
<li>Stub Network，Stub网络。</li>
<li>Point-to-Point links，点对点链路。</li>
<li>Link to a multiaccess network，多路访问链路。</li>
<li>Virtual Links，虚链路。</li>
</ol>
<p>注意，interface（接口）和link（链路）是有区别的，两者并不是同一个概念。一个接口（Interface）表示的是一个路由器上的物理或逻辑接口，逻辑接口比如loop back接口，物理接口比如以太网接口；而一个链路（link）描述的是表格种两个节点的关系，虚链路（Virtual link）是一个说明这个概念的很好的例子，一个虚链路描述的是逻辑上连接到另一个路由器。</p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-07-20_15-46-10.jpg" alt="Snipaste_2020-07-20_15-46-10" style="zoom: 67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-07-22_12-17-06.jpg" alt="Snipaste_2020-07-22_12-17-06" style="zoom: 50%;">

<p>Length及之前的部分都是LSA Header，有两个地方需要说一下，一个是LS Type为1，表示这是一个1类的LSA；另一个是Link State ID部分，这里该字段被设置成路由器的Router ID。LSA的Header也可以用命令”show ip ospf database”进行查看，但必须要注意这里的Link ID并不是上文倒数第二个字段Link ID，而是Link State ID，在1类LSA中就是Router ID。</p>
<p><img src="/2020/06/18/13-ospf/106-02-show_ip_ospf_database.png" alt="106-02-show_ip_ospf_database"></p>
<p>Link ID和ADV Router在不同类型的LSA中表示的不同含义，ADV Router就是生成这个LSA的Router ID，比如1类LSA的ADV Router就是每台路由器本身， 因为1类LSA由每台路由器自己产生；2类LSA的ADV Router是DR的Router ID，因为2类LSA由DR产生。Link ID，是本设备为链路另一端设备所起的名字。</p>
<p>LSA Header中其他的字段在前面已经写过，这里从Length之后的部分开始看。</p>
<ul>
<li>V位：当该位置1时，表示该路由器是一个或多个已经达到Full状态的虚链路（Virtual link）的终点。V代表了Virtual link endpoint。</li>
<li>E位：当该位置1时，表示该路由器时ASBR路由器，也就是AS边界路由器。E代表了External，E位不能在Stub area中置1，因为Stub area不能包含ASBR路由器。</li>
<li>B位：当该位置1时，表示该路由器是ABR路由器，也就是区域边界路由器。B代表了Border，当路由器连接到2个或更多区域时，B字段应马上置1表明它的ABR身份，即使该路由器目前还没连接到核心区域B位也应置1。</li>
<li>#Links：又叫Number of LSAs，也就是后面携带的LSA的数量，是路由器包含的一个区域中的总体链路的数量。</li>
<li>接下来的三个字段Link ID、Link Data以及Type，前两个字段，也就是Link ID和Link Data由Type所决定，当Type值为不同数值时，Link ID和Link Data的含义随之不同。Link ID字段定义了这条链路的对端是什么，也就是连接到的是什么；这里的Type其实是Link Type，主要用于描述OSPF路由器的接口或邻居，它的值取决于所连接网络的类型。当Type为1时，表示这是一个’Point-to-Point connection to another router’，翻译成中文就是‘点对点连接到另一台路由器’；相对应的Link ID为’Neighboring router’s Router ID’，也就是邻居路由器的路由器ID；相对应的Link Data为’the IP interface address of the associated router interface’，也就是和网络相连的始发路由器接口的IP地址。具体参见下面几张表：</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-01-45.jpg" alt="Snipaste_2020-07-21_17-01-45" style="zoom:80%;">

<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-02-14.jpg" alt="Snipaste_2020-07-21_17-02-14"></p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-02-21.jpg" alt="Snipaste_2020-07-21_17-02-21"></p>
<ul>
<li>#TOS：The type of service，如果没有TOS度量和一条链路相关，那么这个字段就设置为0X00，。</li>
<li>metric：度量值。</li>
<li>TOS：该字段思科设备只支持为0。</li>
<li>TOS metric：TOS特定的指标信息。</li>
</ul>
<h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_14-33-52.jpg" alt="Snipaste_2020-10-08_14-33-52" style="zoom: 67%;">

<h4 id="Type字段"><a href="#Type字段" class="headerlink" title="Type字段"></a><a href="http://blog.sina.com.cn/s/blog_5ec353710102vcsc.html">Type字段</a></h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><img src="/2020/06/18/13-ospf/capture-1596510103043.png" alt="capture" style="zoom:67%;">

<p>这个Type字段定义的是链路类型，注意这个链路类型（Link type）与网络类型（Network type）不同，链路类型（Link type）主要用于描述OSPF路由器的接口或邻居，比如Link ID字段能够了解链路对端是什么设备或者链路对端是否有设备，因为构建OSPF数据库和运行SPF算法需要每台路由器宣告它们的1类LSA，这个1类LSA中必须描述路由器链路的状态，链路状态一共有4种；而网络类型（Network type）是由OSPF协议在接口上针对不同的二层链路介质或封装而定义的，如果二层封装协议是以太网（Ethernet）那么OSPF在这个接口的网络类型为Broadcast，如果二层封装的是HDLC或PPP，那么OSPF的网络类型是P2P。网络类型（Network type）决定了路由器和相邻节点在网段上的行为，常见也比较重要的就是是否选举DR\BDR，以及Hello\Dead interval（Hello和过期时间，网络类型为广播时为10S\40S，P2P、P2MP和point to multipoint non-broadcast时为30S\120S），可以在进入接口以后用命令ip ospf network XXXX（point-to-point、broadcast….想修改成什么网络类型，这个XXXX就改成什么）进行修改。</p>
<p>在1类LSA中，可以看到始发该LSA的路由器所连接的所有链路、链路的类型以及相关内容，在设备上可以用show ip ospf database router internal或show ip ospf database router self-originate查看：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-24_15-36-33-1596510697675.jpg" alt="Snipaste_2020-07-24_15-36-33" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-03_17-24-25.jpg" alt="Snipaste_2020-08-03_17-24-25" style="zoom:67%;">

<p>上面说过，1类LSA中的Type字段的值也决定了后面的Link ID和Link Data的取值，下面两张图，第一张是红茶三杯笔记中的，第二张是我结合RFC文档写的，维基百科上的图和我总结的一样，区别在于虚链路的Link Data如何取值，RFC 2328的Page 128上写的是“For links to transit networks, numbered point-to-point links and virtual links, this field specifies the IP interface address of the associated router interface”。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-01-45.jpg" alt="Snipaste_2020-07-21_17-01-45" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-07_16-49-52.jpg" alt="Snipaste_2020-08-07_16-49-52" style="zoom: 50%;">

<p>OSPF链路类型分为四种，分别是Stub network link、Transit network link、Point-To-Point link、Virtual link。OSPF将链路分为以上的类型自然不是吃饱了没事儿干，一方面是描述网络连接方式，P2P link和Transit network link是用于描述网络拓扑结构的而Stub network link是用于描述子网的；另一方面是不同类型的Link消耗的硬件资源不同，比如Transit network消耗资源多一些，Stub network消耗资源少一点。必须注意的是，Stub network和后面的Stub area是完全不同的两个概念，千万不要混淆二者。</p>
<h5 id="Stub-network-link"><a href="#Stub-network-link" class="headerlink" title="Stub network link"></a>Stub network link</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><blockquote>
<p>A stub network’s vertex has only incoming edges.</p>
<p> ——RFC2328 Section 2.1</p>
</blockquote>
<p>RFC的定义过于严谨所以就比较难懂，通俗一些的说法就是在一个链路中只有一台OSPF路由器的情况下，该链路被OSPF链路类型定义为Stub network link，因为一个链路中只有一台OSPF路由器，所以这个链路的网段不可能有OSPF邻居，这个网段的网关就是这台路由器。如果路由器的一个接口被通告进OSPF，无论其二层链路是什么介质，只要在该接口上没有OSPF邻居，那么它就是Stub network link。</p>
<h6 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-04_16-39-26.jpg" alt="Snipaste_2020-08-04_16-39-26"></p>
<p>图中R2身后有一个10.1.23.2/24的网络，它就是Stub network，因为这个网段中只有一个R2一个路由器运行OSPF协议没有其他OSPF邻居。R2产生的1类LSA用于描述FE0/0的Link 数据就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line">  (Link ID) Network/subnet number: 10.1.23.0</span><br><span class="line">  (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">  Number of TOS metrics: 0</span><br><span class="line">   TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>第一行’Link connected to: a Stub Network’ 对应的是Type字段表达的意思，这里的10.1.23.2是一个Stub network，也就是Type字段值为3时的‘connect to a stub network’，也就是路由器连接到一个末梢网络；Link ID是IP network/subnet number，也就是网络号或子网号，这里10.1.23.2/24这个网段的网络号是10.1.23.0；Link Data是网络的IP地址或子网掩码，这里的255.255.255.0就是这个网络的子网掩码。</p>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>运行OSPF的路由器会维护一张网络拓扑表，通常存储这个网络拓扑表的方式是内存的中邻接矩阵，矩阵图会在下文有说明这里先暂时不管，Stub network的连接图和邻接矩阵的对应图如下：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-25_17-17-16-1596609560127.jpg" alt="Snipaste_2020-07-25_17-17-16"></p>
<p>由于Stub network只有一个路由器就行，没有其他OSPF邻居，所以相比前面有两台路由器要承载穿越流量（也就是不以本地为源也不以本地为目的）的Transit network来说，Stub network需要存放的路由信息就会相对少一些。Stub network类似于快递公司中，最靠近收件人的小的快递投送点，它只需要负责周边收件人快件的投送即可，不需要将快件发送到其他快递否送点，所以只需要知道周边用户的地址即可，硬件消耗会降低一些。</p>
<h5 id="Transit-network-link"><a href="#Transit-network-link" class="headerlink" title="Transit network link"></a>Transit network link</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><blockquote>
<p>Transit networks are those capable of carrying data traffic that is neither locally originated nor locally destined. A transit network is represented by a graph vertex having both incoming and outgoing edges.</p>
<p> ——RFC2328 Section 2.1</p>
</blockquote>
<p>RFC给出的定义很严谨，但由于它过于严谨，使得理解起来过于费劲，通过RFC的定义我是没搞明白，又查了一些文章，这里以红茶三杯的笔记为主体，结合自己的理解谈谈这个概念：由于Transit有运输、经过和运送的意思，从定义上看，Transit network是指的有能力发送既不是本网段产生也不是以本网段为目的的数据。但这个定义十分的不好理解，所以也可以把Transit network等同于，至少有两台路由器需要选举DR\BDR的网络，红茶三杯的原话是“简单理解为有邻居的OSPF接口，使用Transit Link来描述。但网络类型为Point-To-Point和点到多点（Point-To-Multipoint）的接口除外，因为它们被定义为Point-To-Point Link。”（在<a href="https://community.cisco.com/t5/routing/does-the-transit-network-in-ospf-equal-ma-network/m-p/4125009#M337365">思科论坛</a>上看到几次有人讨论过这个问题&lt;transit network means there is at least one OSPF neighbor on the link but does not require the election of DR/BDR even if most of the times this happens.&gt;，也在另一个<a href="https://www.networkfuntimes.com/ospf-what-is-a-stub-network/">技术博客</a>上看到有人这么说&lt;What a transit network actually is, is any network that requires a designated router.&gt;，所以为了方便理解这里采用这个说法），这个Transit network可以是以太网LAN或者有多个虚链路的帧中继网络，不管是哪种网络，只要需要选举DR，那么它就是一个Transit network。在之前笔记中写过，由于DR和BDR选举时是每个网段上选的，所以这个Transit network中的network其实也可以理解成网段的意思（ Does the word ‘network’ in the ‘Transit network’ meaning ‘network segment’?Yes I agree——<a href="https://community.cisco.com/t5/routing/does-the-transit-network-in-ospf-equal-ma-network/m-p/4125009#M337365">出处</a>）。举一个不恰当的例子，Transit network有点类似于快递公司中相对大一点的集散中心，这个集散中心既能把周边地区的快递送到，也能把不属于本集散中心投送的快递交给其他靠近最终收件人的投送点进行投递，所以Transit network既要知道其他快递集散点的路径，又要知道周边收件人的地址，硬件消耗相对多一些。</p>
<h6 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_14-46-10.jpg" alt="Snipaste_2020-08-05_14-46-10"></p>
<p>例如上图所示，R1的FE0/0接口激活了OSPF并且有一个OSPF邻居R2，因此R1在LSA1中描述这个接口时，使用Transit Link来描述，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Transit Network</span><br><span class="line">     (Link ID) Designated Router address: 10.1.23.2</span><br><span class="line">     (Link Data) Router Interface address: 10.1.23.1</span><br><span class="line">     Number of TOS metrics: 0</span><br><span class="line">      TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>第一行’Link connected to: a Transit Network’ 对应的是Type字段表达的意思，这里的10.1.23.2是一个Transit network，也就是Type字段值为2时的‘connect to a transit network’，也就是路由器连接到一个传送网络；Link ID是IP address of Designated Router，也就是DR接口的IP地址，这里DR接口的IP地址是10.1.23.1；Link Data是和Transit network这个链路相连的，始发路由器接口的IP地址，这里10.1.23.1就是这个始发路由器的IP地址。</p>
<h6 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_14-49-40.jpg" alt="Snipaste_2020-08-05_14-49-40"></p>
<p>由于Transit network能发送那些既不是本地产生，也不以本地为目的地的数据，而且这货必须最少有2个路由器，所以不难想象，Transit network所需要存放的关于路由的数据相对后面的Stub network要多一些。</p>
<h5 id="Point-To-Point-link"><a href="#Point-To-Point-link" class="headerlink" title="Point-To-Point link"></a>Point-To-Point link</h5><p>OSPF网络类型（network type）为Point-to-Point和Point-to-Multipoint的接口（Loop back接口除外），使用Point-to-Point Link（Link type）来描述，也就是Type字段为1时的“Point-to-Point connection to another router”，表示路由器的接口通过P2P方式连接到另一个路由器。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_16-24-37.jpg" alt="Snipaste_2020-08-05_16-24-37"></p>
<p>例如上图，R1的S0/0口的OSPF网络类型是P2P，因此R1产生的1类LSA中用于描述该接口的网络类型就是P2P Link，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: another Router (point-to-point)</span><br><span class="line">    (Link ID) Neighboring Router ID: 1.1.1.1</span><br><span class="line">    (Link Data) Router Interface address: 10.1.12.2</span><br><span class="line">    Number of TOS metrics: 0</span><br><span class="line">     TOS 0 Metrics: 64</span><br><span class="line"></span><br><span class="line">   Link connected to: a Stub Network</span><br><span class="line">    (Link ID) Network/subnet number: 10.1.12.0</span><br><span class="line">    (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">    Number of TOS metrics: 0</span><br><span class="line">     TOS 0 Metrics: 64</span><br></pre></td></tr></table></figure>

<p>值得注意的是，对于P2P的网络类型接口，OSPF使用了两个Link来描述，一个是P2P Link，用于描述链路对端连接的路由器ID及自己本地的接口IP地址，还用了一个Stub Network Link来描述该条链路的掩码。</p>
<p>点对点的链路类型比较奇怪，因为理论上来说这种类型的链路并不需要IP地址就可以通信，因为OSPF将这种类型的链路视为“unnumbered”，也就是未编号，也可以理解成没有IP地址。因为链路上只有两个设备，流量从一段发过来肯定是要到另一端去的，给它提供两个IP地址其实意义并不大，但思科IOS中，一个接口如果没有IP地址就没法发送数据，所以也可以用命令“ip unnumbered XX”来让一个接口借用其他IP地址，比如如果想让Ethernet 0 这个链路类型为P2P的接口接用其他IP地址类通信，可以配置“ip unnumbered Ethernet 0”命令。</p>
<h5 id="Virtual-link"><a href="#Virtual-link" class="headerlink" title="Virtual link"></a>Virtual link</h5><p>这种链路类型用来描述OSPF虚链路（Virtual Link）。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_11-43-00.jpg" alt="Snipaste_2020-08-12_11-43-00" style="zoom:67%;">

<p>在上图中，R1和R3之间建立了一条虚链路，则R1产生的LSA1中描述该虚链路的数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Virtual Link</span><br><span class="line">     (Link ID) Neighboring Router ID: 3.3.3.3                #虚链路对端设备的RouterID</span><br><span class="line">     (Link Data) Router Interface address: 10.1.12.1       #本地接口IP地址</span><br><span class="line">     Number of TOS metrics: 0</span><br><span class="line">      TOS 0 Metrics: 128</span><br></pre></td></tr></table></figure>

<p>上面输出的Metric：128，指的是从本地到虚链路对端，沿途所有出接口的COST累加，例如R1产生的描述虚链路的Link数据中包含的metric值就是如图中所示绿色标记的接口的cost值累加。</p>
<h5 id="为什么如此定义"><a href="#为什么如此定义" class="headerlink" title="为什么如此定义"></a>为什么如此定义</h5><p>为什么要定义Stub\Transit network呢？答案是为了减少内存使用（This distinction is made because of memory requirements of the OSPF implementation.——<a href="https://community.cisco.com/t5/switching/ospf-lsa-type-1-stub-network/td-p/1536761">出处</a>），OSPF最早是在1989年提出来的，当时路由器的硬件配置比较低，但现在设备的硬件性能有了很大的提高，已经不太需要去如此节约系统资源了，但理解OSPF如此规定的理念有助于对协议整体的把握，所以建议有时间还是了解一下。当然具体如何减少内存使用，说实话我也没完全搞懂，写一下目前的理解，也许有时间再把这一块完善一下。</p>
<p>OSPF会利用内存维护一个网络拓扑表的矩阵，这个矩阵通常的存在形式如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-38-29.jpg" alt="Snipaste_2020-07-28_15-38-29" style="zoom:67%;">

<p>矩阵最上面，行的备注是“form”，也就是“form object”：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-03-50.jpg" alt="Snipaste_2020-07-28_15-03-50" style="zoom:67%;">

<p>矩阵最左边，列的备注是“to”，也就是“to object”：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-04-54.jpg" alt="Snipaste_2020-07-28_15-04-54" style="zoom:50%;">

<p>做标记的N1和RT1交汇处的数值为3，表示从RT1（行代表的意思为form，也就是从的意思）路由器去到N1（列代表的意思为to，也就是去的意思）网段的cost值为3，当然从N1网段到RT1的cost也是3。其实这个网络拓扑矩阵也就是把物理连接图用矩阵图的形式存在了路由器中，从图中也可以看出这个拓扑矩阵：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-41-18.jpg" alt="Snipaste_2020-07-28_15-41-18" style="zoom:67%;">

<p>那么这个拓扑矩阵和减少内存使用有毛关系呢？从矩阵图可以看出，有两个重要元素，路由器和网段。每个<strong>路由器</strong>都在该矩阵的“from”和“to”中出现（如果路由器不在该矩阵中出现，表示这个路由器和其背后的网络均无法到达），但不是每个<strong>网段</strong>在“from”和“to”中都出现，具体来说就是，Transit network属性的网段不论是在“form”的行上，还是在“to”的列中都会出现，但Stub network属性的网段在“to”的列中会出现，因为这个网段作为其他路由器或网段的目的地（也就是在to这一列出现）是没问题的；但在“from”的行上不出现，因为Stub network中只有一个路由器没有其他邻居，而这个网段就是终点了，网段后面也没有其他网段了，它没有穿越流量，因此不需要知道去往其他网段或路由器的路径，只需要把出向流量交给和该Stub network相连的路由器就OK了，那个路由器不管是在“from”还是“to”上都有，知道所有的路径。所以Stub network在“to”的列中有，但在“from”行上不会出现。上面矩阵图中最上边的行中，只有N3、N6、N8、N9出现了，说明这几个网段为Transit network而除此之外的网段均为Stub network，Stub network不出现在from行中减少了矩阵的大小，节约了硬件资源。如果有兴趣可以看一下下面这段话的出处，感觉我的理解并不到位。</p>
<blockquote>
<p>The key observation here is that the stub networks are actually uninteresting for shortest path calculations between routers because they do not provide any further path to any other part of the network. The stub network is the edge - there is nothing behind it, only the network itself. It can be considered an attribute of the router to which it is connected but it is not interesting as a transit topology object. This idea allows us to save memory by <strong>not including the stub networks into the “from” rows of the adjacency matrix</strong> and thus reducing its size. If out of N networks, only N’ (N’ &lt; N) networks are transit networks, the adjacency matrix could be reduced to the size of (M+<strong>N’</strong>) rows x (M+<strong>N</strong>) columns.</p>
<p>This is why the OSPF actually has the stub/transit network distinction in the first place.                                    ——<a href="https://community.cisco.com/t5/switching/ospf-lsa-type-1-stub-network/td-p/1536761">出处</a></p>
</blockquote>
<p>关于节约资源的部分举一个简单的例子，比如一个网络拓扑中有4台路由器和5个网段：</p>
<p>（N1）R1—（N2）—R2—（N3）—R3—（N4）—R4（N5）</p>
<p>如果<strong>不区分Transit\Stub network</strong>，那么矩阵图的大小就是9X9，矩阵图的面基为81：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_16-04-43.jpg" alt="Snipaste_2020-07-28_16-04-43"></p>
<p><strong>区分了Transit\Stub network</strong>后，由于N1和N5这两个Stub network不用在表示from的行中出现，那么矩阵图的大小就是9X7，面基为63：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_16-08-40.jpg" alt="Snipaste_2020-07-28_16-08-40"></p>
<p>通过以上的例子能看出区分Transit和Stub链路类型后，能节约一定的资源。</p>
<h5 id="Loop-back接口"><a href="#Loop-back接口" class="headerlink" title="Loop back接口"></a>Loop back接口</h5><p>Loopback接口的链路类型（Link type）永远被定义为Stub host（红茶三杯笔记中这里写的时Stub network link，但看过RFC以后，我感觉还是用RFC中的Stub host更严谨一些&lt;To facilitate this, such interfaces are advertised in router-LSAs as single host routes, whose destination is the IP interface address.—RFC 2328，Page 68&gt;），默认使用32位掩码表示，无论配置loop back的IP地址时使用24/的掩码也是如此。如果进入loop back接口在里面配置一条ip ospf network point-to-point命令，将这个loop back接口的网络类型由loop back 变为了point-to-point，那么这个loop back接口的掩码长度就由32位变成了24位。但必须强调的是，这里更改的是接口的network type也就是网络类型，而接口的链路类型（Link type）由二层封装决定，没有变化，所以Link type还是Stub host\Stub network，也可以说除了网络掩码发生了变化其他都没有变化。</p>
<h6 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-11-52.jpg" alt="Snipaste_2020-08-11_16-11-52"></p>
<h6 id="基础配置："><a href="#基础配置：" class="headerlink" title="基础配置："></a>基础配置：</h6><p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> network 7.7.7.7 0.0.0.0 area 0</span><br><span class="line"> network 192.168.78.0 0.0.0.255 area 0</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 8.8.8.8</span><br><span class="line"> network 192.168.78.8 0.0.0.0 area 0</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.78.8 255.255.255.0</span><br></pre></td></tr></table></figure>

<h6 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h6><p>默认情况下，即使R7的loopback接口的IP地址配置成24/位掩码，但在<strong>R8</strong>的OSPF路由表中，依旧是32位掩码，因为此时R7的loop back 接口的Link type，也就是链路类型是stub host：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-28-22.jpg" alt="Snipaste_2020-08-11_16-28-22" style="zoom:67%;">

<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-27-16.jpg" alt="Snipaste_2020-08-11_16-27-16"></p>
<p>为了改变思科IOS默认将Loop back接口的掩码设置为32位的情况，我们在思科设备中只能将接口的网络类型（Network type）设置为点对点：</p>
<p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.0</span><br><span class="line"> ip ospf network point-to-point</span><br></pre></td></tr></table></figure>

<p>在R7的loop back接口的Network type，也就是网络类型设置为点对点后，R8的路由表中R7loop back接口的掩码由32位变成了loop back地址中配置的24位掩码：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-32-14.jpg" alt="Snipaste_2020-08-11_16-32-14" style="zoom:67%;">

<p>此时再看R7的loop back接口：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-34-22.jpg" alt="Snipaste_2020-08-11_16-34-22" style="zoom:67%;">

<h4 id="LSA实验"><a href="#LSA实验" class="headerlink" title="LSA实验"></a>LSA实验</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>在图中，R1有三条链路，一条是右边的E0/1口的链路，连接着R2，一条是上边的通向192.168.1.0/24网络的链路，另一条是通往下边的另一个网段的链路。R1需要用1类LSA描述这三条链路并将LSA宣告给R2。R1要给R2（或其他路由器）提供三种信息：</p>
<ol>
<li>一个ID，用于将自己标识为图中的节点；</li>
<li>链路邻接关系列表；</li>
<li>与链路上所有连接的节点的关系。</li>
</ol>
<p>为了标识图中的节点，OSPF使用32位长度的数字作为这些节点在LSDB中的标识符，成为路由器ID，英文为Router ID，简写为RID。默认情况下，OSPF选择loop back接口中最大的IP地址作为RID，如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。RID也可以在OSPF进程中用“router-id XXXXX”配置。当R1生成它的1类LSA时，它将使用1.1.1.1这个RID作为Link State ID和Advertising Router字段的值，具体如下：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_17-22-24.jpg" alt="Snipaste_2020-08-18_17-22-24"></p>
<p>接下来我们看四种链路类型之一的Stub network在1类LSA中的体现：</p>
<h5 id="Describing-Stub-Network"><a href="#Describing-Stub-Network" class="headerlink" title="Describing Stub Network"></a>Describing Stub Network</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>R1是上面拓扑中的网段192.168.1.0/24中的唯一路由器，这种链路被OSPF分类为Stub network，因为该网段除了R1外没有其他的OSPF路由器，所以流量会从以该网段为起点或终点，但不会穿越该网段，换一种说法就是，网段192.168.1.0/24不会作为传输网段。</p>
<p>R1为Stub network类型的Link type在其1类LSA中建模，好像它是一个连接到另一个节点的链路，用网络前缀作为它的Link ID，用子网掩码作为Link Data。这样一来，这个网段看起来像是一个直接连接到R1上的节点。在所有1类LSA描述的链路邻接节点中，只有Stub network类型的链路描述中携带了网络层地址信息。下面是R1对链路类型为Stub network的192.168.1.0/24这个网段的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line"> (Link ID) Network/subnet number: 192.168.1.0                   #该网段的网络前缀</span><br><span class="line"> (Link Data) Network Mask: 255.255.255.0                        #该网段的网络掩码</span><br><span class="line">  Number of MTID metrics: 0</span><br><span class="line">   TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>Link ID后面标注的是Network/subnet number，翻译成中文就是所描述网段的网络/子网前缀，在这就是192.168.1.0这个网络号，Link Data后面标注的是Network Mask，翻译成中文就是所描述网段的网络掩码，在这就是3个255。至此R1到192.168.1.0/24这个链路类型为Stub network的网段已经描述完毕，接下来看R1如何用1类LSA描述R1和R2之间的点对点链路。</p>
<h5 id="Point-to-Point"><a href="#Point-to-Point" class="headerlink" title="Point-to-Point"></a>Point-to-Point</h5><p>R1上看到的描述这个P2P链路输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: another Router (point-to-point)</span><br><span class="line">(Link ID) Neighboring Router ID: 2.2.2.2</span><br><span class="line">(Link Data) Router Interface address: 12.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>这个P2P链路描述了R1和R2之间直连的链路，Link ID字段后面标注的是Neighboring Router ID，翻译成中文就是链路另一端的邻居设备的RID，在这里也就是R2的RID2.2.2.2。Link Data字段标注的是Router Interface address，翻译成中文就是该本路由器连接到该链路的接口的IP地址，也就是R1的E0/1的IP地址，12.1.1.1。这里必须注意，Link Data字段并不包含地址信息，因此OSPF会用另一个Stub network的LSA来描述这个链路的掩码，Link ID是IP network/subnet number，也就是网络号或子网号，这里10.1.23.2/24这个网段的网络号是10.1.23.0；Link Data是网络的IP地址或子网掩码，这里的255.255.255.0就是这个网络的子网掩码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line">(Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">(Link Data) Network Mask: 255.255.255.0</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<h5 id="OSPF谎言"><a href="#OSPF谎言" class="headerlink" title="OSPF谎言"></a>OSPF谎言</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>看起来OSPF在描述上面R1和R2之间的，链路类型为P2P的时候撒了个谎，因为在上面说过，在宣告P2P链路时有两条LSA，一个是P2P，用来描述直连到对方的链路，另一个是Stub network，用来描述掩码，但前面同样说过Stub network是没有邻居的，也不能用于传输穿越流量，而R1和R2是邻居关系，这条链路也承载穿越流量了，比如从R2到192.168.1.0/24的网段就是穿越流量，所以两者矛盾了。</p>
<p>但其实是，逻辑上R1将R2和12.1.1.0/24视作网络中的两个不同节点，当用SPF算法计算路由时，通向这两个节点的每条链路都作为独立的个体，当计算1.1.1.1和2.2.2.2这两个节点之间的路径时，用P2P链路的描述参数计算，当计算通向12.1.1.0/24的网络时，用Stub network链路的描述参数计算：</p>
<p><img src="/2020/06/18/13-ospf/image-20200827163801952.png" alt="image-20200827163801952"></p>
<p>具体请参见<a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">该贴</a>中的The OSPF Lie部分。</p>
<h3 id="Type-2"><a href="#Type-2" class="headerlink" title="Type-2"></a>Type-2</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-3.jpg" alt="ospf-lsa-types-explained-3"></p>
<p>2类LSA的英文是Network-LSA，两个或多个路由器组成广播或NBMA类型的网络时，在DR和至少一个路由器形成全邻接状态（Full adjacency）后，会由DR产生2类LSA，2类LSA描述了包括DR本身在内的连接到网络的所有路由器。2类LSA在本区域内传播。2类LSA的Link state ID字段列出了DR接口的IP地址，这个IP地址和掩码地址（2类LSA中携带着掩码地址）做与运算后，可以得出网络号。</p>
<h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_16-54-39.jpg" alt="Snipaste_2020-08-12_16-54-39" style="zoom:50%;">

<p>LSA的Header部分之前分析过，这里只看message部分。</p>
<ul>
<li>Network Mask：网络的掩码。</li>
<li>Attached Router：连接到网络的路由器的Router ID，事实上，只有那些和DR形成了全邻接关系（Full adjacency）的设备才会在这里面显示出来，DR的Router ID也会显示在这里面。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_17-03-38.jpg" alt="Snipaste_2020-08-12_17-03-38" style="zoom:50%;">

<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><h5 id="只用1类LSA的情况"><a href="#只用1类LSA的情况" class="headerlink" title="只用1类LSA的情况"></a>只用1类LSA的情况</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_16-52-47.jpg" alt="Snipaste_2020-08-27_16-52-47" style="zoom:67%;">

<p>上图中R1、R2和R3各有一个接口在同一网段，是MA类型的网络，这种情况下，如果只用1类LSA中的P2P链路类型描述三个路由器之间的关系，而完全不用2类LSA的话，也可以描述，但只能一个一个链路的描述，也就是说一个路由器需要两条1类LSA描述，比如R1的话，需要节点1.1.1.1连接到节点3.3.3.3，1.1.1.1连接到4.4.4.4这两条1类LSA才能描述，只用1类LSA描述后的逻辑拓扑如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_17-05-30.jpg" alt="Snipaste_2020-08-27_17-05-30" style="zoom:50%;">

<p>只用1类LSA描述网络的连接关系不仅看起来过于繁琐，也会使LSDB显得很臃肿，庞大的LSDB数据库在运行SPF算法计算路由时会极大的消耗路由器的内存，再具体的解释请参见<a href="https://community.cisco.com/t5/other-network-architecture/why-ospf-lsa-type-2-s/td-p/288472">这个帖子</a>。</p>
<h5 id="使用2类LSA的情况"><a href="#使用2类LSA的情况" class="headerlink" title="使用2类LSA的情况"></a>使用2类LSA的情况</h5><p>用2类LSA描述MA网络信息的方式，就是构筑一个虚拟的节点，这个虚拟节点表示这个MA网络的网段，并让该网段上的每个路由器向新节点通告他们的关系：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_17-26-34.jpg" alt="Snipaste_2020-08-27_17-26-34" style="zoom:50%;">

<p>如果上图的连接转换成语言描述的话就是：1.1.1.1、4.4.4.4和3.3.3.3这三个节点都连接到134.1.1.4这个Transit network上。这样宣告几台路由器之间的MA网络及连接关系占用的空间比较少，OSPF认为134.1.1.4这个节点为其他与之相连的路由器（图中就是1.1.1.1、3.3.3.3、4.4.4.4）提供了连接，并将134.1.1.4这个节点视作另一个虚拟路由器。在134.1.1.0/24网段中会选举出DR，前面说过，DR\BDR是接口属性，从这里也能看出来原因，因为三台路由器各有一个接口连在这个网段中。选出的这个DR生成2类LSA宣告相关信息。在这个拓扑中，在几台路由器R4的Router ID是4.4.4.4比其他路由器的Router ID大，所以一般情况下，R4会被选举（选举过程详见之前的DR\BDR选举）为该网段的DR并宣告2类LSA，该LSA中携带着以下信息：</p>
<ol>
<li>R4用自己在134.1.1.0/24的接口的IP地址134.1.1.4，作为虚拟节点产生的2类LSA的Link State ID；</li>
<li>由R4产生的2类LSA，包含着和该虚拟节点相连的所有路由器的列表，也就是后面的Attached Router。</li>
</ol>
<p>下面来看由R4生成的这条2类LSA，这条LSA描述的是134.1.1.4这个虚拟节点以及该虚拟节点连接的1.1.1.1、3.3.3.3、4.4.4.4这三个节点。因为2类LSA的Link State ID是DR的IP地址，所以其他路由器使用DR的IP地址加上后面的Network mask，也就是部分写的是/24，这两个做与运算后就是网络号，134.1.1.0/24：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# show ip ospf database network</span><br><span class="line">— omitted —</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Network Links</span><br><span class="line">Link State ID: 134.1.1.4 (address of Designated Router) </span><br><span class="line">Advertising Router: 4.4.4.4</span><br><span class="line">LS Seq Number: 80000001</span><br><span class="line">Checksum: 0x9CDC</span><br><span class="line">Length: 36</span><br><span class="line">Network Mask: /24</span><br><span class="line">Attached Router: 4.4.4.4</span><br><span class="line">Attached Router: 1.1.1.1</span><br><span class="line">Attached Router: 3.3.3.3</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_16-52-47.jpg" alt="Snipaste_2020-08-27_16-52-47" style="zoom:67%;">

<p>连接到134.1.1.0/24网段中的R1这个路由器，用一个链路类型为Transit network的1类LSA去描述R1和虚拟路由器之间的链路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# show ip ospf database router self-originate</span><br><span class="line">— omitted —</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Router Links</span><br><span class="line">Link State ID: 1.1.1.1</span><br><span class="line">Advertising Router: 1.1.1.1</span><br><span class="line">— omitted —</span><br><span class="line">Link connected to: a Transit Network</span><br><span class="line">   (Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">   (Link Data) Router Interface address: 134.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>上面描述的这个链路类型为Transit network的链路时，Link ID为134.1.1.4，既是DR（R4）在网段134.1.1.0/24上接口的IP地址，也同样时虚拟路由器的Link State ID，这个值是134.1.1.4；这条Transit network链路的Link Data部分，是R1连接到134这个网段上接口的IP地址，这个值是134.1.1.1 。</p>
<p>上面这两条LSA组合到一起可以后描述了R1的链路情况，节点1.1.1.1通过一个Transit link类型的链路连接到一个虚拟节点134.1.1.4，掩码为24/。这个虚拟节点连接到了节点1.1.1.1、3.3.3.3和4.4.4.4 。</p>
<h4 id="特殊情况分析"><a href="#特殊情况分析" class="headerlink" title="特殊情况分析"></a>特殊情况分析</h4><blockquote>
<p>A router that has formerly been the Designated Router for anetwork, but is no longer, should flush the network-LSA thatit had previously originated.  This LSA is no longer used inthe routing table calculation.  It is flushed by prematurely incrementing the LSA’s age to MaxAge and reflooding.</p>
</blockquote>
<p>如果一个路由器接口的角色由DR变成了非DR，那么它应该刷新之前产生的那条2类LSA，因为之前这个接口还是DR时会产生2类LSA，并将LSA中的age字段设置为最大，也就是3600秒，使这条2类LSA过期，好让其他路由器从LSDB中将这条已经不适用于计算路由的2类LSA删除，因为其他路由器并不能删除那些不是本身产生的LSA。</p>
<blockquote>
<p>In addition, in those rare cases where arouter’s Router ID has changed, any network-LSAs that were originated with the router’s previous Router ID must beflushed. Since the router may have no idea what it’s previous Router ID might have been, these network-LSAs are indicated by having their Link State ID equal to one of the router’s IP interface addresses and their Advertising Router equal to some value other than the router’s current RouterID .</p>
</blockquote>
<p>此外，在那些路由器的Router ID改变的极少数情况下，任何之前产生的带有旧的Router ID的2类LSA都必须被刷新成带有新Router ID的2类LSA，比如在MA网络中的R12的E0/1接口角色为DR，这台路由器一开始的Router ID是1.1.1.1，后来通过配置将Router ID改成了2.2.2.2，这时候这台路由器就得重新发送2类LSA通告其他路由器它的Router ID进行了更改，因为之前2类LSA中的Advertising Router部分是DR的Router ID，而这个Router ID已经发生了变化。2类LSA的Link State ID字段的值为该路由器接口之一的IP地址，Advertising Router字段的值为路由器当前Router ID以外的值。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_16-50-32.jpg" alt="Snipaste_2020-08-12_16-50-32" style="zoom:67%;">

<h3 id="Type-3"><a href="#Type-3" class="headerlink" title="Type-3"></a>Type-3</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-4.jpg" alt="ospf-lsa-types-explained-4"></p>
<h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-29_15-44-12-1602320576543.jpg" alt="Snipaste_2020-08-29_15-44-12"></p>
<p>1类和2类LSA解决了区域内路由计算问题，计算并生成了标识为O的区域内路由，解决了区域内部的通信问题，那么区域间的路由怎么办呢？如果路由器需要访问其他区域呢？这时就需要3类LSA。3类LSA是网络汇总LSA，由ABR路由器生成，3类LSA与1类2类LSA不同的是，3类LSA不是详细描述一个区域种存在着哪些节点以及这些节点之间如何连接，它描述的是一个网络号、AS边界路由器或一个IP地址范围段（The destination described by a summary-LSA is either an IP network, an AS boundary router or a range of IP addresses——RFC2328 - Page 135），也可以理解成是路由表中需要通告给其他Area的路由条目的网络号，也就是网络前缀。3类LSA通告范围只有一个区域，也就是把3类LSA传递给邻接的Area0（flood them into the other areas to which it is attached），再由Area 0的ABR生成到其他非Backbone区域的3类LSA。</p>
<h5 id="OSPF的网络号"><a href="#OSPF的网络号" class="headerlink" title="OSPF的网络号"></a>OSPF的网络号</h5><p>在一个多区域OSPF网络中，存在着两种不同的路由，区域内路由和区域间路由，这两种路由也有对应的网络号（网络前缀）：</p>
<ul>
<li>区域内：来自区域内路由的网络号；</li>
<li>区域间：来自区域外路由的网络号；</li>
</ul>
<h5 id="OSPF的层次结构"><a href="#OSPF的层次结构" class="headerlink" title="OSPF的层次结构"></a>OSPF的层次结构</h5><p>还必须了解一下OSPF的层次结构。为了提高抗路由环路能力，OSPF将拓扑分成两层，顶层是Area 0，也就是Backbone Area（骨干区域），下层是除了Area 0之外的其他Area。所有的区域必须和最顶层的Area 0相连接，所有的3类LSA通过位于顶层的骨干区域进行交换后，再发送到下层的其他Area中。这种层次的结构去交换3类LSA就相当于创建了一个下图的“Hub-and-Spoke”（中心辐射型）类型的拓扑：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-01_13-07-04.jpg" alt="Snipaste_2020-09-01_13-07-04" style="zoom:50%;">

<h5 id="3类LSA的泛洪"><a href="#3类LSA的泛洪" class="headerlink" title="3类LSA的泛洪"></a>3类LSA的泛洪</h5><p>由于采用了层级设计，有区域间、区域类两种路由要传递，且3类LSA的通告范围只有一个区域，所以3类LSA的泛洪方式如下：</p>
<ul>
<li>ABR会为骨干区域的区域内路由和区域间路由产生3类LSA，并将3类LSA从骨干区域泛洪到非骨干区域；</li>
<li>ABR会为非骨干区域的区域内路由产生3类LSA，并将3类LSA从非骨干区域泛洪到骨干区域；</li>
<li>ABR使用SPF算法计算路由时，只会用骨干区域产生的3类LSA进行计算。</li>
</ul>
<p>比如上面的拓扑中，ABR1会为Area 1这个非骨干区域的内部路由生成3类LSA，并将该LSA泛洪到骨干区域Area 0，同样ABR1也会为骨干区域Area 0的内部路由和外部路由（剔除出原属于Area 1这个区域的路由后）生成3类LSA并将该LSA泛洪到Area1这个非骨干区域。</p>
<p>上面的算法意味着ABR只有连接到Area 0的时候才会产生3类LSA，在思科设备中ABR是这个工作模式，但可能其他厂商的设备中会有所不同。</p>
<p>有些人认为，3类LSA的通告范围是除了特殊区域的整个OSPF网络，但实际上这种说法是不严谨的，比较严谨的说法是3类LSA的通告范围只有一个区域，也就是邻接的其他那个区域。比如下面这个拓扑中，身处Area256中的R5身后192.168.5.0/24这个网段，由所在区域Area 256的ABR路由器R2生成3类LSA泛洪到Area 0中，这时可能有人要问，如果你说3类LSA的通告范围是邻接的一个区域，那么这个代表192.168.5.0/24网段的3类LSA就不会泛洪到Area 37或Area 489了，可实际实验中这两个区域是有192.168.5.0/24这个OIA的区域间路由的，这和上面3类LSA传播范围只有一个区域的说法矛盾了。是这样，R2生成的这条3类LSA发送到Area 0后，如果想将192.168.5.0/24这个OIA区域间路由用3类LSA继续传递给Area 37或Area 489，这时候R3会为Area 37重新生成一条3类LSA然后传递到这个区域中，R4会为Area 489重新生成一条3类LSA传递到这个区域中，也就是说这条由R2生成的3类LSA由Area 256泛洪到Area 0以后这条3类LSA的泛洪就结束了，如果要继续泛洪到其他Area，就要由其他的ABR，比如R3或R4重新生成，虽然表示192.168.5.0/24这条路由的的3类LSA在每个Area中都有，但由于每过一个区域就要重新生成一次3类LSA，所以严格来说已经不是同一条LSA了，因为这两条LSA的Advertising Router不同。</p>
<h4 id="LSA实验-1"><a href="#LSA实验-1" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-29_22-47-33.jpg" alt="Snipaste_2020-08-29_22-47-33" style="zoom:50%;">

<p>查看路由器R2的LSDB得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database</span><br><span class="line">OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line">Router Link States (Area 0)</span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         842         0x80000019 0x00AC74 4</span><br><span class="line">2.2.2.2         2.2.2.2         851         0x80000012 0x00034D 3</span><br><span class="line">3.3.3.3         3.3.3.3         834         0x80000011 0x003338 2</span><br><span class="line">4.4.4.4         4.4.4.4         834         0x80000011 0x000A57 2</span><br><span class="line">— some output has been omitted —</span><br><span class="line">Router Link States (Area 256)</span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         851         0x80000006 0x002BAB 1</span><br><span class="line">5.5.5.5         5.5.5.5         852         0x8000000A 0x00A7F9 3</span><br><span class="line">6.6.6.6         6.6.6.6         853         0x80000007 0x000CE5 2</span><br><span class="line">— some output has been omitted —</span><br></pre></td></tr></table></figure>

<p>这里需要注意，由于是多区域的拓扑，R2在Area 0和Area256中间，所以R2分别为这两个区域生成了1类LSA。R2的Area 0中的1类LSA中并没有R5或者R6，是因为这两个路由器处于Area 256中，同理R1、R3、R4这三个属于Area 0的路由器的1类LSA也没出现在Area 256中。show ip ospf database给出的是LSDB的摘要情况，现在我们来看看R1（Area 0）和R6（Area 256）上的1类LSA，也就是Router LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1769        0x80000019 0x00AC74 4</span><br><span class="line">2.2.2.2         2.2.2.2         1780        0x80000012 0x00034D 3</span><br><span class="line">3.3.3.3         3.3.3.3         1761        0x80000011 0x003338 2</span><br><span class="line">4.4.4.4         4.4.4.4         1761        0x80000011 0x000A57 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (6.6.6.6) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         10          0x80000007 0x0029AC 1</span><br><span class="line">5.5.5.5         5.5.5.5         1831        0x8000000A 0x00A7F9 3</span><br><span class="line">6.6.6.6         6.6.6.6         1830        0x80000007 0x000CE5 2</span><br></pre></td></tr></table></figure>

<p>从拓扑图中可以看到，R1、R6、R7、R8和R9这几台路由器的全部接口都在单一区域内，所以这几台路由器只有他们所在区域的拓扑信息，比如R7只有Area 37的信息，R8和R9只有Area 489的信息。因为R2、R3和R4这三台路由器的接口连接到了多个区域，所以它们是ABR（Area Border Router），也就是区域边界路由器，它们有所连接所有区域的拓扑信息，比如R2有接口在Area 256和Area 0中，所以它会有Area 256和Area 0的拓扑信息。</p>
<p>为了提供不同区域之间的连通性，作为ABR的R2执行了以下四个步骤：</p>
<ol>
<li>查询路由表中来自Area 256的所有区域内路由条目；</li>
<li>将这些区域内的路由条目作为3类LSA宣告进骨干区域，Area 0；</li>
<li>查询路由表中来自骨干区域Area 0的区域内路由和区域间路由的网络号；</li>
<li>将这些网络号，剔除出原本属于Area 256区域的路由后，以3类LSA的形式泛洪到非骨干区域Area 256。</li>
</ol>
<p>来看R2路由表中关于前缀192.168.5.0的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2# show ip route ospf | include 192.168.5.0</span><br><span class="line">O     192.168.5.0/24 [110/11] via 25.1.1.5, 02:10:12, Ethernet0/2</span><br></pre></td></tr></table></figure>

<p>注意这条路由最前方用的标识是“O”，也就是说这条路由对于R2来说是区域内部的路由，所以按照上面提到的四个步骤，R2将会把这条属于Area 256的内部路由用3类LSA宣告并宣告进Area 0，现在来看看关于192.168.5.0这个网络号的3类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database summary 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1947</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)                              #该LSA是3类LSA</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)          #该LSA所表示的网络号是192.168.5.0</span><br><span class="line">  Advertising Router: 2.2.2.2                                  #该LSA由路由器2.2.2.2（R2）生成</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0xCCEB</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>R2的Link State ID后面的备注是summary Network Number，说明该值为需要汇总那条路由的网络号也就是192.168.5.0；路由的子网掩码在‘Network Mask’中体现，为24/位；Advertising Router的值设为自己的Router ID，因为3类LSA由ABR产生而自己就是ABR。最后我们可以看到这条LSA发送到了Area 0中：Summary Net Link States (Area 0)。</p>
<p>在Area 0 中的路由器会进行以下步骤：</p>
<ul>
<li>将这条3类LSA发送过来的网络前缀放入路由表中；</li>
<li>运行SPF算法算出到2.2.2.2这个路由器的最短路径；</li>
<li>在路由计算时加入LSA中的Metric值进行计算。</li>
</ul>
<p>执行完以上步骤后，会计算出区域间的路由前缀，在路由表中用“O IA”进行标识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | i 192.168.5.0</span><br><span class="line">O IA  192.168.5.0/24 [110/21] via 12.1.1.2, 02:46:49, Ethernet0/1</span><br></pre></td></tr></table></figure>

<h5 id="距离矢量特征"><a href="#距离矢量特征" class="headerlink" title="距离矢量特征"></a>距离矢量特征</h5><p>执行完以上的所有3类LSA需要的步骤后会发现，这些步骤和距离矢量路由协议执行的步骤相同，只是简单的将路由前缀、方向（发给路由器2.2.2.2也就是3类LSA的Advertising Router）和Cost（在这个例子中是Metric：11）通告给邻居。这样一来，在区域间添加或删除路由前缀时不需要经过完整的SPF计算。当删除区域间路由时，只需要R2这个ABR将这条3类LSA中的LS age字段设置为超过3600的值，即表示这条LSA已经过期，其他路由器就会将它们LSDB中的条目删除。看完这一段，是不是发现OSPF这个链路状态协议的区域间路由，其实和RIP这种距离矢量协议比较像，都是告诉其他路由器区你要去往X网段发给我就行，是基于传闻的，运行OSPF的路由器只知道本区域内的拓扑但并不知道其他Area的连接方式，具体参照红茶三杯的<a href="http://blog.sina.com.cn/s/blog_5ec353710101bkg6.html">这篇博文</a>，这里就不再赘述了。</p>
<h5 id="传播范围验证"><a href="#传播范围验证" class="headerlink" title="传播范围验证"></a>传播范围验证</h5><p>下面来验证刚才说的3类LSA传播范围，先看Area 256区域中192.168.5.0/24这条路由的的3类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 601</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD2E8</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>再来看Area 0中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 726</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD2E8</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>Area 37中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R7#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (7.7.7.7) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 37)</span><br><span class="line"></span><br><span class="line">  LS age: 653</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 3.3.3.3</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0x7D26</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 31</span><br></pre></td></tr></table></figure>

<p>Area 489中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R9#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (9.9.9.9) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 489)</span><br><span class="line"></span><br><span class="line">  LS age: 1061</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0x5F40</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 31</span><br></pre></td></tr></table></figure>

<p>Area 256和Area 0中的LSA是一样的，但和Area 37以及Area 489中的LSA不同，说明3类LSA的泛洪距离为一个Area，想泛洪到其他Area中的话，必须由连接到其他Area的ABR重新生成LSA。</p>
<h3 id="Type-5"><a href="#Type-5" class="headerlink" title="Type-5"></a>Type-5</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-6.jpg" alt="ospf-lsa-types-explained-6"></p>
<p>1 、2类LSA解决了本区域的路由，3类LSA解决了区域间的路由，如果有从外部注入的路由信息该如何表示呢？这种外部注入的路由信息可能是通过重分布注入的其他路由协议的路由，亦或是由其他OSPF进程重分布进本OSPF进程的路由，比如说一个公司A并购了同一楼层的另一个公司B，A公司网络所采用的的网络协议是OSPF，但B公司的网络用的是RIP，两个公司在同一层楼，为了方便交换信息需要把网络连接起来，这时候该如何处理呢？这时就要用到5类LSA了，也就是AS external link advertisement。5类LSA描述的是去往AS外部路由，由ASBR（AS boundary routers）路由器生成，泛洪范围为所有Area，5类LSA也是唯一一种泛洪到除了特殊区域（Stub, Totally Stubby and Not-so-stubby areas）之外的整个AS的LSA（’AS-external-LSAs are the only type of LSAs that are flooded throughout the entire Autonomous System; all other types of LSAs are specific to a single area.However, AS-external-LSAs are not flooded into/throughout stub areas’——RFC 2328，Page 40）。LSA的Link State ID的值为目标网络的IP地址，当5类LSA的Link State ID设置为0.0.0.0时，LSA用来描述到AS的默认路由。ASBR路由器通过另一个路由协议（比如BGP）或通过配置信息（比如配置静态路由然后重分布）学到外部路由，并为这些学到的外部路由生成一个5类LSA。</p>
<h4 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-09_15-44-11.jpg" alt="Snipaste_2020-09-09_15-44-11">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-10_15-04-49.jpg" alt="Snipaste_2020-09-10_15-04-49">

<ul>
<li>Network Mask：被宣告路由的IP地址的子网掩码；</li>
<li>E位：标识了外部路由的Metric类型。Metric有两种类型，1和2，当E位置1时，表示该路由为OE2，此时这条路由的cost值为ASBR到外部目标网络的值，固定为20；当E位为0时，表示该路由为OE1，此时这条路由的cost值为整个路径的cost值，也就是外部路由到ASBR的cost，与内部路由到ASBR的cost，两者之和。具体差别详见后面的OE1 VS OE2部分。</li>
<li>metric：表示这条路由的cost值，取决于之前E位的取值，具体见后面的OE1 VS OE2部分。</li>
<li>Forwarding address：要发送到外部路由的数据将被发送到Forwarding address这个地址中，如果该字段被设置为0.0.0.0，则数据将被发送到这条LSA的起源路由器，例如ASBR路由器。必须注意的是，当Forwarding address字段不为0.0.0.0时，此字段应指向一个属于其他AS的地址，也就是一个不属于OSPF协议的地址。Forwarding address字段也可以指向一个默认路由，这时Link State ID字段设置为默认路由的目的地址。</li>
<li>External Route Tag：为路由打上标签，防止重分布时产生路由环路。</li>
</ul>
<h4 id="OE1-VS-OE2"><a href="#OE1-VS-OE2" class="headerlink" title="OE1 VS OE2"></a><a href="https://ipwithease.com/ospf-external-e1-and-e2-routes/">OE1 VS OE2</a></h4><p>E1类型路由的cost值，不仅包含了内部路由到达ASBR的cost值，还包括了ASBR到达外部路由的cost，所以E1的cost值是上面提到的两个cost值之和，而E2路由并没包含内部到达ASBR的cost值。看下面图表中的例子能更好的理解E1、E2两种外部路由类型的区别：</p>
<p><img src="/2020/06/18/13-ospf/OSPF-E1-VS-E2.jpg" alt="OSPF-E1-VS-E2"></p>
<p>拓扑如上图所示，有一个外部网段10.1.1.0/24，通过R3重分布进OSPF协议，此时这条外部路由的seed metric（seed metric一般翻译成初始度量值或种子度量值，个人觉得初始度量值更容易理解。主要是因为各种不同的路由协议计算度量值的方法不一致，如RIP是跳数，OSPF则基于带宽，所以使用seed metrics建立一个标准的重分布metric值。）为20，这个seed metric对于E1和E2来说都是存在的。现在轮到R2计算去往外部网段10.1.1.0/24的metric/cost值了，这时E1和E2两种外部路由类型计算的方式出现了不同：</p>
<p>当这条路由为O E1时：R2会把R2和R3之间的cost值，也就是cost=1，加上外部路由原有的seed metric值，也就是20，二者之和就是1+20=21，把21当作外部网段10.1.1.0/24的cost值；R1则会在R2的cost=21的基础上再加上R1到R2的cost值，也就是说R1会认为到10.1.1.0/24这条路由的cost为1+1+20=22。</p>
<p>当这条路由为O E2时：R2只会计算外部网段10.1.1.0/24的seed metric值，而不会加上R2和R3之间的cost值，也就是说E2类型的外部路由的cost值恒为20，R1也将20视为这条外部路由的cost值。</p>
<h4 id="LSA实验-2"><a href="#LSA实验-2" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:50%;">

<p>上面拓扑中的5类LSA由R6产生，这条LSA中包含着以下三种重要信息：</p>
<ul>
<li>Link State ID字段的备注时External Network Number，也就是被注入OSPF路由协议的外部网段的网络号，在本例中被注入的网段是172.16.56.0/24和172.16.65.0/24；</li>
<li>Advertising Router字段是ASBR路由器的Router ID，在本例中是R6的Router ID，也就是6.6.6.6；</li>
<li>Forwarding Address字段的值为0.0.0.0，表示所有的其他路由器想给外部注入的网段发送数据时，只要将数据发送给ASBR路由器，也就是R6即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show ip ospf database external</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (6.6.6.6) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">  LS age: 572</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.56.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0x4151</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br><span class="line"></span><br><span class="line">  LS age: 572</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.65.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0xDDAB</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br></pre></td></tr></table></figure>

<p>这两条5类LSA也可以简单的理解为“去往外部网段172.16.56.0/24和172.16.65.0/24的数据可以通过节点6.6.6.6到达”，由于可以通过6.6.6.6去往外部网段，所以问题从“如何去往外部网段172.16.56.0/24和172.16.65.0/24”，变成了“如何去往节点6.6.6.6”。在Area 256域中的路由器，比如R2或R5，知道如何前往节点6.6.6.6，因为他们的LSDB中有ASBR6.6.6.6的1类LSA（1类LSA描述了路由器在本区域内链路的状态，通告了直连这个区域接口的信息，所以R5有足够的信息知道去往R6的路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         908         0x80000004 0x002FA9 1</span><br><span class="line">5.5.5.5         5.5.5.5         890         0x80000007 0x00C3DF 3</span><br><span class="line">6.6.6.6         6.6.6.6         933         0x80000006 0x0024CD 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database router 6.6.6.6</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">  LS age: 10</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 6.6.6.6</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 8000000B</span><br><span class="line">  Checksum: 0xABB</span><br><span class="line">  Length: 60</span><br><span class="line">  AS Boundary Router</span><br><span class="line">  Number of Links: 3</span><br><span class="line"></span><br><span class="line">               [–omitted–]</span><br><span class="line">               </span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 5.5.5.5</span><br><span class="line">     (Link Data) Router Interface address: 56.1.1.6</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 56.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看出，在ASBR所在的Area中，1类LSA扮演了一个重要的角色，这个角色就是让ASBR域内的其他路由器获知到ASBR的路径，也就是如何到R6。但不在ASBR的Area的路由器的LSDB中，没有像R5一样有通告R6位置的1类LSA，毕竟1类LSA的泛洪范围只限于本Area中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1463        0x8000000A 0x00CA65 4</span><br><span class="line">2.2.2.2         2.2.2.2         1632        0x80000007 0x001942 3</span><br><span class="line">3.3.3.3         3.3.3.3         1400        0x80000009 0x004330 2</span><br><span class="line">4.4.4.4         4.4.4.4         1656        0x80000009 0x001A4F 2</span><br></pre></td></tr></table></figure>

<p>这时候就需要4类LSA来告诉其他Area的路由器如何到达ASBR了。</p>
<h3 id="Type-4"><a href="#Type-4" class="headerlink" title="Type-4"></a>Type-4</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-5.jpg" alt="ospf-lsa-types-explained-5"></p>
<h4 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h4><p>由于5类LSA需要泛洪到AS中的所有Area中，而其他区域中的路由器并没有关于ASBR的LSA，不知道去往ASBR的路径，在这种情况下，ASBR所在区域的ABR会产生4类LSA，用来告知其他Area的路由器如何前往ASBR，所以4类LSA由ASBR所在区域的ABR生成，泛洪范围也是一个区域，4类LSA泛洪到骨干区域后，其他的ABR将重新生成一个4类LSA并将其扩散到自己的区域中。4类LSA对于那些处于非ASBR区域的区域来说，有以下两个重要的作用：</p>
<ol>
<li>为其他Area的LSDB注入关于ASBR的拓扑信息；</li>
<li>使得其他Area的路由器能够选出最佳路径。</li>
</ol>
<p>关于第一点，4类LSA会告知所有在其他Area的路由器，它们所在区域的哪台路由器有足够的信息可以到达ASBR。这样就能让其他Area的路由器做区域间路由查找，解决去往ASBR的路径问题。第二点适用于Area中有多个ABR且这些ABR到达ASBR的cost值不同的情况，当生成4类LSA时，ABR会列出它自身去往ASBR的cost值，该区域的路由器就可以根据列出的ABR值知道哪个ABR有到达ASBR的最佳路径。没有4类LSA的话，在其他Area中的路由器无法知道选择哪个ABR有前往ASBR的最佳路径了。名称中的这个summary的含义，也就是说在一个有多ABR的Area中，summary这些ABR到达ASBR的cost值，让其他路由器知道选择哪个ABR去ASBR，能算出整条路经的cost值。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_17-05-40.jpg" alt="Snipaste_2020-09-27_17-05-40" style="zoom:80%;">

<p>为什么不把5类LSA限制在ASBR这个区域内，让它乱跑不是增加网络负担嘛？对于常规区域的OSPF设计而言，5类LSA的确是可以在OSPF区域内到处乱跑，在某些场合，可能由于OSPF网络的设计，使得OSPF路由器需要维护大量的外部路由，从而导致设备负担过重，那么你可以进行OSPF规划上的调整，例如使用特殊区域——Stub Area、NSSA Area的来优化网络。这些特殊区域能够限制4类LSA或5类LSA的泛洪，并用默认路由来解决网络连通性的问题，因此一来降低了外部路由条目过多带来的影响，二来也解决了去往AS外的连通问题，然而这也带来了一个问题，就是丢失了外部路由的精细度，只知道去往外部路由如何去，但不知道具体有那些路由，好比之前我跟你说的是韩国的妹纸ABCD都很漂亮，现在告诉你韩国的妹纸都不错，你去就是了，这就是所谓的丢失路由的精细度，这在某些特定的网络环境中可能会带来诸如次优路由等等的问题。</p>
<h4 id="LSA实验-3"><a href="#LSA实验-3" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:50%;">

<p>在上面的拓扑中，R6在重分布外部路由进入OSPF时，它的1类LSA中的Flags字段表示R6现在已经时一个ASBR路由器了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LSA-type 1 (Router-LSA), len 60</span><br><span class="line">— omitted —</span><br><span class="line">Link State ID: 6.6.6.6</span><br><span class="line">Advertising Router: 6.6.6.6</span><br><span class="line">Sequence Number: 0x80000004</span><br><span class="line">Checksum: 0x18b4</span><br><span class="line">Length: 60</span><br><span class="line">Flags: 0x02 ((E) AS boundary router)</span><br><span class="line">…. .0.. = (V) Virtual link endpoint: No</span><br><span class="line">…. ..1. = (E) AS boundary router: Yes</span><br><span class="line">…. …0 = (B) Area border router: No</span><br></pre></td></tr></table></figure>

<p>Flags字段中的E位置1时，会告知并提醒Area中的ABR（R2），R6将外部信息注入到了OSPF中，也可以用’show ip ospf database router 6.6.6.6’这条命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database router 6.6.6.6</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">  LS age: 302</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 6.6.6.6</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0x18B4</span><br><span class="line">  Length: 60</span><br><span class="line">  AS Boundary Router                                    #表示R6是ASBR路由器</span><br><span class="line">  Number of Links: 3</span><br></pre></td></tr></table></figure>

<p>和ASBR（R6）同一个Area的ABR（R2）会产生4类LSA并泛洪到所有和ABR相连接的域中，在上面的拓扑中，也就是R2会产生4类LSA泛洪到Area 0中，为了告诉Area0中的路由器如何到达ASBR路由器，也就是到达R6的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 585</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0xF016</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 20</span><br></pre></td></tr></table></figure>

<p>必须注意的是，没有必要将4类LSA泛洪到ASBR（R6）所在的Area 256中，因为前面说过，Area 256中的路由器中的LSDB有足够的信息让它们有到达ASBR的路径。</p>
<p>4类LSA中的Advertising Router字段的值为2.2.2.2，Link State ID（后面的补充信息为AS Boundary Router address，也就是ASBR的地址）值为6.6.6.6，这两个值合起来看表示R1、R3和R4为了到达ASBR（R6），必须有到达R2的最短路径，因为ABR将它自己设置成为宣告4类LSA的路由器，这些4类LSA的泛洪范围不像5类LSA那样覆盖所有的Area，4类LSA的泛洪范围只有1个Area。R2上的4类LSA其实就是在告诉其他路由器：通过我可以到达ASBR 6.6.6.6，我到ASBR的cost值是20。其他拓扑中的ABR路由器，R3和R4，会重新生成一条信的4类LSA，将它们自己设置成为LSA中的Advertising Router，例如Area 489中的4类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip ospf 1 489 database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (4.4.4.4) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 489)</span><br><span class="line"></span><br><span class="line">  LS age: 504</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000003</span><br><span class="line">  Checksum: 0x7B6E</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 40</span><br></pre></td></tr></table></figure>

<p>4类LSA中有ASBR的RID、宣告这条4类LSA的ABR的RID以及ABR到ASBR的cost值。</p>
<h3 id="1-5类LSA组合说明"><a href="#1-5类LSA组合说明" class="headerlink" title="1-5类LSA组合说明"></a>1-5类LSA组合说明</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43-1602248783083.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:67%;">

<p>分别看完了1-5类LSA，是否感觉它们各自为战并没有组成一个有机的整体呢？事实上LSDB中不同类型LSA是用某些因素串联起来的，这些因素就是Link State ID以及Link ID。利用这些关键因素，LSDB掌握了计算两个节点之间最短距离的所有关键信息。接下来用上面的拓扑中的，R1是如何计算到网段192.168.8.0/24，以及到外部网段172.16.65.0/24的路径为例，具体说说各类LSA是如何在LSDB中组合使用去计算路由的。在每次计算路由发现下一跳时，R1会结合使用Link State ID和Link ID，将二者当作R1计算出下一跳并最终到达目标节点的关键因素。</p>
<h4 id="到192-168-8-0"><a href="#到192-168-8-0" class="headerlink" title="到192.168.8.0"></a>到192.168.8.0</h4><p>先看R1的LSDB中关于192.168.8.0/24的条目：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_13-25-13.jpg" alt="Snipaste_2020-09-19_13-25-13" style="zoom:67%;">

<p>从R1的LSDB中能看到，关于192.168.8.0/24的LSA为3类LSA，所以下面看这条LSA的具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database summary 192.168.8.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 339</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.8.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD9CC</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 21</span><br></pre></td></tr></table></figure>

<p>从这条3类LSA中可以看出，192.168.8.0这个网段由R4宣告（Advertising Router: 4.4.4.4）进本Area，cost值为21（Metric: 21），R1把4.4.4.4当作关键因素，接下来查找去往节点4.4.4.4的LSA，也就是说问题由’R1如何去往192.168.8.0/24网段’变成了’R1如何去往节点4.4.4.4’，因为这个3类LSA由R4宣告，前面说过3类LSA相当于R4告诉其他路由器，我R4到192.168.8.0/24网段的cost是21，去往该网段的数据交给我就能到达，这时R1查找去往R4的LSA，并找到了一条1类LSA能到达节点4.4.4.4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router 4.4.4.4</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 626</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 4.4.4.4</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000006</span><br><span class="line">  Checksum: 0x204C</span><br><span class="line">  Length: 48</span><br><span class="line">  Area Border Router</span><br><span class="line">  Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 192.168.4.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit Network</span><br><span class="line">     (Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">     (Link Data) Router Interface address: 134.1.1.4</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，R1去往R4有两条链路（link），一条是链路类型为Stub network的192.168.4.0，另一条是链路类型为Transit Network的134.1.1.4。前面我们说过，Stub network无法承载穿越流量，所以不能用这条link到达R4；后面的Transit network能够承载穿越流量，这条link是到达134.1.1.4这个虚拟网络节点的，R1用134.1.1.4作为关键因素，问题由’R1如何去往192.168.8.0/24网段’，发展成’R1如何去往节点4.4.4.4’，再发展成’R1如何去往虚拟节点134.1.1.4’，因为要去往节点4.4.4.4，必须先到达虚拟节点134.1.1.4。R1此时去LSDB中查找关于134.1.1.4的LSA，可以看到是一条2类LSA，来看看具体这条2类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database network 134.1.1.4</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 446</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Network Links</span><br><span class="line">  Link State ID: 134.1.1.4 (address of Designated Router)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000003</span><br><span class="line">  Checksum: 0x98DE</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Attached Router: 4.4.4.4</span><br><span class="line">        Attached Router: 1.1.1.1</span><br><span class="line">        Attached Router: 3.3.3.3</span><br></pre></td></tr></table></figure>

<p>R1发现134.1.1.4这个虚拟节点有通往节点1.1.1.1的链路，也就是有通往R1的链路。所以上面’R1如何去往虚拟节点134.1.1.4’的问题有了部分答案，也就是R1可以去往虚拟节点134.1.1.4，至于如何去，还要继续看LSDB，所以R1要查看自己的哪条链路能够到达虚拟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router self-originate</span><br><span class="line">OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line">Router Link States (Area 0)</span><br><span class="line">LS age: 1079</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Router Links</span><br><span class="line">Link State ID: 1.1.1.1</span><br><span class="line">Advertising Router: 1.1.1.1</span><br><span class="line">LS Seq Number: 80000005</span><br><span class="line">Checksum: 0x290C</span><br><span class="line">Length: 72</span><br><span class="line">Number of Links: 4</span><br><span class="line">— omitted —</span><br><span class="line">Link connected to: a Transit Network</span><br><span class="line">(Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">(Link Data) Router Interface address: 134.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>从上面的1类LSA中能看出，R1可以去往虚拟节点134.1.1.4，因为它有一条和虚拟节点相连接的Transit network，只要将数据从R1的134.1.1.1接口发出就能到达虚拟节点134.1.1.4。所以问题由’R1如何去往192.168.8.0/24网段’，发展成’R1如何去往节点4.4.4.4’，再发展成’R1是否能去往并如何去往虚拟节点134.1.1.4’，答案是R1能去往虚拟节点134.1.1.4，因为R1的1类LSA中有一条Transit network能到达虚拟节点134.1.1.4，只要将数据从R1的IP地址为134.1.1.1的E0/0接口发出即可。所以R1将R4接口地址134.1.1.4作为下一跳，加上cost值21，写入RIB表中，得到了以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | include 192.168.8.0</span><br><span class="line">O IA  192.168.8.0/24 [110/31] via 134.1.1.4, 01:43:25, Ethernet0/0</span><br></pre></td></tr></table></figure>

<p>当然R1也会计算经由R3去往虚拟节点134.1.1.4的路径，但该路径的cost值为31，大于经由R4前往虚拟节点的cost值。具体怎么得到的31想彻底搞懂的麻烦自行翻译：</p>
<blockquote>
<p><em>NOTE: R1 will also calculate R3’s path to reach the pseudo-node, but the cost value would be 31 vs the 21 of going directly to R4. This is because R1 would forward to R3, which would forward to R4. R4’s cost to the pseudo-node is not used in R1’s calculation, because it is the incoming interface and not the outgoing interface for the traffic. This leads to the cost of 21 instead of 31. In R3’s case, R3’s interface would be used to both receive R1’s packet and forward the packet to R4, which is why it is added in the total cost of the path.</em></p>
</blockquote>
<h4 id="到172-16-65-0"><a href="#到172-16-65-0" class="headerlink" title="到172.16.65.0"></a>到172.16.65.0</h4><p>为了将数据发送到外部网段172.16.65.0/24，R1开始在LSDB中查找相关条目：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_15-12-38.jpg" alt="Snipaste_2020-09-19_15-12-38" style="zoom:80%;">

<p>R1发现一条5类LSA有到达该网段的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database external 172.16.65.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">  LS age: 709</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.65.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0xD9AD</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br></pre></td></tr></table></figure>

<p>从上面的5类LSA中可以看出，由于Metric字段值为20，Forward Address字段的值为0.0.0.0（当该字段为0.0.0.0时，数据将被发送到这条LSA的起源路由器，ASBR路由器，在这里就是R6）且Advertising Router字段的值为6.6.6.6，说明要将数据发送给外部网段172.16.65.0/24，只需要将数据发送到R6，R6到达外部网段的cost为20。这时问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给R6’，因为R6宣告的5类LSA中的Forward Address字段的值为0.0.0.0，说明发送给外部网段的数据发送到R6即可，从R6可以到达外部网段，cost值为20。由于R1和R6处于不同Area，R1就需要以自己为根构建一个到R6的SPT（shortest path tree，最短路径树），大概意思就是要找到一条去往R6的最短且无环路的路径。这时R1会用LSA中的Advertising Router字段的6.6.6.6为关键因素，去查找如何去往节点6.6.6.6，上面说过，由于和ASBR不在同一个Area的其他路由器不知道如何前往ASBR，所以会用4类LSA告诉其他区域的路由器，如何去往ASBR，这里来看4类LSA是如何宣告RID为6.6.6.6的ASBR的位置的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 751</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000006</span><br><span class="line">  Checksum: 0xE81A</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 20</span><br></pre></td></tr></table></figure>

<p>通过4类LSA中的Advertising Router: 2.2.2.2和Metric: 20部分，R1知道节点2.2.2.2可以到达节点6.6.6.6，cost值为20，节点2.2.2.2可以到达节点6.6.6.6，也就是到达ASBR。所以问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，继续发展为’R1如何将数据发送给节点2.2.2.2，R2’，因为数据要达到6.6.6.6先要发送给2.2.2.2才行。这里R1用2.2.2.2作为关键因素查找去往节点2.2.2.2的路径，R1中有一条2.2.2.2的1类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router 2.2.2.2</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1123</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 2.2.2.2</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000008</span><br><span class="line">  Checksum: 0x1743</span><br><span class="line">  Length: 60</span><br><span class="line">  Area Border Router</span><br><span class="line">  Number of Links: 3</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 192.168.2.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 1.1.1.1</span><br><span class="line">     (Link Data) Router Interface address: 12.1.1.2</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>这条1类LSA中的Stub Network无法承载穿越流量，所以无法使用，它还有另一条通往节点1.1.1.1的P2P链路，这条链路说明R1和节点2.2.2.2是相连接的，相互连接自然在一个Area中，所以这时R1以自己的RID为关键因素，查看1类LSA。问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，再发展为’R1如何将数据发送给节点2.2.2.2，R2’，因为R1和2.2.2.2相连，继续发展成’R1如何连接到节点2.2.2.2’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router self-originate</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1867</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 1.1.1.1</span><br><span class="line">  Advertising Router: 1.1.1.1</span><br><span class="line">  LS Seq Number: 8000000B</span><br><span class="line">  Checksum: 0xC866</span><br><span class="line">  Length: 72</span><br><span class="line">  Number of Links: 4</span><br><span class="line"></span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 2.2.2.2</span><br><span class="line">     (Link Data) Router Interface address: 12.1.1.1</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>R1查看自己的1类LSA后发现自己IP地址为12.1.1.1的E0/1接口，有一条P2P链路和节点2.2.2.2相连，cost值为10，所以问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，再发展为’R1如何将数据发送给节点2.2.2.2，R2’，这个问题解决了，也就是把数据从12.1.1.1的P2P接口发送出即可，下一跳设置成为对端的12.1.1.2，也就是R2和R1相连的的E0/1口即可。但要注意，R1不会为外部网段增加cost，因为这里的外部路由类型为E2，cost值恒为20：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | include 172.16.65.0</span><br><span class="line">O E2     172.16.65.0 [110/20] via 12.1.1.2, 03:34:32, Ethernet0/1</span><br></pre></td></tr></table></figure>

<p>本例引用自<a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">这篇文章</a>，这个例子只是简单说明各类LSA的使用方式，在实际中，R1使用一种更彻底的方法来构建其SPT，这里就不继续写了，因为我还不会，等会了也许会继续更新本章。</p>
<h3 id="Type3、Type4报文格式"><a href="#Type3、Type4报文格式" class="headerlink" title="Type3、Type4报文格式"></a>Type3、Type4报文格式</h3><p>由于3类LSA和4类LSA的格式几乎一样，所以RFC上将二者合并起来写的，笔记这里也用这种方式介绍这两种LSA的报文格式。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-09_15-18-15.jpg" alt="Snipaste_2020-09-09_15-18-15" style="zoom:50%;">

<ul>
<li>Network Mask：在3类LSA里，这个字段表示目标网络IP地址的掩码；在4类LSA里，这个字段没有实际意义必须取值为全0。</li>
<li>Metric：这条路由的cost值。和1类LSA中的接口的Cost值一个意思。</li>
</ul>
<p>为了和之前的OSPF版本规范相兼容，LSA中还可以包含TOS-specific信息，TOS字段值的不同表示不同的意思，一般情况下为全0，表示‘normal service’。</p>
<h3 id="TYPE-6"><a href="#TYPE-6" class="headerlink" title="TYPE 6"></a>TYPE 6</h3><p>6类LSA（OSPF GROUP MEMBERSHIP LSA）是OSPF中的组播，但现在已经被PIM所代替，思科设备根本就不支持6类LSA，所以这里就不继续提了。</p>
<h3 id="TYPE-7"><a href="#TYPE-7" class="headerlink" title="TYPE 7"></a>TYPE 7</h3><h4 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h4><p> 7类LSA又叫做not-so-stubby-area（NSSA） LSA，因为NSSA区域不让外部LSA，也就是不让5类LSA进入，所以为了将外部路由引入NSSA area，就要用7类LSA。7类LSA由NSSA ASBR生成，只在原始NSSA区域中泛洪，也就是生成这个7类LSA的NSSA区域中泛洪，不会进入其他常规区域。</p>
<h4 id="报文格式-3"><a href="#报文格式-3" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_17-18-11.jpg" alt="Snipaste_2020-09-19_17-18-11" style="zoom:50%;">

<h5 id="Options字段："><a href="#Options字段：" class="headerlink" title="Options字段："></a>Options字段：</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_17-27-12.jpg" alt="Snipaste_2020-09-19_17-27-12"></p>
<h6 id="E位"><a href="#E位" class="headerlink" title="E位"></a>E位</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_17-20-11.jpg" alt="Snipaste_2020-09-30_17-20-11"></p>
<p>5类LSA不能泛洪到Stub区域和NSSA区域中，E比特确保Stub区域和NSSA区域中的所有路由器都同意5类LSA不能泛洪进入的区域属性。E位只在Hello包和DBD包中有意义。当某一特定接口发出的Hello包中的E位置0时，意味着这个接口不会发送也不会接收5类LSA，换句话说这个接口连接到的是Stub区域或NSSA区域。两个路由器只有在对E位匹配时，也就是E位数值相同时才能成为邻居。</p>
<ul>
<li>E位：5类LSA不能泛洪到Stub区域和NSSA区域中，E比特确保Stub区域和NSSA区域中的所有路由器都同意5类LSA不能泛洪进入的区域属性。E位只在Hello包和DBD包中有意义。当某一特定接口发出的Hello包中的E位置0时，意味着这个接口不会发送也不会接收5类LSA，换句话说这个接口连接到的是Stub区域或NSSA区域。两个路由器只有在对E位匹配时，也就是E位数值相同时才能成为邻居。</li>
</ul>
<h6 id="N-P位"><a href="#N-P位" class="headerlink" title="N/P位"></a>N/P位</h6><ul>
<li>N位：N位决定了路由器是否支持NSSA。N位只在Hello包中有作用有意义，N位确保了区域内所有路由器都同意NSSA区域的属性。当特定接口发出的Hello包中的N位置1时，表示路由器将从那个接口中接收和发送7类LSA。两个路由器只有在N位互相匹配时，也就是N位数值相同时才能成为邻居。如果一个路由器的N位置1，那么它的E位必须置0。因为N位置1意味着能接收发送7类LSA也就是该区域为NSSA area，但如果E位置1意味着能接收发送5类LSA，二者相互冲突，而NSSA area中不能存在5类LSA。</li>
<li>P位：P位只在7类LSA的Header中使用。置1时标识NSSA的边界路由器可以将7类LSA转换成5类LSA。通常P位置0。</li>
</ul>
<p>N/P位其实是一个字段，在Hello包中，该位是N位，用来协商路由器是否支持NSSA区域：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-10_19-39-03.jpg" alt="Snipaste_2020-10-10_19-39-03"></p>
<p>在7类LSA的Header中，该位是P位，用来标识NSSA的边界路由器是否能将7类LSA转换成5类LSA：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-10_19-41-08.jpg" alt="Snipaste_2020-10-10_19-41-08"></p>
<h3 id="其他LSA"><a href="#其他LSA" class="headerlink" title="其他LSA"></a>其他LSA</h3><p>Type8、Type9两种LSA属于在IPV6情况下的OSPF V3版本使用，会在IPV6部分笔记中涉及；Type10、11属于MPLS-TE使用，会在MPLS中进行讨论。</p>
<h1 id="区域种类"><a href="#区域种类" class="headerlink" title="区域种类"></a><a href="https://www.packetflow.co.uk/ospf-areas-explained/">区域种类</a></h1><blockquote>
<ul>
<li><strong>Backbone area</strong> - The backbone area is the core of the OSPF network. Furthermore, OSPF states that every area must be connected to the backbone area (aka area 0).</li>
<li><strong>Standard areas</strong> - This is an area that is not “stub based”. This includes the backbone area.</li>
<li><strong>Stub area</strong> - With stub areas external routes are not propagated into the stub area by the ABR but replaced with a default route instead. This reduces the OSPF topology along with LSA overhead.</li>
<li><strong>Totally stubby area</strong> - This area is the same as a stub area with the addition that they do not receive type 3 LSA’s. The ABR injects a default route.</li>
<li><strong>Not-so-stubby area</strong> - Also known as NSSA, is an area similar to a stub area but with the addition of an ASBR.</li>
</ul>
</blockquote>
<ul>
<li><p>Backbone Area：翻译成中文是骨干区域，也被称为区域0或区域0.0.0.0，骨干区域组成了OSPF网络的核心，所有其他区域都必须和骨干区域（Area 0）相连接，要么直接连接要么经过其他路由器和骨干区域相连，比如通过虚链路和Area 0相连，这样做是因为OSPF的所有非骨干区域之间不能直接传递LSA，必须将非骨干区域的LSA信息发送给骨干区域，再由骨干区域发送到其他区域，这样做的目的是因为OSPF的各区域间的路由是距离矢量路由（对，你没看错确实是距离矢量，我看到以后也很难以置信，但它就是距离矢量路由），所以很容易出现环路，为了避免环路强制其他区域的区域间路由先发送到Area 0 再发送给其他区域。</p>
</li>
<li><p>Standard areas：翻译成中文是标准区域，也就是除了Stub area以外的其他area，上文的骨干区域（区域0）也属于标准区域，绝大多数的区域都是Standard area。标准区域中可以存在1、2、3、4、5类LSA，也可以存在ASBR路由器。</p>
</li>
<li><p>Stub area：翻译成中文是末节区域，在Stub area中，外部路由不会通过ABR路由器直接传播进Stub area，而是采用<strong>自动下发默认路由</strong>的方式代替，这条默认路由代替了所有外部路由。这样减少了路由器的LSDB的大小从而能够减少内存消耗。Stub area中不允许引入外部路由，就是4、5类LSA。</p>
</li>
<li><p>Totally stubby area：翻译成中文是完全末节区域，这个区域和之前的Stub area的性质一样，不过和Stub area的区别在于也<strong>不能有3类LSA存在</strong>，也不允许引入外部路由，综合起来就是不允许有3、4、5类LSA的存在，同时自动下发一条默认路由（以3类LSA形式，自动下发的3类LSA是允许的）。</p>
</li>
<li><p>Not-so-stubby area：翻译成中文是非完全末节区域，另一种英文叫法是NSSA区域，和之前的Stub area性质一样，不过和Stub area的区别在于域中可以有ASBR路由器，由于ASBR既运行了OSPF协议，也运行了其他路由协议，所以表示非完全末节区域中可以引入外部路由，综上所述，NSSA区域内不允许有4、5类LSA，但外部路由可以用7类LSA的形式在NSSA中泛洪，但由于7类LSA不允许进入包括骨干区域在内的常规区域，所以NSSA的ABR会负责将7类LSA转换成5类LSA，但NSSA区域不会像其他特殊区域一样自动下发默认路由，可以使用default-information-originate命令产生默认路由（7类LSA形式）。</p>
</li>
<li><p>Totally NSSA：翻译成中文是完全非末梢区域，继承了所有NSSA区域特性（不允许4、5类LSA，外部路由用7类LSA在NSSA内泛洪，外部路由进入常规区域需要7转5）的同时，区别在于Totally NSSA区域也会将3类LSA过滤并会自动下发一条默认路由（3类LSA形式）。</p>
</li>
</ul>
<h2 id="常规区域"><a href="#常规区域" class="headerlink" title="常规区域"></a>常规区域</h2><blockquote>
<ul>
<li><strong>Backbone area</strong> - The backbone area is the core of the OSPF network. Furthermore, OSPF states that every area must be connected to the backbone area (aka area 0).</li>
<li><strong>Standard areas</strong> - This is an area that is not “stub based”. This includes the backbone area.</li>
</ul>
</blockquote>
<ul>
<li>Backbone Area：翻译成中文是骨干区域，也被称为区域0或区域0.0.0.0，骨干区域组成了OSPF网络的核心，所有其他区域都必须和骨干区域（Area 0）相连接，要么直接连接要么经过其他路由器和骨干区域相连，比如通过虚链路和Area 0相连，这样做是因为OSPF的所有非骨干区域之间不能直接传递LSA，必须将非骨干区域的LSA信息发送给骨干区域，再由骨干区域发送到其他区域，这样做的目的是因为OSPF的各区域间的路由是距离矢量路由（对，你没看错确实是距离矢量，我看到以后也很难以置信，但它就是距离矢量路由），所以很容易出现环路，为了避免环路强制其他区域的区域间路由先发送到Area 0 再发送给其他区域。</li>
<li>Standard areas：翻译成中文是标准区域，也就是除了Stub area以外的其他area，上文的骨干区域（区域0）也属于标准区域，绝大多数的区域都是Standard area。标准区域中可以存在1、2、3、4、5类LSA，也可以存在ASBR路由器。</li>
</ul>
<h2 id="特殊区域"><a href="#特殊区域" class="headerlink" title="特殊区域"></a>特殊区域</h2><h3 id="为什么需要特殊区域"><a href="#为什么需要特殊区域" class="headerlink" title="为什么需要特殊区域"></a><a href="http://ccietea.com/">为什么需要特殊区域</a></h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_11-07-03.jpg" alt="Snipaste_2020-09-23_11-07-03" style="zoom:67%;">

<p>OSPF网络共有三个区域，骨干区域area 0为银行的一级行及二级行设备运行的区域三级行运行的是OSPF的常规区域，为了保证网络的通畅，我们将网络的各个角落都宣告进了OSPF，感觉上很爽，但其实路由器运行的压力很大，因为随着设备使用年限的增加，设备数量的增多，网络前缀越来越多，路由条目势必逐渐增多，那么路由器的压力也会越来越大，毕竟庞大的路由表、LSA以及SPF算法的运行都在极大的消耗着路由器的资源。</p>
<p>从网络优化的角度来看，我们一直在输途保证网络通畅的情况下减少网络中传递的路由条目以及LSA的数量，路由汇总是一种很好的方法，当然，从OSPF的设计规划角度来看，我们还有特殊区域可供使用，下面来看看OSPF的特殊区域是如何帮助我们减少LSA泛洪的。</p>
<p>我们拿area 1做参考区域，当area1为常规区域时，区域中有多少种LSA在泛洪呢？1类LSA肯定有，由于区域中存在MA网络，所以2类LSA也有。其他区域的前缀被ABR注入了本区域，所以3类LSA也有。此外由于area2中的ASBR引入的外部路由，10.1.1.0/24，所以5类LSA也会被泛洪进area1，由于area1的路由器不知道area2中的ASBR路由器的位置，所以4类LSA也在area1中存在。综上所述，area1中有1-5共计种LSA存在。但仔细一想就会发现，area1作为“叶”区域，没必要知道外部路由的详细情况，我只需要知道有这么一条路让我到达区域外即可，此时就需要特殊区域来解决这个问题，例如特殊区域种的stub area就能满足这种需求。</p>
<p>所以综上所述，特殊区域是为了应对多区域时网络设备性能不够的产物，现在设备的性能已经不能和开发OSPF协议的80年代同日而语，所以特殊区域在现网中已经很难见到了。</p>
<h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_10-38-00.jpg" alt="Snipaste_2020-09-23_10-38-00" style="zoom: 50%;">

<p>OSPF中的特殊区域可以在一个区域中注入默认路由来取代3类或5类LSA，这样做的好处是可以将LSA的泛洪限制在最小的范围内、最小化LSDB、减少SPF算法运算并使路由表变得更小。这些特殊区域一共有四种，分别是：</p>
<ul>
<li>Stub area：Stub Area的ABR上会过滤4、5类LSA，同时用3类LSA的形式向内部传递一条默认路由；配置命令：area x stub；</li>
<li>Totally stub area：ABR上会过滤3、4、5类LSA，同时用3类LSA的形式向内部传递一条默认路由，但不允许引入外部路由；配置命令，ABR：area x stub no-summary；其他路由器：area x stub；</li>
<li>NSSA (not so stubby area)：ABR上会过滤4、5类LSA，默认不会向内部传递默认路由，使用default-information-originate命令产生默认路由（7类LSA的形式），但允许引入外部路由。当NSSA中有两个ABR时需要执行7转5时，只有一个会进行转换，router-id大的转换，所有的stub区域的ABR总是会过滤掉5类LSA；配置命令：area x nssa；</li>
<li>Totally NSSA (totally not so stubby area)：思科私有协议，ABR上会过滤3、4、5类LSA，同时向内部传递一条默认路由（3类LSA），允许引入外部路由。当NSSA中有两个ABR需要执行7转5时，只有一个会转换，也就是router-id大的转换，所有的stub area总是会过滤掉5类LSA；配置命令：ABR：area x nssa no-summary；其他路由器：area x nssa；</li>
</ul>
<h3 id="Stub-area"><a href="#Stub-area" class="headerlink" title="Stub area"></a>Stub area</h3><h4 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_11-46-25.jpg" alt="Snipaste_2020-09-23_11-46-25" style="zoom:67%;">

<p>我们可以通过配置，将一个常规区域设置为stub区域。Stub区域将禁止4、5类LSA进入该区域（也就是不让10.1.1.0/24这条外部路由进入），同时该区域会自动下发一条默认路由（3类LSA）进入该区域，以保证数据去往外部路由的路径没有问题。这可以形象的理解为“外面的世界再怎么精彩，你不用告诉我细节，只需要告诉我怎么出去就行了”。这就是stub area的设计思路，当引入大量外部路由进入OSPF时，适当规划某些区域为stub，可以起到不错的网络优化作用。</p>
<p>有一点值得注意，不能将骨干区域area 0配置为stub区域，同时，让一个区域为stub的话，该区域不允许注入外部路由，也就是不能做重发布。</p>
<h4 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1 </span><br><span class="line">area 1 stub </span><br></pre></td></tr></table></figure>

<p>此命令需配置在stub区域中的所有路由器上，如果某台路由器没有配置该命令，那么它无法和其他stub area 中的路由器建立邻接关系。</p>
<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>Area 1中将不会有4、5类LSA，也就是Area 2重发布进来的关于网段10.1.1.0/24的路由被ABR过滤掉了，同时Area 1中的路由器将获得一条3类LSA的默认路由，该默认路由是由area 1的ABR自动下发。</p>
<h3 id="Totally-Stub-area"><a href="#Totally-Stub-area" class="headerlink" title="Totally Stub area"></a>Totally Stub area</h3><h4 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_15-51-20.jpg" alt="Snipaste_2020-09-23_15-51-20" style="zoom:67%;">

<p>通过将区域规划成Stub area，可以起到一定的网络优化作用，但感觉上还是不够彻底，因为Stub area只是不知道外部路由，但除了外部路由，其他区域的路由（约等于其他区域的LSA）其实我也没必要知道太多细节，用一条默认路由代替去往其他area的路由也没问题，那么这里就可以将area 1设置为完全末梢区域，也就是totally stub area，当一个区域被配置为完全末梢区域时，这个区域将：</p>
<ul>
<li>阻挡3、4、5类LSA进入本区域；</li>
<li>区域的ABR自动下发一条3类LSA的默认路由进入本区域；</li>
</ul>
<p>这么一来，area 1区域内的路由器收到的LSA数量进一步减小，LSDB进一步变小，在存储LSA及运行SPF算法的时候消耗的资源自然也就减少了，另外当区域外拓扑出现变更的时候，对本区域的影响也将变为最小，因为内部没有其他区域的LSA了。</p>
<p>与Stub area区域类似，无法将骨干区域area 0配置成totally stub area，当然如果一个区域被指定为totally stub area，将不能在区域中的路由器上做路由重发布动作。</p>
<h4 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h4><p>ASBR配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1 </span><br><span class="line">area 1 stub no-summary </span><br></pre></td></tr></table></figure>

<p>其他路由器配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub</span><br></pre></td></tr></table></figure>

<h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p>完成上述配置后，area 1内的路由器将只有本区域的路由（ABR除外），同时能获取到ABR下发的3类默认路由，也就是说其他区域的路由以及外部注入的路由都被ABR挡在外面，取而代之的是一条默认路由。</p>
<h3 id="NSSA"><a href="#NSSA" class="headerlink" title="NSSA"></a>NSSA</h3><h4 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_17-14-16.jpg" alt="Snipaste_2020-09-23_17-14-16" style="zoom:67%;">

<p>在前面的知识基础上，我们已经了解到，在保证网络连通性的情况下，减少LSA的泛洪以及精简路由表，我们可以将特定区域配置为末梢区域（Stub area）或完全末梢区域（totally stub area），上面的拓扑中，如果我们将area 2配置为stub area，那么该area一方面会阻挡4、5类LSA的进入，另一方面会同时禁止重发布外部路由看，那么如果此时我们期望这个区域保持“阻挡其他区域过来的4、5类LSA”这个特性，同时允许在本area 内重发布路由，该怎么办呢？</p>
<p>例如，假设area 2原来时作为一个stub area运行的，但突然有一个外部网络，需要接入到我们这个OSPF网络中，并且连在area 2中，这种情况下为了保证路由可达，就必须向area 2中注入外部路由了，但注入路由违反了stub area的规则，stub area禁止4、5类LSA进入，外部路由的LSA为5类，无法注入。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_17-32-23.jpg" alt="Snipaste_2020-09-23_17-32-23" style="zoom:67%;">

<p>如何解决呢？引入NSSA（not-so-stubby-area）的概念，中文翻译就是“非完全末梢区域”，当一个区域配置为NSSA时，这个区域一方面将阻挡其他区域传来的4、5类LSA，同时“允许区域本地注入”外部路由，这些外部路由以一种特殊的LSA类型—7类LSA在NSSA中泛洪，并且7类LSA不允许进入骨干区域或常规区域，NSSA的ABR会负责将7类LSA“转换”成5类LSA，从而在常规区域中进一步泛洪。上面的“允许区域本地注入”的意思是，NSSA这个区域的路由器配置重新发布。</p>
<p>必须注意的是，与Stub area及totally stub area不同的是，如果你将一个区域配置为NSSA，默认情况下，NSSA的ABR不会自动下发默认路由进NSSA，因此在NSSA环境下，需要留意网络连通信问题。</p>
<h4 id="配置命令-2"><a href="#配置命令-2" class="headerlink" title="配置命令"></a>配置命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<p>上述命令需配置在NSSA内的所有路由器上。</p>
<h4 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h4><p>将area 2配置为NSSA区域后，从骨干过来的4、5类LSA将无法进入NSSA，也就是说，如果area 1做了重发布，那么这些重发布的外部路由无法进入NSSA区域（NSSA中不许出现5类LSA），与此同时，area 2允许本地的路由器做重发布动作，重发布进来的路由，以7类LSA在NSSA中泛洪，在路由表中可以看到这些外部路由的标记为“O N”，这些7类LSA在“穿越”NSSA的ABR进入骨干区域之前，由ABR负责将7类LSA“转换”成5类LSA，最终area 0和area 1也能学到这些外部路由，不过它们路由表中呈现的是“O E”标记。</p>
<h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><p><strong>NSSA ABR上的路由汇总动作</strong></p>
<p>NSSA 的ABR会将7类LSA转换为5类LSA，在7转5的过程中可以使用summary-address 通告汇总的5类LSA，注意，这里汇总的是针对NSSA区域外部引入路由的汇总，但如果仍想对area 1 nssa 区域自己内部的路由做汇总，则应使用area  range命令。</p>
<p><strong>NSSA的ABR，在某种程度上可以理解成为常规区域的ASBR，它不会为常规区域生成4类LSA。</strong></p>
<p>NSSA的ABR产生了5类LSA（通过7转5）并通告进骨干区域，因此这台NSSA的ABR对于骨干区域而言就是一台ASBR，由于存在这个7转5的过程，真正的ASBR（NSSA区域中执行重发布的那台路由器）信息就不需要被骨干区域路由器知道，因此NSSA区域的ABR也不会为这个区域里的ASBR产生4类LSA并通告进骨干区域。</p>
<p><strong>NSSA的双ABR问题</strong></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-44-34.jpg" alt="Snipaste_2020-09-30_16-44-34" style="zoom:67%;">

<p>上图中，两个ABR都会收到7类LSA，但只有Router ID大的ABR才会执行7转5动作，两台ABR都会在NSSA区域泛洪1类LSA，并从中了解到对方的存在。</p>
<p><strong>N/P位</strong></p>
<p>N/P位为1bit，在HELLO和LSA中都携带option字段，N/P位在两者中分别有不同的意义。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-51-32.jpg" alt="Snipaste_2020-09-30_16-51-32" style="zoom:67%;">

<ul>
<li>在Hello报文中：N bit标识该路由器位NSSA区域路由器，当N  bit被置1时，E  bit就必须被清零。</li>
<li>在LSA报文中：P bit 仅在7类LSA中出现，置1时标识NSSA区域的ABR能够将这条7类LSA转成5类LSA，而P位置0时不能进行7到5的LSA转换。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-53-50.jpg" alt="Snipaste_2020-09-30_16-53-50" style="zoom:67%;">

<ul>
<li>P bit 为0时，ABR将不能将该7类LSA转换成5类LSA，只有NSSA区域的ABR重发布路由时，通告的7类LSA中的P bit才为0。NSSA区域在ABR重发布时，将7类LSA的P bit 置0，通知其他NSSA区域的ABR不要对该LSA进行7转5，因为骨干区域内的其他路由器已经从骨干区域内收到该路由的5类LSA，因此NSSA区域其他ABR执行7转5是没意义的。</li>
</ul>
<p><strong>P bit为0，ABR将不能将该7类LSA转换成5类LSA：</strong></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_17-14-12.jpg" alt="Snipaste_2020-09-30_17-14-12" style="zoom: 67%;">

<p>NSSA区域的ABR在重发布时，将7类LSA的P位置0，用来通知NSSA区域内的其他ABR不要对该LSA进行7转5，因为骨干区域内的其他路由器已经从骨干区域内收到该路由器的5类LSA，因此NSSA区域内其他ABR执行7转5是没有意义的。</p>
<h3 id="Totally-NSSA"><a href="#Totally-NSSA" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h3><h4 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_10-28-51.jpg" alt="Snipaste_2020-09-26_10-28-51" style="zoom:67%;">

<p>Totally NSSA，翻译成中文是一个非常尴尬的名字，完全非末梢区域，Totally NSSA是在NSSA区域的基础上，进一步阻挡NSSA区域外的其他区域过来的3类LSA，同时ABR自动下发一条3类LSA的默认路由进入NSSA区域。</p>
<h4 id="配置命令-3"><a href="#配置命令-3" class="headerlink" title="配置命令"></a>配置命令</h4><p>ABR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa no-summary</span><br></pre></td></tr></table></figure>

<p>其他路由器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<h4 id="实现效果-3"><a href="#实现效果-3" class="headerlink" title="实现效果"></a>实现效果</h4><p>Area 2之外的其他OSPF area 过来的3、4、5类LSA，都会被ABR阻挡在NSSA区域外，同时ABR会自动下发默认路由进NSSA，这条自动下发的默认路由是3类LSA。另外，NSSA区域内的路由器做重发布动作，由于NSSA区域不让传播外部路由的4、5类LSA，所以区域内的其他路由器会学习到7类的外部LSA，这些外部LSA会被ABR转换成5类LSA并注入骨干区域。</p>
<h3 id="区域LSA总结"><a href="#区域LSA总结" class="headerlink" title="区域LSA总结"></a>区域LSA总结</h3><p><img src="/2020/06/18/13-ospf/655555.png" alt="655555"></p>
<ul>
<li>骨干区域：1、2、3、4、5；</li>
<li>标准区域：1、2、3、4、5；</li>
<li>Stub区域：1、2、3以及3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）；</li>
<li>完全Stub区域（totally stub area）：1、2、3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）；</li>
<li>NSSA：1、2、3、7；</li>
<li>Totally NSSA：1、2、7、3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）。</li>
</ul>
<h3 id="特殊区域实验"><a href="#特殊区域实验" class="headerlink" title="特殊区域实验"></a>特殊区域实验</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_11-27-38.jpg" alt="Snipaste_2020-09-26_11-27-38" style="zoom:67%;">

<h4 id="无特殊区域"><a href="#无特殊区域" class="headerlink" title="无特殊区域"></a>无特殊区域</h4><h5 id="基础配置及结果："><a href="#基础配置及结果：" class="headerlink" title="基础配置及结果："></a>基础配置及结果：</h5><p>CO1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> !</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-00-19.jpg" alt="Snipaste_2020-09-26_12-00-19" style="zoom:67%;">

<p>CO2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.26.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.26.2 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-01-25.jpg" alt="Snipaste_2020-09-26_12-01-25" style="zoom:67%;">

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.35.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 192.168.13.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.35.3 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-02-27.jpg" alt="Snipaste_2020-09-26_12-02-27" style="zoom:67%;">

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 192.168.35.4 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-03-05.jpg" alt="Snipaste_2020-09-26_12-03-05" style="zoom:67%;">

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 192.168.35.5 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-03-39.jpg" alt="Snipaste_2020-09-26_12-03-39" style="zoom:67%;">

<p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.26.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.67.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.68.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 6.6.6.6</span><br><span class="line"> network 192.168.26.6 0.0.0.0 area 0</span><br><span class="line"> network 192.168.67.6 0.0.0.0 area 2</span><br><span class="line"> network 192.168.68.6 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-04-17.jpg" alt="Snipaste_2020-09-26_12-04-17" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-04-43.jpg" alt="Snipaste_2020-09-26_12-04-43" style="zoom:67%;">

<p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback1                       #loopback1 接口用作引入外部路由</span><br><span class="line"> ip address 10.1.1.7 255.255.255.0</span><br><span class="line"> ip ospf network point-to-point           #网络类型配置成P2P使该路由为24/</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.67.7 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> redistribute connected subnets</span><br><span class="line"> network 192.168.67.7 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-05-29.jpg" alt="Snipaste_2020-09-26_12-05-29" style="zoom:67%;">

<p>R8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.68.8 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 8.8.8.8</span><br><span class="line"> network 192.168.68.8 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-06-04.jpg" alt="Snipaste_2020-09-26_12-06-04" style="zoom:67%;">



<p>此时Area1中有哪几类LSA呢？之前分析过1-5类LSA都有，实际情况是不是这样呢？</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_11-58-21.jpg" alt="Snipaste_2020-09-26_11-58-21" style="zoom: 67%;">

<p>从输出结果可知，确实有5种LSA，但对于一个“叶”area来说，知道这么多种LSA，其实意义不大，这时我们引入Stub area，看结果如何。</p>
<h4 id="Stub-area-1"><a href="#Stub-area-1" class="headerlink" title="Stub area"></a>Stub area</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-11-14.jpg" alt="Snipaste_2020-09-26_12-11-14" style="zoom:50%;">

<p>此时我们将Area 1配置成Stub area，理论上应该由身为ABR的R3下发一条3类LSA的默认路由，然后Area 1阻止4、5类LSA进入，现在来看是不是这样。</p>
<h5 id="变更的配置"><a href="#变更的配置" class="headerlink" title="变更的配置"></a>变更的配置</h5><p>在R3、R4和R5下加入配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB"><a href="#LSDB及RIB" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-17-46.jpg" alt="Snipaste_2020-09-26_12-17-46" style="zoom:67%;">

<p>从上面的输出结果中可以看到LSDB相比配置之前进行了一定程度的精剪，R4和R5中原本存在的4、5类LSA已经被ABR阻隔了，由身为ABR的R3下发了一条默认路由，这条默认路由是以3类LSA的形式自动下发的，因为并没有进行任何关于默认路由的配置：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-21-02.jpg" alt="Snipaste_2020-09-26_12-21-02" style="zoom: 80%;">

<h4 id="Totally-Stub-area-1"><a href="#Totally-Stub-area-1" class="headerlink" title="Totally Stub area"></a>Totally Stub area</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-47-18.jpg" alt="Snipaste_2020-09-26_12-47-18" style="zoom:50%;">

<p>现在将Area 1配置成Totally Stub area，理论上应阻止3、4、5类LSA进入Area 1并下发3类LSA构成的默认路由。</p>
<h5 id="变更配置"><a href="#变更配置" class="headerlink" title="变更配置"></a>变更配置</h5><p>R3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub no-summary</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-1"><a href="#LSDB及RIB-1" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-03-47.jpg" alt="Snipaste_2020-09-26_13-03-47" style="zoom:80%;">

<p>从上面的输出可以看出，LSDB比之前有了大幅精剪，除了由ABR，R3<strong>自动下发</strong>的一条3类LSA的默认路由以外，其他3、4、5类LSA都被阻隔在了外面，所以路由表中自然没有了其他区域的网络号，这些均由一条默认路由代替。</p>
<h4 id="NSSA-1"><a href="#NSSA-1" class="headerlink" title="NSSA"></a>NSSA</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-19-54.jpg" alt="Snipaste_2020-09-26_13-19-54" style="zoom:50%;">

<h5 id="变更的配置-1"><a href="#变更的配置-1" class="headerlink" title="变更的配置"></a>变更的配置</h5><p>R6、R7、R8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-2"><a href="#LSDB及RIB-2" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-23-42.jpg" alt="Snipaste_2020-09-26_13-23-42" style="zoom:80%;">

<p>从上面的输出可以看出，外部路由10.1.1.0/24由7类LSA引入NSSA区域的，而不是本来的4、5类LSA，因为NSSA阻止了4、5类LSA的传播。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-36-45.jpg" alt="Snipaste_2020-09-26_13-36-45" style="zoom:67%;">

<p>由于7类LSA不允许传入常规区域，所以由作为ABR的R6进行了转换，由7类LSA转换成5类LSA，然后传入骨干区域Area 0。</p>
<p>必须注意的是，默认情况下NSSA的ABR是<strong>不会</strong>自动下发默认路由到NSSA区域的，需要进行如下配置才能下发默认路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> Area 2 nssa default-information-originate</span><br></pre></td></tr></table></figure>

<p>具体见：</p>
<blockquote>
<p>This configuration generates a type 7 default route. You can configure this command on any NSSA ASBR or NSSA ABR with these rules:</p>
<ul>
<li>NSSA ASBR can generate a default only when it has a default route in its routing table.</li>
<li>The default route must be known through non-OSPF protocol</li>
<li>NSSA ABR can generate a default route with or without a default route in its own routing table.</li>
</ul>
<p>This command is used in order to generate an NSSA default route:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> Area 1 nssa default-information-originate</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="Totally-NSSA-1"><a href="#Totally-NSSA-1" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-46-56.jpg" alt="Snipaste_2020-09-26_13-46-56" style="zoom:50%;">

<h5 id="变更的命令"><a href="#变更的命令" class="headerlink" title="变更的命令"></a>变更的命令</h5><p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa no-summary</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-3"><a href="#LSDB及RIB-3" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-49-22.jpg" alt="Snipaste_2020-09-26_13-49-22" style="zoom:67%;">

<p>Area 2之外的其他area的3、4、5类LSA都会被阻挡在NSSA之外，同时ABR，R6会自动下发默认路由进NSSA，默认路由以3类LSA的形式下发。LSDB相比NSSA有了进一步的缩小。NSSA引入的外部7类LSA会被ABR转换成5类LSA注入骨干区域：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-52-21.jpg" alt="Snipaste_2020-09-26_13-52-21" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_16-21-06.jpg" alt="Snipaste_2020-09-26_16-21-06" style="zoom:67%;">

<p>从R6的LSDB中可以看到，在R6上执行了7转5的步骤，在抓包中，标识可以进行7转5操作的是P位：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_14-25-50.jpg" alt="Snipaste_2020-10-11_14-25-50"></p>
<h1 id="邻居建立"><a href="#邻居建立" class="headerlink" title="邻居建立"></a>邻居建立</h1><h2 id="邻居状态机"><a href="#邻居状态机" class="headerlink" title="邻居状态机"></a>邻居状态机</h2><h3 id="Down"><a href="#Down" class="headerlink" title="Down"></a>Down</h3><p>初始化状态，这是OSPF邻居状态机的第一个状态，在Down状态下，意味着没从其他路由器收到OSPF的Hello包，运行OSPF协议的接口仍然有尝试发现邻居的意愿，因此会不断的发送组播Hello包。</p>
<h3 id="Attempt"><a href="#Attempt" class="headerlink" title="Attempt"></a>Attempt</h3><p>仅在NBMA网络类型上存在，如果一个路由器，它邻居处于Attempt状态，表示它从邻居没有收到任何信息，但做了努力来与邻居联系。在NBMA网络上具有DR选取资格的路由器与其邻居路由器相连的接口开始变为有效（Active）时，或当这台路由器成为DR或BDR时，这台具有DR选举资格的路由器会把邻居路由器的状态转换到Attempt状态，在Attempt状态下，路由器将在指定的hello间隔时间内向该邻居发送单播hello包。</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>当OSPF接口收到链路上某个邻居发来的第一个Hello包时，它会在接口上将该邻居状态设置为init，注意这个Hello包种可能并未包含任何的邻居信息，也就是hello包中没有active neighbor这个字段，但这个Hello包至少证明，在运行了OSPF协议的这个接口的链路上，至少有个活着的邻居。当路由器收到邻居发来的Hello包以后，它应该将邻居Hello包中的Router-ID放入它自己的Hello包中的Active Neighbor字段，用来确认它收到了一个有效的Hello数据包。</p>
<p>没有active neighbor的hello包：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-30_17-33-46.jpg" alt="Snipaste_2020-06-30_17-33-46"></p>
<p>有active neighbor的hello包：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-06-30_17-34-52.jpg" alt="Snipaste_2020-06-30_17-34-52" style="zoom:67%;">

<h3 id="2-—-Way"><a href="#2-—-Way" class="headerlink" title="2 — Way"></a>2 — Way</h3><p>当两个路由器之间建立起了双向通信时，进入2-Way状态，双向通信意味着两个路由器都收到了对方的Hello包，而Hello包中的Active Neighbor字段中是对方的Router-ID。当OSPF路由器在某个链路上发现了邻居后，它自己发送的Hello包里就会增加一个叫“Active Neighbor”的字段，用于存储在该链路上发现的OSPF邻居。当一台OSPF Router看到自己的Router ID出现在邻居发过来的Hello包中，它就会将该邻居置为Two-Way，该状态是OSPF邻居之间可以具有的最基本的关系，也是第一个稳定状态，但此时两者还不能共享路由信息。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-03_17-29-25.jpg" alt="Snipaste_2020-07-03_17-29-25"></p>
<p>在2-way状态下，路由器决定是否和邻居形成邻接状态。在类型为广播（MA）或非广播多路访问的情况下，路由器只和DR以及BDR形成FULL的关系，和其他的DR Other形成2-way的关系；在点对点和点对多点的网络中，路由器和所有其他链接的路由器形成FULL关系。在2-way的时候还要选举BDR和DR，<strong>注意是先选举BDR然后再选举DR，DR/BDR具体选举步骤上文写过，这里再简单写一下重点：</strong></p>
<p>当一台OSPF路由器有效（Active）并去发现它的邻居路由器时，它将去检查有效的DR和BDR路由器（如果路由器的Priority为0那么就意味着它是无效的，不能参与选举DR和BDR），如果DR和BDR路由器存在的话，这台路由器将接受已经存在的DR和BDR（为什么要接受已经存在的DR和BDR呢，是因为DR具有非抢占性的，也就是说已经有了DR了，新加入的路由器接口的Priority再低也不会重新选举DR了，如果没有非抢占性，新加入一个Priority 更大的就被选举成新的DR，所有DR Other都和这个新DR再建立邻接关系达到Full状态，太消耗系统资源，所以当一台路由器发现已经存在DR和BDR时就会接受已经存在的DR和BDR），如果BDR和DR路由器都不存在（也就是Hello包种的DR以及BDR字段都为0.0.0.0），将执行一个选举<strong>BDR</strong>的过程，选举出具有最高优先级的路由器作为BDR路由器，选举中如果存在多台路由器具有相同的优先级（Priority），那么在数值上具有最高路由器ID的路由器将被选举成<strong>BDR</strong>（如果两台运行OSPF路由器路由器的接口的Priority都是1，那么此时一台路由器的Router-ID为1.1.1.1，另一台的Router-ID为2.2.2.2，Router-ID为2.2.2.2的显然比1.1.1.1更大，这台Router-ID为2.2.2.2的路由器的接口将被选举成BDR）。<strong>如果没有有效的DR路由器存在，那么之前选举出的BDR路由器将被选举成（或者说成提升）DR路由器，然后再选举出来BDR路由器。</strong>至此BDR和DR选举完毕。</p>
<h3 id="ExStart-amp-Exchange"><a href="#ExStart-amp-Exchange" class="headerlink" title="ExStart &amp; Exchange"></a>ExStart &amp; Exchange</h3><h4 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-06_16-49-52.jpg" alt="Snipaste_2020-07-06_16-49-52"></p>
<p>在<strong>ExStart</strong>状态下，双方开始交互DBD选举Master，<strong>Router ID大的一方在选举以后会成为Master</strong>。在DBD包中有3个标记为用来管理邻居关系的建立过程：</p>
<ul>
<li>I 位，Initial bit，中文翻译成初始位，当该位置位为1时，表示这是第一个用于ExStart协商主从关系的初始化协商的DBD包。当两个路由已经选举完Master、Slave时，I位置0。</li>
<li>M位，More bit，中文翻译为后继位，当该位置位为1时，表示后续还有其他DBD报文需要交互，当该位置0时表示没有其他DBD报文需要交互，表示从ExStart到<strong>Exchange</strong>的整个LSDB目录交换过程结束。</li>
<li>MS位，Master/Slave bit，中文翻译为主/从位，当该位置位为1时，表示自己时Master，Router ID大的一方为Master，大多数情况下DR会成为Master。当两个路由器给对方发送第一个DBD报文时，双方都会将自己的MS位置位为1，然后相互比较Router ID决定主从关系。当决出主从关系时，Master的MS位不变依旧为1而Slave的MS位会置0表示自己为Slave。</li>
</ul>
<p>双方的第一、第二个DBD的I、M、MS位均置1，用来比较出谁是Master/Slave（注意不是BDR\DR），第三个包由Slave发给Master，Slave采用了Master的序列号，I位置0因为已经不是第一个初始化的DBD了，M位置1因为之后还有DBD要交互，MS位置0因为我不是Master而对方是Master。三个数据交互完确定了Master/Slave，从此只有Master可以设置并且增加序列号，而Slave不行。确定了Master/Slave关系后进入Exchange阶段，进入Exchange阶段后，Exchange以后Master发送一个DBD，Slave必须回一个DBD（主从关系确定后，Slave不能主动发送DBD只能被动回应Master的DBD），两者用这种方式交换DBD信息。如果Slave已经没有更多DBD需要交换（也就是M位置0）而Master依旧还在发送DBD，则Slave必须用DBD响应并用Master的序列号隐式确认，但由于Slave端已经发送了所有LSA目录，此时Slave的DBD包中没有LSA的相关信息包含在内了。<strong>Master/Slave关系只在DBD中存在，DBD数据包只在ExStart/Exchange过程中存在。</strong>下面看看抓包的对比，首先是Master发送的包含有LSA目录的DBD：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-13_16-44-11.jpg" alt="Snipaste_2020-07-13_16-44-11" style="zoom:67%;">

<p>接下来是Slave回应上面Master发送的DBD的消息，这个DBD用的序列号是2990，和上面Master发送的序列号相同，属于隐式确认，可以看到由于Slave的I、M、MS位都为0，说明此时它已经发送完了所有的LSA的目录，没有其他可发送了，所以抓包中并没有关于LSA的部分：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-13_16-44-35.jpg" alt="Snipaste_2020-07-13_16-44-35" style="zoom:67%;">

<p><strong>选举完Master/Slave</strong>以后，路由器会进入<strong>Exchange</strong>阶段，在该阶段中执行DBD的交换过程，并且通过交换DBD明白下一步要从邻居路由器下载哪些LSA。为什么要交换DBD呢？因为OSPF是链路状态路由协议，本Area内路由器里的LSDB要相同，这就需要邻居之间相互交换彼此没有的LSA，如何知道哪些LSA需要交换呢？先比较LSDB的目录，也就是比较DBD，DBD是链路状态数据摘要，也就是LSDB的摘要，用于描述链路状态数据库（LSDB）的内容。</p>
<p>在Exchange阶段，双方使用包含自己LSA头部的DBD报文进行交互，并且将对方发过来的LSA头部、自己感兴趣的LSA或自己没有的LSA存储在一个本地的OSPF接口的队列里，以便在下一个阶段进行LSA详细请求。当某个接口收到邻居发来的DBD中的M位置0，说明对方已经发完DBD了，与此同时，如果该路由器的这个OSPF接口上存在待请求的LSA，那么它会将这个邻居置为loading状态。在Exchange状态也有可能发送LSR去请求对方发送LSU。</p>
<h4 id="抓包说明"><a href="#抓包说明" class="headerlink" title="抓包说明"></a>抓包说明</h4><h5 id="空DBD包"><a href="#空DBD包" class="headerlink" title="空DBD包"></a>空DBD包</h5><p>空DBD包中只有LSA头部的信息，并没有整个LSA的信息：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_17-29-34.jpg" alt="Snipaste_2020-07-04_17-29-34" style="zoom:67%;">

<p>而完整的LSA中包含的信息要多得多：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-06_16-42-23.jpg" alt="Snipaste_2020-07-06_16-42-23" style="zoom:67%;">

<h5 id="初始化协商的DBD消息"><a href="#初始化协商的DBD消息" class="headerlink" title="初始化协商的DBD消息"></a>初始化协商的DBD消息</h5><p>初始化协商的DBD消息中的I、M以及MS位均为1。I位置1，因为这是第一个用于ExStart协商主从关系的初始化协商的DBD包；M位为1，因为这不是Router发送的最后一个DBD包，因为还没开始交换DBD，所以这位肯定为1；MS也为1，因为这时Master/Slave选举还没得出结论，得出结论前两个协商的路由器都会认为自己是Master，所以都会把MS位置位为1。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-09-31.jpg" alt="Snipaste_2020-07-04_19-09-31" style="zoom:67%;">

<p>我是10.0.0.1，Router ID为1.1.1.1，这是我协商主从关系的第一个DBD包（I位为1），我还有更多的DBD包要发送（M位为1），我是Master（MS位为1），我的DBD的序列号是3138。该DBD包中不包含LSA的信息。接下来我们看对方（10.0.0.3）发送的DBD初始消息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-10-48.jpg" alt="Snipaste_2020-07-04_19-10-48" style="zoom:67%;">

<p>我是10.0.0.3，Router ID为3.3.3.3，这是我协商主从关系的第一个DBD包（I位为1），我还有更多的DBD包要发送（M位为1），我是Master（MS位为1），我的DBD的序列号是2989。该DBD包中不包含LSA的信息。</p>
<p>交互完DBD包以后，Router ID大的一方也就是ID为3.3.3.3的10.0.0.3成为Master，Router ID小的10.0.0.1成为Slave。</p>
<h5 id="交互LSDB目录的过程"><a href="#交互LSDB目录的过程" class="headerlink" title="交互LSDB目录的过程"></a>交互LSDB目录的过程</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-25-33-1593861960005.jpg" alt="Snipaste_2020-07-04_19-25-33" style="zoom:67%;">

<p>第三个DBD由Slave（10.0.0.1）发给Master（10.0.0.3），序列号采用Master发送初始DBD中的序列号，I位置0因为已经不是初始化的DBD包了，也意味着此时<strong>进入了Exchange状态</strong>；M位置1表示还有后续的DBD包，不过一般实验中LSU较少所以这位为0也是正常的，因为一个DBD就交互完事儿了；MS位为0表示我是Slave。同时DBD包中也有LSA的摘要信息，但并没有LSA的具体信息，主要是交换了LSA的Router ID，表明自己有哪些路由器的信息。Master（10.0.0.3）收到这个DBD包以后，发现I位为0，于是将对方的状态改为Exchange，再查看Sequence号发现这个序号是自己这个Master产生的，于是在这个序列号的基础上+1生成新的序列号，这么做是隐式确认告诉对方之前你发的这个DBD我收到了，然后带上了自己的LSA摘要信息，发送给对方开始交互LSDB的摘要目录。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-28-29.jpg" alt="Snipaste_2020-07-04_19-28-29" style="zoom:67%;">

<p>第四个DBD由Master发给Slave，序列号在之前的基础上+1，也就是2990，用以隐式确认之前收到的序列号为2899的DBD。I位为0，因为已经不是初始化的DBD包了；M位为1，表示还有后续的DBD包；MS位为1，因为自身是Master。后面带上了自己的LSA摘要信息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_20-59-33.jpg" alt="Snipaste_2020-07-04_20-59-33" style="zoom:67%;">

<p>第五个DBD由Slave（10.0.01）发送给Master（10.0.0.3），序列号和之前Master发给它的序列号相同，且M位置0，说明Slave没有需要发送给Master的其他LSDB目录了，这个DBD完全是用来确认之前Master的那个序列号为2990的DBD。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_21-03-53.jpg" alt="Snipaste_2020-07-04_21-03-53" style="zoom:67%;">

<p>第六个DBD由Master（10.0.0.3）发送给Slave（10.0.0.1），序列号为之前Slave确认DBD的序列号+1，也就是2991，这时M位置0，说明Master（MS位置1）没有更多的DBD要发送了。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_21-05-19.jpg" alt="Snipaste_2020-07-04_21-05-19" style="zoom:67%;">

<p>最后一个DBD由Slave（10.0.0.1）发送给Master（10.0.0.3），序列号和刚才Master发送的序列号一致，也是个用来确认的DBD。至此两方都没有DBD信息要交换了，Exchange阶段结束。</p>
<h4 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h4><h5 id="为什么用空DBD包？"><a href="#为什么用空DBD包？" class="headerlink" title="为什么用空DBD包？"></a>为什么用空DBD包？</h5><p>当两个路由器决定建立完全邻接关系时（Full adjacent），二者必须同步彼此的LSDB（Link State DataBase，链路状态信息数据库），因为OSPF是一个链路状态路由协议，每台设备都要知道网络的整体信息（在OSPF中就是了解全网的LSA）所以邻居的LSDB自己也必须掌握，掌握清楚全网的信息以后，再根据自己掌握的信息计算出路由。为了优化LSDB数据库同步过程，两台路由器会先比较它们LSDB的条目列表，这样就不用交换整个LSDB数据库了，再根据LSDB条目列表比较的情况决定去交互哪些LSA，发送空DBD包就是LSDB的条目列表，空DBD是并不包含LSA头部的DBD包，既能达到比较两台设备LSDB的目的，又减小网络及系统的开销，就好像两个商店之间互相比较存货的差异，这时只要比较两个商店的存货目录清单而不用把所有货物搬出来彼此比较一样。</p>
<h5 id="如何确定对方收到DBD？"><a href="#如何确定对方收到DBD？" class="headerlink" title="如何确定对方收到DBD？"></a>如何确定对方收到DBD？</h5><p>由于链路状态路由协议要获知全网的网络信息，所以必须知道和邻居之间LSDB中的LSA差别在哪，这时候需要交换空DBD以交换彼此掌握的LSA目录，但由于OSPF协议中并没给DBD包设计专门的DBD确认（必须注意，LSAck是用来确认LSU的而不是确认DBD的），这时如何确定对方收到了DBD包呢？<strong>用DBD包中的序列号做隐式确认。</strong>当Master发送M位置1\0、MS位置1的DBD并且Sequence为X的DBD时（表示我是Master，我还有后或者没有续的DBD需要发送），Slave会发送一个<strong>序列号同为X</strong>、M位置1\0，MS位置0的DBD<strong>隐式确认</strong>之前Master发送的DBD（表示我是Slave，我有或没有后续的DBD发送，我的序列号是X）。</p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>DBD交换完成后，进入Loading状态，在Exchange状态时已经对链路状态数据库和收到的DBD的LSA头部进行了比较，已经知道要向邻居请求哪些自身没有的LSA了，于是在Loading阶段向邻居发送LSR用来请求这些没有的LSA；邻居收到LSR后，回应LSU（LSU中包含着LSA）；收到邻居发来的LSU，存储这些LSA到自己的链路状态数据库，并发送LSAck确认。也就是一个LSR — LSU — LSAck的数据包交互过程，当需要交互的LSU全部发送完毕后，Loading状态结束进入Full状态。在发送LSU时，路由器中也维护着一个LSU的重传列表以便确定所有发送的LSU都能被正确接收到，如果没收到某个LSU的LSAck的话会重传该LSU，例如下图：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_18-19-36.jpg" alt="Snipaste_2020-07-14_18-19-36" style="zoom:67%;">

<ol>
<li>R2需要向R1请求A2和B2两条LSA的LSU，R1要向R2请求B1这一条LSA的LSU。</li>
<li>R1向R2发送了A2和B2这两个LSU，R2发送了A2的LSAck，表示已经收到了A2的LSU</li>
<li>当R1的LSA计时器过期（5秒）后仍然没收到关于B2的LSAck，R1明白该LSU对方并未受到于是重新发送了B2的LSU给R2。</li>
<li>R2收到B2的LSU后发送了关于B2的LSAck表示该LSU已收到。</li>
<li>R2发送B1的LSU给R1。</li>
<li>R1发送B1的LSAck表示该LSU已收到。</li>
</ol>
<h3 id="Full"><a href="#Full" class="headerlink" title="Full"></a>Full</h3><p>LSU全部交互完毕后，两台路由器拥有的LSDB，并保持在该状态。为了保持邻接状态，路由器之间会交互Hello包，确保对方的状态，如果在Deaf interval计时器到期前都未收到对方的Hello包，则邻接状态终结。一旦发现和其他路由器邻接状态终结，路由器将会泛洪该变化置域内其他路由器。</p>
<h2 id="邻居无法建立常见原因"><a href="#邻居无法建立常见原因" class="headerlink" title="邻居无法建立常见原因"></a>邻居无法建立常见原因</h2><ol>
<li>Hello间隔和Dead间隔不同。默认情况下，Dead间隔是Hello间隔的4倍，可以在接口下通过“ip ospf hello-interval”和“ip ospf dead-interval”命令来调整。</li>
<li>区域号不一致（Area号不同）。</li>
<li>特殊区域（Stub区域和Nssa区域等）区域类型不匹配。</li>
<li>认证类型或密码不一致。</li>
<li>路由器ID相同。</li>
<li>Hello包被ACL给Deny掉。</li>
<li>链路上的MTU不匹配。</li>
<li>接口下的OSPF网络类型不匹配。</li>
</ol>
<h1 id="OSPF路由汇总"><a href="#OSPF路由汇总" class="headerlink" title="OSPF路由汇总"></a><a href="http://blog.sina.com.cn/s/blog_5ec353710102vtfy.html">OSPF路由汇总</a></h1><h1 id="虚链路"><a href="#虚链路" class="headerlink" title="虚链路"></a>虚链路</h1><h2 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-17-35.jpg" alt="Snipaste_2020-10-11_16-17-35"></p>
<p>OSPF规定每个区域都必须与区域0相连，当出现了以上情况，可以在区域1中建立一条虚链路（Virtual-link）来过度，配置命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">area X（过渡区域的ID） virtual-link A.B.C.D（虚链路对端router 的Router ID）</span><br><span class="line">举例：area 1 virtual-link 3.3.3.3    </span><br><span class="line">#过渡区域为区域1，虚链路对端Router的Router ID为3.3.3.3</span><br></pre></td></tr></table></figure>

<p>查看虚链路命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip ospf virtual-links</span><br></pre></td></tr></table></figure>

<p>虚链路用来连接不连续的区域，只是一种临时或割接的手段，不建议用在常规网络的实施中。本质上虚链路是一条属于区域0的线路，所以如果在Area 0上开启了验证那么Virtual-link也要做验证，如果Area 0不做验证，只虚链路上自己做认证，那验证的范围就在虚链路上。虚链路用Hello包建立，以单播形式，虚链路一旦建立起邻居则Hello包不再发送，凡是通过虚链路学到的LSA都会标注DNA表示永远不会老化。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-17-35.jpg" alt="Snipaste_2020-10-11_16-17-35"></p>
<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> area 2 virtual-link 3.3.3.3</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 1</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> area 2 virtual-link 2.2.2.2</span><br><span class="line"> network 192.168.23.3 0.0.0.0 area 2</span><br><span class="line"> network 192.168.34.3 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R2上的部分LSDB：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-34-57.jpg" alt="Snipaste_2020-10-11_16-34-57"></p>
<p>R2上的邻居表：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-37-22.jpg" alt="Snipaste_2020-10-11_16-37-22"></p>
<h1 id="OSPF选路"><a href="#OSPF选路" class="headerlink" title="OSPF选路"></a>OSPF选路</h1><ol>
<li>直连路由：本路由器发起的LSA 1、2；</li>
<li>区域内路由：O；LSA 1、2；</li>
<li>区域间路由：O IA；LSA 3；</li>
<li>1类外部路由：O E1；LSA 5类型1；</li>
<li>2类外部路由：O E2；LSA 5类型2；</li>
<li>1类NSSA路由：O N1；LSA7类型1；</li>
<li>2类NSSA路由：O N2；LSA 7类型2。</li>
</ol>
<p>简单版总结就是：<strong>O&gt;&gt; O IA &gt;&gt; E1 &gt;&gt; N1 &gt;&gt;E2 &gt;&gt; N2</strong>，但实际中不同厂家的优先选择方式不同，以各厂家的文档为准。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://community.cisco.com/t5/routing/ospf-bdr-and-dr-other-relations/td-p/3758851">OSPF BDR and DR-OTHER relations</a></p>
<p><a href="https://community.cisco.com/t5/routing/why-bdr-is-elected-first/td-p/3207520">Why BDR is elected first?</a></p>
<p><a href="https://community.cisco.com/t5/switching/master-and-slave-concept/m-p/2411039#M285022">Master and Slave concept</a></p>
<p><a href="https://community.cisco.com/t5/switching/ospf-lsa-flooding/td-p/1964852">OSPF LSA Flooding</a></p>
<p><a href="https://community.cisco.com/t5/switching/when-was-dbd-database-descriptor-packets-sent/td-p/2080784">When was DBD(database descriptor) packets sent ?</a></p>
<p><a href="https://forum.huawei.com/enterprise/zh/thread-275125.html">OSPF协议介绍及配置 （上）</a></p>
<p><a href="https://www.computernetworkingnotes.com/ccna-study-guide/ospf-neighbor-states-explained-with-example.html">OSPF Neighbor States Explained with Example</a></p>
<p><a href="https://sites.google.com/site/amitsciscozone/home/important-tips/ospf/ospf-packet-types">OSPF Packet Types</a></p>
<p><a href="http://www.firewall.cx/networking-topics/routing/ospf-routing-protocol/1147-ospf-lsu-lsa-packet-structure-lsa-types-overview.html">ANALYSIS OF OSPF LINK STATE UPDATE (LSU) - LINK STATE ADVERTISEMENT (LSA) PACKET STRUCTURE. COMMON LSA TYPES</a></p>
<p><a href="https://community.cisco.com/t5/routing/ospf-implicit-ack-vs-explicit-ack/td-p/2353763">OSPF - Implicit ACK vs. Explicit ACK</a></p>
<p><a href="https://networklessons.com/ospf/ospf-lsas-and-lsdb-flooding-tutorial">OSPF LSAs and LSDB flooding Tutorial</a></p>
<p><a href="http://www.firewall.cx/networking-topics/routing/ospf-routing-protocol/1178-ospf-lsa-types-explained.html">OSPF LSA TYPES - PURPOSE AND FUNCTION OF EVERY OSPF LSA</a></p>
<p><a href="https://www.networkfuntimes.com/ospf-what-is-a-stub-network/">OSPF: WHAT IS A STUB NETWORK?</a></p>
<p><a href="http://ccietea.com/">红茶三杯OSPF笔记</a></p>
<p><a href="https://community.cisco.com/t5/other-network-architecture/why-ospf-lsa-type-2-s/td-p/288472">Why OSPF LSA Type 2’s</a></p>
<p><a href="https://community.cisco.com/t5/other-network-architecture/differences-between-n1-n2-e1-e2-in-ospf/td-p/398381">differences between n1 n2 e1 e2 in ospf?</a></p>
<p><a href="https://ipwithease.com/ospf-external-e1-and-e2-routes/">OSPF EXTERNAL E1 vs E2 ROUTES</a></p>
<p><a href="https://ipwithease.com/ospf-n1-and-n2-routes/">OSPF N1 Route and N2 Route</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>15-VPN</title>
    <url>/2022/01/20/15-VPN/</url>
    <content><![CDATA[<h1 id="VPN简介"><a href="#VPN简介" class="headerlink" title="VPN简介"></a>VPN简介</h1><h2 id="产生背景"><a href="#产生背景" class="headerlink" title="产生背景"></a>产生背景</h2><p>随着时代的发展和企业规模的壮大，企业网络也在不断的发生着变化，比如一家总部在北京的企业，可能会在上海、广州等地都有分支机构，因此需要把各个分支机构连接在一起，以便共享资源、协同工作，提高工作效率。但在广域网上传输数据有被窃听、被篡改以及被冒充的风险，专线或VPN技术可以解决这些问题。传统的专线联网方式价格昂贵，一般中小企业难以负担，这时低成本的VPN技术就孕育而生了。VPN全称是Virtual Private Network，也就是虚拟专用网络，它可以利用廉价接入的公共网络（主要使用Internet）来传输私有数据，相对于传统的专线连接方式具有成本优势，因此被很多企业和电信运营商所采用。VPN技术建立‘保护’网络实体之间的通信，使用加密技术防止数据被窃听，使用数据完整性验证防止数据被破坏、篡改，使用认证机制确认身份，防止数据被截获、回放。</p>
<h2 id="连接方式"><a href="#连接方式" class="headerlink" title="连接方式"></a>连接方式</h2><p>根据网络接入方式的不同，VPN技术主要分为站点到站点（Site to Site）和远程访问（Remote Access）。</p>
<h3 id="Site-to-Site"><a href="#Site-to-Site" class="headerlink" title="Site to Site"></a>Site to Site</h3><p><img src="/2022/01/20/15-VPN/1620099361518-76ec20ef-b231-4d35-9047-a6675b5ede1e.png" alt="img"></p>
<p>站点到站点的连接技术是一种主要的VPN连接方式，主要用于公司重要站点之间的连接，两个站点采用VPN技术虚拟的连接在一起，使得它们在通信时就想通过普通网线一样，可以访问到对方。Site to Site对于终端用户来说是透明的，即用户感觉不到VPN技术的存在，而是觉得互相访问的站点位于同一个内网。</p>
<p>Site to Site主要有以下几种：</p>
<ul>
<li><p>GRE。Generic Routing Encapsulation，通用数据封装，能够对各种网络层协议（例如IP和IPX）的数据进行封装，被封装的数据报文能够在IP网络中传输。GRE采用了Tunnel技术，是VPN的三层隧道协议。</p>
</li>
<li><p>IPSec VPN。是业界标准的网络安全协议，可以为IP网络通信提供透明的安全服务，保护TCP/IP通信免遭窃听和篡改，从而有效的抵御网络攻击。IPSec VPN在网络的灵活性、安全性、经济型、扩展性等方面极具优势，因此越来越受到企业客户的青睐。</p>
</li>
<li><p>MPLS VPN。使用MPLS技术在宽带IP的骨干网络上搭建企业IP专网，以实现跨地域、安全、高速、可靠的数据、语音、图像等多业务通信。MPLS VPN结合区分服务、流量工程（QOS）等相关技术，将公共网络可靠的性能，良好的扩展性，丰富的功能与专用网络的安全、灵活、搞笑地结合在了一起，可以为用户提供高质量的服务。</p>
</li>
</ul>
<h3 id="Remote-Access"><a href="#Remote-Access" class="headerlink" title="Remote Access"></a>Remote Access</h3><p><img src="/2022/01/20/15-VPN/1620100285369-97b1688a-c900-4b5b-8a29-7fe340397111.png" alt="img"></p>
<p>Site to Site的VPN技术只能满足公司站点之间的连接，也就是说客户必须要在公司内部才能使用这种技术来连接其他站点。如果客户出差在外，希望在一个提供Internet连接的咖啡馆、飞机场或酒店连接到公司内部，Site to Site VPN技术就不适用了。在这种场合下，需要用到Remote Access VPN。远程访问VPN一般需要预先在客户计算机上安装VPN客户端，并且通过客户端拨号到公司VPN网关，如果拨号成功，客户就像通过一根网线虚拟的连接到公司VPN网关，然后获取公司内部网络的一个地址并且使用这个内部地质来访问公司内部的服务器。Remote Access有以下几种：</p>
<ul>
<li><p>IPSec VPN。是一种全面的VPN技术，不仅适用于站点到站点的VPN连接方式，也能部署远程访问VPN。</p>
</li>
<li><p>VPDN。全称为Virtual Private Dial-up Networks，虚拟私有拨号网络，是VPN业务的一种，包括PPTP、L2TP和PPPOE等等，是基于拨号用户的虚拟专用拨号网业务。即用户已拨号接入方式连接，并且通过CDMA 1X分组网络传输数据时，VPDN会对传输的数据进行封装和加密，从而保护了数据的私密性使得VPN达到私有网络的安全级别。</p>
</li>
<li><p>SSL VPN。全称是Security Socket Layer，SSL，基于安全套接层协议建立远程安全访问通道的VPN技术。</p>
</li>
</ul>
<h1 id="GRE"><a href="#GRE" class="headerlink" title="GRE"></a>GRE</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>GRE全称是Generic Routing Encapsulation，中文是通用路由封装协议，提供了将一种协议的报文封装在另一种协议报文中的机制，是一种隧道封装技术。GRE可以封装组播数据，并可以和IPSec结合使用，从而保证语音，视频等组播业务的安全。</p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p><img src="/2022/01/20/15-VPN/1619578076343-13ed4894-19b6-4f63-894f-4a5b8eac0d5b.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1619578828319-c435ed9f-4ad1-47aa-89ae-2d6799ed8512.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1619578847582-6dfa35c4-546e-408e-a3c6-eda3c56b3fed.png" alt="img"></p>
<ul>
<li><p>GRE用来对某些网络层协议，比如IPX的报文进行封装，使这些被封装的报文能够在另一网络协议层协议（比如IP）中传输，GRE可以解决异种网络的传输问题。</p>
</li>
<li><p>IPSec VPN技术可以创建一条跨越共享公网的渠道，从而实现私网互联。IPSec VPN能够安全传输IP报文，但无法在隧道的两个端点之间运行RIP和OSPF等路由协议，GRE可以将路由协议信息封装在另一种协议报文（比如IP）中进行传输；</p>
</li>
<li><p>使用GRE可以克服IGP协议的一些局限性，例如RIP是一种距离矢量协议，最大跳数为15，如果网络跳数超过15则无法通信。这种情况下，可以使用GRE技术在两个网络节点之间搭建隧道，隐藏它们之间的跳数，扩大网络的工作范围。</p>
</li>
<li><p>GRE并不支持加密，因而通过GRE隧道传输的流量是不加密的。将IPSec技术与GRE相结合，可以先建立GRE隧道队报文进行GRE封装，然后再建立IPSec隧道对报文进行加密，以保证报文传输的完整性和私密性。</p>
</li>
</ul>
<h2 id="报文结构"><a href="#报文结构" class="headerlink" title="报文结构"></a>报文结构</h2><p><img src="/2022/01/20/15-VPN/1619579208799-697cbeca-e7bc-4159-bd96-e1fca0deff5a.jpeg" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1619579306197-7e141e6e-3d84-401e-adef-a4329cb4695a.png" alt="img"></p>
<ul>
<li><p>Checksum present：长度1bit，如果该位置1则表示后面可选的的Checksum字段存在并且包含有效信息；如果Checksum present位或Routing present位置1了，那么后面可选的Checksum以及Offset字段都会存在；</p>
</li>
<li><p>Routing present：长度1bit，如果该位置1，则表示后面可选的Offset字段存在并包含有效信息；如果Checksum present位或Routing present位置1了，那么后面可选的Checksum以及Offset字段都会存在；</p>
</li>
<li><p>Key present：长度1bit，如果该位置1，那么后面可选的Key字段存在并且包含有有效信息，Key验证是指对隧道接口进行验证，这种安全机制可以防止错误收到来自其他设备的报文。关键字字段（后面可选的Key字段）是一个四字节长的数值，只有隧道两端配置的关键字完全一致时才能通过验证，否则报文将被丢弃；</p>
</li>
<li><p>Sequence Number present：长度1bit，如果该位置1，那么后面可选电动车Sequence Number字段存在并且包含有效信息；</p>
</li>
<li><p>Strict Source Route：长度1bit，该位置1时，表示所有路由信息都包含了路由严格源的信息；</p>
</li>
<li><p>Recursion Control：长度3bit，包含了允许其他封装的数量，默认为0；</p>
</li>
<li><p>Flags：长度5bit，保留字段，必须为0；</p>
</li>
<li><p>Version：长度3bit，GRE版本号，必须为0；</p>
</li>
<li><p>Protocol：长度16bit，标识了载荷的协议类型；</p>
</li>
</ul>
<h2 id="封装-解封装过程"><a href="#封装-解封装过程" class="headerlink" title="封装\解封装过程"></a>封装\解封装过程</h2><p>GRE封装报文后，封装前的<strong>报文</strong>称为净荷，封装前的<strong>报文协议</strong>称为乘客协议，然后GRE会封装GRE头部，GRE称为封装协议，也叫运载协议，最后，负责对封装后的报文进行转发的协议称为传输协议。</p>
<ul>
<li><p>设备从连接私网的接口收到报文后，查询报文头部中的IP地址字段，在路由器查找出下一跳接口，如果发现出接口是隧道接口，则将报文发送给隧道模块进行处理；</p>
</li>
<li><p>隧道模块接收到报文后，首先根据乘客协议的类型和当前GRE隧道配置的校验和参数，对报文进行GRE封装，也就是添加GRE报文头部；</p>
</li>
<li><p>设备给报文添加传输协议报头，即IP报头，该IP报头的源地址就是隧道源地址，目的地址就是隧道目的地址；</p>
</li>
<li><p>设备根据新添加的IP报头的目的地址，在路由表中查找相应的出接口，并发送报文，然后封装后的报文在公网中传输；</p>
</li>
<li><p>接收端设备从连接公网的接口收到报文后，首先分析IP报头，如果发现协议类型字段值为47，也就表示谢意为GRE，于是出接口将报文交给GRE模块处理。GRE模块去掉IP报头和GRE报头，并根据GRE报头的协议类型字段，发现此报文的乘客协议为私有网络中运行的协议，于是将该报文交给该协议处理。</p>
</li>
</ul>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="/2022/01/20/15-VPN/1619600209083-ecca7231-250f-434f-ae24-dc094e82049c.png" alt="img"></p>
<p>PC1和PC2之间通信，在R1和R2上使用GRE隧道进行通信。</p>
<p>配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> tunnel source 192.168.13.1</span><br><span class="line"> tunnel destination 192.168.23.2</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.11.254 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.13.3</span><br><span class="line">ip route 192.168.22.0 255.255.255.0 Tunnel0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> tunnel source 192.168.23.2</span><br><span class="line"> tunnel destination 192.168.13.1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.22.254 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.23.3</span><br><span class="line">ip route 192.168.11.0 255.255.255.0 Tunnel0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PC1:</span><br><span class="line">ip default-gateway 192.168.11.254</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">no ip routing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PC2:</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.22.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip default-gateway 192.168.22.254</span><br><span class="line">!</span><br><span class="line">no ip routing</span><br></pre></td></tr></table></figure>

<p>PC1 和PC2使用路由器的IOS，所以要用‘no ip routing’关闭路由功能，并使用‘ip default-gateway’命令配置默认网关；两个Tunnel口使用192.168.12.0/24网段作为地址，在R1\R2上配置默认路由指向R3，并使用静态路由将去往PC1\PC2的网段，下一跳指向Tunnel口，使得流量走Tunnel到达对端。验证结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC1#traceroute 192.168.22.2</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 192.168.22.2</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 192.168.11.254 1 msec 0 msec 1 msec</span><br><span class="line">  2 192.168.12.2 1 msec 2 msec 1 msec</span><br><span class="line">  3 192.168.22.2 2 msec 2 msec *</span><br></pre></td></tr></table></figure>

<h1 id="DMVPN"><a href="#DMVPN" class="headerlink" title="DMVPN"></a>DMVPN</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>由于现代企业采用的基本是总部——各地分支机构的模式，使用传统的GRE Tunnel的话，如果分支机构之间需要通信，则需要先将流量发回总部，再经由总部发给分支机构，这个过程经历了两次加解密，还需要两次占用中心总部的带宽，而且配置量较大，增加一个分支机构就需要再配置一个GRE Tunnel，每个分支机构\客户都需要固定的IP地址，当任意的分支机构的Tunnel down掉后，即使有其他路径可达也无法自动切换。因此GRE已经无法满足现实网络的需要了。这是DMVPN横空出世，相比Point-to-Point的GRE tunnel，DMVPN的优点有：</p>
<ul>
<li><p>Tunnel Interface数量大幅减少。比起GRE需要为每个Hub-Spoke配置独立的Tunnel，DMVPN只要在路由器上设定mGRE（Multipoint GRE）就可实现Full Mesh，设置复杂性大大降低；</p>
</li>
<li><p>分支机构不需要有固定的公网IP地址。除了中心站点需要公网固定IP地址外，其他分支机构Spoke不需要固定IP地址，因为分支机构Spoke通过Next Hop Resolution Protocol（NHRP）向Hub路由器注册自己的IP地址，而Spoke路由器亦可使用NHRP向Hub查询其他分支机构Spoke的IP地址；</p>
</li>
<li><p>分支机构设置相同。分支机构的Tunnel设置基本相同，只要有一个设置成功，其他机构都可以使用几乎相同的设置，省时省力。</p>
</li>
<li><p>动态建立Spoke-to-Spoke隧道，这些流量无需穿越Hub中心站点；</p>
</li>
<li><p>支持Hub到Spoke的组播；</p>
</li>
<li><p>拥有自愈能力，最大限度的保障了VPN隧道的运行时间；</p>
</li>
</ul>
<p>DMVPN共有四个组件：</p>
<ol>
<li><p>mGRE，也就是Multipoint GRE；</p>
</li>
<li><p>NHRP，也就是Next Hop Resolution Protocol；</p>
</li>
<li><p>Dynamic Routing Protocol，支持路由协议，比如RIP、EIGRP、OSPF、BGP等；</p>
</li>
<li><p>IPSec，不是必须但建议使用以增强数据的安全性；</p>
</li>
</ol>
<h2 id="mGRE"><a href="#mGRE" class="headerlink" title="mGRE"></a>mGRE</h2><p>mGRE全称是Multipoint GRE，和传统的单隧道GRE需要建立多个Tunnel不同，mGRE的单个GRE可以支持多个GRE和IPSec隧道，简化了配置的复杂性，如果一个大型企业使用传统的GRE，那么它的大概拓扑如下：</p>
<p><img src="/2022/01/20/15-VPN/1619603368922-36b1af83-6fae-45ea-a739-49778873f946.png" alt="img"></p>
<p>可以看到，使用传统的GRE需要多条Tunnel，不仅配置麻烦而且容易出问题。如果使用了mGRE，那么配置会简单明了的多：</p>
<p><img src="/2022/01/20/15-VPN/1619603596582-276a0c2a-a2e9-49b5-8717-f3d2f377c077.png" alt="img"></p>
<p>当使用mGRE的时候，每个路由器只有一个Tunnel接口，如果分支机构之间，比如分支机构1和2之间需要通信的话，那么Tunnel会‘自动的’建立好新隧道，分支机构之间的流量不必通过中心站点，而是可以直接在分支机构之间传输：</p>
<p><img src="/2022/01/20/15-VPN/1619603816469-8762842f-67fe-4918-9a21-ea0d19633edf.png" alt="img"></p>
<p>但此时也有个问题，那就是当配置点对点GRE隧道时，我们需要配置建立隧道的源地址和目标地址，当两个分支机构之间想传输数据时，它们该使用什么IP地址呢？这时分支机构是不知道对方的公网IP地址的，所以需要用第二个关键构成协议，NHRP，Next Hop Resolution Protocol，下一跳地址解析协议。</p>
<h2 id="NHRP"><a href="#NHRP" class="headerlink" title="NHRP"></a>NHRP</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>当分支机构之间想要知道对方的公网IP地址时，需要使用NHRP协议，协议的基本特点如下：</p>
<ul>
<li><p>一个路由器会作为NHRP的Server；</p>
</li>
<li><p>其他的路由器是NHRP的Client；</p>
</li>
<li><p>NHRP的Client会在Server上注册并且报告给Server它们自己的公网IP地址；</p>
</li>
<li><p>NHRP的Server会在缓存中持续追踪所有的公网地址；</p>
</li>
<li><p>当一个Client需要通过隧道向其他Client使用隧道传输数据时，它会先向Server请求目标路由器的公网IP地址；</p>
</li>
</ul>
<p>因为NHRP协议是一个Server-Client模式的协议，所以mGRE使用Hub and Spoke模式是合理的。所以Hub路由器（总部服务器）就是NHRP的Server服务器，分支机构就是Spoke和Client。</p>
<p><img src="/2022/01/20/15-VPN/1619765917233-586ecac4-4a66-4a25-b566-901513cb888c.png" alt="img"></p>
<p>上面的拓扑中，我们有两台Spoke路由器，当然它俩也是NHRP中的Client角色，两台Spoke分别和Hub路由器建立了Tunnel。在分支机构路由器的配置中，会配为Hub配置固定的IP地址，而在身为Hub的中心路由器的配置中，会动态的接受Spoke的地址，使用NHRP的注册、请求报文来将分支机构的公网地址注册给中心的Hub路由器。</p>
<p><img src="/2022/01/20/15-VPN/1619766209956-3b630ac9-9a86-4fde-92ca-79c429d3852e.png" alt="img"></p>
<p>中心的Hub路由器，也就是NHRP的Server路由器，会构建一个公网IP地址以及隧道IP地址的这两者之间的映射</p>
<p><img src="/2022/01/20/15-VPN/1619766325173-2584f80a-b35e-4cef-a2ca-fdbbf2eba022.png" alt="img"></p>
<p>当Spoke1想发送信息给Spoke2时，它需要知道Spoke2的公网IP地址，这时它会发送NHRP解析请求，询问身为Hub\Server的路由器，Spoke2的公网地址是什么。</p>
<p><img src="/2022/01/20/15-VPN/1619766446411-ba6b25da-0ccb-4dcf-8f33-44bb0904c1ed.png" alt="img"></p>
<p>Hub\Server路由器会查询缓存，找到Spoke2的条目，并且发送NHRP的解析回复报文给Spoke1，告诉Spoke1它所需要的Spoke2的公网IP地址。</p>
<p><img src="/2022/01/20/15-VPN/1619766980605-c981c6a0-562d-4690-a720-ce2577b41f48.png" alt="img"></p>
<p>Spoke1知道了Spoke2的公网IP地址后，可以直接使用隧道向Spoke2发送数据。只用想Hub路由器请求一个IP地址，而不用像普通GRE一样什么流量都需要经过Hub站点</p>
<p>NHRP的作用是公网IP地址和隧道IP地址之间的转换，换句话说，Spoke路由器会把自己的公网IP地址和Tunnel地址传送给Hub\Server</p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p>Hub配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Tunnel 0</span><br><span class="line"> ip address  X.X.X.1</span><br><span class="line"> tunnel source C</span><br><span class="line"> ip nhrp network-id Y   #所有的设备需要配置相同的ID</span><br><span class="line"> ip nhrp authentication ZZZ     #启动NHRP认证（可选）</span><br><span class="line"> ip nhrp map multicast dynamic  #动态接收组播映射</span><br></pre></td></tr></table></figure>

<p>Spoke配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Tunnel 0</span><br><span class="line">  ip address X.X.X.2</span><br><span class="line">  ip nhrp network-id Y   #所有的设备需要配置相同的ID</span><br><span class="line">  ip nhrp authentication ZZZ    #启动NHRP认证（可选）</span><br><span class="line">  ip nhrp map X.X.X.1  A.A.A.A   #Spoke需映射Hub的公网地址&lt;A.A.A.A&gt;和Tunnel地址&lt;X.X.X.1&gt;</span><br><span class="line">  ip nhrp map multicast A.A.A.A  #Spoke需要手动映射组播到Hub，用于建立动态路由协议邻居</span><br><span class="line">  ip nhrp nhs X.X.X.2   #配置NHRP server地址，Spoke启动后会到Server注册自己的Tunnel、公网地址之间的映射</span><br></pre></td></tr></table></figure>

<p>优化命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Hub：</span><br><span class="line">HUB(config-if)# ip nhrp redirect</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Spoke：</span><br><span class="line">SPOKE(config-if)# ip nhrp shortcut</span><br></pre></td></tr></table></figure>

<h3 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h3><p><img src="/2022/01/20/15-VPN/1619773869115-8b4631a1-29d3-48d1-954e-86629bdef7a0.png" alt="img"></p>
<p>几台路由器的公网接口要能彼此先通信，再配置DMVPN，公网互通是一切的寄出，在这里R2\R3\R4上都配置了到R1的默认路由，所以彼此能ping 通：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#ping 13.1.1.3</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 13.1.1.3, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/2 ms</span><br><span class="line">R2#ping 14.1.1.4</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 14.1.1.4, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<p>然后来配置DMVPN：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先配置mGRE和NHRP：</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 10.1.1.2 255.255.255.0</span><br><span class="line"> no ip redirects</span><br><span class="line"> ip nhrp network-id 10</span><br><span class="line"> tunnel source Ethernet0/0</span><br><span class="line"> tunnel mode gre multipoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 10.1.1.3 255.255.255.0</span><br><span class="line"> no ip redirects</span><br><span class="line"> ip nhrp map 10.1.1.2 12.1.1.2</span><br><span class="line"> ip nhrp map multicast 12.1.1.2</span><br><span class="line"> ip nhrp network-id 10</span><br><span class="line"> ip nhrp nhs 10.1.1.2</span><br><span class="line"> tunnel source Ethernet0/1</span><br><span class="line"> tunnel mode gre multipoint</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 10.1.1.4 255.255.255.0</span><br><span class="line"> no ip redirects</span><br><span class="line"> ip nhrp map 10.1.1.2 12.1.1.2</span><br><span class="line"> ip nhrp map multicast 12.1.1.2</span><br><span class="line"> ip nhrp network-id 10</span><br><span class="line"> ip nhrp nhs 10.1.1.2</span><br><span class="line"> tunnel source Ethernet0/2</span><br><span class="line"> tunnel mode gre multipoint</span><br></pre></td></tr></table></figure>

<p>可以看出，R3和R4的配置基本相同，只在tunnel的IP地址上不一样，配置完mGRE和NHRP后，再来看一下配置是否成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip nhrp detail</span><br><span class="line">10.1.1.3/32 via 10.1.1.3</span><br><span class="line">   Tunnel0 created 00:10:45, expire 00:09:14</span><br><span class="line">   Type: dynamic, Flags: registered nhop</span><br><span class="line">   NBMA address: 13.1.1.3</span><br><span class="line">   Preference: 255</span><br><span class="line">10.1.1.4/32 via 10.1.1.4</span><br><span class="line">   Tunnel0 created 00:00:45, expire 00:09:14</span><br><span class="line">   Type: dynamic, Flags: registered nhop</span><br><span class="line">   NBMA address: 14.1.1.4</span><br><span class="line">   Preference: 255</span><br></pre></td></tr></table></figure>

<p>可以看到，R2上和R3、R4成功配置了mGRE和NHRP，接下来配置路由协议，这里使用OSPF协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 10.1.1.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 10.1.1.3 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 10.1.1.4 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>这里要注意两点，一是在OSPF中只能宣告Tunnel的IP地址进OSPF，而不能宣告上联的公网IP地址进OSPF；二是宣告完OSPF后，会发现邻居不停的Down\UP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Adjacency forced to reset</span><br><span class="line">*May  1 16:14:34.532: %OSPF-5-ADJCHG: Process 1, Nbr 3.3.3.3 on Tunnel0 from EXCHANGE to DOWN, Neighbor Down: Adjacency forced to reset</span><br><span class="line">*May  1 16:14:34.533: %OSPF-5-ADJCHG: Process 1, Nbr 4.4.4.4 on Tunnel0 from EXCHANGE to DOWN, Neighbor Down: Adjacency forced to reset</span><br><span class="line">*May  1 16:14:34.533: %OSPF-5-ADJCHG: Process 1, Nbr 3.3.3.3 on Tunnel0 from EXCHANGE to DOWN, Neighbor Down: Adjacency forced to reset</span><br><span class="line">*May  1 16:14:34.534: %OSPF-5-ADJCHG: Process 1, Nbr 4.4.4.4 on Tunnel0 from EXCHANGE to DOWN, Neighbor Down: Adjacency forced to reset</span><br></pre></td></tr></table></figure>

<p>这是为什么呢？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-router)#do show ip ospf int tun 0 | include Network Type</span><br><span class="line">  Process ID 1, Router ID 2.2.2.2, Network Type POINT_TO_POINT, Cost: 1000</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">R3(config-router)#do show ip ospf int tun 0 | include Network Type</span><br><span class="line">  Process ID 1, Router ID 3.3.3.3, Network Type POINT_TO_POINT, Cost: 1000</span><br></pre></td></tr></table></figure>

<p>因为这里Tunnel在OSPF协议中默认的网络类型是点对点，Point-to-Point，点对点只能有一个邻居，而这里R2有R3和R4两个邻居，所以它会持续的建立-终端邻接关系，所以Tunnel上不能使用点对点类型，必须将类型改为其他的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-if)#ip ospf network ?</span><br><span class="line">  broadcast            Specify OSPF broadcast multi-access network</span><br><span class="line">  non-broadcast        Specify OSPF NBMA network</span><br><span class="line">  point-to-multipoint  Specify OSPF point-to-multipoint network</span><br><span class="line">  point-to-point       Specify OSPF point-to-point network</span><br></pre></td></tr></table></figure>

<p>除了点对点以外，还有广播、非广播、点对多点几种网络类型，在DMVPN中一般使用广播和点到多点两种模式。</p>
<h4 id="广播模式"><a href="#广播模式" class="headerlink" title="广播模式"></a>广播模式</h4><p>先来看广播模式的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">interface tunnel 0</span><br><span class="line">  ip ospf network broadcast</span><br><span class="line">  ip ospf priority 255</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">R3&amp;R4：</span><br><span class="line">interface tunnel 0</span><br><span class="line">  ip ospf network broadcast</span><br><span class="line">  ip ospf priority 0</span><br></pre></td></tr></table></figure>

<p>严格来说，不需要为Hub配置255的priority，这么做只是为了更好的确保Hub作为DR，将Spoke的priority设置为0确保它们不会成为DR。接下来配置OSPF进程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 10.1.1.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 10.1.1.3 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 10.1.1.4 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2#show ip ospf neighbor</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">3.3.3.3           0   FULL/DROTHER    00:00:36    10.1.1.3        Tunnel0</span><br><span class="line">4.4.4.4           0   FULL/DROTHER    00:00:32    10.1.1.4        Tunnel0</span><br></pre></td></tr></table></figure>

<h4 id="点到多点模式"><a href="#点到多点模式" class="headerlink" title="点到多点模式"></a>点到多点模式</h4><p>这里我们将三台路由器的Tunnel接口改成点对多点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-if)#ip ospf network point-to-Multipoint</span><br><span class="line"></span><br><span class="line">R3(config-if)#ip ospf network point-to-Multipoint</span><br><span class="line"></span><br><span class="line">R4(config-if)#ip ospf network point-to-Multipoint</span><br></pre></td></tr></table></figure>

<p>可以发现，在点对多点的网络类型下，邻居很快就建立起来了，因为在这种网络类型中，不需要选择DR\BDR。</p>
<h1 id="IPSec-vpn"><a href="#IPSec-vpn" class="headerlink" title="IPSec vpn"></a>IPSec vpn</h1><h2 id="出现背景"><a href="#出现背景" class="headerlink" title="出现背景"></a>出现背景</h2><p>在IPV4协议出现的时候，由于试用范围很小（一开始在美国国防部高级研究计划局试用）且每个接入网络网络的人均经过审核，每个设备都在严格管控之中，所以一开始IPV4协议中没有加入关于安全方面的考虑，但随着网络技术的发展以及网络范围的机构爆发式的增长，接入互联网的机构不再有审核，每台路由器也不知道都有哪些人来管理，所以安全问题日益突出，所以在IPV6协议的设计之初，加入了IP层安全性方面的设计，设计了IPSec协议，不管是IPV4还是IPV6都能够使用。</p>
<h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="密钥"><a href="#密钥" class="headerlink" title="密钥"></a>密钥</h3><p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数，用来完成加密、解密、完整性验证的秘密信息，在使用密钥对数据进行加密以后，只有用相应的密钥才能进行解密，密钥保护了信息的私密性，没有密钥，即使通信内容被第三方获取也无法获知传输信息的内容。密钥的长度决定了破解的难度，密钥越长，破解起来越困难。</p>
<h4 id="对称密钥算法"><a href="#对称密钥算法" class="headerlink" title="对称密钥算法"></a>对称密钥算法</h4><p>对称加密算法是应用较早的加密算法。在对称加密算法中，数据发送方将明文（也就是原始的要发送的数据）和加密密钥一起经过特殊的算法加密处理后，使其变成复杂的加密密文发送出去。数据的接收方收到密文后，若想知道原始发送的数据是什么，需要使用加密过的密钥，以及相同算法的逆算法，将数据解密，才能恢复成可读的铭文数据。在对称算法中，使用的密钥只有一个，收发两端都是用这个密钥对数据进行加密和解密，所以通信的双方必须实现知道加密的密钥。因此对称算法的安全性依赖于密钥，如果密钥泄露，就意味着其他无关人员在获取到加密信息后也能解密获取其中的通信数据。主流的对称加密算法有DES，3DES等。</p>
<p>对称加密算法的优势是，算法公开，计算量小，加密速度快，效率高。不足是双方都要使用相同的密钥，安全性得不到保证；随着参与者数量的增加，密钥数量急剧膨胀，需要(n×(n-1))/2个秘钥；因为密钥数量过多，对密钥的管理和存储是一个很大的问题；不支持数字签名，不具备不可否认性。</p>
<h4 id="非对称密钥算法"><a href="#非对称密钥算法" class="headerlink" title="非对称密钥算法"></a>非对称密钥算法</h4><p>非对称算法需要两个密钥：公开密钥，也就是公钥，Publickey；私有密钥，也就是私钥，Privatekey。公钥与私钥是成对且相互匹配的，如果用公钥对数据进行加密，只有对应的私钥才能解密，所以私钥需要持有者严密保护，确保只有使用者才能唯一拥有。因为加密和解密使用的是两个不同的密钥，所以这种算法叫做非对称加密算法。常见的非对称加密算法有，RSA、DH和ECC等等。</p>
<p>非对称加密算法实现机密信息交换过程，用一句话来概括就是公钥加密，私钥解密。基本过程是，所有参与通信的设备，都需要预先使用非对称密钥算法（例如RSA），生成一对密钥（公钥和私钥），然后将公钥公开，放在服务器上共享给所有通信的另一方。假设此时乙方要给甲发送数据，则乙会使用甲所公布的公钥对数据进行加密生，成加密数据，然后发送给甲方。当甲方收到加密的信息后，甲会用自己的私钥对数据进行解密，获取明文信息。</p>
<p><img src="/2022/01/20/15-VPN/1621311792019-34ee9f72-1c1f-4702-9314-658676b4a235.png" alt="img"></p>
<ol>
<li><p>用户1，也就是发起方，需要预先获取用户2，也就是接收方的公钥；</p>
</li>
<li><p>用户1使用用户2的公钥，对需要传输的信息进行加密；</p>
</li>
<li><p>中途截获数据的攻击者由于没有用户2的私钥，无法对数据进行解密；</p>
</li>
<li><p>用户2使用自己的私钥对加密后的数据（由用户2的公钥加密，出现在步骤2中）进行解密，使用公钥加密，私钥解密的方式实现了数据的私密性</p>
</li>
</ol>
<p>非对称密钥算法运算速度极慢，相比对称密钥算法要慢得多得多，因此基本不可能使用非对称密钥算法对实际数据进行加密，在实际通信中，主要使用非对称加密算法对密钥进行加密，以完成密钥交换的步骤。</p>
<p><strong>非对称密钥算法的优势有：</strong></p>
<ul>
<li><p>安全。不用担心通信两端的公钥被劫持，所以非对称密钥的分发更加安全；</p>
</li>
<li><p>密钥的数量和通信参与者数目相同；</p>
</li>
<li><p>在交换公钥之前无需建立某种信任关系，因为有了公钥也没法对数据进行解密；</p>
</li>
<li><p>支持数字签名和不可否认性；</p>
</li>
</ul>
<p><strong>非对称密钥算法的不足有：</strong></p>
<p>加密速度奇慢无比，加密同样大小的数据，如果用对称算法DES的话，大概比非对称加密算法的RSA快几百倍。加密后的密文长度会变长，比如用RSA加密1G的数据，加密后可能会变为2G大小。</p>
<h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p><img src="/2022/01/20/15-VPN/1621408131350-682c0d86-377f-4d80-999a-0eb956688bad.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1641372357781-080c3f47-8201-4e2b-8d0b-1e1b03232c65.png" alt="img"></p>
<p>非对称式算法除了可以用来加密数据，也可以用来做数字签名。数字签名是只有信息的发送者才能产生的，别人无法伪造的一段数字串，这段数字串同时也是对信息的发送者发送信息真实性的一个有效证明。它类似于在纸上的普通的物理签名，但使用了非对称加密技术。纸上的签名，比如合同或者欠条，在上面签名是承认了上面写的东西，事后不能抵赖，也就是不可否认性，签名了就承认纸上写的东西并且要履行相应的义务。谁会去检查这个签名呢？一般都是在出现问题后，比如甲向乙借了10000块钱，甲在欠条上签名，如果甲欠债不还，乙会拿出那张由甲签过名的欠条，只要签名经鉴定是甲签的，那么甲这个借钱行为就无法抵赖，无法否认。数字签名可以提供两个很重要的安全特性，完整性校验和源认证，完整性校验保证了数据在发送过程中不会产生变化，完整性由散列函数完成。源认证由散列算法提供，因为使用了甲的公钥加密以后，只有使用甲的私钥才能对数据进行解密，所以甲没法对这个进行抵赖，从而完成了源认证。数字签名可以用于驱动程序签名，PDF签名，IPSec数字签名认证，数字证书中的数字签名。</p>
<p>实现过程为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">明文数据---------hash算法（md5）----------hash值（128bit-例如12345）-------私钥加密------------数字签名</span><br><span class="line">     </span><br><span class="line"> 数字签名 --------用对方公钥解密------hash值12345</span><br><span class="line"> 明文数据--------hash算法（md5) ---hash值12345</span><br><span class="line"></span><br><span class="line">如果散列值1和散列2相同，说明验证成功，如果散列值不相同，说明验证失败</span><br></pre></td></tr></table></figure>

<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>IPSec协议用来在IP层提供安全服务，以便其他TCP/IP协议和应用程序使用，这就意味的IPSec为那些在TCP/IP网络上的设备提供了安全通信所需要的工具。当两个设备（不管是用户终端设备，比如PC，还是中间设备，比如路由器防火墙）想要进行安全通信时，它们会在设备之间设置一个安全的通道来通信，但这个安全通道可能会经过很多中间设备，而这些中间设备并不安全。所以要确保通信的安全，必须达到以下的标准：</p>
<ul>
<li><p>两台设备之间必须就使用一组安全协议达成一致，这样彼此之间才能以对方理解的格式发送数据；</p>
</li>
<li><p>它们必须确定给数据加密的算法，这样数据的内容才会有私密性，不会被其他人所知道；</p>
</li>
<li><p>它们必须交换密钥，这个密钥用于解密已加密的数据；</p>
</li>
<li><p>完成了前几步之后，两台设备必须使用之前协商好的协议、算法和密钥，将数据重新编码然后通过网络发送给对方；</p>
</li>
</ul>
<p>为了达成上述的这几个标准，IPSec协议出现了，IPSec（Internet Protocol Security）并不是一个单独的协议，而是一组服务和协议的集合，它为IP网络提供了完整的安全解决方案，提供了多种保护功能。因为IPSec工作在IP层，它能够为IP层以及IP层之上的其他更高层提供保护，而不需要其他额外的安全措施，它可以提供以下三个方面的保护：</p>
<ul>
<li><p>私密性（Confidentiality），数据私密性就是通过加密技术，例如使用3DES等算法，对数据进行加密，这样一来即使数据被第三方获取，也只是加密后的，无法破解更无法得知原始数据，从而杜绝数据被窃听；</p>
</li>
<li><p>完整性（Integrity），完整性可以确保数据在传输过程中未经第三方进行篡改，例如MD5或SHA1等算法，从而杜绝数据被篡改；</p>
</li>
<li><p>源认证（Authenticity），源认证就是对发送数据包的源头进行身份认证，确保发送数据的源头是合法用户，从而杜绝通信源头被冒充。源认证除了能提供发送的源用户验证，还能提供不可否认性，因为经过了源认证以后能够确定了发送源设备就是它，所以发送者无法否认；</p>
</li>
</ul>
<h2 id="IPSec框架"><a href="#IPSec框架" class="headerlink" title="IPSec框架"></a>IPSec框架</h2><p><img src="/2022/01/20/15-VPN/1620124202121-45e41747-26e4-40c3-9974-909e85401ca7.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620457405851-16b70742-4943-4e60-989e-b939517a60a3.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620114697497-c474dadc-7c78-424a-a31f-ec9851abca8b.png" alt="img"></p>
<p>IPSec主要使用AH（Authentication Header）Protocol、ESP（Encapsulating Security Algorithms）Protocol和IKE这三个核心协议：</p>
<ul>
<li><strong>AH</strong>：AH全称为Authentication Header，它是一个协议，通过添加一个根据数据段中的值所计算出来的AH报头，对数据段的全部或部分内容进行认证（AH is a protocol that provides authentication of either all or part of the contents of a datagram through the addition of a header that is calculated based on the values in the datagram. ）。AH只提供了身份验证机制，可以提供数据完整性验证（Data Integrity）、数据源身份认证（Data Origin Authentication）以及可选的对重放攻击的保护（未认证用户大量且反复的发送数据）。数据完整性验证由算法生成的摘要来确保，比如HMAC-MD5或HMAC-SHA算法；数据源身份验证由共享密钥生成的信息摘要确保；重放攻击防护由AH头部的序列号字段来提供保护。AH对IP报头和它的负载提供了完整性校验，但某些字段可能在传输过程中出现合理的变化，比如TTL字段。</li>
<li><strong>ESP</strong>：ESP全称为Encapsulating Security Payload，ESP不仅提供了认证功能（包含数据完整性验证、数据源身份认证以及重放攻击保户），相比AH来说，ESP还额外提供了数据私密性（通过加密算法）以及。其中数据完整性由MD5或SHA这种验证完整性的算法通过生成消息摘要来确保；数据源认证，由共享密钥创建的消息摘要确保；ESP也可以值提供以上所有的功能，也可以单独提供其中的一个或两个功能，比如只提供数据私密性功能，或者只提供认证功能，或者同时提供数据私密性和认证功能。</li>
</ul>
<p><img src="/2022/01/20/15-VPN/1620456993738-17a1d311-a3d8-4dfb-bd19-42cbb43531c2.jpeg" alt="img"></p>
<ul>
<li><strong>密钥交换构架和机制</strong>：两台设备在通信时为了保证数据的私密性，会对数据进行加密，但数据到了对方设备后，还需要解密的密钥才能正常读取数据，为了让对方能解密就必须要交换密钥，除了交换密钥，还需要交换安全关联信息（Security Associations）。在IPSec中，使用<strong>IKE（Internet Key Exchange）</strong>协议来完成。</li>
</ul>
<p>除了ESP、AH和IKE，还有其他一些辅助的算法及协议：</p>
<ul>
<li><strong>加密/哈希算法</strong>：AH和ESP都是通用协议，不指定使用哪种算法来进行加密，可以使用多种算法来达成目的，这样的话灵活性比较强，所以需要通信的两端进行协商，看使用哪种算法来加密，以便通信时能正确读取数据进而解密。一般使用比较多的算法为<strong>MD5（Message Digest 5）</strong>和<strong>SHA（Secure Hash Algorithm 1）</strong>，它们都叫做哈希算法（Hashing Algorithms）因为这俩都是将输入的数据通过哈希公示计算，得出一个值的方式进行工作。</li>
<li><strong>安全策略和关联及管理办法</strong>：因为IPSec让设备自由选择使用的安全协议，所以需要追踪设备之间的使用的是什么协议，IPSec使用<strong>安全策略（Security Policies）</strong>和<strong>安全关联（Security Associations）</strong>来完成上述工作，并且通过交换安全关联（Security Associations）来完成设备之间的信息交互。</li>
</ul>
<p>传统的安全技术，比如HTTPS或WEP/WEA，往往会采用某种固定的加密和散列函数，这种做法有一个弊端就是如果某天所采用的的加密算法被破解或被爆出严重的漏洞，那么使用这个算法或散列函数的技术也难免被淘汰，因为协议已经不再安全。为了避免这种事情的发生，IPSec没有定义具体的加密和散列函数，它的做法是提供一个框架性的结构，可以使用不同的算法，具体使用哪种算法，通过协商来决定，比如说，如果3DES这个168位的加密算法满足现实使用要求，那么就用它作为加密算法，如果觉得这个算法不行或出现了严重问题，那么也可以马上更换加密协议，以后出现新的加密算法也可以在IPSec框架下使用，始终保持IPSec协议的可用性，所以IPSec有多重算法选择的组合方式：</p>
<p><img src="/2022/01/20/15-VPN/1620288800677-4f623ab6-7426-4563-b079-09efb36db7df.png" alt="img"></p>
<h2 id="总体流程"><a href="#总体流程" class="headerlink" title="总体流程"></a>总体流程</h2><p>为了建立起IPSec tunnel，我们需要使用IKE协议，全称是Internet Key Exchange，IKE协议用于在IPSec协议中对双方所使用的具体协议，比如使用哪种加密算法、认证方式、密钥有效期等参数进行协商，IKE协商完成后的结果叫做安全关联（SA，Security Association），可以说IKE建立了安全关联。</p>
<p>IPSec的建立过程为5个阶段：</p>
<ul>
<li><p>初始化：触发隧道的创建。比如在路由器上配置IPSec，然后配置哪些流量需要被IPSec保护，也就是定义感兴趣流，当路由器收到那些需要被保护的流量时，会开始IKE进程，当然也可以手动初始化隧道。在思科设备上，感兴趣流是用访问列表，access-list来匹配的，被访问列表匹配的流量会被加密，未被匹配的流量将不会被加密；</p>
</li>
<li><p>IKE阶段1：两台设备会对对端设备进行身份认证，协商好安全关联（包含使用什么加密协议、认证方式、密钥有效期等），并用安全关联去建立IKE第一阶段的隧道，又叫ISAKMP Tunnel；</p>
</li>
<li><p>IKE阶段2：在IKE阶段1的隧道中，基于需要被加密的流量协商并建立IKE阶段2的隧道，也就是IPSec SA。协商的内容包括使用哪个IPSec协议（AH或ESP），是用那种封装方式（Transport或Tunnel），使用哪种加密协议（DES或3DES还是AES），使用哪种认证协议（MD5还是SHA），生存周期为多久，是否使用可选的DH交换；</p>
</li>
<li><p>数据传输：用IKE阶段2的隧道传输并保护发送的数据；</p>
</li>
<li><p>终止：当没有需要保护的数据传输的一段时间后，IPSec隧道会终止进程；</p>
</li>
</ul>
<p>初始化IPSec以后，在IKE phase1中，两个终端会协商，到底使用哪些加密、认证、哈希或其他算法协议，以及IPSec协议需要的其他参数。为什么需要协商呢？因为前面说过了，IPSec协议只规定了框架，没规定具体的协议，从而避免某个加密或认证协议算法出现问题而导致整个IPSec协议被攻破，如果一端用3DE而另一端不支持就麻烦了，所以需要IKE收集两端采用的协议，看两遍支持的协议是否相同。如果两端支持的协议相同协商成功了，会在这个阶段中会建立起ISAKMP（Internet Security Association and Key Management Protocol）会话，它也可以叫做ISAKMP Tunnel或IKE 阶段1 Tunnel。</p>
<p>设备收集起来的关于安全的参数，叫做SA（Security Association，安全关联），让我们来看一个已经建立起IKE 第一阶段的隧道的例子：</p>
<p><img src="/2022/01/20/15-VPN/1620790753677-eaa53e7b-7d72-4352-98ee-22c0edeb4158.png" alt="img"></p>
<p>IKE第一阶段所建立的Tunnel仅供管理流量使用，比如keepalive等，一阶段的Tunnel是为了给第二阶段的流量提供安全保障，第二阶段叫做IKE阶段二Tunnel或IPSec隧道。</p>
<p>当两台路由器之间建立完IKE阶段2以后如图所示：</p>
<p><img src="/2022/01/20/15-VPN/1620791858911-5107c6d0-57b7-4604-b0a7-0038c9cc3436.png" alt="img"></p>
<p>当阶段2建立完毕后，就能使用IKE阶段2Tunnel（或者叫IPSec Tunnel也行）来对数据进行保护，这样一来用户数据就能通过IKE 阶段2Tunnel来传输：</p>
<p><img src="/2022/01/20/15-VPN/1620791959595-f9282a2d-81d7-41bd-b1de-2ba32392c96c.png" alt="img"></p>
<p>IKE协议建立起了Tunnel，但它并不能为用户数据提供认证或加密功能，这需要其他两个协议来完成，它们是AH（Authentication Header）和ESP（Encapsulating Security Payload），这两个协议都能提供身份认证和数据完整性校验功能，但ESP额外支持加密功能，因此ESP在现网中使用更多，毕竟数据的私密性还是很重要的。AH和ESP都支持两种模式，Transport模式（传输模式）和Tunnel模式（隧道模式），两种模式的具体区别在后文写，简单说一下最主要的区别就是，Transport模式用原始的IP报头，原始的IP报头不会被保护，而Tunnel模式会生成新IP报头，原始的IP报头会被保护：</p>
<p><img src="/2022/01/20/15-VPN/1620806609705-c35ee991-1436-416a-9aab-52b3118b8de0.png" alt="img"></p>
<p>Transport模式通常在两个终端通信时使用，用来确保流量的安全，Tunnel模式通常在Site-to-Site模式VPN使用，在这种情况下，我们需要将原始的IP报文封装，因为使用的IP地址通常都是私有地址，无法在互联网中被路由。</p>
<h2 id="IKE协议"><a href="#IKE协议" class="headerlink" title="IKE协议"></a>IKE协议</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>IKE协议全称为Internet Key Exchange，互联网密钥交换协议，负责建立和维护两种SA（Security Association，安全关联），分别是阶段一的IKE SA（也叫ISAKMP SA）以及阶段二的IPSec SA。IPSec只规定了大的框架而没有规定具体使用的加密\验证协议，所以需要使用IKE协议用来交换两端使用的协议以及其他IPSec需要用到的参数，IKE协议在RFC2409中定义，具体完成以下几个方面的任务：</p>
<ul>
<li><p>对建立IPSec的双方进行认证，认证需要事先协商认证的方式；</p>
</li>
<li><p>通过密钥交换，产生用于加密和HMAC的随机密钥；</p>
</li>
<li><p>协商加密参数，比如加密协议、散列函数、封装协议、封装模式和密钥有效期；</p>
</li>
</ul>
<p>大概的工作方式是，IKE通过让具备IPSec能力的设备，交互SA（Security Association，安全关联），用来构建安全关联数据库，然后安全关联数据库被AH或ESP协议使用，由AH或ESP来加密用户数据。</p>
<p>IKE协议也是一个‘混合’协议，因为它集合了或者说支持了三个协议，第一个是ISAKMP，Internet Security Association And Key Management Protocol，互联网安全关联管理协议，它是IKE的核心协议（所以也会把IKE和ISAKMP这两个术语互换使用，但要明白其中区别），规定了交换密钥和安全关联信息的体系及框架，工作的方式是通过一系列步骤来协商设备之间的SA（Security Association，安全关联），ISAKMP协议支持多种密钥交换的方式。在IKE中，ISAKMP框架是密钥交换的基础方式，他决定了IKE协商包的封装格式、密钥交换过程、模式的切换的构架，它其实是规定了一个构架，但不规定具体的协议，其他两种协议是SKEME和Oakley，Oakley规定了密钥交换的方式，提供了IPSec对各种技术的支持，例如，支持新的加密与散列技术，Oakley为IPSec提供了一个框架；SKEME定义了密钥交换的体系结构，例如DH算法就是这个协议引入的。</p>
<h3 id="IKE和IPSec的关系"><a href="#IKE和IPSec的关系" class="headerlink" title="IKE和IPSec的关系"></a>IKE和IPSec的关系</h3><p>IKE为IPSec提供了自动协商密钥、建立IPSec SA的服务，能够简化IPSec的使用和管理，大大简化IPSec的配置和维护工作：</p>
<p><img src="/2022/01/20/15-VPN/1621413671913-f68bd6f5-6f11-4899-b6d9-faa58e33cdb7.png" alt="img"></p>
<p>IKE与IPSec的关系如上图所示，对等体之间建立一个IKE SA完成身份验证和密钥信息交换以后，在IKE SA的保护下，根据配置的AH\ESP安全协议等参数协商出一对 IPSec SA。从此以后，对等体之间的数据将在IPSec隧道中加密传输。</p>
<h3 id="安全联盟"><a href="#安全联盟" class="headerlink" title="安全联盟"></a>安全联盟</h3><p>安全联盟的英文全称是Security Association，是建立IPSec隧道的通信双方对隧道参数的约定，包括隧道两端的IP地址、隧道采用的验证方式、验证算法、验证密钥、加密算法、共享秘钥以及生命周期等一系列参数。</p>
<p>SA由三元组来唯一标识，这个三元组包括安全参数索引SPI（Security Parameter Index）、目的IP地址和使用的安全协议号（AH或ESP）。其中，SPI是为了唯一标识SA而产生的一个32bit的数值，它在AH和ESP头中传输。在手工配置SA时，需要手工指定SPI值。一般都使用IKE协商产生SA，SPI将自动随机生成。</p>
<p>SA是一般是单向逻辑连接，因此两设备在使用IPSec通信时，至少需要建立两个SA来分别对两个方向的数据流进行安全保护，但ISAKMP SA是双向的。</p>
<p>SA是IPSec的一个基本组成部分，SA是SADB（Security Association DataBase）的一个条目，它包含着双方关于IKE和IPSec已经协商完毕的安全信息。</p>
<p><strong>IKE or ISAKMP SA：双向的，决定了IKE协议处理的相关细节；</strong></p>
<p><strong>IPSec SA是单向的，与封装协议有关，决定了具体加密流量的处理方式。</strong></p>
<p>上面这两类SA都是由IKE协议协商产生的。</p>
<p>建立IPSec的SA主要有两种方式，手工方式和IKE自动协商的方式，现网中都是用IKE方式建立的，两者的主要区别为：</p>
<ul>
<li>密钥生成方式不同。手工方式下，建立SA所需的全部参数，包括加密、验证密钥都需要用户手工配置，也只能手工配置，在中大型网络中，这种方式的密钥管理成本很高；IKE方式下，建立SA需要的加密、验证密钥，是通过DH算法生成的，可以动态刷新，因此密钥管理成本低，而且安全性较高，所以现网中都是用IKE方式建立的；</li>
<li>生命周期不同。手工方式建立的SA，一旦建立就永久存在；IKE方式建立的SA，生存周期由双方配置的生存周期参数控制。</li>
</ul>
<h3 id="阶段1"><a href="#阶段1" class="headerlink" title="阶段1"></a>阶段1</h3><p>阶段一是一个进行‘设置’的阶段，由于IPSec是一个框架，可以支持很多具体的技术和协议，所以建立IPSec 隧道之前，先要知道对端设备所使用的具协议和本端设备是否一致，因此要协商这些关于安全的协议和参数，两个设备之间协商后为ISAKMP创建了SA（Security Association，安全关联），也就是ISAKMP SA。SA是指两个设备之间安全相关的信息的集合，这个集合描述了两个设备安全连接的方式，也可以把SA看成是一个合同，这个合同规定了两台设备之间安全通信所使用的具体的安全机制，这个SA安全关联存储在安全关联数据库中（SADB，Security Association DataBase）。一般来说SA都是单向的，但ISAKMP SA是双向的，一旦阶段1建立完成，那么任何一台设备都可以使用ISAKMP SA来为后续的ESP或AH使用，这样还能确保阶段2数据交互的安全。一旦阶段1建立完毕将马上进入阶段2，如果阶段1失败则无法开启阶段2。</p>
<p>整个阶段1又可以分为3个小的步骤，协商、DH密钥交换和验证。</p>
<h4 id="协商"><a href="#协商" class="headerlink" title="协商"></a>协商</h4><p>阶段1的ISAKMP SA（Security Association安全关联）协商的内容如下：</p>
<ul>
<li><p>使用的加密算法，用来加密数据，确保数据的私密性，比如是使用DES、3DES还是AES等算法；</p>
</li>
<li><p>使用的哈希算法，用来验证数据的完整性，比如是使用MD5还是SHA等算法；</p>
</li>
<li><p>使用的身份认证方式，通信的两端需要说明自己是谁，可以使用预共享密钥或数字签名证书的形式；</p>
</li>
<li><p>DH组，全称英文是Diffie-Hellman group，DH组决定了在密钥交换过程中所使用的的秘钥的强度，DH是IPSec产生密钥资源的主要协议，是一种非对称密钥算法。DH组的数字越高，安全性越高，比如DH group5是1536bit，而长度1是768bit，但长度越长需要计算的时间相对更长。Diffie和Hellman是发明了公钥密码技术的两位大牛先驱，在使用公钥加密技术的情况下，不需再像之前一样使用同一个密钥来进行加密和解密，数据使用公钥进行加密（公钥大家都能获取的），使用保密的私钥进行解密（私钥只有通信两端知道），DH组参数（Diffie-Hellman group）定义了如何进行这种加密的属性，IKE中需要制定四个Oakley衍生出来的参数。</p>
</li>
<li><p>周期，也就是IKE步骤1所持续的时间，持续的时间越短意味着安全性越强，因为一旦周期结束就会换另一套密钥，破解难度很大。每个厂家的默认周期不同，一般的周期为一天，也就是86400秒；</p>
</li>
</ul>
<h4 id="DH密钥交换"><a href="#DH密钥交换" class="headerlink" title="DH密钥交换"></a>DH密钥交换</h4><p>DH是一种密钥交换方式，用于生产密钥材料，并通过ISAKMP消息在发送和接收设备之间进行密钥材料交换。然后，两端设备各自计算出完全相同的对称密钥。该对称密钥用于计算加密和验证的密钥。任何时候双方都不会交换真正的密钥，而是交换一些数据，并用这些数据计算出真正的共享秘钥，并且即使第三方获取了双方交换的所有数据，也无法计算出真正的密钥。MD5、SHA1、DES、3DES等算法都可以采用DH算法来共享对称密钥。</p>
<p>当协商的步骤完成后，通信的两端会知道需要使用什么协议，它们会使用协商好的DH组去交换秘钥，密钥交换完毕后，通过一系列的算法，得到加密和处理IKE信息的密钥，最后两端都会有这个共享秘钥，包括加密感兴趣流的密钥也是从这个共享秘钥衍生而来的，可以说这个密钥是所有密钥的始祖。</p>
<h4 id="认证"><a href="#认证" class="headerlink" title="认证"></a>认证</h4><p>在认证这个阶段中，通信两端会用之前协商好的认证方式（比如SHA或MD5）对对端进行身份验证。当验证成功以后，意味着IKE的阶段1已经完成，IKE的阶段1会协商出IKE阶段1的隧道（也叫 ISAKMP 隧道），意味着下一步的通信将在该隧道上安全的进行。</p>
<h4 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h4><p>阶段1的以上三个小步骤可以使用两种模式完成：主模式（Main mode）和主动模式（Aggressive mode）。</p>
<h3 id="阶段2"><a href="#阶段2" class="headerlink" title="阶段2"></a>阶段2</h3><p>在这个阶段，其他安全协议会使用阶段1建立好的ISAKMP SA，来为自己（其他安全协议）建立SA，通常来说，这个阶段，是<strong>基于感兴</strong>（所以policy中有感兴趣流）趣流去协商、建立‘真正的’SA安全关联，因为这个SA才是用来给ESP或AH使用的，用来保护那些需要传输的数据。IKE阶段二协商SA和密钥，用于保护真正传输的数据。</p>
<p><img src="/2022/01/20/15-VPN/1622789653451-125f3166-8ef0-4799-9c26-bb3c1553f25e.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621647707547-91fbb87b-d3b0-44bf-b07b-067fc2a93d19.png" alt="img"></p>
<p>在阶段2中也需要协商一些参数：</p>
<ul>
<li><p>使用哪种IPSec的协议，是AH还是ESP；</p>
</li>
<li><p>使用哪种封装模式，是Transport模式还是Tunnel模式；</p>
</li>
<li><p>使用哪种加密算法，是DES、3DES还是AES；</p>
</li>
<li><p>使用哪种认证方式，是MD5还是SHA；</p>
</li>
<li><p>生存周期为多久，也就是IKE阶段2存在的时间是多久，当隧道将要过期时，会更换另一套密钥；</p>
</li>
<li><p>DH交换（可选），DH交换用来确保‘完全向前保密’，这个步骤可选，大概过程是强迫通信两端再次进行DH交换，为IKE第二阶段生成一个新的密钥，能更好的确保通信时的安全；</p>
</li>
</ul>
<h3 id="阶段1VS阶段2"><a href="#阶段1VS阶段2" class="headerlink" title="阶段1VS阶段2"></a><a href="https://www.ibm.com/support/pages/what-are-distinctions-between-phase-1-and-phase-2-security-association">阶段1VS阶段2</a></h3><ul>
<li><p>SA保护的对象不同。阶段1的SA用来保护通信两端的IKE报文；而阶段2的SA则用来保护感兴趣流，也就是需要加密的通信数据；</p>
</li>
<li><p>SA的属性不同。阶段1的SA只能指定一个IP地址作为加密点，阶段2的SA能定义一系列IP地址作为通信点；</p>
</li>
<li><p>SA的出现频率不同。阶段2信息出现得非常频繁（有效期小时），但IKE第一阶段的信息每一天发生一次（有效期一天）；</p>
</li>
<li><p>阶段1的1-4数据包是明文的，阶段1的5-6数据包以及阶段2的1-3数据包是密文；</p>
</li>
</ul>
<h3 id="数据交换过程"><a href="#数据交换过程" class="headerlink" title="数据交换过程"></a>数据交换过程</h3><p><img src="/2022/01/20/15-VPN/1621416722943-4f4a9b85-51f6-4399-b17d-401ebc5b7bb3.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621841547159-f4361c20-e4b0-409b-9cb5-3b607e739bd5.png" alt="img"></p>
<p>阶段1可以使用两种模式来完成数据包的交换，分别是主模式（Main mode）和主动模式（Aggressive mode）。主模式使用六个数据包进行交互，主动模式使用三个数据包进行交互。不管使用几个数据包，其主要目的是对建立IPSec的双方来进行认证，以确保只有合法的对等体才能建立IPSec VPN，协商的结果就是IKE SA。</p>
<p>第二阶段总是使用三个数据包的交换来完成，主要目的是根据需要加密的实际流量（感兴趣流），来协商保护这些流量的策略，第二阶段协商的结果就是IPSec SA。</p>
<p>只有通过预共享密钥认证的远程访问VPN（思科叫做EZVPN）的情况下，第一阶段才会使用主动模式，也就是3个包的方式来完成第一阶段。</p>
<h4 id="阶段1-1"><a href="#阶段1-1" class="headerlink" title="阶段1"></a>阶段1</h4><p>阶段1可以使用两种模式来完成数据包的交换，分别是主模式（Main mode）和主动模式（Aggressive mode）。主模式使用六个ISAKMP数据包进行交互，主动模式使用三个ISAKMP数据包进行交互。不管使用几个数据包，其主要目的是对建立IPSec的双方来进行认证，以确保只有合法的对等体才能建立IPSec VPN，协商的结果就是IKE SA。第一阶段如果完成，一方面标志着收发双方认证通过，还标志着会建立一个双向的ISAKMP/IKE  SA（安全关联），这个SA维护了处理ISAKMP/IKE流量的相关策略（这些策略不会处理实际感兴趣流），而对等体双方还会继续使用这个SA来保护后续阶段2的IKE快速模式3个包的交换过程。</p>
<p>我们先看主模式下的6个包交互的过程：</p>
<p><img src="/2022/01/20/15-VPN/1621648229334-3347ea9e-05d8-4ca8-838b-061ec5b5aa61.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1622789361245-5f7f9cae-bcdd-4b5e-9a53-b42bd57d98e0.png" alt="img"></p>
<p><strong>第一、二个包</strong></p>
<p>主模式数据包1和2主要负责完成两个任务：</p>
<ol>
<li>通过核对收到ISAKMP数据包的源IP地址，来确认收到的ISAKMP数据包是否源自于合法的对等体（Peer，相当于合法的通信对象）；</li>
<li>协商IKE策略；IKE策略包含加密策略、散列函数、DH组、认证方式、密钥有效期。但这个策略不是用于实际加密通信点之间流量的策略；</li>
</ol>
<p>数据包1的wireshark抓包如下：</p>
<p><img src="/2022/01/20/15-VPN/1621653683948-1b2305d7-8ffd-4dad-9a9d-d2df7eab4d44.png" alt="img"></p>
<p>通信的发起者站点1（那个想要建立起隧道的设备）将会发送第一个数据包，这个数据包是建立SA的提议，上面抓包中可以看到，发起者的IP地址是192.168.12.1，收到这个数据包的的对端IP地址是192.168.12.2，并且IKE使用了UDP端口500，抓包中发起者的SPI（Security Parameter Index，安全参数索引）是一个用来标识SA的唯一值。抓包中还能看到，使用的IKE协议版本为1.0，模式为主模式，后面的Payload负载中可以找到发起者希望在SA中使用的参数，比如使用AES算法进行加密、秘钥长度为128位等。</p>
<p>192.168.12.2收到第一个ISAKMP数据包后首先会查看该数据包的源IP地址，如果这个源地址是需要建立IPSec的地址，那么它就会接受这个包，反之则会终止整个协商进程，因为站点2并不希望和不合法的对等体建立IPSec VPN。当站点2确定接收站点1发来的第一个ISAKMP数据包后，它将会回复数据包2，,告诉VPN发起方站点1，同意使用负载中的那些参数来建立连接，数据包2的抓包如下，可以看到站点2使用另一个唯一的SPI值：</p>
<p><img src="/2022/01/20/15-VPN/1621654332594-b168b954-068b-442a-bbd6-e9505e6036d8.png" alt="img"></p>
<p>由于IPSec只规定了框架，没有规定具体使用的协议，所以通信双方可能会支持多协议，前两个包在协商这些具体使用协议的大概过程如下：</p>
<p><img src="/2022/01/20/15-VPN/1621656253656-629d5776-35d0-4c16-8911-a3aa25dc8770.png" alt="img"></p>
<p>站点2接收方首先使用本地策略Policy10，来检查对方发过来的全部策略，如果不匹配就由下一个有线的策略来检查，直到找到一个匹配的策略为止。有了这些结果，在后续交换数据包3-6的时候，就可以使用1-2数据包协商好的策略来进行处理了。</p>
<p><strong>第三、四个包</strong></p>
<p><img src="/2022/01/20/15-VPN/1621656772548-7df805ce-25ab-426a-9ffb-526d1428ef58.png" alt="img"></p>
<p>前两个数据包已经协商出了IKE策略，但仅仅使用上面协商好的加密策略和散列函数来保护IKE还缺一个重要的内容，密钥。加密和HMAC都需要使用秘钥，这个密钥如何产生呢？从DH交换中使用Diffie-Hellman算法产生。所以3-4个数据包开始交换DH密钥，上图中的Payload中就是交换的参数。</p>
<p>站点2也会发送它关于DH算法所需要交换的参数：</p>
<p><img src="/2022/01/20/15-VPN/1621657155784-e0f12856-63c9-4acb-93e2-2d5a719fc601.png" alt="img"></p>
<p>交互完DH所需要的参数后，两端使用DH算法计算出了加密和HMAC处理  IKE信息的密钥，加密感兴趣流的密钥也是从这个密钥衍生出来的，可以说是所有密钥的始祖。</p>
<p><strong>第五、六个包</strong></p>
<p><img src="/2022/01/20/15-VPN/1621657428156-7c07a76b-60f7-45e2-b702-39823447cee0.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621657440534-75ba4ce1-49f5-4dd4-9b36-5bbea2824354.png" alt="img"></p>
<p>第五、六个数据包用来在安全的环境下进行认证，从IKE主模式的第五、第六个数据包开始以后，都会使用之前几个数据包协商出来的加密与HMAC算法进行安全保护，所以抓包中看不到具体的内容。前面的1-4个包的交换，只是在为IKE5-6包做认证铺垫，其中1-2是为认证做好策略（比如认证策略，加密策略和散列函数等），3-4包提供密钥以供后面使用。</p>
<p>6个数据包交换完毕后，IKE 阶段1的主模式已经完成，开始阶段2。</p>
<h4 id="阶段2-1"><a href="#阶段2-1" class="headerlink" title="阶段2"></a>阶段2</h4><p><img src="/2022/01/20/15-VPN/1622789405532-00ef8b69-f261-4967-8a78-b9ea81f2d3a8.png" alt="img"></p>
<p>第二阶段总是使用三个数据包的交换来完成，主要目的是根据需要加密的实际流量（感兴趣流），来协商保护这些流量的策略，第二阶段协商的结果就是IPSec SA，比如使用AH还是ESP，使用Transport还是Tunnel，使用哪种加密\认证算法，DH如何交换，生存周期为多久。在阶段2中建立IPSec Tunnel的方式只有快速模式（Quick mode），抓包如下：</p>
<p><img src="/2022/01/20/15-VPN/1621670160150-79fc2c57-d0fb-4845-ba38-244ab10cdbec.png" alt="img"></p>
<p>第一个及第二个数据包主要协商HASH值，SA提案，IPSec转换机，密钥材料以及感兴趣流；</p>
<p>第三个包为，HASH用于确认隧道建立，只是确认而已。</p>
<h2 id="ESP-amp-AH"><a href="#ESP-amp-AH" class="headerlink" title="ESP&amp;AH"></a>ESP&amp;AH</h2><h2 id><a href="#" class="headerlink" title></a><img src="/2022/01/20/15-VPN/1620114697497-c474dadc-7c78-424a-a31f-ec9851abca8b.png" alt="img"></h2><p>IPSec通过在数据包中插入一个预定义头部的方式，来保障OSI上层协议数据的安全，主要用于保护网络层（IP）数据，因此它提供了网络层的安全性。从上图中可以看出，IPSec在原始的IP头部和IP负载之间加入了一个IPSec头部，这样可以对原始的IP负载实现加密，同时还可以实现对IPSec头部和原始IP负载的验证，以确保数据的完整性。这个头部用来告诉接收方，如何去解密，如果加密没有头部，那么接收方收到以后会一脸懵逼，不知道应该如何去解密。</p>
<p>IPSec有两种头部也就是两种协议，可以将他们理解为是协议，但更严格的来说，是两种嵌入数据中的报头，它们分别是ESP和AH：</p>
<h3 id="AH"><a href="#AH" class="headerlink" title="AH"></a>AH</h3><p>AH全称为Authentication Header，它是一个基于IP的传输层协议，协议号为51，通过添加一个根据数据段中的值所计算出来的AH报头，对数据段的全部或部分内容进行认证（AH is a protocol that provides authentication of either all or part of the contents of a datagram through the addition of a header that is calculated based on the values in the datagram. ）。AH只提供了身份验证机制，可以提供数据完整性验证（Data Integrity）、数据源身份认证（Data Origin Authentication）以及可选的对重放攻击的保护（未认证用户大量且反复的发送数据）。数据完整性验证由算法生成的摘要来确保，比如HMAC-MD5或HMAC-SHA算法；数据源身份验证由共享密钥生成的信息摘要确保；重放攻击防护由AH头部的序列号字段来提供保护。AH对IP报头和它的负载提供了完整性校验，但某些字段可能在传输过程中出现合理的变化，比如TTL字段。但AH不提供保密性，也就是说它不会对数据进行加密，数据可以被读取但禁止修改。AH由于无法加密使得它在现网中出现的几率不大。</p>
<p>AH提供身份认证，它起作用的方式和CRC校验有点类似，CRC使用固定的算法，根据传输数据的内容计算出一个校验值，这个校验值随着原始数据一起发送给接收端，接收端会重新计算一遍，如果计算结果和发送端计算的不同，那么说明数据在传输过程中被更改了，这个数据会被丢弃。AH和上面的概念有点像，不过AH不像CRC一样只用一个简单的算法来验证，而是使用一个特定的哈希算法以及特定的密钥（这个密钥只有通信的发送方和接收方知道），两个设备协商出来的SA会决定这些信息，以便两边设备知道如何计算出‘校验值’而其他设备无法计算出这个值。在信息的发送端，AH完成完整性校验并计算出ICV（Integrity Check Value，完整性校验值），并将这个值放入报头中的Authentication Data部分，然后发给接收端。接收端收到以后会用同样的算法以及两设备之间共享的密钥进行计算，如果计算出的值和发送端相同，则表明数据未经篡改，如果计算出的值不同则表示数据被更改了。</p>
<p><strong>AH协议的完整性验证范围为整个IP报文。</strong></p>
<h4 id="报头格式"><a href="#报头格式" class="headerlink" title="报头格式"></a>报头格式</h4><p><img src="/2022/01/20/15-VPN/1621841814395-8b66e52a-d34a-42b8-8206-9cb233aadbef.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621672449208-b07f7648-39a5-4729-88c1-657b87f29641.png" alt="img"></p>
<ul>
<li>Next Header：下一个报头，使用IP协议ID来标识IP负载。例如TCP数据中，传输模式值为6表示下一个报头为IP报头；</li>
</ul>
<p><img src="/2022/01/20/15-VPN/1621680833310-c6871ae5-e61e-4136-9578-71393889dca7.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621680839155-400edc38-e35f-4b7b-af57-711bd61000ce.png" alt="img"></p>
<ul>
<li><p>Payload Length：负载长度，表示AH报头的长度；</p>
</li>
<li><p>Reserved：保留字段，设置为全0；</p>
</li>
<li><p>SPI：Security Parameter Index，安全索引，与目标地址及安全协议（也就是AH）组合使用，以确保通信的正确安全关联，接收方用SPI确定这个数据包是使用哪一个安全关联的；</p>
</li>
<li><p>Sequence Number：序列号，这是一个计数器性质的字段，标识通过SA所发送的数据包的数量。当两个设备之间的SA建立之初，值为0，随着使用该SA传输数据的增加，该值一起增加。该字段唯一标识了SA上的数据段，用来防止重放攻击；</p>
</li>
<li><p>Authentication Data：认证数据，该字段包含了AH协议所执行的哈希算法的结果，也就是完整性检查值（Integrity Check Value，ICV）；</p>
</li>
</ul>
<p><img src="/2022/01/20/15-VPN/1621680958845-26b3575b-db31-44cf-98f1-21932d15afc6.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621841900432-7d02648a-1ab5-4ae5-a633-abaee09a2d92.png" alt="img"></p>
<h3 id="ESP"><a href="#ESP" class="headerlink" title="ESP"></a>ESP</h3><p>上边提到的AH可以提供数据完整性校验，但在现网中仅仅有数据完整性校验是不够的，我们还需要防止中间设备获取通信的内容，也就是保证通信的私密性，这点AH无法做到，所以需要使用ESP协议。</p>
<p>ESP全称为Encapsulating Security Payload，也是基于IP的传输层协议，协议号为50，ESP不仅提供了认证功能（包含数据完整性验证、数据源身份认证以及重放攻击保户），相比AH来说，ESP还额外提供了数据私密性（通过加密算法）。其中数据完整性由MD5或SHA这种验证完整性的算法通过生成消息摘要来确保；数据源认证，由共享密钥创建的消息摘要确保；重放攻击保户，由AH头部中的序列号确保；</p>
<p>ESP也可以值提供以上所有的功能，也可以单独提供其中的一个或两个功能，比如只提供数据私密性功能，或者只提供认证功能，或者同时提供数据私密性和认证功能。</p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2022/01/20/15-VPN/1621842635839-9cad1dc4-aee7-494c-9075-7b41872b86fc.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1621842501612-9fbff2fe-e0b3-4881-afef-1fc8c86aaebb.png" alt="img"></p>
<ul>
<li><p>SPI：全称为Security Parameters Index，安全参数索引，用于唯一标识IPSec SA；</p>
</li>
<li><p>Sequence Number：序列号，是一个从1开始的单项递增的计数器，唯一的标识每一个数据包，用于防止重放攻击，因为收到相同序列号的数据包可以直接丢弃；</p>
</li>
<li><p>ESP Payload Data：包含由下一头部字段给出的边长数据；</p>
</li>
<li><p>Padding：填充字段，用于增加ESP报文头部的位数，填充字段的长度与负载数据的长度和算法油管，当待加密报文的明文长度不是密文算法所要求的长度时，需要进行填充补齐；</p>
</li>
<li><p>Pad Length：填充长度，给出前面填充字段的长度，如果为0时表示没有填充；</p>
</li>
<li><p>Next Header：标识ESP报文后面的下一个负载类型，传输模式下，这个字段是被保护的上层协议（TCP或UDP）的编号，隧道模式下，是IP协议的编号；</p>
</li>
<li><p>ESP Authentication Data：认证数据，该字段包含完整性校验值ICV，用于接收方进行完整性校验，可选择的认证算法与AH的相同。ESP的验证功能是可选的，如果启动了数据包验证，会在加密数据的尾部添加一个ICV值；</p>
</li>
</ul>
<p><img src="/2022/01/20/15-VPN/1621844010913-83347485-6c70-45c9-b914-c7f4257bad95.png" alt="img"></p>
<h3 id="AH-VS-ESP"><a href="#AH-VS-ESP" class="headerlink" title="AH VS ESP"></a>AH VS ESP</h3><p><img src="/2022/01/20/15-VPN/1621844031767-51de0218-76ae-45f2-ab1a-11ba785c8701.png" alt="img"></p>
<h2 id="IPSec两种模式"><a href="#IPSec两种模式" class="headerlink" title="IPSec两种模式"></a>IPSec两种模式</h2><p>IPSec共有两种模式，Transport模式和Tunnel模式，选择不同的模式不会对插入的报头有任何影响，但不同的模式会中，受到保护的部分不同，并且也会影响报头如何进行保护。本质上来说，模式是不是用来定义AH或ESP如何执行操作的，而是用来定义其他构成因素的基础，比如SA（Security Associations）。</p>
<h3 id="Transport-Mode"><a href="#Transport-Mode" class="headerlink" title="Transport Mode"></a>Transport Mode</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>Transport模式，中文名为传输模式，在终端到终端传输的时候使用该模式，比如一个终端客户和服务器之间的通信，或者一个工作站和网关（网关被对待成另一个终端）之间的通信，在现网中，Transport模式通常在有其他Tunnel协议（比如GRE）出现的时候使用，在这种情况下，IPSec用作保护在Tunnel上的GRE流量：</p>
<p><img src="/2022/01/20/15-VPN/1620701023549-7c7ddfaa-24a4-46ff-bb65-db456f9f3583.gif" alt="img"></p>
<p>在上图中，服务器和电脑既是实际的通信，也是实际的加密设备，这两台设备既要相互通信，也只能自己加密，所以加密点等于通信点，只要能满足加密点等于通信点的条件就可以进行Transport模式的封装。</p>
<p>Transport模式使用AH或ESP报头为数据提供保护，也就是IP层的Payload，IP层的载荷，Payload载荷又由TCP/UDP报头加上数据构成，在Transport模式下，不管是使用AH还是ESP报头用来保护数据，IP报头都不被保护。载荷由IPSec报头及尾部封装而成，原有的IP报头基本保持不变，不过IP protocol字段需要变为ESP（50）或AH（51），原有的IP protocol字段信息被保存在IPSec尾部中，以便接收设备进行解封装使用。</p>
<p>现在来看Transport模式下的数据结构，先看ESP封装，ESP报头被插到了三层报头和四层报头之间，也就是原有的IP层报头会被挪到最前端，并对protocol字段进行了少许修改，从上面这些也能看出来，Transport模式下不会对原始的IP报头进行保护或加密，因为IP报头在ESP报头前面，没有被ESP所‘包含’。ESP在新的IP报头中，被识别为Protocol ID，50。Transport模式下，传输层报头、传输层负载、ESP尾部被加密，ESP头部、传输层报头、传输层负载和ESP尾部进行验证处理。</p>
<p><img src="/2022/01/20/15-VPN/1620702680187-7ef84075-181b-4a67-96ff-8ce377a42cfb.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620779973358-80d4807f-e8e4-4170-a027-eb02b2a3a90a.png" alt="img"></p>
<p>接下来看Transport模式下使用AH报头，当使用Transport模式时，AH可以独立适用，也可以和ESP一起使用，AH的作用是保护整个数据包，和前面提到的ESP的Transport模式差不多，在Transport模式下使用AH报头的数据，也没有重新生成新的IP报头，而是将IP报头中的Protocol ID字段改为51，表示后面跟着的协议为AH，然后将AH报头插入在IP报头和传输层报头之间。</p>
<p><img src="/2022/01/20/15-VPN/1620703041742-77ba46ba-1e7b-40f9-8c89-75cfdfbb3a41.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620466010847-2f4cbd4e-75d0-4197-90d1-22ed2a8873ec.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620467089396-1266c060-9c77-4a42-bd47-30b412b81f36.png" alt="img"></p>
<h4 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h4><p>通信点地址和加密点地址相同；通信点地址可以被路由。</p>
<h3 id="Tunnel-Mode"><a href="#Tunnel-Mode" class="headerlink" title="Tunnel Mode"></a>Tunnel Mode</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>Tunnel模式是默认模式，使用该模式的时候，IPSec会保护整个IP数据包，这意味着IPSec会将原始数据封装起来进行加密，然后加上新的IP报头，再将全新封装好的数据通过VPN Tunnel发送到另一边。</p>
<p>Tunnel模式主要用在网关之间的通信或者终端和网关之间的通信（这时网关充当它背后主机的代理）：</p>
<p><img src="/2022/01/20/15-VPN/1620782664256-b64f1955-a5d4-4e03-9780-fe43a6def775.gif" alt="img"></p>
<p>比如上图中，分支站点有一台电脑要通过站点到站点的IPSecVPN来访问中心站点的服务器，这两台电脑就是通信点，而真正对数据进行加密的设备时两个站点连接互联网的路由器，假设分支站点点路由器获取的互联网地址为202.101.1.1，中心站点的互联网地址为62.128.2.1，那么路由器的这两个地址就是加密点。很明显加密点不等于通信点，这时就应该采用Tunnel模式来对数据进行封装。</p>
<p>在Tunnel模式下，IPSec报头（ESP或AH报头）用来保护已经封装好的完整的IP数据包。IPSec报头插入在原始的IP报头前面，并且会在IPSec的报头前，再插入一个新的IP报头，也就是说，原始的IP报头不会暴露在网络中，也是安全的，然后原始的IP报头会被封装在另一个IP数据包中。如果使用ESP的话，新的IP报头中的Protocol ID字段为50；如果使用AH的话，新的IP报头中的Protocol ID字段为51。</p>
<p><img src="/2022/01/20/15-VPN/1620783333605-146224d7-ac89-4f8d-9c64-659882743cfa.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620783339355-624f87e4-f3e8-4796-9221-0b51b7a13b98.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620783343721-7c959483-ed74-49cc-87d5-90c18084274f.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1620783429631-d52d7cb8-79d9-4b3d-8093-41e04a51f764.png" alt="img"></p>
<h4 id="判断方法-1"><a href="#判断方法-1" class="headerlink" title="判断方法"></a>判断方法</h4><p>通信点地址和加密点地址不同；通信点地址到Internet不能被路由则肯定是隧道模式。</p>
<h3 id="两者比较"><a href="#两者比较" class="headerlink" title="两者比较"></a>两者比较</h3><p>Tunnel模式会将原始的IP数据包看成一个整体，并将这个包含了原始IP报头的整体进行保护；而Transport模式则不会保护原始的IP报头，因此一般而言，报头的顺序如下：</p>
<ul>
<li>Transport模式：IP报头、IPSec报头（AH或ESP）、IP层负载（包含了传输层报头）；</li>
<li>Tunnel模式：新IP报头、IPSec报头（AH或ESP）、旧的IP报头、IP层负载；</li>
</ul>
<p><strong>SOLUTION:</strong></p>
<p><strong>Tunnel mode</strong>:</p>
<ul>
<li><p>Tunnel mode protects the internal routing information by encrypting the IP header of the original packet. The original packet is encapsulated by a another set of IP headers.</p>
</li>
<li><p>It is widely implemented in site-to-site VPN scenarios.</p>
</li>
<li><p>NAT traversal is supported with the tunnel mode.</p>
</li>
<li><p>Additional headers are added to the packet; so the payload MSS is less.</p>
</li>
</ul>
<p><strong>Transport mode</strong>:</p>
<ul>
<li><p>The transport mode encrypts only the payload and ESP trailer; so the IP header of the original packet is not encrypted.</p>
</li>
<li><p>The IPsec Transport mode is implemented for client-to-site VPN scenarios.</p>
</li>
<li><p>NAT traversal is not supported with the transport mode.</p>
</li>
<li><p>MSS is higher, when compared to Tunnel mode, as no additional headers are required.</p>
</li>
<li><p>The transport mode is usually used when another tunneling protocol (such as GRE, L2TP) is used to first encapsulate the IP data packet, then IPsec is used to protect the GRE/L2TP tunnel packets.</p>
</li>
</ul>
<p>从安全性来讲，隧道模式优于传输模式，它可以完全的对原始IP数据包进行验证和加密，隧道模式下隐藏内部IP地址，协议类型和端口；</p>
<p>从性能来讲，隧道模式因为有一个额外的IP头，所以它将比传输模式占用更多的带宽。</p>
<h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2><p>对称密钥算法和非对称密钥算法各自都有相应的优缺点，对称密钥算法加密速度快，但密钥不好管理，且分发密钥的过程不安全，一旦密钥被窃取就完蛋了；非对称密钥算法密钥数量少，分发方便且不存在安全隐患，但加密速度奇慢无比，不可能用于大流量数据的加密。所以在实际使用加密算法的时候，一般会让两种算法共同工作，发挥其各自的优点。</p>
<h3 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h3><p><img src="/2022/01/20/15-VPN/1621397404351-138fbb3b-f2dd-4cbd-8584-909558c74600.png" alt="img"></p>
<p>简单来说就是首先使用对称密钥加密明文，得到密文；然后使用非对称密钥算法（用对端的公钥），加密上一步的密钥（对称加密算法的密钥）得到密钥包。</p>
<p>具体步骤如下：</p>
<ol>
<li><p>用户1，也就是发起方，使用本地随机数产生器，产生用于对称密钥算法的随机密钥。如果使用的对称密钥算法是DES（DES的密钥长度为56bit），也就是说随机数产生器需要产生随机的56个数字，比如‘00011101011000100101….’用于加密数据；</p>
</li>
<li><p>使用步骤1产生的随机密钥，对重要的明文信息通过对称加密算法进行加密，得到密文，这个过程利用了对称加密算法速度快和加密后数据紧凑的特点；</p>
</li>
<li><p>用户1，也就是发起方，需要预先获取用户2，也就是接收方的公钥，并使用用户2的公钥，对步骤1产生的随机密钥进行加密，得到加密的密钥包；</p>
</li>
<li><p>将上两个步骤产生的密文和密钥包进行打包，一起发给接收方。</p>
</li>
</ol>
<h3 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h3><p><img src="/2022/01/20/15-VPN/1621408656867-40e34b2d-cfb2-4c00-a898-4ed1a166b102.png" alt="img"></p>
<p>大概步骤是，使用自己的私钥从密钥包中得到明文的对称密钥，然后用对称密钥解密密文，得到明文数据。</p>
<ol>
<li>用户2首先提取出密钥包，并且使用自己的私钥对它进行解密，并得到密钥，这个密钥是明文的密钥。这个明文密钥之所以使用非对称密钥算法进行交换，能够有效的防止密钥在中途被劫持；</li>
<li>用户2提取出密文，然后用上一个步骤中得到的密钥解密，得到明文信息。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在这个解决方案中，使用了对称密钥算法对实际传输的数据进行了加密，利用的是对称算法加密速度快、加密后数据紧凑的特点。同时也使用了非对称式加密算法，加密的是对称式加密算法的密钥，从而保证了密钥交换的安全性，利用的是非对称式加密算法不怕中途劫持的特点，因为即使被中途劫持了，劫持者没有私钥依旧无法对数据进行解密，没法获取数据实际的明文内容。</p>
<h2 id="GRE-amp-IPSec"><a href="#GRE-amp-IPSec" class="headerlink" title="GRE&amp;IPSec"></a>GRE&amp;IPSec</h2><p>由于IPSec不支持IP协议的封装，不支持多上层协议，也不支持组播，但GRE支持多种上层协议、支持组播（意味着可以运行组播类协议，比如OSPF等动态路由协议）和QOS。所以GRE Over IPSec可以使得GRE和IPSec优势互补，通过GRE将组播、广播和非IP报文封装成普通的IP报文，通过IPSec为封装后的IP报文提供安全的通信，进而可以提供在总部和分支之间安全传送广播、组播业务，例如视频会议或动态路由协议报文等。</p>
<p>可以使用GRE over IPSec或IPSec over GRE两种方式来封装。当网关之间采用GRE Over IPSec连接时，先进性GRE封装，再进行IPSec封装。GRE Over IPSec使用的封装模式，可以是隧道模式也可以是传输模式，因为隧道模式和传输模式相比增加了IPSec头，导致报文长度更长，更容易导致分片，所以更推荐采用传输模式GRE Over IPSec。</p>
<p>IPSec over GRE的封装方式现网中很少用到，这里就不展开讲了。</p>
<p><img src="/2022/01/20/15-VPN/1622002486753-987b9c1d-7eb1-4f88-a21c-3a935459fb24.png" alt="img"></p>
<p>GRE over IPSec也有Tunnel和Transport两种模式，默认是Tunnel模式，IPSec会创建一个Tunnel的新IP头；在Transport模式下，IPSec会使用GRE的原有IP报头：</p>
<p><img src="/2022/01/20/15-VPN/1622270596653-ceca33ad-4824-4cc3-a0ae-24a98bd3f597.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1622270659715-e9be0ecc-3fe3-4843-aa2b-6ddfe3891928.png" alt="img"></p>
<p><img src="/2022/01/20/15-VPN/1622270663790-7a5e2879-28bd-4325-b38b-672d2dd83272.png" alt="img"></p>
<p>GRE over IPSec就是IPSec在最外层，或者叫最底层，也就是在R1和R2之间建立IPSec tunnel，把里面的GRE Tunnel整个进行加密。over是在…..只上的意思，IPSec在最底层，GRE 在IPSec的基础上运行所以叫GRE over IPSec。路由协议在GRE tunnel完成路由交换，所有数据在GRE Tunnel中传送，因为整个GRE Tunnel被加密，所以里面的路由协议以及传输的数据都会被加密。</p>
<p><img src="/2022/01/20/15-VPN/1622341990331-6c4033e8-1823-4a69-9d1f-da99acc364a5.png" alt="img"></p>
<h2 id="其他重要概念"><a href="#其他重要概念" class="headerlink" title="其他重要概念"></a>其他重要概念</h2><h3 id="Security-Policies"><a href="#Security-Policies" class="headerlink" title="Security Policies"></a>Security Policies</h3><h3 id="Security-Parameter-Index"><a href="#Security-Parameter-Index" class="headerlink" title="Security Parameter Index"></a>Security Parameter Index</h3><h2 id="IPSec实验"><a href="#IPSec实验" class="headerlink" title="IPSec实验"></a>IPSec实验</h2><p><img src="/2022/01/20/15-VPN/1622254019280-916eb538-10da-4b9c-bbe1-291ab2d9ef92.png" alt="img"></p>
<p>实验需要配置R4和R5之间的Site to Site IPSec VPN。R4、R5为两台主机，网关为R2\R3的E0/0接口。</p>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.1.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 12.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.2.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 13.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 13.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">确保两边可以ping通：</span><br><span class="line">R2#ping 13.1.1.3</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 13.1.1.3, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<h3 id="初始化IPSec"><a href="#初始化IPSec" class="headerlink" title="初始化IPSec"></a>初始化IPSec</h3><p>在前面介绍IPSec总体流程时说过，第一个阶段是初始化，也就是激活ISAKMP，思科设备默认已经激活，配置命令是‘crypto isakmp enable’</p>
<h3 id="设置IKE-Phase-1"><a href="#设置IKE-Phase-1" class="headerlink" title="设置IKE Phase 1"></a>设置IKE Phase 1</h3><p>阶段1主要协商ISAKMP SA的相关参数，因为IPSec只规定了框架，没有规定具体使用的协议且支持多协议，因此需要协商通信双方使用的协议，只有使用了相同的协议才能正常进行加解密、认证等步骤，为阶段2做准备。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">crypto isakmp policy 10</span><br><span class="line">#进入配置ISAKMP模式，每个policy由后边所配置的序号唯一标识</span><br><span class="line"></span><br><span class="line"> encryption aes</span><br><span class="line"> #设置加密算法，默认为DES</span><br><span class="line"> </span><br><span class="line"> hash md5</span><br><span class="line"> #设置完整性校验的散列算法</span><br><span class="line"> </span><br><span class="line"> authentication pre-share</span><br><span class="line"> #一阶段第5-6个包，认证方式为预共享密钥</span><br><span class="line"> </span><br><span class="line"> group 2</span><br><span class="line"> #一阶段第3-4个包，DH交换使用Group2</span><br><span class="line"> </span><br><span class="line"> lifetime 30000</span><br><span class="line"> 设置生存周期，默认为一天，86400秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">crypto isakmp policy 10</span><br><span class="line"> encryption aes</span><br><span class="line"> hash md5</span><br><span class="line"> authentication pre-share</span><br><span class="line"> group 2</span><br><span class="line"> lifetime 30000</span><br></pre></td></tr></table></figure>

<h3 id="设置IKE-Phase-2"><a href="#设置IKE-Phase-2" class="headerlink" title="设置IKE Phase 2"></a>设置IKE Phase 2</h3><p>在阶段2，其他安全协议会使用阶段1建立好的ISAKMP SA来为自己建立SA，这个阶段建立的才是‘真正的’SA安全关联，因为这个SA才是用来给ESP\AH使用，用来保护那些需要传输的数据的。这个阶段需要协商一些参数：</p>
<ul>
<li><p>使用哪种IPSec的协议，是AH还是ESP；</p>
</li>
<li><p>使用哪种封装模式，是Transport模式还是Tunnel模式；</p>
</li>
<li><p>使用哪种加密算法，是DES、3DES还是AES；</p>
</li>
<li><p>使用哪种认证方式，是MD5还是SHA；</p>
</li>
<li><p>生存周期为多久，也就是IKE阶段2存在的时间是多久，当隧道将要过期时，会更换另一套密钥；</p>
</li>
<li><p>DH交换（可选），DH交换用来确保‘完全向前保密’，这个步骤可选，大概过程是强迫通信两端再次进行DH交换，为IKE第二阶段生成一个新的密钥，能更好的确保通信时的安全；</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#crypto ipsec transform-set TS ?</span><br><span class="line">  ah-md5-hmac   AH-HMAC-MD5 transform</span><br><span class="line">  ah-sha-hmac   AH-HMAC-SHA transform</span><br><span class="line">  comp-lzs      IP Compression using the LZS compression algorithm</span><br><span class="line">  esp-3des      ESP transform using 3DES(EDE) cipher (168 bits)</span><br><span class="line">  esp-aes       ESP transform using AES cipher</span><br><span class="line">  esp-des       ESP transform using DES cipher (56 bits)</span><br><span class="line">  esp-md5-hmac  ESP transform using HMAC-MD5 auth</span><br><span class="line">  esp-null      ESP transform w/o cipher</span><br><span class="line">  esp-seal      ESP transform using SEAL cipher (160 bits)</span><br><span class="line">  esp-sha-hmac  ESP transform using HMAC-SHA auth</span><br><span class="line"></span><br><span class="line">设置转换集并进入转换集配置模式，转换集（transform-set）是一个双方使用的安全协议以及安全算法的集合，包含了阶段2协商好的那些协议。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2(config)#crypto ipsec transform-set TS esp-3des ah-sha-hmac</span><br><span class="line">R3(config)#crypto ipsec transform-set TS esp-3des ah-sha-hmac</span><br></pre></td></tr></table></figure>

<h3 id="设定Pre-share-key"><a href="#设定Pre-share-key" class="headerlink" title="设定Pre-share key"></a>设定Pre-share key</h3><p>设定</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#crypto isakmp key 6 ccie address 13.1.1.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3(config)#crypto isakmp key 6 ccie address 12.1.1.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">6表示密码传输是以密文形式，ccie是预共享密钥，12.1.1.2和13.1.1.3是需要共享密钥的地址</span><br></pre></td></tr></table></figure>

<h3 id="设置感兴趣流"><a href="#设置感兴趣流" class="headerlink" title="设置感兴趣流"></a>设置感兴趣流</h3><p>所谓的感兴趣流（Interesting Traffic）就是需要通过VPN保护的流量，在本例中，R1的Interesting Traffic就是由192.168.1.0/24到192.168.2.0/24的流量，而R2正好相反，是从192.168.2.0/24到192.168.1.0/24的，用Access-list将这些流量匹配好。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">ip access-list extended VPN-TRAFFIC</span><br><span class="line"> permit ip 192.168.1.0 0.0.0.255 192.168.2.0 0.0.0.255</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">ip access-list extended VPN-TRAFFIC</span><br><span class="line"> permit ip 192.168.2.0 0.0.0.255 192.168.1.0 0.0.0.255</span><br></pre></td></tr></table></figure>

<h3 id="设置Crypto-Map"><a href="#设置Crypto-Map" class="headerlink" title="设置Crypto Map"></a>设置Crypto Map</h3><p>将刚才设置的参数，都整合放入Crypto Map中，然后在接口上调用这个Map，从接口发出的数据就会使用设置好的IPSec 进行加密：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#crypto map CMAP 1 ipsec-isakmp</span><br><span class="line">% NOTE: This new crypto map will remain disabled until a peer</span><br><span class="line">        and a valid access list have been configured.</span><br><span class="line">R2(config-crypto-map)#set peer 13.1.1.3</span><br><span class="line">R2(config-crypto-map)#set transform-set TS</span><br><span class="line">R2(config-crypto-map)#match address VPN-Traffic</span><br><span class="line">R2(config-crypto-map)#exit</span><br><span class="line">R2(config)#interface ethernet 0/1</span><br><span class="line">R2(config-if)#crypto map CMAP</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3(config)#crypto map CMAP 1 ipsec-isakmp</span><br><span class="line">% NOTE: This new crypto map will remain disabled until a peer</span><br><span class="line">        and a valid access list have been configured.</span><br><span class="line">R3(config-crypto-map)#set peer 12.1.1.2</span><br><span class="line">R3(config-crypto-map)#set transform-set TS</span><br><span class="line">R3(config-crypto-map)#match address VPN-Traffic</span><br><span class="line">R3(config-crypto-map)#exit</span><br><span class="line">R3(config)#interface ethernet 0/0</span><br><span class="line">R3(config-if)#crypto map CMAP</span><br></pre></td></tr></table></figure>

<h3 id="验证测试"><a href="#验证测试" class="headerlink" title="验证测试"></a>验证测试</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#ping 192.168.2.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.2.1, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/15-VPN/1622260587962-19b7840d-0542-4a00-bb1d-76a24d7dfa3a.png" alt="img"></p>
<p>从抓包中能看到，无法知道具体传输了什么内容，只知道Payload是ESP。</p>
<h4 id="查看第一阶段建立"><a href="#查看第一阶段建立" class="headerlink" title="查看第一阶段建立"></a>查看第一阶段建立</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show crypto isakmp sa</span><br><span class="line">IPv4 Crypto ISAKMP SA</span><br><span class="line">dst             src             state          conn-id status</span><br><span class="line">13.1.1.3        12.1.1.2        QM_IDLE           1001 ACTIVE</span><br></pre></td></tr></table></figure>

<h4 id="查看第二阶段建立"><a href="#查看第二阶段建立" class="headerlink" title="查看第二阶段建立"></a>查看第二阶段建立</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show crypto ipsec sa</span><br><span class="line"></span><br><span class="line">interface: Ethernet0/1</span><br><span class="line">    Crypto map tag: CMAP, local addr 12.1.1.2</span><br><span class="line"></span><br><span class="line">   protected vrf: (none)</span><br><span class="line">   local  ident (addr/mask/prot/port): (192.168.1.0/255.255.255.0/0/0)</span><br><span class="line">   remote ident (addr/mask/prot/port): (192.168.2.0/255.255.255.0/0/0)</span><br><span class="line">   current_peer 13.1.1.3 port 500</span><br><span class="line">     PERMIT, flags=&#123;origin_is_acl,&#125;</span><br><span class="line">    #pkts encaps: 9, #pkts encrypt: 9, #pkts digest: 9</span><br><span class="line">    #pkts decaps: 9, #pkts decrypt: 9, #pkts verify: 9</span><br><span class="line">    #pkts compressed: 0, #pkts decompressed: 0</span><br><span class="line">    #pkts not compressed: 0, #pkts compr. failed: 0</span><br><span class="line">    #pkts not decompressed: 0, #pkts decompress failed: 0</span><br><span class="line">    #send errors 0, #recv errors 0</span><br><span class="line"></span><br><span class="line">     local crypto endpt.: 12.1.1.2, remote crypto endpt.: 13.1.1.3</span><br><span class="line">     plaintext mtu 1438, path mtu 1500, ip mtu 1500, ip mtu idb Ethernet0/1</span><br><span class="line">     current outbound spi: 0x36EDBC65(921549925)</span><br><span class="line">     PFS (Y/N): N, DH group: none</span><br><span class="line"></span><br><span class="line">     inbound esp sas:</span><br><span class="line">      spi: 0x7809602A(2013880362)</span><br><span class="line">        transform: esp-3des ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 5, flow_id: SW:5, sibling_flags 80000070, crypto map: CMAP</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4251466/3356)</span><br><span class="line">        IV size: 8 bytes</span><br><span class="line">        replay detection support: Y</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     inbound ah sas:</span><br><span class="line">      spi: 0x8C299743(2351535939)</span><br><span class="line">        transform: ah-sha-hmac ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 5, flow_id: SW:5, sibling_flags 80000070, crypto map: CMAP</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4251466/3356)</span><br><span class="line">        replay detection support: Y</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     inbound pcp sas:</span><br><span class="line"></span><br><span class="line">     outbound esp sas:</span><br><span class="line">      spi: 0x27E3BDAF(669236655)</span><br><span class="line">        transform: esp-3des ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 6, flow_id: SW:6, sibling_flags 80000070, crypto map: CMAP</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4251466/3356)</span><br><span class="line">        IV size: 8 bytes</span><br><span class="line">        replay detection support: Y</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     outbound ah sas:</span><br><span class="line">      spi: 0x36EDBC65(921549925)</span><br><span class="line">        transform: ah-sha-hmac ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 6, flow_id: SW:6, sibling_flags 80000070, crypto map: CMAP</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4251466/3356)</span><br><span class="line">        replay detection support: Y</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     outbound pcp sas:</span><br></pre></td></tr></table></figure>

<h2 id="GRE-over-IPSec实验"><a href="#GRE-over-IPSec实验" class="headerlink" title="GRE over IPSec实验"></a>GRE over IPSec实验</h2><p><img src="/2022/01/20/15-VPN/1622020979115-d750e6e4-df7a-47ed-bb03-52fbb2251863.png" alt="img"></p>
<p>本实验需要在R1和R2这两个站点之间建立GRE隧道Tunnel0，Tunnel的网段为172.16.12.0/24，另外还需要在GRE隧道上运行OSPF，使得两个站点通过动态路由协议学习到身后网络的路由，1.1.1.0/24和2.2.2.0/24，最后配置IPSec VPN，对两个站点之间的GRE流量进行加密。</p>
<h3 id="基础设置"><a href="#基础设置" class="headerlink" title="基础设置"></a>基础设置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.13.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 0.0.0.0 0.0.0.0 192.168.23.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 验证确保只有192.168.13.1 能 Ping 通 192.168.23.2：</span><br><span class="line"> R1(config)#do ping 192.168.23.2</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.23.2, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#ping 2.2.2.2 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 1.1.1.1</span><br><span class="line">.....</span><br><span class="line">Success rate is 0 percent (0/5)</span><br></pre></td></tr></table></figure>

<h3 id="配置GRE隧道"><a href="#配置GRE隧道" class="headerlink" title="配置GRE隧道"></a>配置GRE隧道</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 172.16.12.1 255.255.255.0</span><br><span class="line"> tunnel source Ethernet0/0</span><br><span class="line"> tunnel destination 192.168.23.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 172.16.12.2 255.255.255.0</span><br><span class="line"> tunnel source Ethernet0/0</span><br><span class="line"> tunnel destination 192.168.13.1</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">测试GRE隧道：</span><br><span class="line">R1#ping 172.16.12.2</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 172.16.12.2, timeout is 2 seconds:</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<h3 id="配置路由协议"><a href="#配置路由协议" class="headerlink" title="配置路由协议"></a>配置路由协议</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 172.16.12.1 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 172.16.12.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show ip ospf nei</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Address         Interface</span><br><span class="line">2.2.2.2           0   FULL/  -        00:00:39    172.16.12.2     Tunnel0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show ip route ospf</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is 192.168.13.3 to network 0.0.0.0</span><br><span class="line"></span><br><span class="line">      2.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">O        2.2.2.2 [110/1001] via 172.16.12.2, 00:01:17, Tunnel0</span><br></pre></td></tr></table></figure>

<p>通过show命令可以看到R1和R2之间建立了邻居关系，并且学到了对方身后的Loopback网段的路由。</p>
<h3 id="设置感兴趣流-1"><a href="#设置感兴趣流-1" class="headerlink" title="设置感兴趣流"></a>设置感兴趣流</h3><p>由于目标是要将整个Interface加密，因此设置ACL用来匹配感兴趣流</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#ip access-list extended IPSEC_TUNNEL </span><br><span class="line">R1(config-ext-nacl)#permit ip host 192.168.13.1 host 192.168.23.2</span><br><span class="line">R2(config)#ip access-list extended IPSEC_TUNNEL </span><br><span class="line">R2(config-ext-nacl)#permit ip host 192.168.23.2 host 192.168.13.1</span><br></pre></td></tr></table></figure>

<h3 id="设置IPSec"><a href="#设置IPSec" class="headerlink" title="设置IPSec"></a>设置IPSec</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#crypto isakmp key ccie address 192.168.23.2</span><br><span class="line">R1(config)#crypto isakmp policy 10</span><br><span class="line">R1(config-isakmp)#encryption aes </span><br><span class="line">R1(config-isakmp)#authentication pre-share </span><br><span class="line">R1(config-isakmp)#group 2</span><br><span class="line">R1(config-isakmp)#exit</span><br><span class="line">R1(config)#crypto ipsec transform-set TS esp-3des </span><br><span class="line">R1(cfg-crypto-trans)#exit</span><br><span class="line">R1(config)#crypto map GRE_OVER_IPSEC 10 ipsec-isakmp </span><br><span class="line">R1(config-crypto-map)#set peer 192.168.23.2</span><br><span class="line">R1(config-crypto-map)#set transform-set TS</span><br><span class="line">R1(config-crypto-map)#match address IPSEC_TUNNEL</span><br><span class="line">R2(config)#crypto isakmp key ccie address 192.168.13.1</span><br><span class="line">R2(config)#crypto isakmp policy 10</span><br><span class="line">R2(config-isakmp)#encryption aes </span><br><span class="line">R2(config-isakmp)#authentication pre-share </span><br><span class="line">R2(config-isakmp)#group 2</span><br><span class="line">R2(config-isakmp)#exit</span><br><span class="line">R2(config)#crypto ipsec transform-set TS esp-3des </span><br><span class="line">R2(cfg-crypto-trans)#exit</span><br><span class="line">R2(config)#crypto map GRE_OVER_IPSEC 10 ipsec-isakmp </span><br><span class="line">R2(config-crypto-map)#set peer 192.168.13.1</span><br><span class="line">R2(config-crypto-map)#set transform-set TS</span><br><span class="line">R2(config-crypto-map)#match address IPSEC_TUNNEL</span><br></pre></td></tr></table></figure>

<h3 id="将IPSec应用到接口"><a href="#将IPSec应用到接口" class="headerlink" title="将IPSec应用到接口"></a>将IPSec应用到接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#int ethernet 1/0</span><br><span class="line">R1(config-if)#crypto map GRE_OVER_IPSEC</span><br><span class="line">R2(config)#int ethernet 1/0</span><br><span class="line">R2(config-if)#crypto map GRE_OVER_IPSEC</span><br></pre></td></tr></table></figure>

<h3 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#ping 2.2.2.2 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 2.2.2.2, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 1.1.1.1</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 2/5/6 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show crypto isakmp sa</span><br><span class="line">IPv4 Crypto ISAKMP SA</span><br><span class="line">dst             src             state          conn-id status</span><br><span class="line">192.168.23.2    192.168.13.1    QM_IDLE           1001 ACTIVE</span><br><span class="line"></span><br><span class="line">IPv6 Crypto ISAKMP SA</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show crypto ipsec sa</span><br><span class="line"></span><br><span class="line">interface: Ethernet0/0</span><br><span class="line">    Crypto map tag: GRE_OVER_IPSEC, local addr 192.168.13.1</span><br><span class="line"></span><br><span class="line">   protected vrf: (none)</span><br><span class="line">   local  ident (addr/mask/prot/port): (192.168.13.1/255.255.255.255/0/0)</span><br><span class="line">   remote ident (addr/mask/prot/port): (192.168.23.2/255.255.255.255/0/0)</span><br><span class="line">   current_peer 192.168.23.2 port 500</span><br><span class="line">     PERMIT, flags=&#123;origin_is_acl,&#125;</span><br><span class="line">    #pkts encaps: 294, #pkts encrypt: 294, #pkts digest: 294</span><br><span class="line">    #pkts decaps: 294, #pkts decrypt: 294, #pkts verify: 294</span><br><span class="line">    #pkts compressed: 0, #pkts decompressed: 0</span><br><span class="line">    #pkts not compressed: 0, #pkts compr. failed: 0</span><br><span class="line">    #pkts not decompressed: 0, #pkts decompress failed: 0</span><br><span class="line">    #send errors 0, #recv errors 0</span><br><span class="line"></span><br><span class="line">     local crypto endpt.: 192.168.13.1, remote crypto endpt.: 192.168.23.2</span><br><span class="line">     plaintext mtu 1462, path mtu 1500, ip mtu 1500, ip mtu idb Ethernet0/0</span><br><span class="line">     current outbound spi: 0x9E692FBE(2657693630)</span><br><span class="line">     PFS (Y/N): N, DH group: none</span><br><span class="line"></span><br><span class="line">     inbound esp sas:</span><br><span class="line">      spi: 0x1EF8F00(32476928)</span><br><span class="line">        transform: esp-3des ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 1, flow_id: SW:1, sibling_flags 80004040, crypto map: GRE_OVER_IPSEC</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4236140/882)</span><br><span class="line">        IV size: 8 bytes</span><br><span class="line">        replay detection support: N</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     inbound ah sas:</span><br><span class="line"></span><br><span class="line">     inbound pcp sas:</span><br><span class="line"></span><br><span class="line">     outbound esp sas:</span><br><span class="line">      spi: 0x9E692FBE(2657693630)</span><br><span class="line">        transform: esp-3des ,</span><br><span class="line">        in use settings =&#123;Tunnel, &#125;</span><br><span class="line">        conn id: 2, flow_id: SW:2, sibling_flags 80004040, crypto map: GRE_OVER_IPSEC</span><br><span class="line">        sa timing: remaining key lifetime (k/sec): (4236140/882)</span><br><span class="line">        IV size: 8 bytes</span><br><span class="line">        replay detection support: N</span><br><span class="line">        Status: ACTIVE(ACTIVE)</span><br><span class="line"></span><br><span class="line">     outbound ah sas:</span><br><span class="line"></span><br><span class="line">     outbound pcp sas:</span><br></pre></td></tr></table></figure>

<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://www.yuque.com/lcheng/hcie/qb74wf">GRE</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/dynamic-multipoint-virtual-private-network-dmvpn/">Dynamic Multipoint VPN (DMVPN) 动态多点虚拟私人网络</a></p>
<p><a href="https://networklessons.com/cisco/ccie-routing-switching/introduction-to-dmvpn">Introduction to DMVPN</a></p>
<p><a href="https://www.juniper.net/documentation/us/en/software/junos/vpn-ipsec/topics/topic-map/security-ipsec-basics.html">IPsec Basics</a></p>
<p><a href="https://www.mrbluyee.com/2019/09/23/IPsec/">IPSec</a></p>
<p><a href="https://ipcisco.com/lesson/ipsec-vpn-overview/">IPSec VPN Overview</a></p>
<p><a href="https://www.ibm.com/support/pages/what-difference-between-ah-and-esp-protocols-ipsec">What is the difference between the AH and ESP protocols of IPSec?</a></p>
<p><a href="https://www.ibm.com/docs/en/zos/2.1.0?topic=ipsec-ah-esp-protocols">AH and ESP protocols</a></p>
<p><a href="http://www.tcpipguide.com/free/t_IPSecAuthenticationHeaderAH.htm">IPSec Authentication Header (AH)</a></p>
<p><a href="http://www.firewall.cx/networking-topics/protocols/870-ipsec-modes.html">UNDERSTANDING VPN IPSEC TUNNEL MODE AND IPSEC TRANSPORT MODE - WHAT’S THE DIFFERENCE?</a></p>
<p><a href="https://networklessons.com/cisco/ccie-routing-switching-written/ipsec-internet-protocol-security#IKE_Internet_Key_Exchange">IPsec (Internet Protocol Security)</a></p>
<p><a href="https://www.juniper.net/documentation/us/en/software/junos/vpn-ipsec/topics/topic-map/security-ike-basics.html">Internet Key Exchange</a></p>
<p><a href="https://blog.csdn.net/qq_38265137/article/details/89423551">IPSec基本原理</a></p>
<p><a href="https://blog.csdn.net/qq_38265137/article/details/89423617">IPSec之IKEv1协议详解</a></p>
<p><a href="https://blog.csdn.net/qq_38265137/article/details/89423663">IPSec之IKEv2协议详解</a></p>
<p><a href="https://www.ciscopress.com/articles/article.asp?p=25474&seqNum=7">How IPSec Works</a></p>
<p><a href="http://www.unixwiz.net/techtips/iguide-ipsec.html">An Illustrated Guide to IPsec</a></p>
<p><a href="https://cshihong.github.io/2019/04/19/GRE-over-IPSec%E6%8A%80%E6%9C%AF%E5%8E%9F%E7%90%86/">GRE over IPSec技术原理</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/gre-over-ipsec-vs-ipsec-over-gre/">GRE over IPSec vs IPSec over GRE</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>14、BGP</title>
    <url>/2020/10/11/14-BGP/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>学习BGP这部分知识的时候，一定不要将之前路由协议的经验或概念,套到BGP上，因为BGP和他们有非常大的区别，因为之前接触的RIP,OSPF,EIGRP等等路由协议都是IGP(Interior Gateway Protocol)也就是内部网关协议,而BGP是EGP(Exterior Gateway Protocol)也就是外部网关协议,内\外部网关协议从根本上有很多不同。</p>
<p>本笔记大部分引用自红茶三杯的BGP技术笔记，基于自己的理解进行了小幅度添加及修改。</p>
<h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><h3 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h3><h4 id="无需BGP的场景"><a href="#无需BGP的场景" class="headerlink" title="无需BGP的场景"></a>无需BGP的场景</h4><p>在常见的小型或需求不高的企业网中,BGP存在的意义不大,比如以下的三个场景.</p>
<p>场景1：</p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-00-24.png" alt="Snipaste_2020-10-13_16-00-24"></p>
<p>客户网络只有一台路由器的情况下,直接用默认路由指向运营商提供的公网IP地址A.B.C.D即可,IP route 0.0.0.0 0.0.0.0  A.B.C.D,网络内私网地址设备要访问互联网的话需要在出口路由器上做PAT\NAT,将私网地址转换成公网地址.所以这种情况下并不需要BGP就能满足用户需求.</p>
<p><strong>场景2:</strong></p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-13-08.png" alt="Snipaste_2020-10-13_16-13-08"></p>
<p>这种场景下,客户不只有一台路由器,还有几台服务器要接入互联网提供服务,这些服务器可能提供邮件或网页服务.这种情况下,需要用端口转发技术将正确的端口和这些服务器对应起来,因此这种情况下不需要用BGP也能够满足用户需求.</p>
<p><strong>场景3:</strong></p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-15-51.png" alt="Snipaste_2020-10-13_16-15-51"></p>
<p>如果在之前场景中加上冗余需求呢?由于用户的服务器对外提供服务,只有一台路由器连接到ISP运营商可能会出现单点故障,也就是说一旦这台对外提供网络的服务器挂掉,整网就瘫痪了,服务器也无法对外提供服务.所以这时需要一个冗余路由器一起提供互联网连接,即使有一台路由器出现故障,另一台路由器可以顺利接替,大体配置方式如下:</p>
<ul>
<li>为主路路线配置一条metric值较低的静态路由；</li>
<li>为备用路线配置一条metric值较高的静态路由；</li>
</ul>
<p>主用线路由于metric值低,所以优先走主用路线,当主用路线挂掉以后会启用备用路线,如果需要主备用路线实现负载均衡则将两条线路的metric配置成相同即可,每条线路的流量会大致为50%,这种情况下也无需BGP。</p>
<h4 id="需要BPG的场景"><a href="#需要BPG的场景" class="headerlink" title="需要BPG的场景"></a>需要BPG的场景</h4><p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-54-57.png" alt="Snipaste_2020-10-13_16-54-57"></p>
<p>在上面的拓扑中,如果两条线路的负载均衡需求为80%和20%呢?显然这种场景下就必须BGP才能胜任了。</p>
<p>现在来看一个更复杂一点的场景,这种情况下,出口路由器需要连接两个不同的ISP运营商,以防在一个运营商挂掉的情况下,整网无法对外提供服务.但此时又遇到一个问题，由于我有两个ISP运营商提供服务，两个ISP都会给我属于他们的公网地址，如果我用了ISP1提供的地址，那么如果属于ISP1的这条链路出现问题，网络还是会断开连接，这时候我们就不能使用运营商所提供的公网地址了，而要使用我们自己从IANA（Internet Assigned Numbers Authority，互联网地址分配机构）申请到的地址，我们把从IANA申请到的地址告诉两家运营商，使用BGP和运营商进行连接并宣告申请到的地址进BGP协议。</p>
<p>除了上面的场景，其他使用BGP的理由主要如下：</p>
<ul>
<li><p>大量路由需要承载的情况，只有BGP能胜任，IGP能容纳的路由条目以千条为单位，但BGP是以万条为单位起算的，一两百万条BGP路由条目的路由器也不在少数；</p>
</li>
<li><p>支持MPLS/VPN的应用，传递客户VPN路由；</p>
</li>
<li><p>策略能力强，可以很好的实现路由策略与数据控制。</p>
</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IGP-amp-EGP"><a href="#IGP-amp-EGP" class="headerlink" title="IGP&amp;EGP"></a>IGP&amp;EGP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>IGP(Interior Gateway Protocol)</li>
</ul>
<p>IGP,内部网关协议,用来在Autonomous System内部的网关间交换路由信息.常见协议有OSPF,EIGRP,ISIS。</p>
<ul>
<li>EGP(Exterior Gateway Protocol)</li>
</ul>
<p>EGP,外部网关协议,用来在Autonomous System之间交换路由信息.目前在用的EGP协议只有BGP一个协议。</p>
<h3 id="AS是什么"><a href="#AS是什么" class="headerlink" title="AS是什么"></a>AS是什么</h3><blockquote>
<p>An autonomous system (AS) is a collection of connected Internet Protocol (IP) routing prefixes under the control of one or more network operators on behalf of a single administrative entity or domain that presents a common, clearly defined routing policy to the internet. ——<a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)#:~:text=An%20autonomous%20system%20(AS)%20is,routing%20policy%20to%20the%20internet.">维基百科</a> </p>
</blockquote>
<p>维基的定义比较晦涩难懂,直译就是说,由一个或多个网络运营商代表单一行政实体或域控制下的连接的互联网协议(IP)路由前缀的集合，它向互联网提出一个共同的、明确定义的路由策略。</p>
<p><img src="/2020/10/11/14-BGP/routingas.png" alt="routingas"></p>
<p>上面这个图能更直观的表现出什么叫一个AS,简单的说就是配置在同一个AS号码（和EIGRP的AS不同）下,自己可管理的所有设备组成的一个较大的逻辑区域。一个AS中必须包含最少一台运行BGP的路由器。</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><img src="/2020/10/11/14-BGP/0_gUtwQ4minoYExQwN.png" alt="0_gUtwQ4minoYExQwN"></p>
<p>IGP在AS内部发挥作用，它们的作用就是在AS内部为如何去往目的网段找到最短路径；EGP在AS之间发挥作用。为什么除了IGP以外还要搞出来一个BGP，简单理解就是因为IGP协议能够处理的路由条目不多，没法满足大批量路由的需要，比如有些路由器要处理一两百万条路由，一般的IGP没法胜任，路由条目在一万条左右就已经差不多了。</p>
<h2 id="AS号"><a href="#AS号" class="headerlink" title="AS号"></a>AS号</h2><p>最开始的时候，AS号长度为2字节，也就是16比特，它的范围是1-65535，和IP地址一样，AS号也有公有和私有之分，1-64511是公有AS号，由IANA规定并出售，64512-65535是私有AS号，可以随意使用。由于互联网持续扩大，原有的65535个AS号已经逐渐用完，所以在RFC4893中将2字节（16比特）的AS号扩展为4字节（32比特），共有4294967295个AS号，和原有的65535个AS号相比，有了很大的提升，扩展的AS号中，4,200,000,000–4,294,967,294是私有AS号。00–4,294,967,294</p>
<p>可以通过<a href="https://www.cidr-report.org/as2.0/">CIDR Report</a>查询AS号目前都被哪个运营商使用以及目前的前缀、邻居等信息。在使用AS号的时候必须使用由IANA所分配的AS号或私有AS号，胡乱使用其他机构的AS号可能导致互联网面临毁灭性的问题。</p>
<h2 id="Looking-Glass-Servers"><a href="#Looking-Glass-Servers" class="headerlink" title="Looking Glass Servers"></a>Looking Glass Servers</h2><blockquote>
<p>Looking Glass servers are computers on the Internet running one of a variety of publicly available Looking Glass software implementations. A Looking Glass server (or LG server) is accessed remotely for the purpose of viewing routing information. Essentially, the server acts as a limited, read-only portal to routers of whatever organization is running the LG server. ——维基百科</p>
</blockquote>
<p>Looking Glass 服务器是一些部署在互联网上安装了Looking Glass软件的计算机，Looking Glass软件能让你远程登陆，运行一些基本的命令并查看关于BGP的相关信息，可以在<a href="https://www.bgp4.as/looking-glasses">该页面</a>找到分布在全球的Looking Glass 服务器。</p>
<p><img src="/2020/10/11/14-BGP/1602594423151-6aca5b7f-0eed-4515-8cae-21dfe2bdd63e.jpeg" alt="img"></p>
<p>这个服务器的作用是什么呢？主要是用来方便排错。比如说运营商有很多那个边缘设备（可以简单的把边缘设备理解成在AS最边界的设备），跟别的运营商对接的peer邻居设备去收全球的路由表，有时候你会发现，你运行BGP的线路中突然有一个业务突然不通或某个网段好像突然不通了，但是为什么呢你也不知道，因为你不知道互联网上到这个网段的路径到底通不通，到底是那边的网络出了问题还是你这边的网络出了问题，这时候你可以用looking glass服务器去查他那个在互联网上他到底有没有问题，如果在他原本在互联网上就有问题的话，那就说明问题不在你这边，能够方便确定问题到底出在哪端。为什么你不知道到底是别人那边出了问题还是你这边出了问题呢？因为BGP是一个距离矢量协议，和之前的RIP有一些相通之处，都是基于传闻的协议，并不知道整个网络的情况。</p>
<h2 id="BGP-Peer-amp-Speaker"><a href="#BGP-Peer-amp-Speaker" class="headerlink" title="BGP Peer&amp;Speaker"></a>BGP Peer&amp;Speaker</h2><p>运行了BGP协议的路由器被称为BGP Speaker，这里可以将BGP协议理解为一种语言,当一个路由器运行BGP协议时,相当于它说了BGP这种语言,所以将运行BGP的路由器称作BGP Speaker;当一个BGP Speaker和另一个BGP Speaker建立了一条基于TCP的BGP连接后，称两者为BGP Peer，直译成中文就是BGP 对等体，说白了就是在BGP协议中换了一种称呼两者为邻居的方式，不说他们是邻居了，而说他们是对等体。</p>
<p><img src="/2020/10/11/14-BGP/1602668367683-94693172-45e5-4581-a194-61ecdd5db6f2.jpeg" alt="img"></p>
<h2 id="IBGP"><a href="#IBGP" class="headerlink" title="IBGP"></a>IBGP</h2><p>IBGP就是Internal BGP，翻译成中文就是内部BGP，用来连接内部对等体（Peer），在同一个自治系统（AS）内运行BGP的路由器之间，是IBGP Peer，也就是IBGP邻居，在配置IBGP邻居时，推荐用loopback地址建立邻居关系。建立IBGP邻居要满足以下几个条件：</p>
<ul>
<li>AS号相同</li>
<li>IBGP邻居之间建立TCP会话</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1602668402711-f7e43efa-9c09-4f65-adc3-cd2da23225ec.jpeg" alt="img"></p>
<h2 id="EBGP"><a href="#EBGP" class="headerlink" title="EBGP"></a>EBGP</h2><p>EBGP就是External BGP，翻译成中文就是外部BGP，用来连接外部，属于不同AS的路由器，不同的自治系统（AS）之间运行BGP的路由器之间，是EBGP Peer，也就是EBGP邻居，建立EBGP邻居时，推荐使用直连的IP地址建立邻居关系。建立EBGP邻居要满足以下几个条件：</p>
<ul>
<li><p>EBGP之间AS号不同</p>
</li>
<li><p>EBGP邻居之间建立TCP会话</p>
</li>
<li><p>Neighbor中指定的地址要可达</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1602668529012-d4fdef25-ea05-4b61-a430-f5d697e91f9a.jpeg" alt="img"></p>
<h2 id="NLRI"><a href="#NLRI" class="headerlink" title="NLRI"></a>NLRI</h2><p>NLRI的全称是Network Layer Reachability Information，直译成中文是网络层可达信息，简单来说是BGP的网络前缀，抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1603516028491-82b5fd06-3916-4f72-bd4e-77df1b4a60c1.jpeg" alt="img"></p>
<p>但问了个厂家的朋友说，NLRI其实是带着路径属性的前缀，不过抓包中并没在一起。</p>
<h2 id="几个管理概念"><a href="#几个管理概念" class="headerlink" title="几个管理概念"></a><a href="http://www.tcpipguide.com/free/t_BGPAutonomousSystemTypesTrafficFlowsandRoutingPoli.htm">几个管理概念</a></h2><h3 id="Local-Transit-Traffic"><a href="#Local-Transit-Traffic" class="headerlink" title="Local/Transit Traffic"></a>Local/Transit Traffic</h3><p><strong>Local Traffic</strong>，直译成中文是本地流量，这种流量要么是起源于本AS，要么是终点在本AS内，也就是起始或终点在本AS内的流量叫做Local Traffic。</p>
<p><strong>Transit Traffic</strong>，直译成中文是穿越流量，这种流量起源于外部AS，并且目的地也不在本AS内，也就是起始或终点都不在本AS内的流量叫做Transit Traffic。</p>
<h3 id="Stub-Multihomed-AS"><a href="#Stub-Multihomed-AS" class="headerlink" title="Stub/Multihomed AS"></a>Stub/Multihomed AS</h3><p><strong>Stub AS</strong>：仅和另外一个AS相连。</p>
<p><strong>Multihomed AS</strong>：和两个或两个以上的AS相连接。</p>
<p><img src="/2020/10/11/14-BGP/1603520481717-cbf0e5dd-bdf5-4add-b3f5-847ee4bf4bed.png" alt="img"></p>
<p>比如上图中的AS2，它同时和AS1及AS3连接，所以它是一个Multihomed AS，而AS1和AS3只和AS2这一个AS相连，所以它们是Stub AS。</p>
<h3 id="No-Transit-Restricted-AS-Criteria–Based-Transit-Policy"><a href="#No-Transit-Restricted-AS-Criteria–Based-Transit-Policy" class="headerlink" title="No Transit/Restricted AS/Criteria–Based Transit Policy"></a>No Transit/Restricted AS/Criteria–Based Transit Policy</h3><p><strong>No Transit Policy</strong>：直译过来就是不许穿越策略，也就是不允许处理上面提到过的穿越流量（Transit Traffic）。</p>
<p><strong>Restrict AS Transit Policy</strong>：直译过来是严格的AS穿越策略，也就是只允许部分AS的穿越流量通过，但不允许其他AS的穿越流量通过的策略。</p>
<p><strong>Criteria–Based Transit Policy</strong>：Criteria–Based，直译过来是基于标准的意思，也就是用标准去确定这些流量是否能穿越，符合规定的标准的穿越流量可以通过。</p>
<h3 id="如何使用这些概念"><a href="#如何使用这些概念" class="headerlink" title="如何使用这些概念"></a>如何使用这些概念</h3><p>以上这几个概念在什么时候用得上呢？一般是在规划BGP如何使用的时候。比如你有一些路由器想跑BGP的时候，肯定要先申请AS号码，这时候就得先定位你想跑BGP的这些路由器的作用是什么，你是只给你自己服务还是说你也要给别人通过BGP提供服务，不同的定位决定了BGP不同的玩法。如果你这些BGP的路由器只给自己服务，也就是说你的BGP路由器是流量的终点，是互联网的末端，跑BGP只是想通过BGP协议接受运营商的路由去进行选路，所以这种情况下，你的AS是一个Stub AS，这时候Private AS就足够了；如果你的AS不只是你自己用，你还要给别人提供服务，那么你就是一个Transit AS，跑的是Transit Traffic，那么这时你的BGP的AS号就得申请公有的AS号了，因为要对外提供服务不能只和自己玩了，那么这时你的Transit的是什么呢，你下面可能有一些小的ISP运营商，你上面有些比较大的ISP运营商，你要为他们之间提供Transit 服务，这时候你就是作为一个Transit AS存在的了。</p>
<p>Multihomed AS是说，当你是末端用户，也就是Stub AS的时候，如果你只和某一个ISP运营商连接的话，万一这个运营商挂掉了你就没法提供服务或连接网络了，也就是单点故障了，这时除了连接到主用ISP以外还要连接到另一个备份的ISP运营商，也就是和两个不同运营商的不同AS相连接，这种情况下会用到Multihomed AS这个概念。</p>
<h1 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h1><h2 id="协议基本知识"><a href="#协议基本知识" class="headerlink" title="协议基本知识"></a>协议基本知识</h2><ul>
<li><p>BGP目前版本为BGP-4，使用TCP作为传输层协议，这样重传、确认、排序等一系列传输层需要实现的功能就由TCP完成而无需BGP操心，BGP会监听TCP的179端口；</p>
</li>
<li><p>由于BGP使用TCP作为传输层协议，是传输是可靠的，在可靠的链路上需不要使用定期更新，所以BGP使用增量更新和触发更新；</p>
</li>
<li><p>每个AS都有一个标识号，也就是AS号，范围是1-65535，其中1-64511是共有AS号，64512-65535是私有AS号；</p>
</li>
<li><p>BGP的设计初衷就是在AS之间传递路由，因此它的一跳实际上是一个AS；</p>
</li>
<li><p>BGP是距离矢量协议，所以具有距离矢量协议的特征，比如水平分割原则（BGP路由器从iBGP获得的路由不会向它的iBGP邻居通告），路由是基于传闻，数据一跳一跳传播等特征。</p>
</li>
<li><p>BGP有三个管理距离，从IBGP学到的路由的AD为200，从EBGP学到的路由AD为20，这是因为BGP的设计初衷就是在AS之间传递路由，所以AS之间的EBGP路由AD值比较小，而在AS内部的路由传递，BGP希望IGP自己搞定，因此IBGP路由的AD值设置为一个较大的AD值，200；</p>
</li>
<li><p>BGP的Router ID和OSPF一样，RID是一个用来标识路由器的IP地址，长度为32位，作用是唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在BGP路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID；</p>
</li>
<li><p>BGP计时器有两个，一个是Keepalive Interval，默认时间为60秒，意思是邻居之间每隔60秒发送Keepalive报文给对方，用来判断邻居是否还存在；另一个是Hold time，默认180秒，意思是如果邻居之间超过180秒还没收到对方的Keepalive信息则认为对方不可达；</p>
</li>
</ul>
<h2 id="BGP水平分割"><a href="#BGP水平分割" class="headerlink" title="BGP水平分割"></a><a href="https://community.cisco.com/t5/routing/why-we-need-bgp-split-horizon-rule/td-p/1891507">BGP水平分割</a></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>BGP水平分割原则是指，当运行BGP的路由器从一个iBGP邻居处收到的路由更新，不能再传递给其他iBGP邻居。</p>
<p><img src="/2020/10/11/14-BGP/1605854882539-3250979d-0b09-4052-9443-be86b81957c8.jpeg" alt="img"></p>
<p>用上面的拓扑来说明水平分割就是，R1和R2是eBGP邻居，R1将网段1.1.1.1/32宣告进BGP并将该路由通过BGP协议宣告给R2，R2又将该路由宣告给iBGP邻居R3，但此时R3不能将从iBGP邻居R2处学到的1.1.1.1/32的路由宣告给iBGP邻居R4。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>为什么需要水平分割原则呢？是因为在eBGP中发挥防止路由环路功能的属性参数，AS Path，在iBGP会话中，不起作用。因为AS Path只有在离开一个AS后才会加上这个AS的号码，用来告诉其他路由器这条路由经过了哪些AS，不要再将它发回到那些AS中，否则会引起路由环路。如果没有水平分割原则，意味着iBGP邻居之间可以多次传递路由，比如一条由R1最初生成的1.1.1.1/32的路由，经过多次传递后可能会重新传回给生成它的R1，如果R1之前已经宣告撤销了1.1.1.1/32，就会使得本该被撤销的路由无法真正撤销。为了避免上面提到的风险，有了水平分割原则，并且水平分割原则无法被关闭，但如果有时候必须要打破水平分割原则该如何呢？可以用Full mesh或Route Reflectors。</p>
<h3 id="Full-mesh"><a href="#Full-mesh" class="headerlink" title="Full mesh"></a>Full mesh</h3><p>BGP的Full mesh就是所有BGP路由器都和其他路由器建立iBGP邻居，这样做的好处是由于所有路由器之间都是iBGP邻居，所以水平分割原则不会对路由的宣告有影响。</p>
<p><img src="/2020/10/11/14-BGP/1605858839062-d1b3f60b-c415-45c9-93fd-19e098f49689.jpeg" alt="img"></p>
<p>比如上图中，R2，R3和R4之间就是Full  mesh状态，彼此两两都是iBGP邻居，这种Full mesh情况下，R2就可以将另一个AS的BGP路由直接发送给另一边界处的R4，不受水平分割的影响了。</p>
<h3 id="Route-Reflectors"><a href="#Route-Reflectors" class="headerlink" title="Route Reflectors"></a>Route Reflectors</h3><p>路由反射器在后面会具体说。</p>
<h2 id="BGP三张表"><a href="#BGP三张表" class="headerlink" title="BGP三张表"></a>BGP三张表</h2><ul>
<li><p>邻居表（Neighbor Table）：表中包含着关于BGP邻居的信息。查看邻居表的命令为show ip bgp summary（简略邻居信息）、show ip bgp neighbor（详细邻居信息）;</p>
</li>
<li><p>BGP表（Forwarding Database）：表中包含着查看BGP表的命令为show ip bgp；</p>
</li>
<li><p>路由表（Routing Table）：查看路由表的命令为show ip route；</p>
</li>
</ul>
<p>查看哪条路由未加表的命令为：show ip bgp rib-failure；</p>
<h2 id="路由处理过程"><a href="#路由处理过程" class="headerlink" title="路由处理过程"></a>路由处理过程</h2><h3 id="三个路由信息库"><a href="#三个路由信息库" class="headerlink" title="三个路由信息库"></a>三个路由信息库</h3><h4 id="Adj-RIBs-In"><a href="#Adj-RIBs-In" class="headerlink" title="Adj-RIBs-In"></a>Adj-RIBs-In</h4><p>The Adj-RIBs-In contains unprocessed routing information that has been advertised to the local BGP speaker by its peers. —-RFC4271,Page 4</p>
<p>直译过来就是，Adj-RIBs-In中存放着的由BGP邻居发送来的未经处理的路由信息。这个“未经处理”指的是什么呢？就是没经过任何路由策略过滤或属性修改。说白了就是邻居发来的原始的路由信息是什么样的，原封不动的保存在Adj-RIBs-In中。通过命令 show ip bgp neighbor x.x.x.x received-routes查看Adj-RIBs-In。但这里也要注意，如果<strong>路由器的IOS比较老的情况下</strong>，想查看邻居发过来的未经处理的路由信息，必须在想查看路由的这个邻居上配置一条命令’neighbor X.X.X.X soft-reconfiguration inbound’，比如说我是12.1.1.2，现在我想查看12.1.1.1发过来的未经处理的原始BGP路由信息，就得在12.1.1.1上配置一条neighbor 12.1.1.2 soft-reconfiguration inbound，否则会提示’% Inbound soft reconfiguration not enabled on 12.1.1.1’，这是因为‘neighbor X.X.X.X soft-reconfiguration inbound’这条命令的作用是让所有BGP的路由前缀保存在本地设备内存中，即使这些路由前缀被BGP的入向策略拒绝掉也会在内存中，如果不配置这条命令，则无法查看。<strong>如果路由器的IOS比较新的情况下</strong>，是不需要配置这条命令的，具体参见后面‘协议配置——重置BGP连接部分’。</p>
<p><img src="/2020/10/11/14-BGP/1604476253448-3873112d-06bc-4d64-9295-9a7bd6604e44.jpeg" alt="img"></p>
<h4 id="Loc-RIB"><a href="#Loc-RIB" class="headerlink" title="Loc-RIB"></a>Loc-RIB</h4><p>The Loc-RIB contains the routes that have been selected by the local BGP speaker’s Decision Process.—-RFC4271,Page 5</p>
<p>Loc-RIB英文全称是Local Routing Information Base，是Adj-RIBs-In中邻居发送过来的原始路由信息，经过BGP路由选择出来的Best路由条目会放入Loc-RIB（BGP表）中存储。</p>
<h4 id="Adj-RIBs-Out"><a href="#Adj-RIBs-Out" class="headerlink" title="Adj-RIBs-Out"></a>Adj-RIBs-Out</h4><p>The Adj-RIBs-Out contains the routes for advertisement to specific peers by means of the local speaker’s UPDATE messages.  —-RFC4271,Page 4</p>
<p>Adj-RIBs-Out中存储着宣告给特定邻居的路由条目，这些路由条目通过update报文发送给邻居。通过命令show ip bgp neighbor x.x.x.x advertise-routes来查看Adj-RIBs-Out。</p>
<p><img src="/2020/10/11/14-BGP/1604474909285-72ca8f6f-2fb4-47df-ac1d-603ace6726bd.jpeg" alt="img"></p>
<p>上面的截图中输出表示，R1向邻居12.1.1.2宣告了1条5.5.5.5/32的BGP路由，这条路由的下一跳是192.168.15.5。</p>
<h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a><a href="https://community.cisco.com/t5/routing/bgp-adj-rib-in-loc-rib-adj-rib-out/td-p/509060">处理过程</a></h3><p><img src="/2020/10/11/14-BGP/1602916955680-a0a9e71d-98b9-4181-8004-3202d4c19523.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1602920356680-b4902eb7-399e-4165-9f71-a3e7d376f2b6.jpeg" alt="img"></p>
<ul>
<li><p>把邻居们（eBGP\iBGP方式建立的）发来的所有路由前缀保存到Adj-RIBs-In中，检查下一跳是否可达，如果不可达则该路由不可能成为最优的BGP路由；</p>
</li>
<li><p>将上面存储的所有路由用BGP Policy过滤，过滤后同一个目标前缀可能有多条路径；</p>
</li>
<li><p>对去往同一前缀有多条路径的路由执行路由选择，在多条路径中选择出一条去往目标前缀最优的路径，比的是BGP的路径属性，最优的BGP路由带有&gt;符号，表示该路由是BGP表中去往某一路径的最优路由，最优的BGP路由会保存在Loc-RIB，也就是BGP表中；</p>
</li>
<li><p>将选择出来的BGP最优路由一方面要看是否能放入路由表中，另一方面要将它放入Adj-RIBs-Out中宣告给其他对等体邻居。是否放入路由表的决策过程为，如果目的地址有其他IGP路由，则需要比较两者的AD值，越小越优。如果BGP路由的AD值小，则会将这条之前在BGP表最优的路由放入路由表中，如果BGP路由的AD值大则不会放入路由表中。如果目的地址没有其他IGP路由，则该BGP路由直接放入路由表中；</p>
</li>
</ul>
<h2 id="BGP路由通告"><a href="#BGP路由通告" class="headerlink" title="BGP路由通告"></a>BGP路由通告</h2><ul>
<li>当存在多条路径时，BGP路由器只选取BGP表中最优的路由，也就是带&gt;标识为Best的；</li>
<li>BGP路由器只把自己使用的路由，也就是自己认为Best的路由发送给邻居：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1605781972710-f94c8b2e-8de5-4864-b843-3472d31e2c11.png" alt="img"></p>
<p>比如上图中，到10.0.196.0/24这个前缀有两条路径，只把下面带&gt;的那个，就是下一跳是172.28.144.5的那条发送给邻居，不是Best的就存在本地的Adj-RIBs-in中。</p>
<ul>
<li><p>BGP路由器从eBGP获得的路由会向它所有的BGP邻居通告，包括eBGP和iBGP；</p>
</li>
<li><p>BGP路由器从iBGP获得的路由不会向它的iBGP邻居通告，因为有水平分割原则并且要避免出现环路（存在RouterReflect的情况除外）；</p>
</li>
<li><p>BGP路由器从iBGP处获得的路由是否通告给其他的eBGP路由器要看IGP和BGP同步的情况来决定；</p>
</li>
</ul>
<h2 id="BGP计时器"><a href="#BGP计时器" class="headerlink" title="BGP计时器"></a>BGP计时器</h2><h3 id="Holdtime-amp-Keepalive"><a href="#Holdtime-amp-Keepalive" class="headerlink" title="Holdtime&amp;Keepalive"></a>Holdtime&amp;Keepalive</h3><p>Holdtime和Keepalive是BGP用来确定邻居还存在的重要机制，当路由器之间没有Update报文可供交换时，运行BGP的路由器之间会相互发送Keepalive报文，看邻居是否还存在，如果收到Keepalive报文的时间在Hold Time规定范围内，则确定了对方还存在，收到Keepalive报文后，Holdtime计时器会重置；如果HoldTime计时器过期前都没收到Keepalive或update报文，则会认为对方已经挂掉，那么路由器就会认为从这个挂掉的邻居那收到的路由前缀已经失效，将这些路由从BGP表以及路由表中去掉，并用其他可用路径代替这些被移除的路径。Keepalive是HoldTime数值的三分之一，RFC4271中对这两个值的建议时间为，HoldTime为90秒，Keepalive为30秒，Juniper设备默认的计时器也是整个数字，但思科和华为对BGP默认的Hold Time为180秒，Keepalive为60秒，也就是每过60秒发送Keepalive报文，如果180秒内没收到邻居的Keepalive报文或update报文，则说明邻居已经挂掉。</p>
<p>在思科设备中对HoldTime和Keepalive进行更改的命令为：neighbor X.X.X.X timers A B。其中X.X.X.X是需要更改计时器的邻居路由器的RID，A是Keepalive的时间，B是HoldTime的时间。如果配置命令为 neighbor 1.1.1.1 timers 10 30，说明将对邻居1.1.1.1的Keepalive时间设置为10秒，HoldTime时间设置为30秒。这里必须注意的是，Open报文中交互的只是HoldTime，而不会对Keepalive进行交互。</p>
<h4 id="Holdtime"><a href="#Holdtime" class="headerlink" title="Holdtime"></a>Holdtime</h4><p>Holdtime的数值表示一个路由器在多长时间未接到邻居信息以后认为这个邻居已经挂掉，比如思科设备默认的Hold time为180秒，从180开始倒数计时，那么如果在180秒内还没收到邻居发来的消息，也就是计时器到0之前都没收到邻居的消息，则会认为邻居已经挂掉，那么路由器就会认为从这个挂掉的邻居那收到的路由前缀已经失效，将这些路由从BGP表以及路由表中去掉，并用其他可用路径代替这些被移除的路径；如果在HoldTime计时器到期前收到了Keepalive或Update报文，则说明邻居还存在，此时HoldTime计时器会重置为180秒，重新进行新一次的倒计时并循环往复。HoldTime在Open报文中会相互交互。</p>
<h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h4><p>Keepalive计时器不会在Open报文中交互，Keepalive在思科设备中默认时间是60S，也就是三分之一的Holdtime时间。</p>
<h4 id="计时器协商"><a href="#计时器协商" class="headerlink" title="计时器协商"></a>计时器协商</h4><p>当两个BGP邻居配置的计时器不同时，两边用Open报文交互了HoldTime的数值，所以彼此知道对方路由器所配置的数值，此时：</p>
<ul>
<li><p>HoldTime采用两个路由器设置值的最小值，也就是说，如果一边的HoldTime为60，另一边的HoldTime为30，则最后采用较小的30，作为HoldTime值。</p>
</li>
<li><p>Keepalive的话，如果手工配置的Keepalive timer小于两边配置的最小的HoldTime的三分之一，则采用配置值；如果手工配置的Keepalive timer大于两边配置的最小的HoldTime的三分之一，则采用两边配置最小的HoldTime的三分之一这个值作为Keepalive。</p>
</li>
<li><p>如果配置了timer bgp 0 0，则表示两边的邻居永远不会down。</p>
</li>
</ul>
<h3 id="触发更新计时器"><a href="#触发更新计时器" class="headerlink" title="触发更新计时器"></a>触发更新计时器</h3><p>英文全称为：MinRouteAdvertisementIntervalTimer（MRAI Timer），BGP不会周期性更新路由，仅在需要的时候更新，由于公网的路由可能的动荡，为了保持BGP路由的稳定性，因此触发更新（包括宣告新路由或撤销路由在内）也会有一定的收敛时间，IBGP peer为5秒，EBGP peer为30秒，在这段时间内，BGP仍可以进行路由信息的收集，但不能宣告\撤销任何BGP路由，所以BGP收敛会比较慢。</p>
<h3 id="ConnectRetryTimer"><a href="#ConnectRetryTimer" class="headerlink" title="ConnectRetryTimer"></a>ConnectRetryTimer</h3><p>翻译成中文就是重传计时器，这个计时器定义的是重新连接请求之前的超时间隔。</p>
<h1 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h1><p><strong>BGP路由器之间交互任何BGP报文之前，必须先建立TCP连接。</strong></p>
<p><img src="/2020/10/11/14-BGP/1602922475484-91341961-eb1b-4120-893a-64b997b1ed70.png" alt="img"></p>
<h2 id="报头部分"><a href="#报头部分" class="headerlink" title="报头部分"></a>报头部分</h2><p><img src="/2020/10/11/14-BGP/1602920546094-f41633a0-9c83-4ce8-b8b4-115c15a7548c.jpeg" alt="img"></p>
<p>BGP的每个报文都有固定大小的报头：</p>
<ul>
<li><p>Marker：长度为16位，用来检测BGP对等体之间同步丢失情况，并且在支持验证功能的情况下进行报文验证。如果报文类型为open或open报文中没有包含验证消息，此字段被置为全1；</p>
</li>
<li><p>Length：长度为2位，表示BGP报文包括头部在内的长度；</p>
</li>
<li><p>Type：1为Open，2为Update，3为Notification，4为Keepalive；</p>
</li>
</ul>
<h2 id="消息部分"><a href="#消息部分" class="headerlink" title="消息部分"></a>消息部分</h2><p>BGP消息部分的字段根据报头部分中的Type字段不同而不同。</p>
<h3 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h3><h4 id="报文概述"><a href="#报文概述" class="headerlink" title="报文概述"></a>报文概述</h4><p>当两台运行BGP协议的路由器已经建立好TCP连接后，他们开始尝试用Open报文建立连接，双方使用Open报文标识自己，并且规定自己的BGP运行参数，如果Open信息被接受则会回送一条Keepalive信息进行确认，确认后再发送Update信息。BGP会话由发送Open信息建立。Open信息的作用是为两台设备建立连接，标识发送Open设备的AS号及Router ID，并且协商BGP会话的重要参数（Keepalive、认证等）。如果两台路由器中的任意一台不接受Open信息中的参数则会发送Notification告知对方无法建立邻居的问题所在。Open信息的最小长度为29字节。</p>
<h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2020/10/11/14-BGP/1602922557293-f1109fed-d776-4633-a956-50614cf147cc.png" alt="img"></p>
<ul>
<li><p>当Type位值为1时，说明此消息为BGP的Open信息；</p>
</li>
<li><p>Version：长度为1字节，标识着发送Open信息的路由器运行的BGP版本，通常这个值为4，表示运行的是BGP-4版本；</p>
</li>
<li><p>My Autonomous System：长度为2字节，标识着发送Open信息路由器的AS号；</p>
</li>
<li><p>Hold Time：长度为2字节，该字段的值默认为180秒，表示如果邻居之间超过180秒还没收到对方的Keepalive信息则认为对方不可达；</p>
</li>
<li><p>BGP Identifier：长度为4字节，和之前OSPF的Router ID作用一致，用来标识运行BGP协议的路由器的身份，选取方式也和OSPF的Router ID选取方式一致，在Cisco设备中，路由器上环回接口的最高IP地址是BGP的Identifier，如果未配置环回接口，则将选择任何最高IP地址物理接口作为BGP标识符的值。</p>
</li>
<li><p>Optional Parameters Length：用来表示后面可选参数字段的长度，如果该字段为0说明该Open信息内没有可选字段；</p>
</li>
<li><p>Optional Parameters：可选参数，包含了一个可选参数列表，每个参数都由一个长度为8位的类型字段、长度为8位的长度字段以及一个可变长度的参数数值字段组成。用来宣告是否支持验证、多协议支持和路由刷新等可选功能，通常被成为能力值，意思就是这台路由器具备什么能力。</p>
</li>
</ul>
<p>A BGP speaker that supports a particular capability may use this capability with its peer after the speaker determines (as described above) that the peer supports this capability.  Simply put, a given capability can be used on a peering if that capability has been advertised by both peers.  If either peer has not advertised it, the capability cannot be used.</p>
<p>A BGP speaker determines that its peer doesn’t support capabilities advertisement if, in response to an OPEN message that carries the Capabilities Optional Parameter, the speaker receives a NOTIFICATION mecification [RFC4271] and not a new requirement.)  In this case, the speaker SHOULD attempt to re-establish a BGP connection with the peer without sending to the peer the Capabilities Optional Parameter.</p>
<p>​                                                                                                      —-RFC 5492 page 2</p>
<p>上面这段话的大概意思是，两个BGP在建立邻居时,会用open报文协商彼此支持的BGP特性,如果两者支持相同的特性那么两者会使用该特性;如果两者支持的特性不同,则会发送Notification报文给对方,然后在不发送Capabilities Optional Parameter的情况下重新建立邻居。</p>
<h4 id="wireshark抓包"><a href="#wireshark抓包" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1603529213037-94e7762a-0b7c-42d0-8daa-c6342e411501.jpeg" alt="img"></p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><h4 id="报文概述-1"><a href="#报文概述-1" class="headerlink" title="报文概述"></a>报文概述</h4><p>当两台BGP Speaker通过Open报文建立连接后，开始交互路由信息的过程，路由器会将那些经过路由决策筛选出来的路由条目宣告给邻居。这些需要宣告给Peer的路由信息会放入BGP的Update报文，Update会发送给每一个已用Open信息建立会话的邻居。每一个Update报文中有以下的某一个或全部元素：</p>
<ul>
<li>路由通告：一条路由的特征；</li>
<li>路由撤销：不可达网络的列表。</li>
</ul>
<p>必须注意的是，一个Update报文息中，<strong>只能通告一组路径属性相同的路由前缀，但能撤销多条路由</strong>。这是因为撤销路由只需要被撤销网段的网络号即可，而宣告路由则需要很多信息，比如要宣告路由的多种路径属性，这需要占用很大空间。当然update报文也可以只撤销路由而不进行任何宣告。实际上，只能通告一条路由这句话并不是简单的一个update报文里只有一个网络前缀，而是说<strong>一个Update<strong><strong>报文</strong></strong>中只发送一组路径属性相同的NLRI的路由前缀</strong>，可以参照下面的抓包对这句话进行理解：</p>
<p><img src="/2020/10/11/14-BGP/1603523038289-894d3dce-0b2c-41e2-93d4-4c22079582bf.jpeg" alt="img"></p>
<h4 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h4><p>update报文的结构比较复杂，具体参见<a href="http://www.tcpipguide.com/free/t_BGPRouteInformationExchangeUpdateMessages-2.htm">这个网页</a>，我截了两张图在下面，就不展开说了。</p>
<p><img src="/2020/10/11/14-BGP/1603272586679-19d4ef81-69ea-4aa6-a045-82542fc62745.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603272604223-10f263b6-0e7b-409a-81c2-7ed6ebf6f9c2.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603273204503-900cf73e-f6f2-499f-8e88-ad05152ca8ff.png" alt="img"></p>
<h4 id="wireshark抓包-1"><a href="#wireshark抓包-1" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p>update报文的格式看起来非常复杂，实际上wireshark的抓包并没有上面看起来那么复杂，每个update报文中是具有相同路径属性的前缀的集合：</p>
<p><img src="/2020/10/11/14-BGP/1604121221487-88cfea81-1bfc-4399-b616-62b08c6163d3.jpeg" alt="img"></p>
<h3 id="Keepalive-1"><a href="#Keepalive-1" class="headerlink" title="Keepalive"></a>Keepalive</h3><h4 id="报文概述-2"><a href="#报文概述-2" class="headerlink" title="报文概述"></a>报文概述</h4><p>当BGP通过Open报文建立连接后，BGP Speaker之间开始用Update报文交互路由信息，当路由信息交互完毕后，BGP进入了一个平稳的状态，只有当路由情况发生变化时，才会再度交互Update报文，此时BGP不会依靠TCP的连接状态去判断对方是否还在，而是用彼此交换Keepalive报文来确定对端没有Down掉。Keepalive报文交互的间隔是Hold Time时间的三分之一，在思科设备中，Hold Time默认时间是180秒，它的三分之一就是60秒，所以默认Keepalive时间是60秒。如果协商后的Hole Time为0，那么两个BGP Speaker之间不会交互Keepalive报文保活。</p>
<h4 id="报文格式-3"><a href="#报文格式-3" class="headerlink" title="报文格式"></a>报文格式</h4><p>Keepalive报文中没有任何实际的信息，它里面只有BGP的报头。</p>
<p><img src="/2020/10/11/14-BGP/1603525086435-f267f43c-0591-4dc2-9070-721d4d978e38.png" alt="img"></p>
<h4 id="wireshark抓包-2"><a href="#wireshark抓包-2" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1604121302480-be354d8f-bc18-4cc2-a217-7ddbf80d6ba0.jpeg" alt="img"></p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><h4 id="报文概述-3"><a href="#报文概述-3" class="headerlink" title="报文概述"></a>报文概述</h4><p>当BGP Speaker建立好连接后，可能会出现一些影响到BGP日常通信的错误，当这种问题出现时，BGP会通过Notification报文将这个错误通告给它的所有对等体（Peer，也就是邻居），当Notification报文发送时，通常会导致BGP的连接中止。Notification中有许多能告知为什么发生错误的字段，这里面包括了一组主要的错误代码以及一些错误代码的子代码，有些错误可能还会附加额外的信息帮助诊断问题所在。</p>
<h4 id="报文格式-4"><a href="#报文格式-4" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2020/10/11/14-BGP/1603530841097-821393b5-5d56-49dc-a574-023bd19a82e9.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603530909552-cc263cfb-4dac-417b-a8ed-3a99665c312e.jpeg" alt="img"></p>
<h4 id="wireshark抓包-3"><a href="#wireshark抓包-3" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1603530778521-69ac95dd-107b-40db-89ca-2e39eb78a7c5.jpeg" alt="img"></p>
<h3 id="Route-refresh"><a href="#Route-refresh" class="headerlink" title="Route-refresh"></a>Route-refresh</h3><p>当路由策略发生变化时，用Route-refresh报文去请求邻居重新通告路由，因为BGP不会周期性发送更新，只有在路由产生变化时才会发送Update报文更新路由。首先先查看邻居是否支持，只有支持了该特性时才能使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip bgp neighbors 192.168.23.3 | section Neighbor capabilities</span><br><span class="line">  Neighbor capabilities:</span><br><span class="line">    Route refresh: advertised and received(new)</span><br><span class="line">    Four-octets ASN Capability: advertised and received</span><br><span class="line">    Address family IPv4 Unicast: advertised and received</span><br><span class="line">    Enhanced Refresh Capability: advertised and received</span><br><span class="line">    Multisession Capability:</span><br><span class="line">    Stateful switchover support enabled: NO for session 1</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，该路由器支持新的Route refresh功能，所以可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#debug ip bgp in</span><br><span class="line">BGP debugging is on for address family: IPv4 Unicast</span><br><span class="line">R2#debug ip bgp updates</span><br><span class="line">BGP updates debugging is on for address family: IPv4 Unicast</span><br><span class="line">R2#clear ip bgp 192.168.23.3 in</span><br><span class="line">R2#</span><br><span class="line">*Nov 27 07:18:17.834: BGP: 192.168.23.3 sending REFRESH_REQ(5) for afi/safi: 1/1, refresh code is 0</span><br><span class="line">*Nov 27 07:18:17.835: BGP: 192.168.23.3 rcv message type 5, length (excl. header) 4</span><br><span class="line">*Nov 27 07:18:17.835: BGP: 192.168.23.3 rcvd REFRESH_REQ for afi/safi: 1/1, refresh code is 1</span><br><span class="line">*Nov 27 07:18:17.835: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) rcvd Refresh Start-of-RIB</span><br><span class="line">*Nov 27 07:18:17.835: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) refresh_epoch is 2</span><br><span class="line">*Nov 27 07:18:17.837: BGP(0): 192.168.23.3 rcvd UPDATE w/ attr: nexthop 192.168.23.3, origin i, metric 0, merged path 3, AS_PATH</span><br><span class="line">R2#</span><br><span class="line">*Nov 27 07:18:17.837: BGP(0): 192.168.23.3 rcvd 3.3.3.0/24...duplicate ignored</span><br><span class="line">*Nov 27 07:18:17.837: BGP: 192.168.23.3 rcv message type 5, length (excl. header) 4</span><br><span class="line">*Nov 27 07:18:17.837: BGP: 192.168.23.3 rcvd REFRESH_REQ for afi/safi: 1/1, refresh code is 2</span><br><span class="line">*Nov 27 07:18:17.837: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) rcvd Refresh End-of-RIB</span><br></pre></td></tr></table></figure>

<p>从上面的Debug中能看出，发送了sending REFRESH_REQ报文给邻居去请求重新发送路由通告，使得BGP新配置的策略能够尽早生效。</p>
<h1 id="邻居建立"><a href="#邻居建立" class="headerlink" title="邻居建立"></a>邻居建立</h1><h2 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h2><p>由于BGP是一个EGP协议，所以它的邻居的建立和之前学的其他IGP协议（比如OSPF和EIGRP）完全不同，IBGP协议只要在路由器上配置了以后就能自动发现邻居，比如在运行OSPF的路由器上，配置了router ospf 1、network  x.x.x.x  y.y.y.y  area z宣告了网段进入OSPF后，其他相连接的路由器也宣告网段进OSPF的话，只要OSPF建立邻居的组播地址（224.0.0.5，224.0.0.6）能正常通信，两者就自动开始建立邻居了，但BGP不同，它必须明确指定和哪个路由器建立邻居，才会启动建立邻居的过程，如果不宣告则不会进行邻居建立。BGP协议由于在传输层采用了TCP协议，BGP邻居建立不像OSPF、EIGRP这些IGP一样邻居之间必须直连才能建立邻居，因为BGP的控制报文（Keepalive、Open、Update、Notification和Withdraw报文）能够被路由从而跨越多个子网进行传输，这意味着BGP支持单跳、多跳的邻居建立:</p>
<p><img src="/2020/10/11/14-BGP/1604466928833-39308be4-3b1f-4e54-b28b-4a3428b9d3e1.png" alt="img"></p>
<p>由于TCP需要经由三次握手建立连接，所以BGP的邻居建立实际上分成了两部分：</p>
<ul>
<li>TCP连接建立阶段：Idle、Connect、Active；</li>
<li>BGP连接建立阶段：Opensent、Openconfirm、Established；</li>
</ul>
<p>BGP的有限邻居状态机（Finite State Machine，FSM）共有6个状态，其中Idle、Connect、Active属于TCP建立连接阶段，在这个阶段中，会交换交换TCP报文用来建立TCP连接，因为BGP协议需要可靠的TCP连接来传递BGP报文；Opensent、Openconfirm、Established属于BGP建立连接阶段，其中Opensent和Openconfirm两个阶段对应的是运行BGP的路由器交换BGP会话所必需的属性值，Established阶段表示邻居进入了稳定阶段，可以接受彼此的BGP路由更新。</p>
<h2 id="TCP连接建立阶段"><a href="#TCP连接建立阶段" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h2><p>在BGP连接建立前，必须先建立TCP连接，因为BGP的四层协议采用的是TCP协议，BGP报文交换需要TCP提供稳定的传输，如果TCP连接中断，BGP会话也会中断，当然TCP阶段建立和BGP阶段建立是两个独立的阶段，并不是只要TCP建立成功以后的BGP连接建立也会成功，因为TCP连接建立成功只是BGP连接建立的基础，而BGP建立阶段也要协商参数，也可能出现错误导致BGP阶段无法建立。当BGP的有限状态机在Idle、Active和Connect几个阶段来反复时，说明是TCP连接出现了问题。</p>
<h3 id="Idle"><a href="#Idle" class="headerlink" title="Idle"></a>Idle</h3><p>Idle是BGP有限状态机的第一个状态，BGP在检测到“Start event启动事件”之前是不会和邻居路由器开始建立邻居过程的。当路由器检测到BGP的Start event后（当路由器配置了一个新的BGP邻居或BGP Peer重置时），BGP会<strong>尝试</strong>和邻居建立TCP连接并且也会接受其他路由器发送的建立BGP邻居的消息，路由器也会在本地开始寻找一条到邻居的路由用于建立TCP连接。如果完成了上述步骤，则BGP进入下一个阶段——connect；如果在BGP邻居建立过程中发生错误，那么BGP会话会立刻终止并回到Idle状态，接下来ConnectRetry Timer（重连计时器）会设置为60秒，在重传计时器倒数到0之前，不会再尝试去建立邻居。每次连接建立失败后重新回到Idle状态的话，会导致ConnectRetry Timer（重连计时器）的时间比上次加倍。</p>
<p>导致BGP进程终止回到Idle状态的原因可能有以下几种：</p>
<ul>
<li><p>TCP的179端口未打开；</p>
</li>
<li><p>高于1023的TCP随机端口未打开；</p>
</li>
<li><p>任意一端地址配置错误；</p>
</li>
<li><p>任意一段AS号配置错误；</p>
</li>
</ul>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>在Connect状态，路由器会在本地尝试找到一条到邻居的路由，初始化TCP连接并尝试TCP三次握手且等待三次握手完成。认证也是在TCP建立期间完成的。在Connect状态下，BGP会启动重传计时器（ConnectRetry），等待TCP完成连接，在思科设备上使用’show tcp brief’来查看TCP会话建立的结果：</p>
<p><img src="/2020/10/11/14-BGP/1603870822553-1785edbd-ea7d-4232-a324-032ab46e6de7.jpeg" alt="img"></p>
<ul>
<li><p>如果TCP连接成功，那么BGP在这个状态的时间会比较短，接着会向邻居对等体发送Open报文，并进入OpenSent状态；</p>
</li>
<li><p>如果TCP连接失败，那么会进入Active状态反复尝试进行TCP连接；</p>
</li>
<li><p>如果重传计时器（ConnectRetry）过期之前，BGP路由器没有收到邻居对等体的响应，那么BGP会停留在Connect状态，会对邻居对等体尝试进行新的TCP连接，此时ConnectRetryTimer会重置且进入Active状态。如果在这过程中对配置进行了更改或收到同一个IP又发过来的三次握手的SYN&lt;比如三次握手还没完，shutdown了这个neighbor&gt;（思科原文用的是If any other input is received），那么会话会重新回到Idle开始；</p>
</li>
</ul>
<h3 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h3><p>TCP连接如果没成功建立，则会在Active状态反复尝试TCP连接。</p>
<ul>
<li>如果在Active状态TCP连接成功建立，则会发送Open报文，Hold Timer会设置为4分钟，也就是240秒，然后进入OpenSent状态；</li>
<li>如果TCP连接建立失败，则进入Connect状态并且重置ConnectRetryTimer；</li>
</ul>
<h2 id="BGP连接建立阶段"><a href="#BGP连接建立阶段" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h2><h3 id="OpenSent"><a href="#OpenSent" class="headerlink" title="OpenSent"></a>OpenSent</h3><p>在OpenSent状态，BGP会话的起始路由器会发送Open报文给对端，等待对端响应Open报文。Open报文用来检查两端BGP的参数是否匹配，下列参数会被比较\协商：</p>
<ul>
<li><p>BGP版本必须相符；</p>
</li>
<li><p>Open报文中的源IP地址必须和邻居配置的IP地址相等；</p>
</li>
<li><p>Open报文中两端配置的AS号要相匹配；</p>
</li>
<li><p>BGP的Identifiers（RID）必须唯一；</p>
</li>
<li><p>安全方面的参数（Password、TTL等）；</p>
</li>
</ul>
<p>如果Open报文的协商过程中没有出现错误，将会协商出来Hold Time的时间（以两端配置的最低值为Hold Time），并且发送Keepalive报文（假设Keepalive不设置为0的情况下），发送完keepalive报文后BGP会进入OpenConfirm状态。</p>
<p>如果Open报文的比较过程中出现了错误，会发送Notification报文，BGP状态会回到Idle状态。</p>
<p>如果在OpenSent状态中收到了TCP的disconnect报文，则BGP会关闭连接，重置ConnectRetryTimer，状态变为Active。</p>
<p>如果在OpenSent状态，配置进行了更改，那么状态会变为Idle。</p>
<h3 id="OpenConfirm"><a href="#OpenConfirm" class="headerlink" title="OpenConfirm"></a>OpenConfirm</h3><p>在OpenConfirm状态下，BGP会等待Keepalive或Notification报文。</p>
<ul>
<li>如果收到Keepalive报文则进入Establish状态；</li>
<li>如果等待Keepalive的时间超过了Hold timer计时器的时间或收到Notification报文，那么状态会变为Idle。</li>
</ul>
<h3 id="Established"><a href="#Established" class="headerlink" title="Established"></a>Established</h3><p>在这个状态下，BGP会话建立完毕，BGP邻居之间通过Update报文交换路由。当收到Update和Keepalive报文时，Hold Timer时间会重置，如果收到Update\Keepalive报文的时间超过了Hold Timer，说明邻居之间出现了问题，BGP会重新回到Idle状态。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2020/10/11/14-BGP/1603531494696-e8ad273f-826a-4e2c-bc43-6757706012af.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531585796-d49ff4b4-f826-4aa1-8c07-a46cf52a8df6.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531689211-ac810210-d781-4dd4-b9e1-69eaa1cd41ab.jpeg" alt="img"></p>
<h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a><a href="https://packetpushers.net/demystifying-bgp-session-establishments/">实验验证</a></h2><h3 id="直连EBGP邻居"><a href="#直连EBGP邻居" class="headerlink" title="直连EBGP邻居"></a>直连EBGP邻居</h3><p><img src="/2020/10/11/14-BGP/1604477133190-64f883ed-09dc-4383-a526-3f30cb704956.jpeg" alt="img"></p>
<p>线缆直连的单跳路由器之间建立EBGP邻居，是EBGP中最简单也最常见的方式，不需要对BGP进行过多的配置。</p>
<h4 id="基本配置："><a href="#基本配置：" class="headerlink" title="基本配置："></a>基本配置：</h4><p>R1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line"> !</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> neighbor 12.1.1.2 remote-as 200</span><br></pre></td></tr></table></figure>

<p>R2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 12.1.1.1 remote-as 100</span><br></pre></td></tr></table></figure>

<h4 id="命令简析"><a href="#命令简析" class="headerlink" title="命令简析"></a>命令简析</h4><ul>
<li>router bgp 命令表示在两台路由器上对BGP进程进行初始化的同时，也指出了本路由器所在的AS，比如R1上配置的是router bgp 100，这个100表示R1属于AS100。</li>
<li>neighbor命令在BGP配置模式中确定建立邻居的路由器的地址和AS号，R1配置的命令为’neighbor 12.1.1.2 remote-as 200’表示R1要和在AS200的IP地址为12.1.1.2的这个路由器建立邻居。R1从这个命令中得知，12.1.1.2在AS200中，和自己不在同一个AS中，所以R1知道了它和R2的BGP为EBGP；neighbor命令还告诉了路由器的TCP协议，只接受地址为12.1.1.2的TCP连接，由于我是在BGP邻居已经建立以后输入的命令，所以可以看到除了监听了neighbor命令中输入的12.1.1.2的179端口以外，12.1.1.1和12.1.1.2的TCP状态是已经建立（ESTAB）。除了TCP方面的影响，在输入neighbor命令后，R1还会运行一个IOS内部的检查机制，叫做samecabletest/same-cable test（<a href="https://learningnetwork.cisco.com/s/question/0D53i00000Kt0ed/is-ebgp-peer-up-bw-two-loopback-interfaces">The reason behind this is because of an internal IOS check mechanism that is known as the same-cable test. IOS makes sure the eBGP neighbor is directly connected (“C” route) before sending BGP open messages to the neighbor.</a>），也就是看EBGP的邻居是否是由同一个线直接连接，并且R1会查询到12.1.1.2的路由是否是类型C的，也就是否是直连路由。R1发送给R2的TCP和BGP报文中的TTL会设置为1，从抓包中可以看出这一点，因为要建立的是EBGP邻居。从show ip cef 12.1.1.2中能看到，到12.1.1.2的路由直连E0/0接口。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1604481355465-b42068c6-5959-4687-9326-04b491092234.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1604488330680-188241c7-9748-4363-830e-10abcdf50a9d.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1604488463443-5f0adf0b-3229-49f5-9579-5b70d31538a8.jpeg" alt="img"></p>
<p>BGP会话建立完毕后，BGP邻居之间使用Update报文交换路由，可以用show ip bgp neighbor查看建立状态：</p>
<p><img src="/2020/10/11/14-BGP/1604488644252-8f4c4472-c185-4999-adaf-e10847185e25.jpeg" alt="img"></p>
<h3 id="环回口EBGP邻居"><a href="#环回口EBGP邻居" class="headerlink" title="环回口EBGP邻居"></a>环回口EBGP邻居</h3><h4 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h4><p><img src="/2020/10/11/14-BGP/1604725542204-baa04789-2eca-4945-8ecd-3516af63fe15.jpeg" alt="img"></p>
<p>当两个AS之间有两根或以上的链路连接时，这时如果还用直连的地址建立BGP邻居，那么有以下两个方式：</p>
<ul>
<li>如果只用E0/0或E0/1之中的一个接口建立EBGP邻居，如果当这跟链路中断时，两端的BGP邻居会中断，所有从另一端学到的BGP路由信息都会从BGP路由表中删除，即使还有另一根备份链路能够联通两台路由器也是这样，因为只在其中一个链路上宣告了BGP，从而浪费了另一个链路的路由备份功能；</li>
<li>如果分别使用E0/0和E0/1都和对方建立EBGP邻居，这么做的缺点是，损失了可扩展性。因为在两条链路上分别宣告了BGP，E0/0一个BGP，E0/1一个BGP，也就是一共有两个宣告了BGP的链路，所以所有的路由信息会被宣告两次。</li>
</ul>
<p>经过分析可以发现，上面的两个方案都在高可用性和扩展性方面都存在着一定问题，所以这次不用两台路由器之间直连的地址建立EBGP邻居，而用两个路由器上的Lookback接口建立EBGP邻居。为什么这么做呢？因为loopback接口不是物理上存在的接口，而是一个逻辑上的接口，能够同时提供高可用性和扩展性。高可用性就是，只要两个设备之间的TCP连通性还在，用Loopback接口建立的邻居就不会Down掉，可以充分的利用冗余链路；扩展性就是，两台路由器之间还能加入更多的物理链路，而不会影响Loopback接口，也不用加入其他的配置。Loopback接口会一直保持的up的状态，除非两设备之间的物理链路断掉或逻辑接口被人为Shutdown。当然这两个Loopback接口之间并不是物理直连，所以这两个路由器上必须有对方Loopback的路由，保持这两个Loopback接口的TCP连通性，因为BGP协议的传输层用的是TCP协议。一般情况下，EBGP会用静态路由来保证两个Loopback接口的TCP连通性，而IBGP则用IGP（OSPF、EIGRP）协议提供Loopback的连通性。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><p>由于要用Loopback接口建立邻居，所以在R1和R2上进行如下配置：</p>
<p><strong>R1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 21.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line">bgp router-id 1.1.1.1</span><br><span class="line">neighbor 2.2.2.2 remote 200</span><br><span class="line">!</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 12.1.1.2</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 21.1.1.2</span><br></pre></td></tr></table></figure>

<p><strong>R2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 21.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line">bgp router-id 2.2.2.2</span><br><span class="line">neighbor 1.1.1.1 remote 100</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 12.1.1.1</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 21.1.1.1</span><br></pre></td></tr></table></figure>

<p>但配置过后发现，两者并未建立起BGP邻居，由于BGP在传输层采用TCP协议，所以先测试TCP协议是否成功建立，使用Ping命令测试两边Loopback接口的连通性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#ping 1.1.1.1 source 2.2.2.2</span><br><span class="line">R1#ping 2.2.2.2 source 1.1.1.1</span><br></pre></td></tr></table></figure>

<p>发现两边接口没问题，此时用debug ip bgp查看输出后发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#</span><br><span class="line">BGP: 2.2.2.2 Active open failed – update-source NULL is not available, open active delayed 12288ms (35000ms max, 60% jitter)</span><br></pre></td></tr></table></figure>

<p>这个Debug前半段显示的是，配置中的Update源头不存在，这是一个EBGP邻居会话独有的错误提示，默认情况下，运行思科IOS系统的路由器会用出接口，在这里是E0/0和E0/1，去连接配置中邻居的地址2.2.2.2，所以这个错误提示其实是说，2.2.2.2这个地址和本路由器不直连：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip cef 2.2.2.2</span><br><span class="line">0.0.0.0/0</span><br><span class="line">  no route</span><br></pre></td></tr></table></figure>

<p>输入命令show ip bgp neighbors 2.2.2.2 | include External BGP neighbor也能得到类似的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp neighbors 2.2.2.2 | include External BGP neighbor</span><br><span class="line">  External BGP neighbor not directly connected.</span><br><span class="line">  External BGP neighbor configured for connected checks (single-hop no-disable-connected-check)</span><br></pre></td></tr></table></figure>

<p>为什么在两边都有对方Loopback接口路由的情况下，依然TCP连接还失败呢？一方面是因为BGP的报文默认TTL为1，而两个Loopback接口之间至少需要两跳，也就是至少TTL=2才行，所以TCP连接一直无法建立；另一方面是因为BGP默认的update接口为直连口，必须将update源配置为Loopback接口才行。</p>
<p><img src="/2020/10/11/14-BGP/1604743789511-77243268-b13b-45ae-9e80-2b4e770d1323.png" alt="img"></p>
<p>所以分别在R1和R2上配置如下命令BGP才能顺利建立邻居关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line">neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="Update-source"><a href="#Update-source" class="headerlink" title="Update-source"></a>Update-source</h4><p>BGP建立邻居时没有用到组播地址，所以它无法像IGP那样自动发现邻居，需要手工指定，邻居的IP由本地的BGP neighbor命令指定，而该BGP连接的源IP（更新源）默认情况下为流量的出接口IP，只有当本地配置的邻居IP与邻居用于BGP连接建立的源IP相同时，BGP连接才能被正常建立，如果两台路由器之间需要用Loopback接口建立邻居，那么对方的Loopback接口就不是直连的IP，不满足BGP建立邻居的要求，无法建立起BGP邻居，解决这个问题，需要配置neighbor x.x.x.x update-source Loopback0这条命令，下面来看EBGP和IBGP两种不同情况：</p>
<ul>
<li>EBGP邻居之间的建立通常用直连的IP地址建立，建立EBGP邻居关系时，会首先检查直连路由，并且TTL默认为1，这么做是为了确保想要建立的邻居路由器和本路由器之间只有一跳，这么设计的初衷是为了保护EBGP的会话，缓解收到基于TCP或IP的攻击，也说明BGP的设计者认为EBGP用直连接口建立是最好的选择。如果此时用Loopback接口建立邻居的话就，就得指定Loopback接口为更新源，也就是配置一条neighbor x.x.x.x update-source Loopback0的命令，从而顺利完成邻居建立。那么，是需要在两边都配置这条命令还是只需要在一端配置呢？各个厂家的规定不同，<strong>思科<strong><strong>只在一端配</strong></strong>置****即可</strong>，<strong>但<strong><strong>Juniper是必须在两端都配置该命令</strong></strong>才能建立起邻居</strong>，所以严谨起见还是查阅厂家文档更万无一失。当R1和R2到对方的Loopback的网段使用静态或动态路由获取时，BGP邻居可以正常建立，但如果两端都用默认路由互指的话，BGP邻居无法正常建立，这么设计的原因是为了防环。</li>
<li>IBGP为了保持邻居关系的稳定，一般使用Loopback接口建立，这是因为如果使用物理接口，一旦用于建立BGP邻居关系的接口发生故障，BGP邻居就Down了，而且在AS内部，通常路径都是由冗余备份的，也就是有多条路径能够到达两个路由器，邻居之间的Loopback路由可通过IGP获取并提供一定的路由冗余性，只要还有其他的路径能维持两台路由器之间的TCP连通性，则BGP邻居就不受单一路径故障的影响，能一直维持BGP邻居的稳定。所以IBGP邻居用Loopback接口建立邻居时，也需要配置TTL和update-source这两条命令。</li>
</ul>
<p><strong>一端配置分析</strong></p>
<p>在上面的拓扑中，如果使用思科设备时只在一端，比如只在R2上配置了Update-source Loopback0这条命令，则建立邻居的步骤如下：</p>
<ol>
<li><p>R1尝试建立源为1.1.1.1，目标为2.2.2.2的EBGP邻居；</p>
</li>
<li><p>R2尝试建立源为2.2.2.2，目标为1.1.1.1的EBGP邻居；</p>
</li>
<li><p>R1收到R2试图建立TCP连接的SYN报文，因为TCP成功建立连接后路由器才会发送Open报文开始建立BGP邻居，R1拒绝了R2建立邻居的请求，因为R1上并<strong>没有配置</strong>Update-source Loopback0这条命令，所以R1认为它要和2.2.2.2建立邻居，而不是12.1.1.2&lt;因为BGP连接的源IP（更新源）默认情况下为流量的出接口IP&gt;；</p>
</li>
<li><p>R2收到了R1试图建立TCP连接的SYN报文，并且接受了TCP连接建立的请求，因为TCP连接的源地址为1.1.1.1，目标地址为2.2.2.2，R2<strong>配置了</strong>Update-source Loopback0这条命令，将BGP连接的更新源地址配置成了Loopback0；</p>
</li>
<li><p>R2用TCP的SYN-ACK报文回复R1，回复的报文源地址为2.2.2.2，目标地址为1.1.1.1；</p>
</li>
<li><p>R1收到了R2发过来的SYN-ACK报文，回复了TCP的ACK报文；</p>
</li>
<li><p>R1和R2之间的TCP连接成功建立，R1是TCP的Client端，R2是TCP的Server端，TCP连接建立的抓包如下：</p>
</li>
</ol>
<p><img src="/2020/10/11/14-BGP/1605066243442-4ce5f168-6dfe-4b04-963e-7bb3e93b8165.png" alt="img"></p>
<p>Update-source Loopback0这条命令只会对路由器初始化TCP连接时的动作产生影响，而不会对路由器作为TCP Server去回应TCP连接的动作产生影响。只要路由器从配置的neighbor地址上收到请求，就会允许连接建立。具体到上面的例子就是，R2配置了Update-source Loopback0这条命令，所以会使用2.2.2.2作为更新源，尝试与1.1.1.1建立BGP连接，而R1没有配置更新源的命令，所以更新源还是默认的12.1.1.1，但两者之间的TCP连接建立是没问题的，因为R2向R1的连接是没问题的。</p>
<p>如果使用loopback接口建立连接时忘记配置update-source这条命令，在debug bgp的时候会显示类似‘BGP: 2.2.2.2 Active open failed - tcb is not available, open active delayed 12288ms (35000ms max, 60% jitter)’的信息，里面的tcb表示tcp control block，也就是TCP连接受阻。</p>
<p>从上面可以看到，仅需保证<strong>一方</strong>满足上面的条件即可，也就是说一边配置update-source Loopback0命令即可，但为了加深印象、加快邻居建立以及防止漏配方便排错，<strong>建议两边都配置上</strong>。</p>
<h4 id="ebgp-multihop"><a href="#ebgp-multihop" class="headerlink" title="ebgp-multihop"></a>ebgp-multihop</h4><ul>
<li><p>如果在配置ebgp-multihop时并未指定具体条数，也就是配置了neighbor x.x.x.x ebgp-multihop命令时，则BGP报文的TTL被设置为255的同时，路由器会放弃直连检测；</p>
</li>
<li><p>如果在配置ebgp-multihop时明确的将数值配置成1，也就是配置了neighbor x.x.x.x ebgp-multihop 1，则BGP报文的TTL仍旧为1，路由器也会继续进行直连检测；</p>
</li>
<li><p>如果在配置bgp-multihop时将条数配置为2-255之间的数值，也就是配置了neighbor x.x.x.x ebgp-multihop {2-255}，则BGP报文的TTL值会配置为配置中的具体值，路由器放弃直连检测。</p>
</li>
</ul>
<p><a href="https://www.cisco.com/c/en/us/td/docs/ios/iproute_bgp/command/reference/irg_book/irg_bgp3.html#wp1106590">思科的文档</a>中描述该命令时说的是：</p>
<p>To accept and attempt BGP connections to external peers residing on networks that are not directly connected, use the <strong>neighbor ebgp-multihop</strong> command in router configuration mode. </p>
<p>翻译过来大概意思是，如果想要建立不直连的EBGP邻居时，需要配置该命令，不配置该命令的默认情况下，只有直连的邻居可以建立，因为EBGP默认情况下使用直连接口作为更新源。由于只有直连能够建立邻居，不配置ebgp-multihop时，R1的Loopback接口和R2的Loopback接口无法建立邻居，所以说明不用直连接口建立邻居时，肯定使用了直连检测看建立邻居的接口是否直连。那么能不能只把直连检测关闭呢？因为如果R1和R2之间直连用Loopback接口建立邻居时，TTL=1是能保证两者BGP报文相互传达的，因为中间没有其他路由器，TTL只有经过路由器时才会减1。答案是可以只关闭直连检测，用到的命令是：neighbor x.x.x.x disable-connected-check。</p>
<h4 id="disable-connected-check"><a href="#disable-connected-check" class="headerlink" title="disable-connected-check"></a><a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp3.html#wp1106122">disable-connected-check</a></h4><p><img src="/2020/10/11/14-BGP/1605329079757-18f0c77f-6d55-4e94-8423-44b8a6f5d6f6.jpeg" alt="img"></p>
<p>图中R1和R2直连但属于不同的AS，如果此时想用Loopback接口建立BGP邻居，那么两个Loopback接口之间的TTL是多少才能确保顺利通信呢？答案是1，因为在R2上用traceroute 1.1.1.1 source 2.2.2.2 ttl 1 1时，TTL=1也是能顺利trace到R1的1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1605329564073-ee095c3e-b58c-4d89-a863-efff55a622f8.jpeg" alt="img"></p>
<p>所以如果R1和R2此时想用Loopback接口建立邻居，且希望TTL=1应该如何呢？配置neighbor x.x.x.x disable-connected-check就能关闭直连检测用TTL=1建立Loopback邻居。</p>
<h3 id="EBGP多跳邻居"><a href="#EBGP多跳邻居" class="headerlink" title="EBGP多跳邻居"></a>EBGP多跳邻居</h3><p><img src="/2020/10/11/14-BGP/1605333855982-2ce686eb-1cc6-426e-a5ce-f1db89c02d6d.jpeg" alt="img"></p>
<h4 id="TCP阶段配置："><a href="#TCP阶段配置：" class="headerlink" title="TCP阶段配置："></a>TCP阶段配置：</h4><p>R1和R3用Loopback接口建立邻居，首先要考虑两个Loopback接口的TCP连通问题，这里用静态路由实现：</p>
<p><strong>R1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 3.3.3.3 255.255.255.255 10.1.12.2</span><br></pre></td></tr></table></figure>

<p><strong>R2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 10.1.12.1</span><br><span class="line">ip route 3.3.3.3 255.255.255.255 10.1.23.3</span><br></pre></td></tr></table></figure>

<p><strong>R3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 10.1.23.2</span><br></pre></td></tr></table></figure>

<p>配置完上述命令后，在R1或R3上分别ping对方的Loopback接口测试两个Loopback接口之间的连通性：</p>
<p><img src="/2020/10/11/14-BGP/1605334269937-4ceb1a68-d19e-4fa0-becb-aff43d469bac.jpeg" alt="img"></p>
<h4 id="BGP阶段配置"><a href="#BGP阶段配置" class="headerlink" title="BGP阶段配置"></a>BGP阶段配置</h4><p><strong>R1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> neighbor 3.3.3.3 remote-as 300</span><br><span class="line"> neighbor 3.3.3.3 ebgp-multihop 2</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p><strong>R3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> neighbor 1.1.1.1 remote-as 100</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>配置完BGP后，查看BGP邻居建立情况：</p>
<p><img src="/2020/10/11/14-BGP/1605334487388-0df04fba-ae83-493f-a3e7-1a7543c8f3ea.jpeg" alt="img"></p>
<h3 id="GRE隧道建立eBGP"><a href="#GRE隧道建立eBGP" class="headerlink" title="GRE隧道建立eBGP"></a>GRE隧道建立eBGP</h3><p><img src="/2020/10/11/14-BGP/1605337723554-d72de155-b116-4eed-be36-7f0fa6d181cf.jpeg" alt="img"></p>
<h4 id="TCP连接建立阶段-1"><a href="#TCP连接建立阶段-1" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h4><p>用GRE隧道建立BGP连接，首先要保证GRE隧道两端隧道的地址以及两个Loopback接口的连通性，这里用静态路由实现。由于使用了GRE隧道，R3上就不需要为1.1.1.1或2.2.2.2配置静态路由，因为GRE隧道的原目的IP地址是13.1.1.1和23.1.1.2：</p>
<p><img src="/2020/10/11/14-BGP/1605339705410-9b730824-b918-4139-9067-31b269e6ec4f.jpeg" alt="img"></p>
<p>R3和这两个端口直连，已经有了它们的路由：</p>
<p><img src="/2020/10/11/14-BGP/1605339592675-d65a903d-760b-4bc8-b4fc-4120dfccbac4.jpeg" alt="img"></p>
<p>所以在配置完tunnel和静态路由后，TCP连通性已经没有问题。</p>
<h4 id="BGP连接建立阶段-1"><a href="#BGP连接建立阶段-1" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h4><p><strong>R1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line"> tunnel source 13.1.1.1</span><br><span class="line"> tunnel destination 23.1.1.2</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 13.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 12.1.1.2</span><br><span class="line">ip route 23.1.1.2 255.255.255.255 13.1.1.3</span><br></pre></td></tr></table></figure>

<p><strong>R2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line"> tunnel source 23.1.1.2</span><br><span class="line"> tunnel destination 13.1.1.1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">！</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 12.1.1.1</span><br><span class="line">ip route 13.1.1.1 255.255.255.255 23.1.1.3</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，R1和R2可以在不改变BGP的TTL值情况下成功建立邻居，这种使用Loopback接口通过Tunnel（隧道）方式建立的BGP邻居，在逻辑上只有一跳，比如TCP建立过程中的SYN包中的TTL为1：</p>
<p><img src="/2020/10/11/14-BGP/1605758827224-66b75b48-d67f-45f2-a15b-872d6e6f0122.jpeg" alt="img"></p>
<p>所以结合上边几个实验可以得出结论，当配置了正确的update更新源时，ebgp-multihop命令只需要在两台设备物理上被其他设备隔开，也就是需要物理上多跳时必须配置，因为这种情况下的TTL大于默认值1；在设备直连并且通过Loopback接口建立邻居时，只是用‘disable-connected-check’命令就能建立起邻居，因为这种情况下的TTL=1，和默认的TTL相同，只需要关闭直连检测就行。</p>
<h3 id="iBGP直连邻居建立"><a href="#iBGP直连邻居建立" class="headerlink" title="iBGP直连邻居建立"></a>iBGP直连邻居建立</h3><p><img src="/2020/10/11/14-BGP/1605770492770-88d203c0-7a3d-4084-baa2-b5a2808f1e17.jpeg" alt="img"></p>
<p>上图中，AS100有两个相邻AS，AS100和AS200，由于AS100会承载起源和目标都不在本AS的流量，比如位于AS300的R5要发送数据给位于AS200的R1时会经过AS100，所以AS100是一个Transit AS，R2和R4是AS100的边界路由器；AS200和AS300由于之和AS100相连，所以它俩是Local AS；为了成功传递AS200和AS300之间的流量，所以两个边界路由器，R2和R4必须想办法交换他们从eBGP邻居那学到的路由条目，这种情况下就要用到iBGP了，R2和R4建立iBGP邻居后，两者就能交换彼此的路由。与eBGP不同，iBGP不在乎两个iBGP邻居之间的跳数是多少，因为iBGP设计的初衷就是为了让处于AS边界的路由器，例如R2，把它从eBGP邻居那学到的路由发送给在同一个AS的其他边界路由器，比如R4，虽然图中R2和R4之间只间隔了一个路由器R3，但在实际中两个边界路由器之间可能隔着很多其他路由器，因此没法要求iBGP邻居之间直连。</p>
<h4 id="TCP连接建立阶段-2"><a href="#TCP连接建立阶段-2" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h4><p>前面说过，要使得R2和R4建立BGP邻居首先要保证两台路由器TCP层面的连通性，可以使用静态路由或动态路由来达到这个目的从而使得BGP邻居顺利建立，这个实验中，我们用OSPF协议来保证AS100内部三个路由器彼此的TCP连通性，配置OSPF的时候在R3上偷懒使用了network 0.0.0.0  0.0.0.0 area 0，生产网络中中为了提高安全性还是尽量别这么配置，要宣告接口进OSPF，下面来看基本配置和连通性配置：</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 21.1.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 21.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 23.1.1.2 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 23.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> ip address 43.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 45.1.1.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 43.1.1.4 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 45.1.1.5 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这时查看R2、R3、R4的路由表可以发现，他们彼此有对方全部接口的路由，所以TCP连接没问题：</p>
<p><img src="/2020/10/11/14-BGP/1605937051694-6d81b024-2aad-4c53-8e3d-015fb739432a.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605937056382-89ddc6e5-a8df-4608-a1fc-13f220aee46d.jpeg" alt="img"></p>
<h4 id="BGP连接建立阶段-2"><a href="#BGP连接建立阶段-2" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h4><p>BGP阶段的目标是，R2、R3、R4彼此之间建立全互联（Full mesh）的iBGP邻居，R1和R2建立eBGP邻居，R4和R5建立eBGP邻居。配置如下：</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 21.1.1.2 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 21.1.1.1 remote-as 200</span><br><span class="line"> neighbor 23.1.1.3 remote-as 100</span><br><span class="line"> neighbor 43.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 23.1.1.2 remote-as 100</span><br><span class="line"> neighbor 43.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 23.1.1.2 remote-as 100</span><br><span class="line"> neighbor 43.1.1.3 remote-as 100</span><br><span class="line"> neighbor 45.1.1.5 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 45.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>用show ip bgp summary命令查看各路由器之间邻居建立关系：</p>
<p><img src="/2020/10/11/14-BGP/1605937941284-9cf80bc0-35ae-4179-81ba-5e7e386a81f4.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605938090917-82b7b9d1-e81c-4667-a45f-bd6508ca8b40.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605938122830-1a2848ee-1eff-4a73-9c53-726af4c9ed8f.jpeg" alt="img"></p>
<h3 id="iBGP邻居Loopback口建立"><a href="#iBGP邻居Loopback口建立" class="headerlink" title="iBGP邻居Loopback口建立"></a>iBGP邻居Loopback口建立</h3><p><img src="/2020/10/11/14-BGP/1605938292002-8ec1b06c-c387-49bf-b6dc-83f9823f25d5.jpeg" alt="img"></p>
<p>TCP连接建立阶段和上个实验相同，依旧用OSPF建立TCP连接，这里就不再赘述了，下面来看BGP连接建立阶段。</p>
<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 100</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>配置完后查看BGP邻居可以看到三个路由器之间彼此建立了iBGP邻居：</p>
<p><img src="/2020/10/11/14-BGP/1605939195577-a5483819-ae78-457b-99b0-7b2da3a1dcdc.jpeg" alt="img"></p>
<h3 id="iBGP邻居Next-hop-self"><a href="#iBGP邻居Next-hop-self" class="headerlink" title="iBGP邻居Next-hop-self"></a>iBGP邻居Next-hop-self</h3><p>iBGP邻居的一个潜在的坑就是，它不会自动更改next-hop-self也就是不会改变BGP表中的下一跳部分的值，让我们具体看个例子：</p>
<p><img src="/2020/10/11/14-BGP/1606194876453-c6a4c483-744d-4953-a2e1-3c5de47bd6a0.jpeg" alt="img"></p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>R1和R2是iBGP邻居，用OSPF协议保证TCP连通性；R2和R3是eBGP邻居，用直连接口建立。</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 12</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 12</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 3</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 3</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.2 remote-as 12</span><br></pre></td></tr></table></figure>

<p>此时iBGP、eBGP邻居都已顺利建立：</p>
<p><img src="/2020/10/11/14-BGP/1606195723044-dcf613c7-f9e5-408b-879f-e93da064fbbc.jpeg" alt="img"></p>
<h4 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h4><p>R3使用network命令将3.3.3.0/24的路由引入BGP，该路由在R3上是最优，所以传递给eBGP邻居R2，由于3.3.3.0/24始发于R3，所以在R3上的下一跳值为0.0.0.0：</p>
<p><img src="/2020/10/11/14-BGP/1606196061404-502790f4-3eb1-4d68-ae52-646bf385b19e.jpeg" alt="img"></p>
<p>现在来看R2上关于3.3.3.0/24的路由，收到R3发来的eBGP路由后，由于没有入向策略，所以这条路由不会被入向策略拒绝而直接进入Adj-RIBs-in路由表中，第一步先会检查下一跳是否可达，在R2上，这条路由的下一跳地址是192.168.23.3，R2的路由表中有去往该地址的路由，因为R2和它直连，所以这条路由有资格被选做最优的BGP路由；第二步进行BGP的路径选择，由于去往3.3.3.0只有一条BGP路由故该路由直接为最优，思科在前面加上&gt;表示Best；第三步BGP将这条是Best的路由的BGP放入Loc-RIB和Adj-RIBs-out表中，放入Adj-RIBs-out中的路由会更新发送给其他邻居，在本拓扑中也就是也就是发送给R1；第四步这条最优的BGP路由会发送到路由表，经过执行路由表选择程序，看它能否放入路由表中，由于R2的IGP路由表中没有关于3.3.3.0这条前缀的路由，所以这条BGP就是最佳的路由，最终加入路由表中。</p>
<p>这条路由中的Next Hop部分为什么是192.168.23.3呢？因为R2和R3使用直连接口建立邻居，eBGP邻居发过来的路由使用更新源地址作为Next Hop，也就是eBGP邻居彼此建立邻居用的地址，R2上配置eBGP邻居的命令是‘neighbor 192.168.23.3 remote-as 3’，所以由R3这个eBGP邻居宣告过来路由的下一跳是192.168.23.3。假设如果两者使用Loopback接口建立eBGP邻居，则R3宣告给R2的路由的Next Hop部分就是R3的Loopback接口地址。</p>
<p><img src="/2020/10/11/14-BGP/1606197045599-61017c05-5182-4694-942e-63d44419fe37.jpeg" alt="img"></p>
<p>R1收到来自iBGP邻居R2的关于3.3.3.0的BGP路由，由于没有入向BGP策略所以将该路由放入Adj-RIBs-in中：</p>
<p><img src="/2020/10/11/14-BGP/1606278129352-58cd2d5c-8aeb-4cdc-ae2e-6674e3a929b2.jpeg" alt="img"></p>
<p>可以看到，这条BGP路由在R1上的下一跳依旧是192.168.23.3，这是因为路由来自iBGP邻居时Next Hop部分在AS内传递时不会发生改变（除非做了策略），这个Next Hop始终指向的是下一个AS，也就是通告该路由的eBGP邻居的接口IP，具体到这个拓扑中就是，R1收到来自iBGP邻居R2的这条路由时，不会对Next Hop部分做更改，3.3.3.0这条路由的Next Hop在AS12内传递时的Next Hop始终是R3和本AS建立邻居的接口的IP地址，192.168.23.3。</p>
<p>但查看R1的路由表会发现，R1路由表中并没有到下一跳192.168.23.3的路由，所以这条路由并不是最优的BGP路由也不会加入路由表：</p>
<p><img src="/2020/10/11/14-BGP/1606285162672-433db18f-c660-466e-92c4-3ee8a9611cc9.jpeg" alt="img"></p>
<p>那么，R1即使有到3.3.3.0的路由但这种情况下却没法给该前缀发送数据，如果想给该路由发送数据怎么办呢？可以看到，R1之所以没法给该前缀发送数据是因为下一跳不可达，所以该路由并不是最佳路由也没法加入路由表，只需要将下一跳可达，那么这条路由就能加入路由表，R1也就能给该前缀发送数据了，如何让下一跳192.168.23.3可达呢？有两种方法，一种是将192.168.23.0网段宣告进BGP，另一种现网中在使用的是使用Next-hop-self命令改变这条路由的下一跳地址，这里只具体分析这种方法，在R2上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router bgp 12</span><br><span class="line">R2(config-router)#neighbor 1.1.1.1 next-hop-self</span><br></pre></td></tr></table></figure>

<p>来看看配置前后BGP表的变化：</p>
<p><img src="/2020/10/11/14-BGP/1606285610313-5793d9db-3813-4c61-82bb-c8e01a624cfd.jpeg" alt="img"></p>
<p>在R2上对邻居R1配置了Next-hop-self命令后，R2上该BGP路由的Next Hop值由不可达的192.168.23.3变为了2.2.2.2这个可达的地址，于是该BGP路由也是Best的，由于没有其他IGP路由，所以直接加入路由表，于是R1可以发送数据到3.3.3.0网段。</p>
<h3 id="Peer-Group"><a href="#Peer-Group" class="headerlink" title="Peer Group"></a>Peer Group</h3><p>当配置BGP邻居时，可能有时每个邻居的配置除了地址以外完全相同，为了避免每个邻居都要重复舒服一边命令，可以使用peer group来简化输入流程。</p>
<h4 id="EBGP邻居实验"><a href="#EBGP邻居实验" class="headerlink" title="EBGP邻居实验"></a>EBGP邻居实验</h4><p><img src="/2020/10/11/14-BGP/1608539673036-e2c4a0fe-590b-4c7a-b94c-47f0854748d2.png" alt="img"></p>
<p>当R1分别和R2、R3、R4用Loopback接口分别建立EBGP邻居并且将路由的metric设置为6666时，会发现配置R1时，每个邻居都要配置update-source loopback0和ebgp-multihop2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1(config)#route-map SET_MED permit 10</span><br><span class="line">R1(config-route-map)#set metric 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 remote-as 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 remote-as 3</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 remote-as 4</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 route-map SET_MED out</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 route-map SET_MED out</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 route-map SET_MED out</span><br></pre></td></tr></table></figure>

<p>如果使用peer  group的话，可以省掉那些配置相同的部分，不用每个邻居都配置一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 remote-as 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 remote-as 3</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 remote-as 4</span><br><span class="line"></span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 peer-group</span><br><span class="line"></span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 peer-group R2_R3_R4</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 peer-group R2_R3_R4</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 peer-group R2_R3_R4</span><br><span class="line"></span><br><span class="line">如果想对R2\R3\R4做任何策略的话，只需要对R2_R3_R4这个peer group做就行了，比如对R2\R3\R4应用配置邻居时的update-source和eBGP-multihop：</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 route-map SET_MED out</span><br></pre></td></tr></table></figure>

<p>R2\R3\R4的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.12.1</span><br><span class="line">!</span><br><span class="line">router bgp 2</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.13.1</span><br><span class="line">!</span><br><span class="line">router bgp 2</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.14.1</span><br><span class="line">!</span><br><span class="line">router bgp 4</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="IBGP邻居实验"><a href="#IBGP邻居实验" class="headerlink" title="IBGP邻居实验"></a>IBGP邻居实验</h4><p><img src="/2020/10/11/14-BGP/1609497517529-efe5c344-f274-4051-886d-31de60145bb9.jpeg" alt="img"></p>
<p>TCP层用OSPF打通，为了节省配置直接配置的‘network 0.0.0.0 255.255.255.255 area 0’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor R2_R3_R4 peer-group</span><br><span class="line"> neighbor R2_R3_R4 remote-as 1234</span><br><span class="line"> neighbor R2_R3_R4 update-source Loopback0</span><br><span class="line"> neighbor R2_R3_R4 next-hop-self</span><br><span class="line"> neighbor 2.2.2.2 peer-group R2_R3_R4</span><br><span class="line"> neighbor 3.3.3.3 peer-group R2_R3_R4</span><br><span class="line"> neighbor 4.4.4.4 peer-group R2_R3_R4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h2 id="如何宣告前缀进BGP"><a href="#如何宣告前缀进BGP" class="headerlink" title="如何宣告前缀进BGP"></a>如何宣告前缀进BGP</h2><p>宣告前缀进BGP有两个方法，</p>
<ul>
<li>用Network命令；</li>
<li>重分布；</li>
</ul>
<h3 id="Network命令"><a href="#Network命令" class="headerlink" title="Network命令"></a>Network命令</h3><p><img src="/2020/10/11/14-BGP/1606121717084-e0347cc5-12e6-4e0f-b4b5-7314a89ddd07.jpeg" alt="img"></p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 65101</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.12.1 remote-as 65101</span><br></pre></td></tr></table></figure>

<p>上面在宣告1.1.1.1/32这条路由进BGP时，必须宣告的和IGP路由表中的路由完全一样才行，也就是说前缀和掩码都必须相同，因为Loopback0的IP地址为1.1.1.1/32，所以在IGP路由表中是：</p>
<p><img src="/2020/10/11/14-BGP/1606121924273-cde94629-bcb1-43e9-adc1-b8f351cd147a.jpeg" alt="img"></p>
<p>所以应该宣告1.1.1.1掩码为32位进BGP，也就是network 1.1.1.1 mask 255.255.255.255。如果此时network命令后的前缀和路由表中不一样则输入的命令不会有效。如果宣告正确的话如图所示：</p>
<p><img src="/2020/10/11/14-BGP/1606122027282-264383c8-c56f-4049-b458-e485c4e5323a.jpeg" alt="img"></p>
<h3 id="重分布命令"><a href="#重分布命令" class="headerlink" title="重分布命令"></a>重分布命令</h3><p>也可以使用redistribute命令将路由重分布进BGP，用比如此时我们在R1上创建一个IP地址为111.111.111.111/32的Loopback接口，将该接口宣告进OSPF协议，并将OSPF协议用‘redistribute ospf1’重分布进BGP进程，会得到以下BGP表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;   111.111.111.111/32</span><br><span class="line">                       0.0.0.0                  0         32768 ?</span><br></pre></td></tr></table></figure>

<h2 id="BGP黑洞与同步"><a href="#BGP黑洞与同步" class="headerlink" title="BGP黑洞与同步"></a>BGP黑洞与同步</h2><h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><p><img src="/2020/10/11/14-BGP/1606287822270-adf20e04-8588-4ee7-b000-d143cce20d00.jpeg" alt="img"></p>
<p>拓扑如上，R1和R2，R5和R6之间为eBGP邻居关系，R2和R5之间为iBGP邻居，R3和R4不运行BGP协议。</p>
<h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3><p>R1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 65101</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.24.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.24.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 5.5.5.5 remote-as 65102</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"> neighbor 192.168.12.1 remote-as 65101</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.56.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 5.5.5.5 0.0.0.0 area 0</span><br><span class="line"> network 192.168.35.5 0.0.0.0 area 0</span><br><span class="line"> network 192.168.45.5 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 65102</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 192.168.56.6 remote-as 65103</span><br></pre></td></tr></table></figure>

<p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.56.6 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 65103</span><br><span class="line"> bgp router-id 6.6.6.6</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.56.5 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R6的BGP表和路由表：</p>
<p><img src="/2020/10/11/14-BGP/1606288634698-79b1a9c2-2e81-4525-a994-2353ac3870ed.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1606288667588-8b8c2431-a4bf-4531-ad40-6bd32ff1dcca.jpeg" alt="img"></p>
<h3 id="路由分析-1"><a href="#路由分析-1" class="headerlink" title="路由分析"></a>路由分析</h3><p>中间的AS 65102为Transit AS，AS 65102里的路由器的TCP连接由OSPF协议连通，R1上宣告了一条1.1.1.1/32的路由，宣告给eBGP邻居R2，由R2宣告给iBGP邻居R5，在R2上对邻居R5配置了Next-hop-self命令所以该路由在R5上是最优，可以最终传递给R5的eBGP邻居R6。但要注意，R2将BGP路由更新传递给R5时，是将BGP的update报文放在IP报内经过R3或R4发送给R5的，对于不运行BGP协议的R3和R4来说，这个BGP的update报文都是普通IP包，源目的地址为5.5.5.5和2.2.2.2，这两个地址的路由它们的路由表中有，可以正常转发，它们直接转发而不查看内部：</p>
<p><img src="/2020/10/11/14-BGP/1606289900580-2c1a04d4-7337-4e6c-be6f-e2bec78e6662.jpeg" alt="img"></p>
<p>此时在R6上能否ping通1.1.1.1呢？答案是不能，为什么不能ping通呢？先看R6，R6的路由表中有1.1.1.1/32的路由，下一跳是192.168.56.5，路由表中有到下一跳的路由，从E0/0发出即可：</p>
<p><img src="/2020/10/11/14-BGP/1606290419468-a6337b7c-22b7-499b-ae4a-3daeb29f2f00.jpeg" alt="img"></p>
<p>现在Ping包到了R5：</p>
<p><img src="/2020/10/11/14-BGP/1606290587409-bd67dba1-f48c-4070-9939-feade9321cbd.jpeg" alt="img"></p>
<p>从抓包中可以看到，ping包（ICMP）到了R5以后，目标IP地址是1.1.1.1，而R5的路由表中到1.1.1.1的下一跳是2.2.2.2，而到2.2.2.2的下一跳是192.168.45.4或192.168.35.3，也就是把数据包交给R3或R4，而R3或R4由于不运行BGP，不会知道去往会丢弃掉去往1.1.1.1这个不知道目的地的数据包，所以ping包无法通，至此形成路由黑洞。经过R3去往1.1.1.1网段的ping包抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1606293474582-8898b39b-d4c8-4f73-8f05-bf67adb0cc09.jpeg" alt="img"></p>
<p>问题产生的原因就是不运行BGP的R3、R4不知道AS外部1.1.1.1如何到达，要解决路由黑洞就要让中间的R2、R3有这个路由，可以采取iBGP全互联，将外部路由重发布进IGP（BGP的庞大路由对IGP来说一般无法搞定），路由反射器、联邦或MPLS解决。</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="联邦（confederation）"><a href="#联邦（confederation）" class="headerlink" title="联邦（confederation）"></a>联邦（confederation）</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>由于BGP有水平分割原则（运行BGP协议的路由器从一个iBGP邻居处收到的路由更新，不能再传递给其他iBGP邻居），iBGP邻居之间往往无法传递路由，为了解决该问题，除了可以使用full mesh、路由反射器以外，还可以用联邦。当然现网中为了传递iBGP之间的路由，几乎很少使用联邦，99.99%用的还是路由反射，联邦只是相对full mesh来说省事一些。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>在联邦内部保留联邦外部的Next Hop属性；</p>
</li>
<li><p>公布给联邦的路由的MED属性在整个联邦范围内予以保留；</p>
</li>
<li><p>路由的Local-Preference属性在整个联邦范围内给予保留；</p>
</li>
<li><p>在联邦范围内，将成员AS号压入AS_Path，但不公布到联邦外，并且使用TYPE3和TYPE4的AS_Path；</p>
</li>
<li><p>AS_Path中的联邦AS号用于在联邦内部避免环路；</p>
</li>
<li><p>联邦通过将一个AS“拆分”成多个小AS的方式解决iBGP路由传递的问题，比如下图中的AS345，被“拆分”成了AS 64512和AS64513，R3和R4之间是联邦iBGP关系，R4和R5之间是联邦eBGP关系。在联邦内部，R3和R4都属于AS64512，对于R4来说，R4属于AS64513，但对于联邦外部的路由器来说，R3\R4\R5都是AS345，外部根本不知道有AS64512、64513的存在。</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607506648291-f30c1d1a-a63a-48b3-81ec-b832413ad9dc.jpeg" alt="img"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2020/10/11/14-BGP/1607587871106-fe7fc954-b70b-4f06-833d-753c30356946.jpeg" alt="img"></p>
<p>AS2中的所有路由器运行OSPF协议打通TCP的连通性，AS2中又分为2个联邦AS。</p>
<h4 id="OSPF配置"><a href="#OSPF配置" class="headerlink" title="OSPF配置"></a>OSPF配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router ospf 1</span><br><span class="line">R2(config-router)#network 192.168.23.0 0.0.0.255 area 0</span><br><span class="line">R2(config-router)#network 192.168.24.0 0.0.0.255 area 0</span><br><span class="line">R2(config-router)#network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3(config)#router ospf 1</span><br><span class="line">R3(config-router)#network 192.168.23.0 0.0.0.255 area 0</span><br><span class="line">R3(config-router)#network 192.168.35.0 0.0.0.255 area 0</span><br><span class="line">R3(config-router)#network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4(config)#router ospf 1</span><br><span class="line">R4(config-router)#network 192.168.24.0 0.0.0.255 area 0</span><br><span class="line">R4(config-router)#network 192.168.45.0 0.0.0.255 area 0</span><br><span class="line">R4(config-router)#network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5(config)#router ospf 1</span><br><span class="line">R5(config-router)#network 192.168.35.0 0.0.0.255 area 0</span><br><span class="line">R5(config-router)#network 192.168.45.0 0.0.0.255 area 0</span><br><span class="line">R5(config-router)#network 5.5.5.5 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<h4 id="BGP-confederation配置"><a href="#BGP-confederation配置" class="headerlink" title="BGP confederation配置"></a>BGP confederation配置</h4><p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router bgp 24</span><br><span class="line">R2(config-router)#bgp confederation identifier 2</span><br><span class="line">R2(config-router)#bgp confederation peers 35</span><br><span class="line">R2(config-router)#neighbor 4.4.4.4 remote-as 24</span><br><span class="line">R2(config-router)#neighbor 4.4.4.4 update-source loopback 0</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 remote-as 35</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 update-source loopback 0</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 ebgp-multihop 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当配置BGP 联邦时，BGP的AS号要使用所在联邦的AS号，也就是使用24这个子AS号，所以这里配置命令为‘router bgp 24’；</p>
</li>
<li><p>前边说过，联邦的AS_Path只在联邦内部传递，也就是说R2所在的联邦的AS号24只在AS内部传递，那么联邦外的路由器如何知道R2真正的AS号，AS2呢？用命令‘bgp confederation identifier 2’来告诉其他AS的路由器，R2的主AS号为2，配置以后，对于联邦外的AS来说，整个AS就不是AS24了，而是AS2；</p>
</li>
<li><p>接下来要配置R2的其他所有BGP联邦的子AS号，在这里由于只有两个子AS，AS24和AS35，所以R2只需要配置另一个子AS，AS35就行了：bgp confederation peers 35。如果除了AS35以外还有另一个子AS，比如AS78，那么R2配置‘bgp confederation peers 35 78’即可，后面可以跟多个AS号；</p>
</li>
<li><p>R2和R4同在子AS24中，像配置普通的iBGP邻居一样配置即可；R3和R2分别在不同的子AS中，属于联邦的eBGP邻居，所以相比配置R4要多配置一条eBGP多跳的命令，因为eBGP的TTL默认为1跳，但R2和R3使用Loopback接口建立的eBGP邻居，TTL至少要2才能让报文传递到彼此成功建立邻居，所以这里配置‘neighbor 3.3.3.3 ebgp-multihop 2’这条命令。</p>
</li>
</ul>
<p>R3\R4\R5的配置和R2类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line">router bgp 35</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 24</span><br><span class="line"> neighbor 2.2.2.2 remote-as 24</span><br><span class="line"> neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 35</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router bgp 24</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 35</span><br><span class="line"> neighbor 2.2.2.2 remote-as 24</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 35</span><br><span class="line"> neighbor 5.5.5.5 ebgp-multihop 2</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line">router bgp 35</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 24</span><br><span class="line"> neighbor 3.3.3.3 remote-as 35</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 24</span><br><span class="line"> neighbor 4.4.4.4 ebgp-multihop 2</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p>现在在R5上用Loopback接口宣告进BGP一条55.55.55.55/32的路由，看其他路由器上这条路由的显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5(config)#interface loopback 5</span><br><span class="line">R5(config-if)#ip address 55.55.55.55 255.255.255.255</span><br><span class="line">R5(config-if)#exit</span><br><span class="line">R5(config)#router bgp 35</span><br><span class="line">R5(config-router)#network 55.55.55.55 mask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>R3关于这条路由的显示：</p>
<p><img src="/2020/10/11/14-BGP/1607745757988-544c8220-467a-45fd-9007-f6fd1e2eb352.jpeg" alt="img"></p>
<p>在R3上这条路由中，会显示‘confed-internal’表示该路由来自联邦子AS内部的iBGP邻居，现在来看看R2：</p>
<p><img src="/2020/10/11/14-BGP/1607745960837-b1f3ead9-7cea-4958-9de0-1e894c8a0af9.jpeg" alt="img"></p>
<p>在R2上显示‘confed-external’表示该路由来自联邦子AS的外部eBGP邻居。联邦AS之间的AS_Path类型为‘AS_CONFED_SEQUENCE’，用来在联邦内防环，该属性不会出联邦：</p>
<p><img src="/2020/10/11/14-BGP/1607751702754-80767e96-88d2-4c73-a00d-6f1bb8d64188.jpeg" alt="img"></p>
<p>现在让R1和R2之间建立eBGP邻居，看看R1上这条路由的显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 192.168.12.2 remote-as 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">R2(config)#router bgp 24</span><br><span class="line">R2(config-router)#neighbor 192.168.12.1 remote-as 1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1607752112362-05f09e5c-437c-44d2-b48c-28dbcacbdf53.jpeg" alt="img"></p>
<p>可以看到，55.55.55.55/32这条路由在R1上被看作是一条eBGP邻居传过来的路由，至于联邦内部的AS24和AS35是不会告诉处于联邦外部的R1的：</p>
<p><img src="/2020/10/11/14-BGP/1607752276014-0f73e31e-4df7-4db7-8eb1-0cee7c3fa11e.jpeg" alt="img"></p>
<p>现在来看看在如果在R1上宣告一条路由进BGP后会是什么效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#int loop 11</span><br><span class="line">R1(config-if)#ip add 11.11.11.11 255.255.255.255</span><br><span class="line">R1(config-if)#exit</span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#network 11.11.11.11 mask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>对于R2来说就是普通的由eBGP邻居发送过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752679710-7063dd27-b1bc-4af0-a6d0-096320c9cef3.jpeg" alt="img"></p>
<p>对于R3来说11.11.11.11/32是由联邦eBGP邻居，R2，宣告过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752813623-7fa53bde-da5d-4af7-9be2-e156500f7d23.jpeg" alt="img"></p>
<p>对于R4来说11.11.11.11/32是由联邦iBGP邻居，R2，宣告过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752906491-a721eb7d-69e3-4276-95cf-676d23fcf178.jpeg" alt="img"></p>
<h2 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>在AS内部，由于存在iBGP水平分割原则，使得AS内部的iBGP邻居之间传递路由十分麻烦，不得不两两建立iBGP连接，使得AS内部的BGP邻居之间形成full mesh（全互联）状态以获得完整的BGP路由更新，然而这是个扩展性非常低的做法，同时也给网络设备带来了负担，因为BGP对设备资源消耗很大，解决iBGP路由扩展问题的两种有效办法是路由反射器及联邦。路由反射器相比于联邦的优势在于，联邦中所有路由器都需要支持并理解联邦机制，而路由反射器只要RR（route reflector）理解反射机制即可，另外路由反射器的实现机制也相对简单一些，所以现网中99%用的都是路由反射器。</p>
<p>思考路由反射器时，将簇当作一个逻辑的整体去考虑，RR和client共同构成反射簇，相关配置在RR上完成，只有它才知道，RR只通告或反射它所知道的最佳路径。</p>
<p>为了维护BGP拓扑，RR在反射路由的时候不修改某些BGP路径属性，包括NH、AS_Path、Local-Preference和MED，并且增加了ORIGINATOR和CLUSTER_LIST用来防环。</p>
<p>路由反射器的反射规律如下：</p>
<ul>
<li><p>如果路由是从非client的iBGP对等体学习到的，则反射给所有的client和eBGP邻居；</p>
</li>
<li><p>如果路由是从client学习到的，则反射给所有非client的iBGP邻居以及除了该client以外的所有client；</p>
</li>
<li><p>如果路由是从eBGP邻居学习到的，则反射给所有client和非client的iBGP邻居。</p>
</li>
</ul>
<p>用一句话归纳就是“iBGP邻居非非不传，eBGP邻居反射路由”，也就是iBGP邻居的非client和非client之间不会进行路由反射，但都会反射给eBGP邻居。</p>
<h3 id="规则示例"><a href="#规则示例" class="headerlink" title="规则示例"></a>规则示例</h3><p><img src="/2020/10/11/14-BGP/1608350627934-6f5707b8-9bfb-4643-80c9-1c0c9bda3142.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1608350630941-06534341-1b18-4b91-8fbe-3bacf08791df.jpeg" alt="img"></p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p><img src="/2020/10/11/14-BGP/1608352413089-87eac9df-e296-4580-ac44-ff4b719b4847.jpeg" alt="img"></p>
<p>R1\R2之间，R2\R3之间为iBGP邻居，TCP连通性用OSPF打通，R1上宣告一条10.10.10.0/24的路由，由于水平分割原则的存在，R2从iBGP邻居R1那里学到的路由不能发送给R3，所以R3的路由表中没有这条10.10.10.0/24的路由。此时为了打破水平分割原则，在R2上配置路由反射器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-router)#neighbor 1.1.1.1 route-reflector-client</span><br></pre></td></tr></table></figure>

<p>此时在R3上已经有了10.10.10.0/24这条路由：</p>
<p><img src="/2020/10/11/14-BGP/1608353398313-11059a4d-6900-4702-8919-d411e3893a25.jpeg" alt="img"></p>
<p>在R3上如果想修改Cluster ID可以用命令‘bgp cluster-id X.X.X.X’进行修改。</p>
<p>上面输出中能看到，这条经过反射的路由多了两个属性，ORIGINATOR_ID和CLUSTER_LIST，下面来看看这两个属性。</p>
<h3 id="ORIGINATOR-ID与CLUSTER-LIST"><a href="#ORIGINATOR-ID与CLUSTER-LIST" class="headerlink" title="ORIGINATOR_ID与CLUSTER_LIST"></a>ORIGINATOR_ID与CLUSTER_LIST</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>由于AS_Path属性在AS内部不会发生变化，仅当路由离开本AS时才会被更新，而路由反射器打破了水平分割原则，有可能使路由出现环路，所以AS内必须有相对应的防环机制，所以路由反射器使用两个新的属性进行防环，ORIGINATOR_ID和CLUSTER_LIST，二者为路由反射器使用的可选非传递属性，用来防止环路。</p>
<ul>
<li>ORIGINATOR_ID是一个路由反射器创建的32bit值，该数值是本地AS中路由发起方的iBGP Router ID，注意发起方未必是这条路由的引入者，如果发起方发现其RID在所接收到的路由的ORIGINATOR_ID中，那么就知道已经出现了路由环路，因此会忽略该路由。</li>
<li>CLUSTER_LIST是遗传路由传递所经过的路由反射簇（Cluster）的ID，AS内的每个路由反射簇都有一个32bit的簇ID，如果簇中包含了多个RR，则需手工为每个RR配置簇ID。当RR将来自客户的路由反射给非客户时，同时将其簇ID附加到CLUSTER_LIST中，那么就知道出现了环路，则忽略该路由。CLUSTER_LIST属性只用于RR防环，RR只在反射路由的时候才会创建或更新CLUSTER_LIST，而下面几种情况，RR不会创建该属性：1、RR自己始发的路由；2、RR向EBGP邻居发送路由更新时，将会清除所有的CLUSTER_LIST属性；3、当RR从eBGP邻居收到路由，传递给client或非client时，不会创建CLUSTER_LIST。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1608365403976-5c775260-036a-49d4-a053-a13a03f9c471.jpeg" alt="img"></p>
<h4 id="ORIGINATOR-ID取值"><a href="#ORIGINATOR-ID取值" class="headerlink" title="ORIGINATOR_ID取值"></a>ORIGINATOR_ID取值</h4><p><img src="/2020/10/11/14-BGP/1608367486050-fa2c2078-7b28-4865-be7a-31d1e52e29b3.jpeg" alt="img"></p>
<p>R1位于AS100，与R2是eBGP邻居关系，将1.1.1.0/24的路由传递给R2，R2传递给iBGP邻居R3，但由于水平分割原则，R3不会将从iBGP邻居R2处学到的1.1.1.0/24路由传递给另一个iBGP邻居R4，这种情况下如果想将路由传递给R4，使R3成为RR，R4为R3的client，R3就能将路由传递给R4了，此时身为RR的R3会添加ORIGINATOR_ID和CLUSTER_LIST进路由，其中ORIGINATOR属性为R2的Router ID，也就是2.2.2.2而不是R1的Router ID，1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1608367767846-b91f554c-6c26-45ef-ba84-884d58f25851.jpeg" alt="img"></p>
<h4 id="CLUSTER-LIST与BGP选路"><a href="#CLUSTER-LIST与BGP选路" class="headerlink" title="CLUSTER_LIST与BGP选路"></a>CLUSTER_LIST与BGP选路</h4><p><img src="/2020/10/11/14-BGP/1608367924110-f6b40265-a996-421a-9833-e2d515285aba.jpeg" alt="img"></p>
<p>R1宣告11.11.11.0/24进BGP，R5分别通过R2和R4学到这条路由，在其他属性一致的情况下，Cluster list短的路由更优：</p>
<p><img src="/2020/10/11/14-BGP/1608368122153-83f9884d-67e4-4e1c-aa85-7ad11f16cfd2.jpeg" alt="img"></p>
<h3 id="冗余RR环境"><a href="#冗余RR环境" class="headerlink" title="冗余RR环境"></a>冗余RR环境</h3><p>单RR可能会存在单点故障，因此从冗余性的角度出发，一个簇中可以拥有多台RR，Client与每一台RR都有物理连接并建立BGP对等体关系，在其中一台RR出现故障的情况下，Client仍然有替代连接。因为Client不知道主机是别人的Client，所以RR本身也可以成为别人的Client，使用荣誉RR增加了网络的健壮性，ORIGINATOR_ID和CLUSTER_LIST属性用来在冗余RR中避免环路，可以将两个RR的Cluster ID配置为一样，可以进一步起到防环作用，所有的RR之间建议采取全互联的形式，比如：</p>
<p><img src="/2020/10/11/14-BGP/1608369164961-37ba507a-2b08-4c2a-a229-a0247a72a5b2.jpeg" alt="img"></p>
<h2 id="手工汇总"><a href="#手工汇总" class="headerlink" title="手工汇总"></a>手工汇总</h2><p>BGP支持自动汇总和手工汇总，但自动汇总存在很多问题，所以建议使用手工汇总。手工汇总的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aggregate-address address / length [ advertise-map map-name ] [ as-set ] [ attribute-map map-name ] [ summary-only ] [ suppress-map map-name ]</span><br></pre></td></tr></table></figure>

<p>常见配置为aggregate-address X.X.X.X  Y.Y.Y.Y，在不加任何关键字的情况下，同时传递明细路由和汇总路由。</p>
<h3 id="summary-only"><a href="#summary-only" class="headerlink" title="summary-only"></a>summary-only</h3><p>加上参数summary-only后，只传递汇总路由，明细路由被抑制不进行传播。这种情况下的汇总路由将丢失明细路由的AS_Path属性，因此可能存在一定的隐患。</p>
<p><img src="/2020/10/11/14-BGP/1608710052439-f810a49a-bde4-4b8f-b1ec-baf5e6255530.jpeg" alt="img"></p>
<p>基本配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br><span class="line"> </span><br><span class="line"> R2</span><br><span class="line"> router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br><span class="line"></span><br><span class="line">R3</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 summary-only</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br><span class="line"></span><br><span class="line"> R4</span><br><span class="line"> router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>此时在R3上show ip bgp查看BGP表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show ip bgp</span><br><span class="line">BGP table version is 10, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.0.0       0.0.0.0                            32768 i</span><br><span class="line"> s&gt;   172.16.1.0/24    192.168.13.1             0             0 100 i</span><br><span class="line"> s&gt;   172.16.2.0/24    192.168.13.1             0             0 100 i</span><br><span class="line"> s&gt;   172.16.10.0/24   192.168.23.2             0             0 200 i</span><br><span class="line"> s&gt;   172.16.11.0/24   192.168.23.2             0             0 200 i</span><br></pre></td></tr></table></figure>

<p>这条172.16.0.0/24的汇总路由，由于是本地产生的，所以Next Hop是0.0.0.0，weight为默认的32768，origin为i，其余的明细路由标记为‘s’，因为有summary-only，因此都被抑制了。</p>
<p>在R4上show ip bgp查看BGP表</p>
<p><img src="/2020/10/11/14-BGP/1608710967456-9f912dd4-dbb4-440f-ae28-4944de635ecb.jpeg" alt="img"></p>
<p>可以看到汇总路由带上了atomic-aggregate属性，用来告知下游路由器，这是汇总路由，丢失了明细路由的属性，同时aggregator属性标识了汇总的地点为AS300内的Router ID为3.3.3.3路由器。抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608711140898-8e923bcc-567f-4b12-91a9-57e301bd000b.jpeg" alt="img"></p>
<h3 id="AS-SET"><a href="#AS-SET" class="headerlink" title="AS-SET"></a>AS-SET</h3><p>汇总命令加上关键词‘as-set’后，产生的这条汇总路由就可以继承明细路由的某些路径属性，从而规避一些问题。as-set继承明细属性的规则如下：</p>
<ul>
<li><p>AS_Path：将收到的所有明细路由的AS号都放在{}中，计算AS_Path长度时，带{}的AS只被算作一个AS号；</p>
</li>
<li><p>Origin：继承最差的Origin属性；</p>
</li>
<li><p>Community：继承所有明细路由的Community，形成一个列表；</p>
</li>
<li><p>MED：不继承；</p>
</li>
<li><p>LP：取明细路由中LP最大值；</p>
</li>
<li><p>Next-Hop：汇总路由为0.0.0.0，因为汇总路由由本地产生。</p>
</li>
</ul>
<p>在R3上将汇总的配置命令替换为‘aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only’，刷新BGP以后R3上的BGP表为：</p>
<p><img src="/2020/10/11/14-BGP/1608796173697-f2da4dbb-ba17-48c4-af8e-5ccb3e28460d.jpeg" alt="img"></p>
<p>可以看到R3上这条汇总路由的AS_Path继承了明细路由的AS_Path，以{100，200}的形式呈现，这样能起到放缓作用，而且不会由于丢失明细路由的AS_Path而带来隐患，注意这里{}内的AS_Path类型是AS_SET，是无序的AS列表。</p>
<p><img src="/2020/10/11/14-BGP/1608796557547-8e333b33-870b-4b32-9f4b-9870f3e32001.jpeg" alt="img"></p>
<p>可以看到由于配置汇总路由时使用了AS-SET的关键字使得汇总路由得以继承明细路由的部分属性，因此产生的路由仍然保留有AGGREGATOR属性，但没有atomic-agg属性了，因为有了AS-SET关键字以后明细路由的属性都得以保留，不需要通告下游路由器这条路由的属性丢失，自然也就不需要atomic-agg属性了。</p>
<p>在R4上抓取R3发给R4的BGP update报文：</p>
<p><img src="/2020/10/11/14-BGP/1608796813231-56f8e211-1665-475c-b650-e19c63bdfd04.jpeg" alt="img"></p>
<h3 id="suppress-map-xxxx-as-set"><a href="#suppress-map-xxxx-as-set" class="headerlink" title="suppress-map xxxx  as-set"></a>suppress-map xxxx  as-set</h3><p>用于宣告聚合路由及抑制特定的明细路由，后边跟上的route-map XXX里route-map匹配（permit）的路由将被过滤，其他放行。抑制列表虽然调用route-map，但route-map只用于匹配路由，不能设置路由属性，也就是不能使用set命令。</p>
<h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/2020/10/11/14-BGP/1608970784715-868738dd-42a9-4574-aad9-50681f727209.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback22</span><br><span class="line"> ip address 11.22.22.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback33</span><br><span class="line"> ip address 11.33.33.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 1</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 11.22.22.0 mask 255.255.255.0</span><br><span class="line"> network 11.33.33.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.12.2 remote-as 23</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> R2：</span><br><span class="line"></span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 192.168.12.1 remote-as 1</span><br><span class="line"> neighbor 192.168.23.3 remote-as 23</span><br><span class="line"> neighbor 192.168.23.3 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.23.2 remote-as 23 </span><br></pre></td></tr></table></figure>

<p>R3在配置汇总抑制列表前的BGP表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  11.11.11.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.22.22.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.33.33.0/24    192.168.23.2             0    100      0 1 i</span><br></pre></td></tr></table></figure>

<p>现在来配置汇总和抑制列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router bgp 23</span><br><span class="line"> aggregate-address 11.0.0.0 255.0.0.0 as-set suppress-map SUPPRESS</span><br></pre></td></tr></table></figure>

<p>这种配置下，除了汇总路由，明细路由的11.11.11.0/24会被干掉，放行其他明细路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  11.0.0.0         192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.22.22.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.33.33.0/24    192.168.23.2             0    100      0 1 i</span><br></pre></td></tr></table></figure>

<p>如果将上面有关汇总的配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS deny 10</span><br><span class="line"> match ip address prefix-list 1</span><br></pre></td></tr></table></figure>

<p>等于route-map不匹配（deny）任何条目，因此所有明细路由都会被放行。</p>
<p>如果将配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 deny 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br></pre></td></tr></table></figure>

<p>效果也是不匹配任何路由，所有明细路由被放行。</p>
<p>如果将配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map SUPPRESS permit 10</span><br></pre></td></tr></table></figure>

<p>则明细全都被干掉，不放行任何明细。</p>
<p>如果将配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map SUPPRESS deny 10</span><br></pre></td></tr></table></figure>

<p> 则放行所有明细。</p>
<h4 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h4><p>可以在BGP中用‘邻居地址+route-map’实现相同功能，但用route-map实现的话，最后是隐含干掉any的，而suppress-map则不同。比如也在R2上进行汇总然后干掉明细的11.11.11.0/24的话，R2配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24               #抓取11.11.11.0/24这条要过滤掉的路由</span><br><span class="line">!</span><br><span class="line">route-map DENY deny 10                                    #deny掉这条需要过滤的明细路由</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">route-map DENY permit 20                                  #放行其他明细路由，由于route-map最后是deny掉any的，如果不放行则没有明细路由传递</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> neighbor 192.168.23.3 route-map DENY out                 #对邻居R3的out方向用设定好的route-map</span><br><span class="line"> aggregate-address 11.0.0.0 255.0.0.0 as-set              </span><br></pre></td></tr></table></figure>

<h4 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h4><p><img src="/2020/10/11/14-BGP/1608972665566-3934c61c-f426-4ba8-a7f1-c6f50fb2605f.jpeg" alt="img"></p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.2.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback10</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> ip address 192.168.35.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br><span class="line"> neighbor 192.168.35.5 remote-as 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 500</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.35.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>现在要求在R3上做汇总，将路由汇总为172.16.0.0/24，传给R5的除了汇总路由以外还有172.16.1.0/24这条明细路由，而传给R4的路由只有汇总路由。总体思路是，由于有四条明细路由而只想让R5知道其中一条明细路由，所以这里使用as-set搭配summary-only进行汇总，先将所有明细路由都抑制掉，然后再对特定的邻居R5使用非抑制列表，将需要传递给R5的那条明细路由传递给R5。</p>
<p>R3的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 172.16.1.0/24             #抓取路由172.16.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map PASS permit 10                                #配置抑制列表需要的route-map，将上面抓取的路由和route-map相匹配</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only    #用as-set搭配summary-only进行汇总，使得R4、R5上只有172.16.0.0/24的路由</span><br><span class="line"> neighbor 192.168.35.5 unsuppress-map PASS              #对邻居使用非抑制列表用来将172.16.1.0/24的路由传递给R5</span><br></pre></td></tr></table></figure>

<h3 id="attribute-map"><a href="#attribute-map" class="headerlink" title="attribute-map"></a>attribute-map</h3><p>attribute-map命令可以修改汇聚路由的属性，比如汇聚路由的origin、metric等，但该命令仅仅对汇总路由产生作用，对明细不起效。</p>
<p><img src="/2020/10/11/14-BGP/1609046627457-ebdf3cd0-97a6-4011-a8e1-15b361e8de8c.jpeg" alt="img"></p>
<p>在R2上将明细路由汇总为192.168.0.0/16并修改其属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 12</span><br><span class="line"> aggregate-address 192.168.0.0 255.255.0.0 attribute-map TEST</span><br><span class="line"></span><br><span class="line">route-map TEST permit 10</span><br><span class="line"> set metric 666</span><br></pre></td></tr></table></figure>

<p>汇总前和汇总后的BGP表对比</p>
<p><img src="/2020/10/11/14-BGP/1609125163847-d1b205bd-640d-4483-a41f-6fc587226dfd.jpeg" alt="img"></p>
<p>但此时再看R3的路由表：</p>
<p><img src="/2020/10/11/14-BGP/1609125266918-a23f52ac-e49f-4eb3-b5f1-dd466b5b9519.jpeg" alt="img"></p>
<p>由于R2和R3是eBGP邻居，所以汇总这条路由也传递给了R3，有可能造成路由环路，必须过滤掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 1 deny 192.168.0.0 0.0.255.255</span><br><span class="line"></span><br><span class="line">router bgp 12</span><br><span class="line">neighbor 10.1.23.3 distribute-list 1 out</span><br></pre></td></tr></table></figure>

<h3 id="advertise-map"><a href="#advertise-map" class="headerlink" title="advertise-map"></a>advertise-map</h3><p>当advertise-map与summary-only命令合用时，aggregate-address的汇总路由下面的明细路由均会被抑制，同时如果advertise-map匹配的条目中的明细路由如果全部挂掉，则汇总路由也会消失，但只要advertise-map匹配的明细中有一条路由还在，那么汇总路由就会在，并且汇总路由仅会继承advertise-map匹配的明细路由的BGP路径属性。结合下面这个实验具体说明advertise-map的作用。</p>
<h4 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/2020/10/11/14-BGP/1609126288482-59fa9336-e024-4c4e-8cf5-6a111edbb799.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 permit 172.16.1.0/24           #抓取1.0和2.0两条明细路由</span><br><span class="line">ip prefix-list 1 permit 172.16.2.0/24</span><br><span class="line"></span><br><span class="line">route-map TEST permit 10                        #设置抓取两条明细路由的route-map</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router bgp 300</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only advertise-map TEST</span><br></pre></td></tr></table></figure>

<p>手动汇总时的advertise-map调用了抓取了1.0/24和2.0/24的route-map，所以明细路由均会被压制，汇总路由仅会继承route-map TEST所匹配的明细路由的属性，由于route-map TEST匹配的明细路由是来自AS100的R1的1.0/24和2.0/24，所以汇总路由的Path属性中只继承了1.0和2.0的AS_Path，也就是300和100。只要1.0和2.0其中有一条存在，汇总路由就会存在，如果1.0和2.0都挂掉，那么汇总路由也会不存在。</p>
<p><img src="/2020/10/11/14-BGP/1609129461304-78cd98b4-7efa-41e4-b08a-c5714e1d20fa.jpeg" alt="img"></p>
<h4 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h4><p>R3宣告192.168.1.0和2.0进BGP进程，同时将1.0的community设置为no-adv，设置为no-adv以后，1.0路由从R1传递给R2后，不会再传递给R1，因为community为no-adv的路由不会再宣告给其他邻居：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 1 permit 192.168.1.0</span><br><span class="line">!</span><br><span class="line">route-map TEST permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line"> set community no-advertise</span><br><span class="line">!</span><br><span class="line">route-map TEST permit 20</span><br><span class="line"> set community none</span><br><span class="line">!</span><br><span class="line">router bgp 3</span><br><span class="line"> neighbor 10.1.23.2 send-community</span><br><span class="line"> neighbor 10.1.23.2 route-map TEST out</span><br></pre></td></tr></table></figure>

<p>在如上配置以后，R2能学到1.0和2.0两条路由，而R1只能学到2.0，学不到community为no-adv的1.0路由。</p>
<ul>
<li>当R2配置了‘aggregate-address 192.168.0.0 255.255.0.0’后，R1能学到汇总路由及明细路由2.0；</li>
<li>当R2配置了‘aggregate-address 192.168.0.0 255.255.0.0 as-set’后，R1只能学到2.0路由而无法学习到汇总路由，原因是因为1.0携带了no-adv的community，当汇总路由加了关键字‘as-set’后，汇总路由会继承明细路由1.0的community，因此汇总路由也携带了no-adv的community，不会发送汇总路由到R1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  192.168.2.0      10.1.12.2                0    100      0 3 i</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在上面的基础上在R2上进行如下配置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 11 deny   192.168.1.0</span><br><span class="line">access-list 11 permit any                               抓取除了192.168.1.0以外的其他路由，那就是抓取2.0这条路由</span><br><span class="line">!</span><br><span class="line">route-map ADV permit 10</span><br><span class="line"> match ip address 11</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line">aggregate-address 192.168.0.0 255.255.0.0 as-set advertise-map ADV</span><br></pre></td></tr></table></figure>

<p>上面的配置大概意思是说，汇总路由继承2.0的属性，而不继承192.168.1.0的属性，也就是不再有1.0的no-adv的community属性，所以汇总路由可以传递给R1。</p>
<p>配置以后R1的路由表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp</span><br><span class="line">BGP table version is 7, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  192.168.0.0/16   10.1.12.2                0    100      0 3 i</span><br><span class="line"> *&gt;i  192.168.2.0      10.1.12.2                0    100      0 3 i</span><br></pre></td></tr></table></figure>

<h2 id="Route-Dampening"><a href="#Route-Dampening" class="headerlink" title="Route Dampening"></a>Route Dampening</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>那些时有时无的不稳定路由称作路由翻滚，当路由翻滚出现在BGP中时，会导致邻居之间反复的发送update报文，从而增加设备的硬件资源消耗。BGP Dampening这个特性存在的意义是，减少那些翻滚路由的传播的同时，不会影响那些稳定路由的收敛。使用BGP dampening以后，会减少路由的硬件资源消耗并且增强网络总体的稳定性，稳定的路由会持续宣告给其他路由器，而翻滚的路由则会被抑制等它稳定后再进行传播。</p>
<p>具体步骤是，当路由翻滚出现后，给它分配一个惩罚值，翻滚越多惩罚值越大并且不断地积累。同时惩罚值又以一定的速率降低，每一个半衰期结束，如果在半衰期时间内路由不再翻滚的话，惩罚值会变为原来的一半。如果惩罚值超出了预先设置的阈值，也就是抑制阈值，路由会被抑制，也就是这条路由不再对外不发布，直到N个半衰期以后，惩罚值降低到另一个阈值，也就是低于重新使用阈值后，才会解除对路由的抑制。</p>
<p><strong>必须注意的是，Route Dampening只对eBGP路由生效，而对iBGP路由无效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">惩罚值： 每次摆动增加1000</span><br><span class="line">抑制阈值：   2000</span><br><span class="line">重新使用阈值：   750 </span><br><span class="line">半衰期： 15分钟</span><br><span class="line">最大抑制时间：  60分钟（半衰期的4倍） </span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1609145745191-9554c7a3-5fe5-4949-bddf-3e18fb539939.jpeg" alt="img"></p>
<p>正常情况下，所有路由的惩罚值都是0，惩罚值是瞬间增加的，例如某条路又出现翻滚后，则惩罚值瞬间会增加到1000，这时会有半衰期，也就是15分钟，15分钟后如果该路由没有出现翻滚，则惩罚值降低为一半，降低到500， 再经过15分钟变成250，这时如果路由又一次发生抖动，惩罚值再加1000，变成1250，在此之前，这条路由正常使用。如果在中间又抖动了一次，惩罚值再加1000，变成2250，超过了阈值规定的2000，则这条路由将被抑制，不更新也不使用，这段时间路由进入了抑制期。如果15分钟内这条路由不再翻动了，则惩罚值降低为一半，也就是1125，但仍然被抑制，只有当该路由的惩罚值降低为750，小于重新使用的界限（1000）时，路由会再次被启用。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip bgp dampening parameters                  #查看关于dampening的相关参数，比如各种阈值的设定和半衰期的时间</span><br><span class="line">show ip bgp dampening flap-statistics             #查看翻滚路由目前的状态</span><br><span class="line">show ip bgp dampening                             #查看那些路由被抑制了</span><br><span class="line">bgp dampening                                     #启动BGP dampening，默认对全部EBGP路由有效，也可以加route-map对特定路由起作用</span><br></pre></td></tr></table></figure>

<h1 id="路径属性"><a href="#路径属性" class="headerlink" title="路径属性"></a>路径属性</h1><p>BGP路由器通常会收到多条去往同一路由前缀的BGP路由，像IGP一样，这时就需要进行路径选择流程，选出最佳路径。但不像IGP一样只有一到两个属性用来选路，比如RIP是跳数小的路径更优，OSPF是Cost值小的路径更优，而BGP有很多属性用来决定一条路径是否更优：</p>
<p><img src="/2020/10/11/14-BGP/1606295209278-331107aa-8bf9-4244-82d9-68772a55575f.png" alt="img"></p>
<p>这些属性又分为公认属性（Well-known）和可选属性（Optional），公认属性又分为公认必遵（Well-known mandatory）和公认自决（Well-known discretionary）；可选属性又分为可选传递（Optional transitive）和可选非传递（Optional non-transitive）：</p>
<h2 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h2><p><img src="/2020/10/11/14-BGP/1606295493589-47555be0-9014-4d3c-87d1-dd081aee444b.jpeg" alt="img"></p>
<h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>公认必遵属性，明确了路由更新的来源，一共有三种：</p>
<ul>
<li><p>IGP，在BGP表中用‘i’表示，通过BGP的network命令宣告进BGP，也就是起源于IGP，因为BGP network命令宣告的路由必须在路由表中存在；</p>
</li>
<li><p>EGP，在BGP表中用‘e’表示，通过EGP协议重发布而来，现在已经没有EGP协议使用，因此不会见到e开头的路由；</p>
</li>
<li><p>Incomplete，在BGP表中用‘?’表示，通过其他渠道学习到的，路由来源的信息不完全，通常是由其他路由协议重分布进BGP的路由，当然整个不完整不表示这条路由可能会失效而是说路由的起源信息不完整；</p>
</li>
</ul>
<p>这三种来源路径之间的优选原则是IGP&gt;EGP&gt;Incomplete。</p>
<p>起始属性可以通过命令修改：</p>
<ul>
<li><p>route-map ORI permit 10                     #先配置route-map；</p>
</li>
<li><p>match ip address 1                               #确定要对哪些路由的origin属性进行修改；</p>
</li>
<li><p>set origin incomplete\igp                    #将origin属性修改成incomplete或igp；</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606363442113-2388ac61-1c87-44da-b2fa-4e8e121f7aca.png" alt="img"></p>
<h3 id="实验验证-1"><a href="#实验验证-1" class="headerlink" title="实验验证"></a>实验验证</h3><p><img src="/2020/10/11/14-BGP/1606373497233-3b069aee-0b56-41c5-b46f-25c370ec66ed.jpeg" alt="img"></p>
<p>R2和R3是eBGP邻居，R3上宣告一条3.3.3.0/24的路由到R2，现在要在R2上对这条BGP路由的origin属性进行更改，由之前的‘i’改为‘?’。R2更改origin属性之前的BGP表：</p>
<p><img src="/2020/10/11/14-BGP/1606374455509-4723d744-e245-4bcd-a5c9-885461d938dd.jpeg" alt="img"></p>
<p>之前BGP邻居的配置这里就不写了，只看和改变origin属性有关的配置，改变origin的配置可以在R2上的in方向，也可以在R3上out方向，我们在R2的in方向上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先用ACL匹配需要改变origin的这条路由：</span><br><span class="line">access-list 1 permit 3.3.3.0 0.0.0.255</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后用route-map将匹配的路由的origin变成incomplete：</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line"> set origin incomplete</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 最后在R2的in方向上对邻居使这条route-map在in方向上生效：</span><br><span class="line"> router bgp 12</span><br><span class="line"> neighbor 192.168.23.3 route-map 1 in</span><br><span class="line"> do clear ip bgp * soft                             #软刷新使BGP的配置生效 </span><br></pre></td></tr></table></figure>

<h2 id="AS-Path"><a href="#AS-Path" class="headerlink" title="AS_Path"></a><a href="https://sites.google.com/site/amitsciscozone/bgp/bgp-as_path-attribute">AS_Path</a></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>公认必遵属性，描述到达目标网络要经过的AS号序列，最重要的作用是防止BGP路由环路，如果BGP speaker发现自己的AS号出现在接收到的BGP路由更新的AS_Path中，那么说明可能有路由环路，路由器会忽略该路由更新。另一个重要作用，是在BGP选路过程中，作为AS跳数的丈量，AS_Path中包含的AS个数越少，表示距离目的网络更近，在其他路径属性相同的情况下，AS_Path越短越优先，先添加的AS号在右边，后添加的AS号在左边。AS_Path属性包含在建立邻居时的update报文中：</p>
<p><img src="/2020/10/11/14-BGP/1606541976124-06905b2f-5080-4202-939d-c2d0c13bf3fe.jpeg" alt="img"></p>
<p>在BGP表中的Path部分也是AS_Path，例如去往6.6.6.0/24的最佳BGP路由，也就是下一跳是192.168.13.3的这条，先经过了AS65300，然后经过AS65100最后发送到本AS：</p>
<p><img src="/2020/10/11/14-BGP/1606461813458-08659f18-aecb-4131-b7c2-b383895e14df.png" alt="img"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Four types of AS segments are supported within the AS_PATH in Cisco IOS-</p>
<ol>
<li><ol>
<li><strong>AS_SET -</strong> Unordered set of ASes a prefix in the UPDATE message has traversed</li>
<li><strong>AS_SEQUENCE -</strong> Ordered set of ASes a prefix in the UPDATE message has traversed</li>
</ol>
</li>
<li><ol>
<li><strong>AS_CONFED_SET -</strong> Unordered set of Member AS numbers in the local confederation that the UPDATE message has traversed</li>
<li><strong>AS_CONFED_SEQUENCE -</strong> Ordered set of Member AS numbers in the local confederation that the UPDATE message has traversed</li>
</ol>
</li>
</ol>
<p>AS_Path共分为四类：</p>
<ul>
<li>AS_SEQUENCE：RFC1771中的英文定义是‘ordered set of ASs a route in the UPDATE message has traversed’，就是按照该BGP路由经过AS的顺序有序列出来的有序AS列表，这里要注意，如果一个AS号在AS_Path部分越靠右，表示这条路由越早经过这个AS，比如下图中到6.6.6.0/24这条BGP路由，下一跳为192.168.13.3的这个，AS65300在最右边，表示该路由从AS65300发出，然后经过AS 65100到达本AS：<img src="/2020/10/11/14-BGP/1606544505722-70ceea4d-88f2-4740-a076-18c8780c781c.jpeg" alt="img"></li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606541922954-a785b815-01a8-435c-abb0-7851305a65d1.jpeg" alt="img"></p>
<ul>
<li>AS_SET：RFC1771中的英文定义是‘unordered set of ASs a route in the UPDATE message has traversed’，就是无序的将该BGP路由所经过的AS号无序列出来的一个无顺序的AS列表。一开始的时候我觉得，AS_Path不就是用来表示经过了哪些AS的嘛，肯定是要用上面提到的AS_SEQUENCE这种有序的排列类型的AS_Path啊，为什么还要有AS_SET这种无序的AS列表呢？后来才明白，AS_SET是在路由汇总时使用的，具体的参见后面实验部分。下图括号中的100，300就是AS_SET类型的AS_Path，但由于AS_SET是无序的，所以从中无法看出该路由是先经过了AS 100还是AS 300：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606544378538-c946baf4-38de-4fc5-b83c-7ea539b54016.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1606544663113-af5e3d1d-2dce-4d5b-b72b-1ab7ffd94bfc.jpeg" alt="img"></p>
<ul>
<li>AS_CONFED_SEQUENCE：和之前的AS_SEQUENCE用法完全一样，都是有顺序的AS列表，区别在于列表中的AS号属于本地联邦中的AS号：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606546397647-7b4b4908-a9ec-4476-9ec9-19265dabe2de.png" alt="img"></p>
<ul>
<li>AS_CONFED_SET：和之前的AS_SET用法完全一样，都是无序的AS列表，区别在于列表中的AS号属于本地联邦中的AS号。</li>
</ul>
<h3 id="生成-amp-修改AS-Path"><a href="#生成-amp-修改AS-Path" class="headerlink" title="生成&amp;修改AS_Path"></a>生成&amp;修改AS_Path</h3><p>When a BGP speaker advertises a prefix it learned from another BGP speaker, it modifies the prefix’s AS_PATH attribute based on location of BGP peer to which the prefix will be sent i.e. iBGP or eBGP peer-</p>
<ul>
<li><ul>
<li>The AS_PATH attribute is *<strong>not*</strong> modified when a prefix is advertised to an iBGP peer</li>
<li>The AS_PATH attribute is modified as follows when a prefix is advertised to an eBGP peer-</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>if the first path segment of the AS_PATH is of type <strong>AS_SEQUENCE</strong>, the local system prepends its own AS number as the last element of the sequence.</li>
<li>if the first path segment of the AS_PATH is of type <strong>AS_SET</strong>, the local system prepends a new path segment of type AS_SEQUENCE to the AS_PATH, including its own AS number in that segment</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>if the AS_PATH is empty, the local system creates a path segment of type AS_SEQUENCE, places its own AS into that segment, and places that segment into the AS_PATH.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>当BGP路由生成一条BGP路由时，起源路由器会将该路由用update报文通告给其他邻居：</p>
<ul>
<li>当通告给eBGP邻居时，这个update报文中会包含着类型为AS_SEQUENCE的AS_Path，路由器会将它的AS号放入该AS_Path中；</li>
<li>当通告给iBGP邻居时，这个update报文中AS_Path部分将为空，因为路由发送给iBGP不会修改AS_Path属性；</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>当运行BGP协议的路由器将一个从其他路由器学到的前缀宣告给另一个BGP邻居时，路由器是否修改前缀的AS_Path属性取决于通告的路由器是iBGP邻居还是eBGP邻居：</p>
<p>当BGP路由前缀被通告给iBGP邻居时，AS_Path属性不会被修改；</p>
<p>当BGP路由前缀被通告给eBGP邻居时，AS_Path属性会被修改：</p>
<ul>
<li>如果AS_Path已经有数值且该数值类型为AS_SEQUENCE时，路由器会将它自己的AS号加到序列的左侧，因为靠左侧的AS编号是最新经过的AS；</li>
<li>如果AS_Path已经有数值且该数值类型为AS_SET时，路由器会为AS_Path添加一段包含自己AS号在内，属性为AS_SEQUENCE的新序列，这个AS_SEQUENCE新序列和之前的AS_SET相互独立，但AS_SEQUENCE和之前的AS_SET是有先后之分的，下图中的AS_PATH表示路由先经过了{10 20}这个类型为AS_SET的AS，然后经过了30这个类型为AS_SEQUENCE的AS：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606720824164-a63a96d8-5594-486a-98cd-9f76d5dea377.jpeg" alt="img"></p>
<ul>
<li>如果AS_Path值为空，路由器会创建一个属性为AS_SEQUENCE的序列并将自身的序列号加入其中。</li>
</ul>
<p>这也意味着如果要修改AS_Path属性，必须在AS边界路由器上执行策略。</p>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><strong>AS_SEQUENCE</strong></p>
<p><img src="/2020/10/11/14-BGP/1606558436164-ea4d34d6-2b37-463d-9cc4-414d57506a22.jpeg" alt="img"></p>
<p><em>R1发给R2的update中的AS_Path：</em></p>
<p><img src="/2020/10/11/14-BGP/1606557673901-11a9663a-f954-4068-a823-8bf7902b5715.jpeg" alt="img"></p>
<p>R1和R2之间是eBGP邻居，所以该update在离开AS100时，会生成类型为AS_SEQUENCE的AS_Path序列，并将自己的AS号，也就是100，放入其中。</p>
<p><em>R2发给R3的update中的AS_Path：</em></p>
<p><img src="/2020/10/11/14-BGP/1606558402536-1d25129e-c3e1-4bf3-a11f-ae7149b9642f.jpeg" alt="img"></p>
<p>R2和R3之间是eBGP邻居，且该update中已经有了类型为AS_SEQUENCE的AS_Path，这个AS_Path值为100，这时R2会将它自己的AS号，200，加到序列号的左侧，也就是加到100的左侧。</p>
<p><strong>AS_SET</strong></p>
<p><img src="/2020/10/11/14-BGP/1606808699034-fdf3d310-922a-4484-8cc4-ebe6d8e34e12.png" alt="img"></p>
<p>R1和R3、R2和R3、R3和R4之间都是ebgp邻居，R1上用loop 1和loop 2两个环回口宣告172.16.1.0/24和172.16.2.0/24的两条BGP路由，R2上用loop 1和loop 2两个环回口宣告172.16.11.0/24和172.16.10.0/24的两条BGP路由，在R3上用aggregate-address as-set命令汇总，由于在汇总时带了AS_Set命令，产生的这条汇总路由可以继承明细路由的某些路径属性，比如AS_Path、Origin、Community等，具体参见后面路由汇总部分，现在我们只观察AS_Path部分。</p>
<p><strong>基本配置：</strong></p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.2.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br></pre></td></tr></table></figure>



<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R4上的BGP表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 18, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.0.0       192.168.34.3             0             0 300 &#123;100,200&#125; i</span><br><span class="line"> *&gt;   172.16.1.0/24    192.168.34.3                           0 300 100 i</span><br><span class="line"> *&gt;   172.16.2.0/24    192.168.34.3                           0 300 100 i</span><br><span class="line"> *&gt;   172.16.10.0/24   192.168.34.3                           0 300 200 i</span><br><span class="line"> *&gt;   172.16.11.0/24   192.168.34.3                           0 300 200 i</span><br></pre></td></tr></table></figure>

<p>先看最上面172.16.0.0这条汇总路由的update：</p>
<p><img src="/2020/10/11/14-BGP/1606810192758-f13beb3b-f858-4a80-a5f6-7180087afaba.jpeg" alt="img"></p>
<p>这条汇总路由的AS_Path部分包含两部分，值为300的为AS_SEQ 类型，用来标识路由起源，它是有序的；值为{100,200}为AS_SET类型，用来标识汇总前的明细的AS列表，它是无序的，用来防环。</p>
<p>如果你做实验并抓包了会发现，update中除了172.16.0.0/16这条汇总路由以外，携带了明细路由，这些明细路由的AS_PATH类型都是AS_SEQ 类型：</p>
<p><img src="/2020/10/11/14-BGP/1606810685377-3bd43c21-8322-4452-91ed-0cdcd2d46d77.png" alt="img"></p>
<p><strong>修改AS_Path</strong></p>
<p><img src="/2020/10/11/14-BGP/1606812352537-db9c189d-a051-4aa3-a7f5-e08931e71ff9.png" alt="img"></p>
<p>R1和R3、R2和R3之间都是EBGP邻居，R1和R2上均宣告一条1.1.1.0/24的BGP路由，目前R3上的BGP表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *    1.1.1.0/24       192.168.23.2             0             0 200 i</span><br><span class="line"> *&gt;                    192.168.13.1             0             0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到目前到1.1.1.0/24选择的是从R1到达，如何通过控制AS_PATH来影响选路呢？可以在R1上做策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set as-path prepend 6666</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 192.168.13.3 route-map 1 out</span><br></pre></td></tr></table></figure>

<p>这样配置后，R3上从R2学到的关于1.1.1.0的路由中的AS_PATH就由‘100  i’变成了‘100  6666  i’，当然这种操作在现网中还是不建议，因为6666这个AS并不存在，虽然加长了AS_PATH但带入了一个根本不存在的AS，所以可以用‘et as-path prepend 100 100 100’这种重复本AS的方式加长来实现目的同时避免不必要的麻烦。当然也可以在R3上对R1使用route-map：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> R3：</span><br><span class="line"> ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set as-path prepend 6666</span><br><span class="line"> router bgp 300</span><br><span class="line"> neighbor 192.168.13.1 route-map 1 in</span><br></pre></td></tr></table></figure>

<p>做完配置后，R3上从R1学到的关于1.1.1.0的路由的AS_Path就会变成‘6666  100  i’，这是因为R3收到1.1.1.0的时候，AS_Path已经是‘100  i’了，而新加入的AS号只能在左边插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.0/24       192.168.23.2             0             0 200 i</span><br><span class="line"> *                     192.168.13.1             0             0 6666 100 i</span><br></pre></td></tr></table></figure>

<p>使用策略修改AS_Path只能在BGP路由器上对其eBGP邻居执行，是因为AS_Path只有在AS边界才会发生改变，因此如果<strong>对iBGP邻居做AS_Path的策略修改是无效的</strong>。</p>
<h2 id="Next-hop"><a href="#Next-hop" class="headerlink" title="Next-hop"></a>Next-hop</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Next-hop是公认必遵属性，描述了到目的地的下一跳路由器。</p>
<h3 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h3><h4 id="路由传递自eBGP邻居"><a href="#路由传递自eBGP邻居" class="headerlink" title="路由传递自eBGP邻居"></a>路由传递自eBGP邻居</h4><p>如果BGP 路由传递自EBGP peer，那么这条BGP路由的NH就是通告者的接口IP，EBGP邻居一般使用对方的直连接口IP互指neighbor，但如果是采用Loopback接口建立的EBGP邻居，则NH就是EBGP邻居的更新源地址（一般情况下EBGP邻居不适用Loopback接口建立邻居）。</p>
<p><img src="/2020/10/11/14-BGP/1606903026168-5a263917-63c4-4f93-9a70-b88da2131ca7.jpeg" alt="img"></p>
<p>比如上面拓扑中的R1和R2为EBGP邻居，R1上宣告了一条1.1.1.0/24的BGP路由，该路由通过update报文传递给R2，由于R1和R2建立邻居使用的是直连接口，该直连接口的IP地址为10.1.12.1，所以在R2的BGP表中，该路由的下一跳为10.1.12.1，也就是说要去往1.1.1.0/24的数据，发送给10.1.12.1，也就是发给R1就行了，看到这，是不是感觉BG在nexthop方面很像之前的RIP呢？这是因为两者都是距离矢量路由协议，都是基于传闻传递的路由，而不是状态链路路由协议，所以不知道整体拓扑的连接情况，所以红茶三杯在讲BGP的时候曾经说过，BGP其实很像RIP协议，只不过多了很多的特性和属性，这个说法一个原厂大佬朋友也很赞同。</p>
<p><img src="/2020/10/11/14-BGP/1606903296486-57eafd1c-16cb-4d5d-abc7-ec64c03efca3.jpeg" alt="img"></p>
<h4 id="路由传递自iBGP邻居"><a href="#路由传递自iBGP邻居" class="headerlink" title="路由传递自iBGP邻居"></a>路由传递自iBGP邻居</h4><p><strong>同AS的路由器引入了某路由</strong></p>
<p><img src="/2020/10/11/14-BGP/1606988007404-a4dc754d-6e18-443c-be04-d96375bfb902.jpeg" alt="img"></p>
<p>R1、R2、R3都在AS 123内，R1\R2，R2\R3之间为iBGP邻居都用直连接口建立，R1\R2之间网段为192.168.12.0/24，R2\R3之间网段为192.168.23.0/24，R1上宣告了一条1.1.1.1/32的BGP路由，并将其宣告给了iBGP邻居R2，如果这时不做额外的配置，那么由于水平分割原则（从一个iBGP邻居处收到的路由条目不会再传递给另一个iBGP邻居），那么R2不会将1.1.1.1/32这条路有宣告给R3，如果此时在R2上配置了路由反射器，打破了水平分割原则，所以R3能收到这条路由，在R3上这条路有的Next Hop依旧为R1的更新源地址，也就是R1和R2建立邻居的地址，192.168.12.1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.1/32       192.168.12.1             0    100      0 i</span><br></pre></td></tr></table></figure>

<p><strong>路由传递自iBGP邻居，描述的是AS外的目的地</strong></p>
<p>从外部AS传递进来的路由，Next Hop为通告该路由的eBGP 邻居，且整个Next Hop会随着路由在AS内部传递而不发生改变，除非做了策略，否则始终指向的是下一个AS（通告该路由的eBGP 论据接口IP）。下面来看个例子：</p>
<p><img src="/2020/10/11/14-BGP/1606989582716-20f2c0f8-3a48-435d-91f4-e7dad91046a5.jpeg" alt="img"></p>
<p>R1\R2为eBGP邻居，R2\R2为iBGP邻居，在R1上宣告一个1.1.1.0/24的路由，该路由宣告给R2，再由R2宣告给R3，来看这条路由在R3上的Next Hop：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到，R3上关于该路由的Next Hop和在R2上一致，始终是R2建立eBGP邻居的那个IP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor 10.1.12.1 remote-as 100</span><br></pre></td></tr></table></figure>

<p><strong>路由传递自iBGP邻居，并由AS内BGP路由引入</strong></p>
<ul>
<li><p>如果是通过aggregate-address命令被注入的，那么Next Hop等于执行汇总的路由器的更新源地址；</p>
</li>
<li><p>如果是通过network或重发布注入的，那么在注入前，该前缀的IGP下一跳将成为BGP的Next Hop；</p>
</li>
<li><p>如果本地的BGP宣告者成为了下一跳地址，那么在本地BGP RIB中的下一跳字段就是0.0.0.0；</p>
</li>
</ul>
<h3 id="Next-hop-self命令"><a href="#Next-hop-self命令" class="headerlink" title="Next-hop-self命令"></a>Next-hop-self命令</h3><p>由于next hop在传递给EBGP邻居时会改变，而传递给iBGP邻居时不会改变所以在建立iBGP邻居时，这样导致法网iBGP邻居的路由下一跳不可达从而不会加入路由表，此时可以用‘neighbor 1.1.1.1 next-hop-self’命令将传递给iBGP邻居路由的下一跳设置为自己，使得BGP路由的下一跳可达，具体用法及实验参照邻居建立中iBGP邻居部分。</p>
<h2 id="Local-Preference"><a href="#Local-Preference" class="headerlink" title="Local-Preference"></a>Local-Preference</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>Local-Preference是公认自决属性，默认值为100，只用于iBGP邻居之间，决定离开AS的最优路径，一般用于控制本AS的出口设备。</p>
<ul>
<li>Local-Preference就是本地优先级，当一个AS收到一个去往同意目的地的，但经过两个AS的路由，在其他BGP路由属性完全一致的情况下，根据两条路由的local-preference决定，值越大越优，比如下图中的路由器D，从C和E两个路由器都收到了去往172.20.0.0的路由，但E发过来的路由属性中Local-Preference值大于C发过来的路由属性，所以去往E的路由更优：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607149141276-33b3db5c-2872-426d-93d9-68314eaef8ad.jpeg" alt="img"></p>
<ul>
<li><p>Local-Preference只能在AS内部的iBGP邻居之间传递，而不会传递给其他eBGP邻居，Local-Preference除非做了策略，否侧在AS内的iBGP邻居之间传递时不会丢失，如果eBGP邻居之间收到的路由的路径属性中携带了Local-Preference的话，会触发notification报文造成BGP会话中断，但可以在AS边界路由器上使用IN方向策略；</p>
</li>
<li><p>Local-Preference在向eBGP邻居发送路由更新时，不能携带LP属性，对方收到该eBGP路由的LP值为空，也就是说路径属性中根本没有LP这个字段，但它会在本地为这条路由赋一个默认值，也就是100，然后再传递给自己的iBGP邻居；</p>
</li>
<li><p>本地network命令及重发布命令发布的路由，LP值默认为100，并能在AS内向其他iBGP邻居传输，传输过程中除非部署了策略，否则LP值不会发生变化；</p>
</li>
<li><p>修改默认LP值的命令为：bgp default local-preference  XXX。</p>
</li>
</ul>
<h3 id="实验及抓包"><a href="#实验及抓包" class="headerlink" title="实验及抓包"></a>实验及抓包</h3><h4 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h4><p><img src="/2020/10/11/14-BGP/1607148741237-dcc8acdd-c13d-431e-aa78-398444e1ac91.jpeg" alt="img"></p>
<p>R1发送给R2的update抓包中可以看到，eBGP邻居之间的路由属性中没有Local-Preference属性：</p>
<p><img src="/2020/10/11/14-BGP/1607148820773-a562ce75-c05a-4bce-938e-bfe7e024c66e.jpeg" alt="img"></p>
<p>R2发送给iBGP邻居R3的update报文抓包中可以看到，iBGP邻居之间的路由属性中有Local-Preference属性，这里没有用策略修改，所以默认值是100：</p>
<p><img src="/2020/10/11/14-BGP/1607149038111-368b4537-ff1d-43c9-a1dd-1f72316b54ed.jpeg" alt="img"></p>
<h4 id="单独修改LP"><a href="#单独修改LP" class="headerlink" title="单独修改LP"></a>单独修改LP</h4><p><img src="/2020/10/11/14-BGP/1607153818205-254dbe49-34ed-44ce-a3c9-7b4caf32f553.jpeg" alt="img"></p>
<p>拓扑和上一个实验相同，区别在于R1上除了宣告1.1.1.0/24以外，也宣告了111.111.111.0/24，在R3上的BGP表中如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br><span class="line"> * i  111.111.111.0/24 10.1.12.1                0    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>从上面的BGP表中可以看到，默认情况下，两条路由在R3上的Local-Preference都是100，现在我们在R2上对111.111.111.0/24的路由做策略，让这条路由的LP变为200：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">ip prefix-list 1 seq 5 permit 111.111.111.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.23.3 route-map LP out</span><br></pre></td></tr></table></figure>

<p>R3上的BGP表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br><span class="line"> * i  111.111.111.0/24 10.1.12.1                0    200      0 100 i</span><br></pre></td></tr></table></figure>

<h2 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p>MED是可选非传递属性，当其他属性相同时，MED值越小越优，用于AS之间影响路由，一般用于控制进入本AS的入口设备，思科设备默认MED=0，默认情况下只比较来自同一邻居AS的BGP路由的MED值，如果同一个目的地的两条路由来自不同的AS则不进行MED值的比较。下图中路由器A从路由器B和C上都收到了172.20.0.0这条路由，B和C在同一AS所以比较MED值，由于B这条路由的<strong>MED值更小所以更优</strong>，故A会选择路由器B的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607152363500-f40cd17c-bc9e-4210-845b-8dfba9804f43.jpeg" alt="img"></p>
<h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><ul>
<li><p>将IGP路由引入BGP时关联Route-map进行设置；</p>
</li>
<li><p>对BGP 邻居使用IN\OUT方向的Route-map进行设置；</p>
</li>
<li><p>非Route-map方式：</p>
</li>
</ul>
<ol>
<li>使用network或redistribute方式将IGP路由引入BGP时，MED将继承IGP路由的Metric（直连路由及静态路由的Metric为0）；</li>
<li>使用aggregate-address方式引入路由则MED为空；</li>
</ol>
<h3 id="MED传递"><a href="#MED传递" class="headerlink" title="MED传递"></a>MED传递</h3><p>当BGP路由通告给eBGP邻居时：</p>
<ul>
<li>如果该BGP路由是本地始发的，也就是在本路由器上通过network或redistribute引入的，则发送给eBGP邻居时携带MED值；</li>
<li>如果该BGP路由是从其他BGP邻居雪莱的，则将该路由通告给eBGP邻居时不携带MED（路由属性中没有MED部分），换句话说，就是MED不会被传出本AS；</li>
</ul>
<p>当BGP路由通告给iBGP邻居时，一定会携带MED值，如果接收或产生的路由的MED为空，那么在向iBGP邻居通告时，将MED设置为0。</p>
<p><strong>总的来说就是MED在iBGP邻居之间传递没有问题，不会丢失，但在eBGP邻居之间传递要看路由是否起源于自己，起源于自己就带MED，不起源于自己就不带MED。</strong></p>
<h3 id="MED继承"><a href="#MED继承" class="headerlink" title="MED继承"></a>MED继承</h3><ul>
<li><p>network本地从IGP路由协议学到的路由进BGP，MED值继承IGP协议中的metric；</p>
</li>
<li><p>network本地直连接口的网段进BGP，MED值为0；network本地静态路由进BGP，MED值为0；</p>
</li>
<li><p>redistribute本地从IGP路由协议学到的路由进BGP，MED值继承IGP协议中的me</p>
</li>
<li><p>redistribute本地直连接口网段进BGP，MED值为0；redistribute本地静态路由进BGP，MED值为0。</p>
</li>
</ul>
<h3 id="其他配置命令"><a href="#其他配置命令" class="headerlink" title="其他配置命令"></a>其他配置命令</h3><p><strong>bgp always-compare-med</strong></p>
<p>默认情况下，只有来自相同AS的外部路由才比较MED值，但如果配置了这条命令，即使是来自不同AS的路由，也会比较MED。如果配置了该命令，那么建议在整个AS中都这么配置，以避免路由选择环路。</p>
<p><strong>bgp bestpath med missing-as-worst</strong></p>
<p>如果某路由MED属性丢失，一般的做法是给MED默认设置为0，但如果配置了这条命令，再收到没有MED值的路由，会将该路由的MED值设置为最大，也就是4294967295。</p>
<p><strong>set metric-type internal</strong></p>
<p>用在route-map中，当用route-map匹配某些条目且使用了该set命令后，比如在out方向上向邻居应用了带set metric-type internal的route-map命令以后，被匹配的这些路由条目更新给邻居后，BGP的MED属性会继承这些路由在本地IGP的metric值。</p>
<p><strong>bgp bestpath med confed</strong></p>
<p>配置这条命令后，在选路时，路由器只比较具有带有AS_CONFED_SEQ属性的条目，此命令用于联邦路由器，同时weight及LP属性比MED具有更高的优先级。</p>
<p><strong>bgp deterministic-med</strong></p>
<p>用于确保来自相同的AS的不同对等体通告的路由<strong>先</strong>进行MED比较。</p>
<p>此命令和bgp always-compare-med的关系如下：</p>
<p><img src="/2020/10/11/14-BGP/1607325749976-bb8b43cd-6938-4c68-8979-b77ea1e6cc4f.png" alt="img"></p>
<ul>
<li><p>如果两条命令都关闭：则按缺省的从上往下的顺序进行比较 ，则 1、2 先比较，2 优选（因为 2 具有更小的 RID）； 然 后 2 与 3 比较，2 为 external，所以 2 优选。</p>
</li>
<li><p>如果打开bgp always-compare-med：则 1、2 先比较，1 优选（因为 1 具有更小的 MED） ；由于 1、3 在一个相同的 AS 中，所以再次比MED，选 3。</p>
</li>
<li><p>如果打开deterministic-med，路由前缀的信息按AS重新分组：</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607326342712-e22a5f44-5d91-4f47-9ed8-ef6cf3f94c48.png" alt="img"></p>
<ul>
<li>如果都打开，则2、3 同 AS 内先比较，2 的 MED 小所以优选；2 与 1 再比较，由于开了 always-compare-med 所以比 MED，2 的 MED 小，所以 2 为最佳路径.</li>
</ul>
<p><strong>Default-metric X</strong></p>
<p>修改MED值的缺省值，但此命令对直连路由不生效，直连路由的MED仍为0</p>
<h2 id="COMMUNITY"><a href="#COMMUNITY" class="headerlink" title="COMMUNITY"></a>COMMUNITY</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p>community属性为可选传递。</p>
<p>community属性是一组4个8位组的数值，RFC1997规定前2B表示AS号，后2B表示基于管理项目设置的标识符，格式为AA:NN，32位的BGP community被分成了两部分，前16位一般用来标识使用该community的AS号，后16位一般用来标识作用。而CISCO默认显示格式为NN:AA，可使用全局配置命令，ip bgp-community new-format将思科默认格式改为RFC格式。</p>
<p>例如将AS12的某条路由的community值改为10000，RFC采用十六进制表示community属性，而CISCO采用十进制。RFC格式为12：10000，十六进制为0X000C2710，再转换为十进制796432：</p>
<p><img src="/2020/10/11/14-BGP/1607411667258-8766defd-a867-4338-b5b1-ed02012bb9f5.png" alt="img"></p>
<p>用于简化路由策略的执行，可以将某些路由分配一个特定的community属性，之后可基于community值而不是每条路由进行BGP属性的设置了。community属性对邻居起作用。具体如何执行呢？让我们用一个北美ISP举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - Prepending</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">65001:0   - prepend once  to all peers</span><br><span class="line">65001:XXX - prepend once  at peerings to AS XXX</span><br><span class="line">65002:0   - prepend twice to all peers</span><br><span class="line">65002:XXX - prepend twice at peerings to AS XXX</span><br><span class="line">65003:0   - prepend 3x to all peers</span><br><span class="line">65003:XXX - prepend 3x    at peerings to AS XXX</span><br><span class="line">65004:0   - prepend 4x to all peers</span><br><span class="line">65004:XXX - prepend 4x    at peerings to AS XXX</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - Regional</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">Will only work for regional peers</span><br><span class="line">64980:0   - announce to customers but not to EU peers</span><br><span class="line">64981:0   - prepend once  to all EU peers</span><br><span class="line">64982:0   - prepend twice to all EU peers</span><br><span class="line">64983:0   - prepend 3x    to all EU peers</span><br><span class="line">64984:0   - prepend 4x    to all EU peers</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - LocalPref</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">3356:70   - set local preference to 70</span><br><span class="line">3356:80   - set local preference to 80</span><br><span class="line">3356:90   - set local preference to 90</span><br></pre></td></tr></table></figure>

<p>上边是一个过去的北美ISP的配置，用来说明如何使用community属性来简化配置。如果该ISP将一条前缀打上3356：90的标签，那么这条前缀的local preference将被设定为90，如果将路由打上标签64983：0，则该路由在发送到欧洲的邻居对等体之前将复制自身AS三次。这么做就不用每次对一条路由做策略时都需要配置相同的route-map了，只需要将路由前缀打上相应的TAG划分到相应的community中就能实现相应的路由操作。</p>
<p>community属性是可选传递，在设置后，同时需要向邻居发送（SEND），邻居才能真正收到这个community，而且要每个邻居设置一次，举例看一下：</p>
<p><img src="/2020/10/11/14-BGP/1608088856876-8908d4b4-40fa-4c24-929b-b9941e16dfbb.jpeg" alt="img"></p>
<p>如果R1上针对11.11.11.0/24设置了community，那么必须在R1上配置‘neighbor 10.1.12.2 send-community’那么R2才能收到这个community，但如果R2上不对R3配置send-community，这个community R3是不知道的，必须在R2上对R3设置‘send-community’R3才能收到这个community。配置send-community是思科和华为的做法，juniper默认不用配置就能传递community。</p>
<p>除了上面这个community，还有一个扩展community（extended community），具体在MPLS VPN部分会具体写这个，不要混淆两者。</p>
<h3 id="基本概念实验"><a href="#基本概念实验" class="headerlink" title="基本概念实验"></a>基本概念实验</h3><p><img src="/2020/10/11/14-BGP/1607413844338-02a82838-759c-4271-97d2-8c39c53a5a3b.png" alt="img"></p>
<p>左边的customer路由器连接到ISP1上，位于北美的ISP1又分别连接了ISP2和ISP3，假设ISP2是位于欧洲的服务器，当ISP1发送路由更新到位于欧洲的ISP2上之前，需要先将本地的AS号复制四次，这里用community进行配置，将这些发送给欧洲的路由前缀的community值设置为64984：0。</p>
<h4 id="基本配置-2"><a href="#基本配置-2" class="headerlink" title="基本配置"></a>基本配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer#show running-config | section bgp</span><br><span class="line">router bgp 10</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 10.10.10.10 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.10.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP1#show running-config | section bgp</span><br><span class="line">router bgp 1</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.10.10 remote-as 10</span><br><span class="line"> neighbor 192.168.12.2 remote-as 2</span><br><span class="line"> neighbor 192.168.13.3 remote-as 3</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP2#show running-config | section bgp</span><br><span class="line">router bgp 2</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.12.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP3#show running-config | section bgp</span><br><span class="line">router bgp 3</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.13.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br></pre></td></tr></table></figure>

<p>此时ISP1已经从Customer路由器上学到了路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   10.10.10.10/32   192.168.10.10            0             0 10 i</span><br></pre></td></tr></table></figure>

<h4 id="配置customer"><a href="#配置customer" class="headerlink" title="配置customer"></a>配置customer</h4><p>首先使用前缀列表抓取10.10.10.10/32这条需要进行配置的路由，假设这条前缀要发送给位于欧洲的ISP2，在customer上赋予community值方便在ISP1上进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#ip prefix-list LOOPBACK permit 10.10.10.10/32</span><br></pre></td></tr></table></figure>

<p>接下来用route-map来设置BGP的community，所有符合前缀列表的路由将被赋予community值，也就是64984：0，因为发送给欧洲的路由前缀的community值设置为64984：0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#route-map SET_COMMUNITY permit 10</span><br><span class="line">Customer(config-route-map)#match ip address prefix-list LOOPBACK</span><br><span class="line">Customer(config-route-map)#set community 64984:0</span><br><span class="line">Customer(config-route-map)#exit</span><br><span class="line">Customer(config)#route-map SET_COMMUNITY permit 20</span><br></pre></td></tr></table></figure>

<p>现在来对ISP1使用这条route-map，赋予发往ISP1的路由community值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#router bgp 10</span><br><span class="line">Customer(config-router)#neighbor 192.168.10.1 route-map SET_COMMUNITY out</span><br><span class="line">Customer(config-router)#neighbor 192.168.10.1 send-community</span><br></pre></td></tr></table></figure>

<p>对ISP1配置了send-community是因为community为可选传递属性，路由器不会自动发送community到邻居。</p>
<h4 id="配置ISP1"><a href="#配置ISP1" class="headerlink" title="配置ISP1"></a>配置ISP1</h4><p>接下来在ISP1上用配置community：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#ip community-list 1 permit 64984:0</span><br></pre></td></tr></table></figure>

<p>首先配置community列表，该列表和access-list以及prefix-list很像，但只用于BGP的community上，这个community-list 匹配的是由customer发过来的community值为64984:0的路由前缀，其实也就是抓取的10.10.10.10/32这条路由。接下来用route-map设置将这条路由的AS号复制四次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#route-map PREPEND_EU permit 10     </span><br><span class="line">ISP1(config-route-map)#match community 1</span><br><span class="line">ISP1(config-route-map)#set as prepend 1 1 1 1                 </span><br><span class="line">ISP1(config-route-map)#exit</span><br><span class="line">ISP1(config)#route-map PREPEND_EU permit 20</span><br></pre></td></tr></table></figure>

<p>接下来将这条route-map应用到邻居ISP2的出方向上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#router bgp 1 </span><br><span class="line">ISP1(config-router)#neighbor 192.168.12.2 route-map PREPEND_EU out</span><br></pre></td></tr></table></figure>

<h4 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h4><p>在customer上软刷新BGP后在ISP1上可以看到它已经收到了BGP 的community值，最后一行的‘Community: 4258791424’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1#show ip bgp 10.10.10.10</span><br><span class="line">BGP routing table entry for 10.10.10.10/32, version 6</span><br><span class="line">Paths: (1 available, best #1, table Default-IP-Routing-Table)</span><br><span class="line">  Advertised to update-groups:</span><br><span class="line">        1    2</span><br><span class="line">  10</span><br><span class="line">    192.168.10.10 from 192.168.10.10 (10.10.10.10)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, external, best</span><br><span class="line">      Community: 4258791424</span><br></pre></td></tr></table></figure>

<p>可以看到ISP1确实收到了community但并没有按照AA:NN的格式显示，是因为思科默认使用自己的格式显示，而不是使用RFC格式，在ISP1上配置‘<strong>ip bgp community new-format</strong>’后会恢复成RFC格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1#show ip bgp 10.10.10.10</span><br><span class="line">BGP routing table entry for 10.10.10.10/32, version 6</span><br><span class="line">Paths: (1 available, best #1, table Default-IP-Routing-Table)</span><br><span class="line">  Advertised to update-groups:</span><br><span class="line">        1    2</span><br><span class="line">  10</span><br><span class="line">    192.168.10.10 from 192.168.10.10 (10.10.10.10)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, external, best</span><br><span class="line">      Community: 64984:0</span><br></pre></td></tr></table></figure>

<p>再来看ISP2上该配置是否生效了，对比ISP3上的这条路由发现配置生效了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP2#show ip bgp</span><br><span class="line">BGP table version is 12, local router ID is 192.168.12.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line"></span><br><span class="line">   Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; 10.10.10.10/32   192.168.12.1                           0 1 1 1 1 1 10 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP3#show ip bgp</span><br><span class="line">BGP table version is 12, local router ID is 192.168.13.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line"></span><br><span class="line">   Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; 10.10.10.10/32   192.168.13.1                           0 1 10 i</span><br></pre></td></tr></table></figure>

<p>如果以后Customer要发送其他路由到位于Europe的ISP2路由器，那么只需要在Customer上将之前配置的抓取路由的前缀列表进行适当更改，匹配上那条新路由即可。</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><h4 id="No-advertise"><a href="#No-advertise" class="headerlink" title="No-advertise"></a>No-advertise</h4><p>当为一条前缀配置了no-advertise命令时，收到这条前缀的BGP路由器，R2，会将这条前缀存储在自己的BGP表中，而不会向其他邻居宣告这条路由。用下图中的拓扑举个例子，如果在R1上配置了no-advertise这条community的命令，则R1传给R2的路由，R2不会再发给任何BGP对等体邻居。</p>
<p><img src="/2020/10/11/14-BGP/1607503143643-50577307-155f-4823-80c0-b96799b932cb.jpeg" alt="img"></p>
<h4 id="No-export"><a href="#No-export" class="headerlink" title="No-export"></a>No-export</h4><p><img src="/2020/10/11/14-BGP/1607754498509-3367b21f-897b-4f77-a1a6-4280e96f79d6.jpeg" alt="img"></p>
<p>当为一条前缀配置了no-export命令时，收到这条前缀的BGP路由器R2只会将这条路由宣告给iBGP邻居而不会宣告给任何eBGP邻居（会传递给联邦eBGP邻居）。用上图中的拓扑举个例子，如果在R1上配置了no-export这条community的命令，则R1传给R2的路由，R2只会传递给在AS 2345内部的路由器，也就是只传给R3\R4\R5，但不会传递给eBGP邻居R6。</p>
<h4 id="Local-as"><a href="#Local-as" class="headerlink" title="Local-as"></a>Local-as</h4><p><img src="/2020/10/11/14-BGP/1607757025165-fa185539-f6de-44de-a524-5c338937b283.jpeg" alt="img"></p>
<p>local-as和之前的no export有些类似，区别在于当为一条前缀配置了local-as命令时，如果定义了联邦，只会在联邦AS内部传递不会传递给联邦eBGP邻居。用上图中的拓扑举个例子，如果在R1上配置了local-as这条community的命令，则R1传给R2的路由，R2只会传递给联邦iBGP邻居R3，但不会传递给联邦eBGP邻居R4。</p>
<h3 id="为路由分配community"><a href="#为路由分配community" class="headerlink" title="为路由分配community"></a>为路由分配community</h3><p><img src="/2020/10/11/14-BGP/1607761644664-5889c622-4e78-4f6b-8d12-8be44c16f269.jpeg" alt="img"></p>
<p>在R1上为路由11.11.11.0/24分配community 100：11，并且传递给R2，那么R1上配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24              #抓取需要分配community的前缀</span><br><span class="line">!</span><br><span class="line">route-map COMMUNITY permit 10                            #用route-map为抓取的前缀分配community值</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">route-map COMMUNITY permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community                       #默认情况下不发送community值给邻居，配置命令后会发送</span><br><span class="line"> neighbor 10.1.12.2 route-map COMMUNITY out              #对邻居的out方向使用route-map</span><br></pre></td></tr></table></figure>

<p>一条前缀路由可携带多个community形成一个列表，如果要针对特定路由在原有的community基础之上再增加一个community，则在route-map中set community时，增加additive关键字即可，比如R1在上面配置的基础上加上如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map COMMUNITY permit 10</span><br><span class="line">set community 100:12 additive</span><br></pre></td></tr></table></figure>

<p>最后route-map的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-route-map)#do show run | s route-map</span><br><span class="line"> neighbor 10.1.12.2 route-map COMMUNITY out</span><br><span class="line">route-map COMMUNITY permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11 100:12 additive</span><br><span class="line">route-map COMMUNITY permit 20</span><br></pre></td></tr></table></figure>

<h3 id="community-list"><a href="#community-list" class="headerlink" title="community-list"></a>community-list</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><p>ip community-list和ACL类似，ACL用来抓取前缀，ip community-list用来抓取community的值，和ACL类似，community-list也有标准和扩展之分，1-99为标准，100-199为扩展，标准ip community-list 后面只能跟XX:NN的格式，而扩展的community-list可以使用正则表达式匹配路由，下面扩展community-list后面的regexp是正则表达式的意思，在笔记的其他章节会涉及到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p extcommunity-list standard list-name &#123; deny | permit &#125; generic &#123; transitive | nontransitive &#125; aa4 : nn</span><br><span class="line"></span><br><span class="line">no ip extcommunity-list standard generic &#123; transitive | nontransitive &#125; list-name</span><br><span class="line"></span><br><span class="line">ip extcommunity-list expanded list-name &#123; deny | permit &#125; generic &#123; transitive | nontransitive &#125; regexp</span><br><span class="line"></span><br><span class="line">no ip extcommunity-list expanded generic &#123; transitive | nontransitive &#125; list-name</span><br></pre></td></tr></table></figure>

<p>当使用扩展community-list且后面接了正则表达式的情况下，设备是否配置了ip bgp-community new-format会影响community-list匹配的结果。</p>
<h4 id="删除特定值"><a href="#删除特定值" class="headerlink" title="删除特定值"></a>删除特定值</h4><p>前面说过，一条路由允许携带多个community值，构成一个community列表，那么如果不是要删除全部的community值，而是想删除1个或几个community值，例如一个带有12：11、12：1111以及no-export的community列表，要删除其中的no-export的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 1 permit no-export              #匹配要删除其中的no-export的community值</span><br><span class="line">route-map test permit 10</span><br><span class="line"> set comm-list 1 delete                           #用这条命令删除</span><br></pre></td></tr></table></figure>



<p>如果要删除多个但不是所有community值的话，则可在一个community-list中写多条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 1 permit no-export</span><br><span class="line">ip community-list 1 permit 12:1111</span><br></pre></td></tr></table></figure>

<p>然后在用set comm-list 1 delete去删除，这里必须注意community-list必须写多行，如果在一行里写多个community，比如ip community-list 1 permit no-export  12:1111则不生效，删除不了这两个值。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><img src="/2020/10/11/14-BGP/1608087693890-ce7fc733-63b1-4c34-87c9-b705c3de78c9.jpeg" alt="img"></p>
<p>在上面实验的基础上，R1传递给R2的11.11.11.0/24的路由，携带了community值，100：11，这个值可以在R2上用ip community-list进行匹配，从而可以进一步在route-map中使用这个community-list去设置策略。我们先在R2上用community-list去匹配100：11，通知添加一个no-export的community到该路由。</p>
<p>R2的配置如下：</p>
<p><img src="/2020/10/11/14-BGP/1608090080532-26c63b47-ebe1-4bf2-96cb-f8f34da2db2b.jpeg" alt="img"></p>
<p>R3上关于11.11.11.0这条路由：</p>
<p><img src="/2020/10/11/14-BGP/1608091005056-0b2ca818-77cd-471f-88cb-e8789aa70bff.jpeg" alt="img"></p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>在上面例子的基础上，11.11.11.0/24路由前缀所携带的community属性为‘100：11 no-export’，看以下的community-list是否能匹配到这条路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11</span><br><span class="line"></span><br><span class="line">#匹配，这种写法将匹配community中包含100：11的路由</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11 no-advertise</span><br><span class="line"></span><br><span class="line">#不匹配，这种写法要求community中同时包含100：11及no-advertise才匹配成立，换句话说，100：11和no-advertise是与的关系</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11</span><br><span class="line">ip community-list 11 permit no-export(no-advertise)</span><br><span class="line"></span><br><span class="line">#匹配，这种写法将只要community中包含100：11或no-export(no-advertise)就行，换句话说，100：1和no-export(no-advertise)是或的关系，只要满足一个就匹配</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p><img src="/2020/10/11/14-BGP/1608094871413-6517807d-2f79-4410-b6d3-12f4b0949169.jpeg" alt="img"></p>
<p>在上面实验的基础上，12.12.12.0/24也携带了no-export的community值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map NO-EXPORT permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set community no-export</span><br><span class="line">!</span><br><span class="line">route-map NO-EXPORT permit 20</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community</span><br><span class="line"> neighbor 10.1.12.2 route-map NO-EXPORT out</span><br></pre></td></tr></table></figure>

<p>如果我们只希望匹配community值为no-export的路由，该如何呢？如果是直接匹配no-export的话，不仅会匹配到12.12.12.0/24，也会匹配到community值为100：11 no-export的11.11.11.0/24这条路由，这里要用到exact-match的关键字了，在R3上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit no-export</span><br><span class="line">route-map test permit 10</span><br><span class="line">  match community 11 exact-match                #也就是严格匹配no-export的community</span><br></pre></td></tr></table></figure>

<p>如果不加exact-match关键字，则该community-list将匹配11及12的路由，加了以后，则只匹配community为no-export的路由，不能多也不能少。</p>
<h4 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h4><p><img src="/2020/10/11/14-BGP/1608098576710-41d92014-e30c-4ee6-8571-4ed4b75f7028.jpeg" alt="img"></p>
<p>R2收到R1传过来的两条路由，分别携带的community属性如上，这里我们只想删除11.11.11.0/24所携带的no-export属性，这里有两种办法。</p>
<p>*<strong>方法一：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip community-list 11 permit 100:11 no-export            </span><br><span class="line">ip community-list standard del permit no-export         </span><br><span class="line">route-map test permit 10                               </span><br><span class="line">  match community 11                                   </span><br><span class="line">  set comm-list del delete                               </span><br><span class="line">route-map test permit 20</span><br><span class="line"></span><br><span class="line">router bgp 200</span><br><span class="line">  neighbor 10.1.12.1 remote-as 100</span><br><span class="line">  neighbor 10.1.12.1 route-map test in              </span><br></pre></td></tr></table></figure>

<ul>
<li><p>ip community-list 11 permit 100:11 no-export，这条名称为11的标准community-list用来匹配community值为100:11 no-export的对象，在这也就是抓取11.11.11.0/24这条路由；</p>
</li>
<li><p>ip community-list standard del permit no-export，这条名称为del的标准community-list用来匹配community值为no-export的对象；</p>
</li>
<li><p>match community 11，表示匹配名称为11的community-list，也就是11.11.11.0/24这条路由；</p>
</li>
<li><p>set comm-list del delete，表示将11.11.11.0/24这条路由中no-export的对象删除，之前这条路由的community有100:11和no-export两个，删除掉no-export后只剩下100:11了；</p>
</li>
<li><p>neighbor 10.1.12.1 route-map test in，在邻居10.1.12.1的in方向上使用route-map test；</p>
</li>
</ul>
<p>如果想把11.11.11.0/24路由的100：11以及no-export两个community值都删除，则修改del的这条community-list即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list standard del permit no-export</span><br><span class="line">ip community-list standard del permit 100:11</span><br></pre></td></tr></table></figure>

<p><a href="https://community.cisco.com/t5/routing/how-to-strip-a-specific-community-list/td-p/3183348">*<strong>方法二：*</strong></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24                       #抓取要进行操作的前缀</span><br><span class="line">ip community-list expanded REMOVE_COMMUNITY permit no-export      #抓取要删除的community值</span><br><span class="line">!</span><br><span class="line">route-map MODIFY_COMMUNITY permit 10                              #对11.11.11.0/24这条前缀将no-export的community删除</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set comm-list REMOVE_COMMUNITY delete</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.12.1 remote-as 100</span><br><span class="line"> neighbor 10.1.12.1 route-map MODIFY_COMMUNITY in                 #对邻居10.1.12.1的in方向使用删除community的route-map</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Aggregate及aggregator"><a href="#Atomic-Aggregate及aggregator" class="headerlink" title="Atomic_Aggregate及aggregator"></a><a href="https://www.networkers-online.com/blog/2010/12/bgp-attributes-atomic-aggergate-atribute/">Atomic_Aggregate及aggregator</a></h3><p>Atomic_Aggregate是公认自决属性；Aggregator是可选传递属性。</p>
<p><img src="/2020/10/11/14-BGP/1608194376455-1a68636e-737c-4714-88cb-988f7d8fd52e.jpeg" alt="img"></p>
<p>R1和R2均发布了路由，R3上对这些明细路由进行了汇总，汇总成172.16.0.0/16，汇总路由被R3传递给了其他BGP邻居，然而这条汇总路由丢失了明细路由的所有属性，其中的AS_Path最关键，因为一旦丢失了明细路由的AS_Path属性，这条汇总路由就极有可能产生路由环路。因此有必要让R3警告下游的BGP邻居，告诉它们两点，其一，这是一条汇总路由，其二汇总路由发生的地方，也就是汇总路由的始发AS和始发路由器。</p>
<p>在R3上配置‘aggregate-address 172.16.0.0 255.255.0.0’或‘aggregate-address 172.16.0.0 255.255.0.0 summary-only’进行汇总时，R4上关于汇总路由如下：</p>
<p><img src="/2020/10/11/14-BGP/1608201218196-7b20dee0-1925-49f1-a440-618cb02dfcd4.jpeg" alt="img"></p>
<p>抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608274329140-2523f10e-f467-4955-aa59-dbf8afac060a.png" alt="img"></p>
<p>其中Aggregator是可选传递属性，用来标识路由是在AS300的路由器3.3.3.3上经过汇总的；Atomic_Aggregate是公认自决属性，由于配置路由汇总时没有带上AS_SET命令，所以AS_PATH中只有路由被汇总路由器的AS号300，有可能会将汇总路由传回明细路由的AS100或200从而产生环路，所以在汇总路由不携带明细路由的AS_PATH时，需要加上atomic_aggregate属性警告下游BGP peer，这是一条汇总路由，局和路径丢失了某些信息，可能不是去往目的地的最佳路径（The purpose of the attribute is to alert BGP speakers along the path that some information have been lost due to the route aggregation process and that the aggregate path might not be the best path to the destination.）</p>
<p>如果在R3上汇总命令中加上as-set关键字，则汇总路由就继承了明细路由的AS_Path属性，没有丢失AS_PATH信息，就不需要加上Atomic_Aggregate属性了，汇总时加上AS_SET的抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608277413278-189c6204-da99-4ac9-beee-41139bbe5d39.png" alt="img"></p>
<p>R4上关于172.16.0.0的输出中也没有了Atomic_Aggregate，具体如下：</p>
<p><img src="/2020/10/11/14-BGP/1608277473593-a136e600-a514-4fca-ab60-a2b371bdc35e.png" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Aggregate是可选传递属性，用来标识路由在哪个AS的哪个路由器上进行过汇总，只要是汇总路由就会携带Aggregate属性；Atomic_Aggregate是公认自决属性，用来提醒沿途路由器，聚合路由丢失了某些属性，可能不是最佳路径。在汇总时如果不使用AS_SET命令，则汇总路由不携带明细路由的AS_Path，这时候执行汇总的路由器会将用Atomic_Aggregate属性来提醒其他路由器。如果汇总时使用了AS_SET命令，则明细路由的AS会用AS_SET形式保存在汇总路由的AS_Path中，没有丢失属性，所以这时汇总路由不携带Atomic_Aggregate属性。</p>
<p>思科设备的对汇总路由的默认做法是，汇总路由默认不携带明细路由的所有AS_Path信息，如果汇总时没有使用AS_SET命令，则汇总路由必携带Atomic_Aggregate属性；而juniper的做法和思科完全相反，汇总路由默认会携带所有明细路由的AS_Path，这意味着用来提醒属性丢失的Atomic_Aggregate属性不是必须有的。</p>
<h3 id="ORIGINATOR-ID和CLUSTER-LIST"><a href="#ORIGINATOR-ID和CLUSTER-LIST" class="headerlink" title="ORIGINATOR_ID和CLUSTER_LIST"></a>ORIGINATOR_ID和CLUSTER_LIST</h3><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><p>由于AS_Path属性在AS内部不会发生变化，仅当路由离开本AS时才会被更新，而路由反射器打破了水平分割原则，有可能使路由出现环路，所以AS内必须有相对应的防环机制，所以路由反射器使用两个新的属性进行防环，ORIGINATOR_ID和CLUSTER_LIST，二者为路由反射器使用的可选非传递属性，用来防止环路。</p>
<ul>
<li>ORIGINATOR_ID是一个路由反射器创建的32bit值，该数值是本地AS中路由发起方的iBGP Router ID，注意发起方未必是这条路由的引入者，如果发起方发现其RID在所接收到的路由的ORIGINATOR_ID中，那么就知道已经出现了路由环路，因此会忽略该路由。</li>
<li>CLUSTER_LIST是遗传路由传递所经过的路由反射簇（Cluster）的ID，AS内的每个路由反射簇都有一个32bit的簇ID，如果簇中包含了多个RR，则需手工为每个RR配置簇ID。当RR将来自客户的路由反射给非客户时，同时将其簇ID附加到CLUSTER_LIST中，如果CLUSTER_LIST为空则创建一个，如果反射路由器发现其本地簇ID出现在了其受到的CLUSTER_LIST中，那么就知道出现了环路，则忽略该路由。CLUSTER_LIST属性只用于RR防环，RR只在反射路由的时候才会创建或更新CLUSTER_LIST，而下面几种情况，RR不会创建该属性：1、RR自己始发的路由；2、RR向EBGP邻居发送路由更新时，将会清除所有的CLUSTER_LIST属性；3、当RR从eBGP邻居收到路由，传递给client或非client时，不会创建CLUSTER_LIST。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1608365403976-5c775260-036a-49d4-a053-a13a03f9c471-1642643880956170.jpeg" alt="img"></p>
<h4 id="ORIGINATOR-ID取值-1"><a href="#ORIGINATOR-ID取值-1" class="headerlink" title="ORIGINATOR_ID取值"></a>ORIGINATOR_ID取值</h4><p><img src="/2020/10/11/14-BGP/1608367486050-fa2c2078-7b28-4865-be7a-31d1e52e29b3-1642643880956174.jpeg" alt="img"></p>
<p>R1位于AS100，与R2是eBGP邻居关系，将1.1.1.0/24的路由传递给R2，R2传递给iBGP邻居R3，但由于水平分割原则，R3不会将从iBGP邻居R2处学到的1.1.1.0/24路由传递给另一个iBGP邻居R4，这种情况下如果想将路由传递给R4，使R3成为RR，R4为R3的client，R3就能将路由传递给R4了，此时身为RR的R3会添加ORIGINATOR_ID和CLUSTER_LIST进路由，其中ORIGINATOR属性为R2的Router ID，也就是2.2.2.2而不是R1的Router ID，1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1608367767846-b91f554c-6c26-45ef-ba84-884d58f25851-1642643880956172.jpeg" alt="img"></p>
<h4 id="CLUSTER-LIST与BGP选路-1"><a href="#CLUSTER-LIST与BGP选路-1" class="headerlink" title="CLUSTER_LIST与BGP选路"></a>CLUSTER_LIST与BGP选路</h4><p><img src="/2020/10/11/14-BGP/1608367924110-f6b40265-a996-421a-9833-e2d515285aba-1642643880956176.jpeg" alt="img"></p>
<p>R1宣告11.11.11.0/24进BGP，R5分别通过R2和R4学到这条路由，在其他属性一致的情况下，Cluster list短的路由更优：</p>
<p><img src="/2020/10/11/14-BGP/1608368122153-83f9884d-67e4-4e1c-aa85-7ad11f16cfd2-1642643880956178.jpeg" alt="img"></p>
<h4 id="冗余RR环境-1"><a href="#冗余RR环境-1" class="headerlink" title="冗余RR环境"></a>冗余RR环境</h4><p>单RR可能会存在单点故障，因此从冗余性的角度出发，一个簇中可以拥有多台RR，Client与每一台RR都有物理连接并建立BGP对等体关系，在其中一台RR出现故障的情况下，Client仍然有替代连接。因为Client不知道主机是别人的Client，所以RR本身也可以成为别人的Client，使用荣誉RR增加了网络的健壮性，ORIGINATOR_ID和CLUSTER_LIST属性用来在冗余RR中避免环路，可以将两个RR的Cluster ID配置为一样，可以进一步起到防环作用，所有的RR之间建议采取全互联的形式，比如：</p>
<p><img src="/2020/10/11/14-BGP/1608369164961-37ba507a-2b08-4c2a-a229-a0247a72a5b2-1642643880956180.jpeg" alt="img"></p>
<h2 id="Weight"><a href="#Weight" class="headerlink" title="Weight"></a>Weight</h2><p>weight属性为思科私有，作用范围是本路由器，该值既不会被包含在update报文中，也不会传递给任何BGP邻居，只在路由器本地产生影响，中文翻译为权重值，越大越优先。取值范围为0-65535。如果路由是从其他BGP邻居学过来的，则weight值为默认的0；如果路由是从本地network产生的，则weight值为32768；本地重发不的直连接口路由或静态路由的weight为32768；本地汇总产生的BGP路由weight值为32768。</p>
<h1 id="协议配置"><a href="#协议配置" class="headerlink" title="协议配置"></a>协议配置</h1><h2 id="建立邻居"><a href="#建立邻居" class="headerlink" title="建立邻居"></a>建立邻居</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network X.X.X.X  mask Y.Y.Y.Y  route-map NNNN</span><br></pre></td></tr></table></figure>

<p>在IGP中，network命令用于确定要发送和接收路由更新的接口，以及通告哪些直连的网络；</p>
<p>在BGP中，network命令与BGP在哪些接口上运行无关。仅仅是讲本地某个网络注入到BGP里，该路由我们称为可靠的。也就是说，只有<strong>路由表</strong>中有这个路由条目，且它不在BGP表中，才能使用network命令讲它注入到BGP表中。比如下面这个路由器的路由表中，有10.0.0.0/24这条路由，才能在BGP中用network 10.0.0.0 mask 255.255.255.0这条命令来宣告，将它注入进BGP中。而不能注入一条路由表中没有的路由，比如这个路由器中没有192.168.1.0/24这条路由，所以就不能network这条路由进BGP。再比如路由表中有192.168.0.0/24的路由，如果network 192.0.0.0也不成功。</p>
<p>后边的route-map NNNN，就是对前边宣告路由进行属性上的操控。</p>
<p><img src="/2020/10/11/14-BGP/1609745691690-86261972-ba32-479b-87ef-504ff1c266f6.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X remote-as Y.Y.Y.Y</span><br></pre></td></tr></table></figure>

<p>neighbor 的这个地址必须是IP可达的。</p>
<h2 id="邻居身份验证"><a href="#邻居身份验证" class="headerlink" title="邻居身份验证"></a>邻居身份验证</h2><p>BGP支持MD5身份验证，要在BGP对等体邻居之间的TCP连接上启用MD5身份验证，使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X password YYYY</span><br></pre></td></tr></table></figure>

<p>同一个BGP连接，密码必须一致，不同的邻居可设置不同的密码。认证配置完毕后，将通过对等体之间的TCP连接传输所有的数据端进行验证，注意这只是基本的身份验证功能并不是加密，抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1609747001219-ee22a6d2-bd7e-4a04-9524-0efc44562612.jpeg" alt="img"></p>
<h2 id="重置BGP连接"><a href="#重置BGP连接" class="headerlink" title="重置BGP连接"></a>重置BGP连接</h2><h3 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h3><p>硬重置意味着将所有的BGP邻居的TCP连接以及BGP邻居状态都重新复位。</p>
<p>clear ip bgp *       //表示将所有邻居的TCP、BGP连接都重新复位；</p>
<p>clear ip bgp *  {neighbor-address}     //表示将特定邻居的TCP、BGP连接重新复位，比如如果配置clear ip bgp * 1.1.1.1，表示将邻居1.1.1.1的TCP、BGP连接重新复位。</p>
<h3 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a><a href="https://community.cisco.com/t5/routing/clear-ip-bgp-soft-command/td-p/1827626">软重置</a></h3><p>和硬重置不同，软重置不会拆重建邻居的TCP或BGP连接，而是浸出法更新的操作以便让新的路由策略生效。软重置可以单独用于出站或入栈策略，也可以同时用于出站入站策略。</p>
<p>clear ip bgp * soft          //对所有的邻居的出站及入站进行软重置</p>
<p>clear ip bgp soft out      //出站软重置，会重新发送update消息给所有邻居；</p>
<p>clear ip bgp soft in        //入站软重置，本地重新发送route-refresh给所有BGP邻居；</p>
<p>clear ip bgp {neighbor-address}  soft in/out   //对特定邻居使用软重置；</p>
<p>执行入站软重置的方法有两种：</p>
<h4 id="Soft-Reconfiguration"><a href="#Soft-Reconfiguration" class="headerlink" title="Soft Reconfiguration"></a>Soft Reconfiguration</h4><p>这种重置方式的中文叫‘<strong>使用存储的路由更新信息的软重置</strong>’，是一种相对老一些的软重置方式，使用这种方式进行软重置，需要在输入命令前先使用命令neighbor x.x.x.x soft-reconfiguration inbound才可以进行软重置。在BGP进程中使用以上命令会将x.x.x.x邻居发来的最原始、未经过滤变更的BGP路由存储在本地内存中，当配置入站方向的软重置后（输入命令clear ip bgp * soft 【in】），路由器不再向邻居发送更新请求，而是直接对在内存中存储的那些原始未经改变的BGP路由执行新配置的入站策略，以此来防止出发大批量的路由更新而造成资源的浪费，但这种操作仍然比较消耗内存，因此在性能不太好的设备上使用时要非常谨慎。</p>
<h4 id="Dynamic-Inbound-Soft-Reset"><a href="#Dynamic-Inbound-Soft-Reset" class="headerlink" title="Dynamic Inbound Soft Reset"></a>Dynamic Inbound Soft Reset</h4><p>这种重置方式的中文叫‘动态入站软重置’，英文‘Route Refresh capability’说的也是它，在2000年发布的RFC2918中正式规定，思科从IOS 12.1开始全面支持入站路由的动态软重置，目前在用的几乎所有路由器都支持动态入站软重置。这种软重置的能力<strong>不需要进行任何的命令配置</strong>，在BGP邻居建立时会预先协商好，当输入命令clear ip bgp * soft 【in】【out】（没错，和前一种软重置触发的命令相同）时，路由器会自动向所有支持这个特性的邻居发送route-refresh报文，要求这些邻居重新发送它们的路由宣告。</p>
<p>如何知道邻居设备是否支持这种新的软重置呢？看show ip bgp neighbors X.X.X.X的显示中的‘Route refresh’后的部分，带new的就是支持不配置直接刷新的：</p>
<p><img src="/2020/10/11/14-BGP/1608624995973-839b197a-ad0a-4cb5-ac7b-b5d7a2a42989.jpeg" alt="img"></p>
<h4 id="软重置总结"><a href="#软重置总结" class="headerlink" title="软重置总结"></a>软重置总结</h4><p>第一种软重置方式由于内存消耗过大已经被第二种方式替代，目前几乎所有在网运行BGP的路由器都支持第二种更新的方式进行软重置，无需配置任何命令，遇到软重置时提示让你配置‘soft-reconfiguration inbound’的，说明邻居只支持老的刷新方式，不过一般很难遇到了。所以如果你觉得看到两种软重置有点懵逼，忽略第一种直接看第二种就好。如果想进一步搞明白，推荐看<a href="https://community.cisco.com/t5/switching/soft-reset-and-route-refresh-in-bgp/td-p/2674389">帖子1</a>、<a href="https://community.cisco.com/t5/routing/clear-ip-bgp-soft-command/td-p/1827626">帖子2</a>和<a href="https://ccieblog.co.uk/bgp/route-refresh-capability-vs-soft-reconfiguration">帖子3</a>，我上面的内容摘抄\翻译自这。</p>
<h2 id="查看邻居支持的特性"><a href="#查看邻居支持的特性" class="headerlink" title="查看邻居支持的特性"></a>查看邻居支持的特性</h2><p>使用命令‘show ip bgp neighbot x.x.x.x |  section Neighbor capabilities’查看邻居X.X.X.X支持的BGP特性，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip bgp neighbors 192.168.23.3 | section Neighbor capabilities</span><br><span class="line">  Neighbor capabilities:</span><br><span class="line">    Route refresh: advertised and received(new)</span><br><span class="line">    Four-octets ASN Capability: advertised and received</span><br><span class="line">    Address family IPv4 Unicast: advertised and received</span><br><span class="line">    Enhanced Refresh Capability: advertised and received</span><br><span class="line">    Multisession Capability:</span><br><span class="line">    Stateful switchover support enabled: NO for session 1</span><br></pre></td></tr></table></figure>

<h2 id="BGP表含义"><a href="#BGP表含义" class="headerlink" title="BGP表含义"></a>BGP表含义</h2><p>BGP表就是上面说的Loc-RIB（Local Routing Information Base），用命令‘show ip bgp’查看：</p>
<p><img src="/2020/10/11/14-BGP/1606113319088-6ea8349a-9d45-4efe-9691-43c5ef2e6bf1.jpeg" alt="img"></p>
<p>可以看到，R2的BGP表中有一条1.1.1.1/32的路由，前面的*和&gt;是神么意思呢？</p>
<ul>
<li>*****表示这条路由是有效的，BGP可以使用它，只要路由器从其他BGP邻居收到一条路由就表示这条路由有效，和下一跳能否到达没有关系，一个<a href="https://community.cisco.com/t5/other-network-architecture/bgp-valid-status-code/td-p/355514">帖子里</a>关于valid是这么说的：The prefix is marked as valid if received from a peer or locally originated. The next hop reachability doesn’t affect this flag.那什么情况下，一条BGP路由无效呢？那个帖子里说：When a path is dampened among other conditions. In such a case, the prefix is not received anymore from the peer. It is kept for the sake of conserving the history information and is not marked as valid.大概意思是说，当一条路由在被阻断的情况下就无效了，比如这条路由不再从邻居那边收到，但为了保存历史信息，会被标记成无效留下来；</li>
<li>&gt;表示这条路由被选为BGP中的最优（但不代表着它一定是路由表中最优的）：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606113482740-b217341b-d421-4096-b281-c5ec35b4b4f5.jpeg" alt="img"></p>
<p>那么不是最优的BGP路由如何表示呢？前面没有&gt;符号的就不是最优路由，例如下面：</p>
<p><img src="/2020/10/11/14-BGP/1606113245098-5668e18a-fc9f-474f-88d4-8c2b2918f7ca.jpeg" alt="img"></p>
<ul>
<li><p>Next Hop，表示去往目标网络下一跳发给谁，在最上面图中的next hop部分值为192.168.12.1，表示在R2上通过BGP去往1.1.1.1/32，需要把数据发给192.168.12.1即可。如果这部分值为0.0.0.0呢？表示该路由始发于本路由器，所以不需要发给别的地址，故该部分值为0.0.0.0；</p>
</li>
<li><p>后面几个值，Metric、LocPrf、Weight以及Path都是BGP的属性，用来选取最佳路径，会在后面具体解释；</p>
</li>
<li><p>最后面还有一个‘i’，这是BGP的origin code，就是路由更新的来源，一共有三种途径，其中‘i’表示通过BGP中的network命令注入到BGP中的，也就是起源于IGP，因为BGP通过的network命令宣告进入的必须在IGP的路由表中；其中‘e’是由EGP这种早期的协议重发布而来，该协议现网中已不再使用；其中‘？’表示从其他渠道学习到的，也就是该路由来源的信息不完全，重发布路由的origin都是这个标记；</p>
</li>
<li><p>BGP表中开头部分还有个‘BGP table version’表示BGP表的版本号，每当最佳路径产生变化时，BGP表的版本号会随之增加。</p>
</li>
<li><p>Status Codes中还有一些其他的代码：s是suppressed，翻译成中文是被抑制，表示BGP知道该路由前缀但不会对它进行通告，通常发生在该路由前缀是路由汇总中一部分的时候；d是damped，翻译成中文是衰减，表示BGP不会宣告这条路由前缀，因为该路由频繁翻滚（路由一会儿存在过一会儿又消失），标志为d的路由会被限制传播范围，这个特性有三个作用，一是减少路由器因为路由翻滚而带来的高负载，二是增加路由稳定，三是防止路由长时间的震荡。；h是history，翻译成中文是历史，表示BGP学到过这条路由但目前该路由不存在；r是RIB-failure，表示BGP学到过这条路由但并未将它加入路由表中，这种情况常见于有其他AD管理距离更低的路由协议也学到了该路由时；S是Stable，表示过期的路由，用于不间断转发，当远程BGP邻居返回时，必须刷新此条目。</p>
</li>
</ul>
<h3 id="关于思科的valid"><a href="#关于思科的valid" class="headerlink" title="关于思科的valid"></a>关于思科的valid</h3><p>思科设备关于BGP路由的valid，也就是是否有效这个，它和华为或Juniper的做法都不一样，Juniper和华为是需要这条BGP路由下一跳可达才会标记valid，而思科的BGP路由下一跳即使不可达也不影响这条路由的valid（The prefix is marked as valid if received from a peer or locally originated. The next hop reachability doesn’t affect this flag.），比如下图中，3.3.3.0/24这条路由是valid，也就是有效的，但它的下一跳192.168.23.3在路由表中并不存在，这并不影响它是否是valid，每个厂家关于路由协议都有自己的理解，所以在不同厂家设备对接的时候一定要了解这些差异，具体出处在<a href="https://community.cisco.com/t5/other-network-architecture/bgp-valid-status-code/td-p/355514">这个帖子</a>：</p>
<p><img src="/2020/10/11/14-BGP/1609574798947-f5e93db6-8524-480c-b5cc-23c4f3004c90.png" alt="img"></p>
<h3 id="关于思科的‘-gt-best’"><a href="#关于思科的‘-gt-best’" class="headerlink" title="关于思科的‘&gt;-best’"></a>关于思科的‘&gt;-best’</h3><p>BGP表中的Best表示这条路由是BGP表中的最优，而不代表它一定就是路由表中的最优。决定一条BGP路由是否是路由表中的最优有两个过程，第一个过程是BGP表维护过程，大概就是BGP表中去往同一目的地的候选路由进行比较，选出一条BGP表中的最优路由，这个过程比的是BGP的属性，比如AS_PATH或MED这种，如果在BGP的路由表中最优则会有&gt;的标识，<strong>标识它是BGP表中的最优</strong>，如果去往目的地只有一条BGP路由，那么它不需要比较，直接就是BGP表中的最优；第二个过程是由路由表维护过程，BGP中带&gt;符号最优的这条BGP路由和IGP路由进行比较，如果IGP路由协议中有和BGP路由去往同一个前缀的路由，则Best的BGP路由和IGP路由进行比较AD值，AD值越小的越优，AD值小的进入路由表；如果IGP路由协议中没有和BGP路由去往同一个前缀的路由，则BGP的Best路由直接进入路由表中。这部分笔记出自于<a href="https://community.cisco.com/t5/routing/bgp-gt-best-status-code/td-p/4265857">这个帖子</a>。</p>
<h2 id="show-ip-bgp-summary"><a href="#show-ip-bgp-summary" class="headerlink" title="show  ip bgp summary"></a>show  ip bgp summary</h2><p><img src="/2020/10/11/14-BGP/1608540858816-cc5a8027-e5f6-48d7-9963-9500715b25bf.png" alt="img"></p>
<ul>
<li><p>BGP table version，每当BGP表发生变化时，这个数字+1；</p>
</li>
<li><p>main table version，被注入到主路由表中的最后一个table version；</p>
</li>
<li><p>AS，邻居的AS号；</p>
</li>
<li><p>MsgRcvd：从邻居那里收到的消息数；</p>
</li>
<li><p>MsgSent：发送给该邻居的消息数；</p>
</li>
<li><p>TblVer：发送给该邻居的最后一个bgp table的version；</p>
</li>
<li><p>InQ：来自该邻居的等待处理的消息数；</p>
</li>
<li><p>OutQ：队列中等待被发送到该邻居的消息数；</p>
</li>
<li><p>State：BGP当前的会话状态，可能有Idle、Opensent等，如果状态为admin表示该邻居被管理型Shutdown，当处于establish状态时，不会显示状态提示，而显示一个表示PfxRcd的数字，也就是上图中所示的状态，表示从该邻居处收到的前缀条目，图中表示从邻居10.1.12.2收到了1个路由前缀。</p>
</li>
</ul>
<h2 id="BGP-Policy-Accounting"><a href="#BGP-Policy-Accounting" class="headerlink" title="BGP Policy Accounting"></a>BGP Policy Accounting</h2><p>基本概念</p>
<p>BGP Policy Accounting能对BGP 邻居发送来的IP流量进行度量或流量统计。Policy accounting is enabled on an input interface, and counters based on parameters such as community list, autonomous system number, or autonomous system path are assigned to identify the IP traffic. </p>
<p>在R2上抓取R1发过来的去往30.30.30.0/24的流量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 30 permit 30.30.30.0/24 </span><br><span class="line"></span><br><span class="line">route-map setComm permit 10 </span><br><span class="line">  match ip address prefix-list 30 </span><br><span class="line">  set community 300:30 </span><br><span class="line">  </span><br><span class="line">ip community-list 30 permit 300:30 </span><br><span class="line"></span><br><span class="line">route-map PA permit 10 </span><br><span class="line">  match community 30 </span><br><span class="line">  set traffic-index 30 </span><br><span class="line">  </span><br><span class="line">router bgp 12</span><br><span class="line">  table-map PA </span><br><span class="line">  neighbor 10.1.23.3 route-map setComm in</span><br><span class="line">  </span><br><span class="line">interface fast0/0</span><br><span class="line">  ip address 10.1.12.2 255.255.255.0</span><br><span class="line">  bgp-policy accounting input</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/iproute_bgp/configuration/15-s/irg-15-s-book/irg-bgp-pol-acct.html">https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/iproute_bgp/configuration/15-s/irg-15-s-book/irg-bgp-pol-acct.html</a></p>
<p><a href="https://community.cisco.com/t5/networking-documents/how-to-configure-the-bgp-policy-accounting-feature/ta-p/3132729">https://community.cisco.com/t5/networking-documents/how-to-configure-the-bgp-policy-accounting-feature/ta-p/3132729</a></p>
<p>1、设定进行审计的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device(config)# ip community-list community-list-number &#123;permit | deny&#125; community-number</span><br><span class="line">Device(config)# route-map map-name [permit | deny] [sequence-number]</span><br><span class="line">Device(config-route-map)# match community-list community-list-number [exact]</span><br><span class="line">Device(config-route-map)# set traffic-index bucket-number</span><br></pre></td></tr></table></figure>



<p>1、定义要统计的感兴趣流量，并设置流量索引，Communitu-list、AS_PATH或者 AS号等参数都可以用于抓取感兴趣流量</p>
<p>2、将IP流量归类，在BGP进程中使用route-map关键字关联上面定义好的route-map。BGP将基于route-map中定义的规则对路由表中的路由进行归类，其实就是把感兴趣流量归类到traffic-indexzh中</p>
<p>1、需要进行流量可以根据BGP的community或AS_Path属性进行分类。如果用community属性进行分类，则需要用ip community-list列表来抓取流量；如果用AS_Path属性进行分类，则需要用ip as-path access-list列表来抓取流量。</p>
<p>2、创建route-map来匹配之前配置的community-list或AS_Path list，并为收集到的流量信息设置存储桶的名称。</p>
<p>3、用route-map中的set traffic-index命令来规定如何将那些被route-map匹配的数据包进行分类</p>
<h2 id="BGP路由重发布"><a href="#BGP路由重发布" class="headerlink" title="BGP路由重发布"></a>BGP路由重发布</h2><h3 id="BGP重发布到IGP"><a href="#BGP重发布到IGP" class="headerlink" title="BGP重发布到IGP"></a>BGP重发布到IGP</h3><p>讲BGP路由重发布到IGP时，默认不重新发布IBGP路由，只重发布EBGP路由，在MPLS VPN环境的PE没有这个限制。如果想让IBGP路由也被重发布的话，需要使用命令‘bgp redistribute-internal’。</p>
<h3 id="OSPF重发布进BGP"><a href="#OSPF重发布进BGP" class="headerlink" title="OSPF重发布进BGP"></a>OSPF重发布进BGP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp X</span><br><span class="line">  redistribute ospf 1</span><br></pre></td></tr></table></figure>

<p>默认情况下，只会将OSPF中O以及OIA的路由重发布进BGP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 external 1 external 2</span><br></pre></td></tr></table></figure>

<p>只重发布OSPF的外部路由E1、E2进BGP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 external 1</span><br></pre></td></tr></table></figure>

<p>只重发布OSPF的外部路由E1进BGP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 nssa-external 1 nssa-external 2</span><br></pre></td></tr></table></figure>

<p>只重新发布OSPF的NSSA路由进BGP</p>
<h2 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h2><p>show ip bgp neighbors {address} received-routes</p>
<p>显示从指定邻居收到的所有BGP路由，也就是本地入站策略执行前的原始路由</p>
<p>show ip bgp neighbors {address} routes</p>
<p>显示从指定邻居那里收到的所有路由，是上一条命令的子集，这里显示的是执行入站策略后剩下的路由</p>
<p>show ip bgp neighbors {address} advertised-routes</p>
<p>显示通告给特定邻居的所有BGP路由</p>
<p>neighbor maximum-prefix XX</p>
<p>限制从邻居处接受的前缀的最大数，如果超出了这个数字，路由器就会关闭与该邻居的BGP连接，在应用clear ip bgp xxx之前都不会再次建立BGP会话</p>
<p>neighbor maximum-prefix XX restart 2</p>
<p>当从邻居处收到的前缀数量超过XX这个数字，断开与邻居的BGP连接，2分钟后才能重新连接</p>
<p>Neighbor maximum-prefix  300  90%  warning-only</p>
<p>当从邻居处接受的前缀数量超过了最大数字，300，的90%时（默认值为75%），生成一条消息日志</p>
<h1 id="BGP决策"><a href="#BGP决策" class="headerlink" title="BGP决策"></a>BGP决策</h1><h2 id="决策过程总览"><a href="#决策过程总览" class="headerlink" title="决策过程总览"></a>决策过程总览</h2><p>在一个既有IGP又有BGP的环境中，路由决策分为两个部分，一个是BGP表的决策过程，一个是路由表的决策过程。BGP表的决策过程大概就是BGP表中去往同一目的地如果有多条BGP路由，要选出一条最优路由，这个过程比的是BGP属性的优先程度，比如AS_PATH或MED这种，如果一条BGP路由在BGP路由表中最优则会有&gt;的标识，<strong>标识它是BGP表中的最优</strong>，如果去往目的地只有一条BGP路由，那么它不需要比较，直接就是BGP表中的最优；第二个过程是由路由表决策过程，BGP中带&gt;符号最优的这条BGP路由和IGP路由进行比较，如果IGP路由协议中有和BGP路由去往同一个前缀的路由，则Best的BGP路由和IGP路由进行比较AD值，AD值越小的越优，AD值小的进入路由表；如果IGP路由协议中没有和BGP路由去往同一个前缀的路由，则BGP的Best路由直接进入路由表中。这部分笔记出自于<a href="https://community.cisco.com/t5/routing/bgp-gt-best-status-code/td-p/4265857">这个帖子</a>。</p>
<h2 id="BGP路由信息库"><a href="#BGP路由信息库" class="headerlink" title="BGP路由信息库"></a>BGP路由信息库</h2><p>BGP路由信息数据库，BGP Routing Information Base (RIB)，包含三个部分：</p>
<ul>
<li><p>ADJ-RIBS-IN：存储来自对等体邻居的、未经处理的消息，所包含的路由都是可用路由。说白了就是邻居发来的原始的路由信息是什么样的，原封不动的保存在Adj-RIBs-In中。通过命令 show ip bgp neighbor x.x.x.x received-routes查看Adj-RIBs-In。</p>
</li>
<li><p>Loc-RIB：存储着去往每个目标地址的最佳BGP路由。大体过程是，BGP路由器通过对ADJ-RIBS-IN中的路由使用它入向路由策略，那些符合入向策略的策略路由中，如果有多条路由去往同一目标地址的，则需要经过BGP的路由决策过程，从它们中选出最优（BEST）的放入Loc-RIB中并标记上&gt;符号，如果去往该目标地址只有一条路由，则直接将路由放入Loc-RIB中并标记上&gt;符号。</p>
</li>
<li><p>ADJ-RIBS-OUT：宣告给对等体邻居的路由，这些路由条目通过update报文发送给邻居，通告给邻居的是最优的路由。通过命令show ip bgp neighbor x.x.x.x advertise-routes来查看Adj-RIBs-Out。</p>
</li>
</ul>
<p>可以说，BGP的RIB有以上这三个不同的数据库，或者说RIB是由以上三个部分构成的一个单独的数据库。</p>
<p>The BGP Routing Information Base (RIB) consists of three parts:</p>
<ul>
<li><p><strong>Adj-RIBs-In</strong>: Stores unprocessed routing information that has been learned from BGP Updates received from peers. The routes contained in Adj-RIBs-In are considered feasible routes.</p>
</li>
<li><p><strong>Loc-RIB</strong>: Contains the routes that the BGP speaker has selected by applying the decision process to the routes contained in Adj-RIBs-In. These routes populate the routing table (RIB) along with routes discovered by other routing protocols.</p>
</li>
<li><p><strong>Adj-RIBs-Out</strong>: Contains the routes that the BGP speaker advertises to its peers in BGP Updates. The outgoing routing policies determine what routes are placed in Adj-RIBs-Out.</p>
</li>
</ul>
<p>These three parts of the RIB may be three distinct databases, or the RIB may be a single database with pointers to distinguish the three parts.</p>
<h2 id="BGP决策过程"><a href="#BGP决策过程" class="headerlink" title="BGP决策过程"></a>BGP决策过程</h2><h3 id="BGP表处理、决策过程"><a href="#BGP表处理、决策过程" class="headerlink" title="BGP表处理、决策过程"></a>BGP表处理、决策过程</h3><ul>
<li><p>Phase 1 calculates the degree of preference for each feasible route in the Adj-RIBs-In. It is invoked whenever a router receives a BGP Update from a peer in a neighboring AS containing a new route, a changed route, or a withdrawn route. Each route is considered separately, and a nonnegative integer is derived that indicates the degree of preference for that route.</p>
</li>
<li><p>Phase 2 chooses the best route out of all the available routes to a particular destination and installs the route in the Loc-RIB. It is invoked only after phase 1 has been completed. Loops are also detected in Phase 2 by examining the AS_PATH. Any routes with the local AS number in the AS_PATH are dropped.</p>
</li>
<li><p>Phase 3 adds the appropriate routes to the Adj-RIBs-Out for advertisement to peers. It is invoked after the Loc-RIB has changed, and only after phase 2 has been completed. Route aggregation, if it is to be performed, happens during this phase.</p>
</li>
<li><p>从邻居处收到的所有BGP路由原封不动的保存到Adj-RIBs-In中，去往同一目的地可能存在多条BGP路由，所以从多条BGP路由中选出一条最优的BGP路由。</p>
</li>
<li><p>每当路由器收到由邻居AS对等体发来的BGP update（注意，update中可能有新路由，变更现有路由或撤销原有路由）报文后，就会计算所有Adj-RIBs-In中可用BGP路由的优先级，算出来的优先级是一个整数（非负数的），这个值代表着这条路由的优先程度，这个优先程度是BGP用来对每条路由进行排序的依据，列出哪条路由是最优，哪条路由是次优。</p>
</li>
<li><p>在计算完所有Adj-RIBs-In中路由的优先级后，在那些既符合入向策略且下一跳可达的路由中，选出一条BEST的路由(在BGP表中标记上&gt;，表示它是BEST最优的)，将这条最优路由放入Loc-RIB中。一条BGP路由的下一跳如果不可达，则它不能成为最优。如果去往目标地址有多条路由则用优先级选出一条最优的，如果去往该目的地址只有一条路由，则该路由即为最优BGP路由。这些被计算优先级的路由是Adj-RIBs-In中的所有未经本地策略改变的。本阶段除了选出最优的路由以外也会进行路由防环的检测，路由器会查看收到路由的AS_PATH，如果本路由器所处的AS号在新收到路由的AS_PATH中，则会丢弃该路由，因为有本AS的AS_PATH号意味着路由曾经到过本AS，为了防止环路必须丢弃该路由。</p>
</li>
<li><p>在完成了上一步骤后，将选出来的最优且无环的路由放入Adj-RIBs-Out中，宣告给对等体邻居。如果配置了路由汇总，也会在本阶段进行。</p>
</li>
</ul>
<h3 id="路由表决策过程"><a href="#路由表决策过程" class="headerlink" title="路由表决策过程"></a>路由表决策过程</h3><p>由BGP表决策过程选出来的BEST的BGP路由，将参与<strong>路由表的决策过程</strong>，如果有去往同一目的的IGP路由，则比较最优BGP路由和IGP路由的AD值，谁小谁加路由表；如果没有其他去往相同目的地的IGP路由，则BGP路由直接为最优。</p>
<h2 id="属性优先级判定"><a href="#属性优先级判定" class="headerlink" title="属性优先级判定"></a>属性优先级判定</h2><h3 id="总体规则"><a href="#总体规则" class="headerlink" title="总体规则"></a>总体规则</h3><p>当到达同一个目标地址有多条BGP路由时，由BGP路由属性来判断优先选择哪条BGP路由，如果两条路由的某个属性能分出哪条更优先时，则停止比较，如果两条路由的一个属性相同无法比出结果，则比较下一个属性，例如路由A和路由B这两条路由去往同一个目的地，先比较Weight值，如果路由A的weight值更大，则路由A为最优，停止比较；如果路由A和B的Weight值相同无法比较出谁更优，则比较下一个属性值，Local Preference，以此类推，直到有一个属性能分出胜负后，停止比较。这个比较过程是在Adj-RIBs-In中做的。</p>
<p>那么这个属性优先级排定和之前说的每条路由计算出一个非负数的优先级有什么联系呢？<a href="https://community.cisco.com/t5/routing/what-s-the-role-of-degree-of-preference-in-the-adj-ribs-in-in/m-p/4270220#M345214">这个帖子</a>中是这么说的：‘The BGP decision process is an integral part of the process that assigns the degree of preference to each prefix for its ranking. It may help to think of it in this way: the process for degree of preference reads each entry of the Adj-RIBs-In and the process for degree of preference uses the BGP decision process on that prefix and uses the results of the BGP decision process to assign the ranking.’大概意思是说，这个属性优先级判定是前面提到的，给Adj-RIB-in中所有路由计算优先级的一部分，计算优先级的过程会读取Adj-RIBs-in中的每条路由信息并用属性优先级判定过程来决定一条路由的优先级程度，然后决定哪条BGP路由为最优。</p>
<p><img src="/2020/10/11/14-BGP/1610164572582-7ee675dc-4a44-4395-a795-c724dbff7a41.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611376250625-781c53c5-faac-4e88-b31f-a9fa42936d8e.jpeg" alt="img"></p>
<ol>
<li>Weight值是思科IOS专有属性，Weight值越大越优先，Weight值只在本路由器上有意义，在一个路由器上对Weight值进行更改，不会传递给其他路由器，不会影响其他路由器上的Weight值。</li>
<li>如果Weight值相等，那么LOCAL_PREF值大的路由更优先。</li>
<li>如果LOCAL_PREF值相等，那么优先选择起源于本地的路由（例如在本路由器使用network或aggregate命令宣告的），即下一跳是0.0.0.0的路由（在BGP表中，当前路由器宣告的BGP路由下一跳为0.0.0.0），优先顺序从高到低为：default-originate（针对每个邻居配置）、default-information-originate（针对每种地址簇配置）、network、redistribute、aggregate-address；</li>
<li>如果LOCAL_PREF相同并且没有起源于本路由器的路由，则比较AS_PATH长度，越短越优先。路由聚合时使用AS-SET后产生的AS_PATH列表中{}里的AS号长度只选一个AS号的长度，比如如果AS_PATH中有{100 300 500}则只算一个AS号的长度，如果AS_PATH中有{100 300 500} 400，则算两个AS号长度。在联邦内的AS_PATH列表中的（）的AS号长度不做计算依据。如果配置了bgp bestpath as-path ignore这条命令，则跳过比较AS_PATH这步。</li>
<li>如果AS_PATH长度相同，则比较ORIGIN属性，IGP&gt;EGP&gt;Incomplete。</li>
<li>如果ORIGIN属性相同，则比较MED，越小越优先。一般情况下属性值比到这一步只可能是，需要比较的路由都来自同一个AS的不同EBGP邻居。可以配置bgp always-compare-med这条命令使得即使来源于不同的AS也进行MED比较。</li>
<li>如果MED也相同，则EBGP路由优于联邦EBGP路由，联邦EBGP路由优于IBGP路由。</li>
<li>如果上一步也依旧无法比较出是否优选，则优选到BGP NEXT_HOP更近的路由，该路由在AS内部是去往下一跳IGP度量值最小的路由。严格来说应该说，一台路由器从<strong>本AS</strong>的两个BGP邻居各收到一条路由，这两条BGP路由具有相同的路由前缀，首先这两条BGP路由的Next hop是不相同的才具有可比性，这时候比较本地到达这两个Next_hop的IGP的度量值，谁的Metric小，就优选谁。</li>
<li>如果有多条来自同一个相邻AS的路由并通过Maximum-paths命令激活了负载均衡属性，则将所有开销相同的路由加入Loc-RIB。</li>
<li>如果所有路由都来自EBGP邻居，则优选最先收到的EBGP邻居传来的路由，降低路由翻滚的影响。最老的EBGP邻居意味着可能是最稳定的BGP邻居，因此在这条规则中做了优选。这条比较规则主要针对EBGP路由起效，但现在基本不再使用，因为不确定性比较强。如果配置了‘bgp bestpath compare-routerid’命令后则跳过本原则。</li>
<li>如果没有激活负载均衡，优选Router ID最小的，在使用了路由反射器的情况下，优选ORIGINATOR_ID小的。</li>
<li>如果在使用了路由反射器的情况下ORIGINATOR_ID相同，则优选CLUSTER_LIST小的路由。</li>
<li>如果路由CLUSTER_LIST依旧相同，则优选IP地址小的邻居发送过来的路由。</li>
</ol>
<h3 id="weight越大越优"><a href="#weight越大越优" class="headerlink" title="weight越大越优"></a>weight越大越优</h3><h4 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h4><p>weight属性为思科私有，作用范围是本路由器，该值既不会被包含在update报文中，也不会传递给任何BGP邻居，只在路由器本地产生影响，中文翻译为权重值，<strong>越大越优先</strong>。取值范围为0-65535。如果路由是从其他BGP邻居学过来的，则weight值为默认的0；如果路由是从本地network产生的，则weight值为32768；本地重发不的直连接口路由或静态路由的weight为32768；本地汇总产生的BGP路由weight值为32768。</p>
<h4 id="如何操控"><a href="#如何操控" class="headerlink" title="如何操控"></a>如何操控</h4><p>*<strong>方法1*</strong></p>
<p>如果想对weight值进行更改，那么应该在本路由器上进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor &#123;ip address|peer-group_name&#125; weight XXXX</span><br></pre></td></tr></table></figure>

<p>例如，C从A和B都学到了1.1.1.0/24这条BGP路由，在不对weight值进行操控的情况下，这两条路由在C上的weight值都是0，因为该路由是从其他邻居那学过来的，weight值默认为0，此时我如果想让从B学到的路由更优选，则配置可以配置‘neighbor B weight 200’，那么从B获得的路由1.1.1.0/24的路由的weight值为200，为Best路由，被C优选：</p>
<p><img src="/2020/10/11/14-BGP/1610775563455-87517886-85d7-4639-b5e3-2cd1ef763cc8.jpeg" alt="img"></p>
<p>但按照上面的方式进行配置也有另一个问题就是，简单的将从B宣告过来的所有路由的weight值都设置成为了200，如果A和B也同时宣告过来一条2.2.2.0/24的路由，C想优选从A发过来的这条2.2.2.0/24路由按上面的配置则无法做到，此时需要用到下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X  filter-list 1 weight XXX</span><br></pre></td></tr></table></figure>

<p>这条命令是将邻居X.X.X.X发送过来的，且被Filter-list 1 匹配的条目的weight值设置为XXX。这条命令可以对同一个邻居使用多次，也就是对不同的路由设置不同的weight，但命令‘neighbor 1.1.1.1filter-list 1’在同一个邻居的in 或out方向，只能使用一次，这两条命令有很大区别。</p>
<p>*<strong>方法2*</strong></p>
<p>使用route-map进行修改，达到去往100.0.1.0/24走左边的R3路由器，而去往100.0.2.0/24走右边的R5路由器。</p>
<p><img src="/2020/10/11/14-BGP/1610776730473-0c3330ce-1b99-46da-8f92-4b95f8980ac1.jpeg" alt="img"></p>
<p>这时候我们可以将R3传来的100.0.1.0/24路由的weight值设置为10，将R4传来的100.0.2.0/24路由的weight值设置为10，这样就能达成要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map 1 in</span><br><span class="line"> neighbor 5.5.5.5 route-map 2 in</span><br></pre></td></tr></table></figure>

<p>配置完以后，用show ip bgp 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#do show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    100     10 100 i</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<p>此时达成了题干要求，但这么配置是否是最优的呢？并不是，因为R3和R5都有去往1.0和2.0的路由，互为备份，如果按照上面的配置方式，一旦R3或R5某一方向的链路出现问题，假设这里是R1和R3之间的链路出现问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-router)#neighbor 10.1.13.3 shutdown</span><br></pre></td></tr></table></figure>

<p>那么此时R4的路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<p>也就是去往100.0.1.0/24的路由完全没有了，为什么会这样呢？是因为在R4上配置的route-map为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br></pre></td></tr></table></figure>

<p>route-map的结尾默认有一条deny any，没匹配上的路由就会被deny掉，route-map1中只匹配了100.0.1.0/24这条路由，所以虽然R3发送了两条BGP路由到R4，但R4上的入向策略将没被route-map 1匹配到的2.0/24路由给deny掉了，所以R4只从R3收到了route-map1匹配到的1.0/24这条路由。同理R4入向策略过滤掉的route-map2没匹配到的1.0路由，R4从R5上只收到了2.0/24这条路由，所以不管是R3方向或R5方向上的链路中断，则R4上没有备份路径。所以如果想要两个方向互为备份路径应该如何配置呢？需要对R4上配置的route-map进行更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 20</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 5</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 20</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 5</span><br></pre></td></tr></table></figure>

<p>配置完的新route-map对1.0/24和2.0/24都进行了匹配，R4可以从R3和R5上都收到两条BGP路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config-route-map)#do show ip bgp</span><br><span class="line">BGP table version is 10, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     5.5.5.5                  0    100      5 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                  0    100     10 100 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      5 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<h3 id="Local-Preference越大越优"><a href="#Local-Preference越大越优" class="headerlink" title="Local-Preference越大越优"></a>Local-Preference越大越优</h3><h4 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h4><p>Local-Preference是公认自决属性，默认值为100，只用于iBGP邻居之间，决定离开AS的最优路径，一般用于控制本AS的出口设备。</p>
<ul>
<li>Local-Preference就是本地优先级，当一个AS收到一个去往同意目的地的，但经过两个AS的路由，在其他BGP路由属性完全一致的情况下，根据两条路由的local-preference决定，值越大越优，比如下图中的路由器D，从C和E两个路由器都收到了去往172.20.0.0的路由，但E发过来的路由属性中Local-Preference值大于C发过来的路由属性，所以去往E的路由更优：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607149141276-33b3db5c-2872-426d-93d9-68314eaef8ad-1642643991222194.jpeg" alt="img"></p>
<ul>
<li><p>Local-Preference只能在AS内部的iBGP邻居之间传递，而不会传递给其他eBGP邻居，Local-Preference除非做了策略，否则在AS内的iBGP邻居之间传递时不会丢失，如果eBGP邻居之间收到的路由的路径属性中携带了Local-Preference的话，会触发notification报文造成BGP会话中断，但可以在AS边界路由器上使用IN方向策略；</p>
</li>
<li><p>Local-Preference在向eBGP邻居发送路由更新时，不能携带LP属性，对方收到该eBGP路由的LP值为空，也就是说路径属性中根本没有LP这个字段，但它会在本地为这条路由赋一个默认值，也就是100，然后再传递给自己的iBGP邻居；</p>
</li>
<li><p>本地network命令及重发布命令发布的路由，LP值默认为100，并能在AS内向其他iBGP邻居传输，传输过程中除非部署了策略，否则LP值不会发生变化；</p>
</li>
<li><p>修改默认LP值的命令为：bgp default local-preference  XXX。</p>
</li>
</ul>
<h4 id="如何操控-1"><a href="#如何操控-1" class="headerlink" title="如何操控"></a>如何操控</h4><p>使用route-map来修改本地优先级，实验拓扑如下，使用LP来操控路由，使得R4去往100.0.1.0/24走R3方向且LP=200，去往100.0.2.0/24走R5方向且LP=200。</p>
<p><img src="/2020/10/11/14-BGP/1610785384351-c9d2aa43-e2bc-43ff-ba08-0c107e2d04b4.jpeg" alt="img"></p>
<p>由于LP在IBGP邻居之间可以传递，所以这里既可以在R4的In方向上使用route-map来操控LP，也可以在R3和R5上对R4的OUT方向使用route-map来操控。</p>
<p>*<strong>方式1：*</strong></p>
<p>先看在R4的In方向上使用route-map：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 100.0.2.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 20</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map LP1 in</span><br><span class="line"> neighbor 5.5.5.5 route-map LP2 in</span><br></pre></td></tr></table></figure>

<p>route-map LP1和LP2后面之所以写了两个空的permit 20，是因为route-map最后都默认有一个deny any，如果不写空的permit 20，则其他路由会被deny掉，无法传到R4上，也就没法达到备份路径的效果。R3从R1（R5从R2）获取的eBGP路由中的LP值为空，到了R3\R5后被赋予了默认值100，这个值不被route-map改变的话，传到邻居R4后还是默认值100。</p>
<p>配置完结果如下：</p>
<p><img src="/2020/10/11/14-BGP/1610786417710-b571938f-7ef2-4304-91ce-76aabffd3fed.jpeg" alt="img"></p>
<p>为什么会这样选择最优路由呢？因为weight值相同，不起源于本地的路由默认weight值都是0，所以比较LP值，而LP值不相同，拥有200LP值的路径被优选，因为LP值越大越优先。</p>
<p>*<strong>方法2：*</strong></p>
<p>在R3和R5上分别对out方向的R4使用route-map来操控LP，因为R4和R3\R5都为ibgp邻居关系，而LP在IBGP邻居之间是可以传递的。配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map LP1 out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">ip prefix-list LP2 seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 10</span><br><span class="line"> match ip address prefix-list LP2</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map LP2 out</span><br></pre></td></tr></table></figure>

<p>配置后结果如下：</p>
<p><img src="/2020/10/11/14-BGP/1610788896487-998dc664-31d0-4b00-b906-27f6aedda7b5.jpeg" alt="img"></p>
<h3 id="优选本地起源路由"><a href="#优选本地起源路由" class="headerlink" title="优选本地起源路由"></a>优选本地起源路由</h3><h4 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h4><p>优选起源于本地的路由，也就是那些在本路由器上network、aggregate或redistribute的，也就是下一跳是0.0.0.0的路由，因为在BGP表中，起源于当前路由器的路由，下一跳为0.0.0.0。</p>
<h4 id="实验验证-2"><a href="#实验验证-2" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610857596183-6c383ba3-048f-4cb6-8e6b-d7a6d26b5979.jpeg" alt="img"></p>
<p>R3上宣告一条8.0.0.0/8的BGP路由，R4上network一条同样的8.0.0.0/8的路由，来验证起源于本地的路由是否被优选。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">R3(config)#ip route 8.0.0.0 255.0.0.0 null 0                   配置一条目的地是null接口的路由使得8.0.0.0路由能宣告进BGP</span><br><span class="line">R3(config)#router bgp 345</span><br><span class="line">R3(config-router)#network 8.0.0.0 mask 255.0.0.0</span><br><span class="line">配置完毕后查看R3的BGP表：</span><br><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;   100.0.1.0/24     10.1.13.1                0             0 100 i</span><br><span class="line"> *&gt;   100.0.2.0/24     10.1.13.1                0             0 100 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">R4(config)#ip route 8.0.0.0 255.0.0.0 null 0</span><br><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#network 8.0.0.0 mask 255.0.0.0</span><br><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0         32768 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 i</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    200      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    200      0 200 i</span><br></pre></td></tr></table></figure>

<p>但此时必须注意，虽然R4上优选了起源于本地的路由，但要知道，这两条路由不是上来就用‘优选起源于本地的路由’这条规则来比较，而是先要比Weight值，然后比较Local-Preference，比较完前两个才使用‘优选起源于本地的路由’这条规则来比较。这里也按照这个顺序进行比较，先看Weight值，由于起源于本地路由默认的weight值为32768，所以在第一部比较出来了就不会再用其他规则进行比较，这里用route-map将weight值改成一样的来验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map WEIGHT permit 10</span><br><span class="line"> set weight 0</span><br><span class="line"></span><br><span class="line">router bgp 345</span><br><span class="line"> network 8.0.0.0 route-map WEIGHT</span><br></pre></td></tr></table></figure>

<p>如此配置以后，再查看R4的BGP表发现，此时R4上8.0.0.0的Weight值为0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 7, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0             0 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 i</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    200      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    200      0 200 i</span><br></pre></td></tr></table></figure>

<p>这时R4优选了本地起源的路由，因为首先比较的Weight值相同，接下来比较的Local-Preference值也相同，都为默认的100，起源于本地这条LP也是100具体见下图，接下来是起源于本地的路由更优，所以选择了本地那条下一跳为0.0.0.0的路由。<img src="/2020/10/11/14-BGP/1610869076686-fa5bb6f4-7caa-43f1-8e78-5c4eab29e824.jpeg" alt="img"></p>
<h3 id="AS-PATH越短越优"><a href="#AS-PATH越短越优" class="headerlink" title="AS_PATH越短越优"></a>AS_PATH越短越优</h3><h4 id="基本概念-12"><a href="#基本概念-12" class="headerlink" title="基本概念"></a>基本概念</h4><p>AS_PATH是公认必遵属性，描述到达目标网络所要经过的AS号序列，最重要的作用是防环。当且仅当update报文被发送给其他的AS（也就是EBGP peer）时，BGP路由器才会将其AS号追加在AS_PATH中。也就是如果要修改AS_PATH属性，则必须在AS边界路由器上执行，对IBGP邻居去执行修改AS_PATH的策略是无效的。</p>
<p><img src="/2020/10/11/14-BGP/1610869583847-dfa585d5-6256-4f21-aab3-fed01d40be5f.png" alt="img"></p>
<p>例如在上面的BGP表中，去往4.4.4.4/32的路由有两条，要对这两条路由进行比较，看谁更优先，首先看这两条路由的weight值，都为0，所以比较下一个属性，local-preference，虽然BGP表中为空，但两者在本地都被赋予了默认值100，所以继续比较下一项，看两者谁是起源于本地的，由于两条路由的Nexthop都不为0.0.0.0，意味着两条路由都不起源于本地，所以继续比较下一项AS_PATH，越短越优，下一跳为192.168.34.4的这条路由只经过了一个AS（AS4），短于经过了两个AS（AS4-AS1）的下一跳为192.168.13.1的路由，所以AS_PATH短的被优选。</p>
<p>如果做了聚合路由时，使用AS-SET关键字后产生的AS_PATH列表中的{}，无论里边有几个号码，只算做一个AS号的长度，比如如果800 {200 100}只算两个AS号的长度，{200 100 300 400}也只算一个AS号的长度。</p>
<p>如果做了联邦，则联邦AS的AS号不算做长度计算的依据，也就是如果AS_PATH为（65412  65413）100，只算一个AS号的长度。</p>
<h4 id="实验验证-3"><a href="#实验验证-3" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610870199066-58d578a2-089e-4299-9161-c7e489122714.jpeg" alt="img"></p>
<p>由于AS_PATH只在update报文发送给其他AS时才发生变化，这意味着修改操控它必须在AS边界路由器上执行策略，所以既可以在R1\R2的out方向上对AS345的EBGP邻居修改，也可以在R3和R5的In方向上进行修改。</p>
<p>*<strong>方法1：*</strong></p>
<p>方法1采用在R1\R2的out方向上做策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.2.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 88888 88888 88888</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 10.1.13.3 route-map AS_PATH out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 44444 44444 44444</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.25.5 route-map AS_PATH out</span><br></pre></td></tr></table></figure>

<p>此时R4上BGP表如下：</p>
<p><img src="/2020/10/11/14-BGP/1610871790826-e221e4cf-b569-485d-bca4-d03f17f54697.jpeg" alt="img"></p>
<p>由于从R3和R4都收到了去往100.0.1.0/24和100.0.2.0/24的路由，这时需要选择最优路由，先看Weight值越大越优，由于所有路由都不是本地起源所以都为默认值0，所以比较下一个属性，Local-Preference越大越优，由于LP不会通过EBGP邻居传递，所以两条起源于外AS的路由在本AS内的LP为空，本AS路由器会赋予相同的默认值100，所以比较下一个属性，优选起源于本AS的路由，由于路由都不起源于本AS，Nexthop不为0.0.0.0，所以比较下一个，AS_PATH小的优选。这时划红线的两条路由的AS_PATH较长所以不被选择，路由器会选择AS_PATH较短的两条路由。</p>
<p>*<strong>方法2：*</strong></p>
<p>从R3和R5上配置in方向的route-map对AS_PATH进行操控。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 88888 88888 88888</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 10.1.13.1 route-map AS_PATH in</span><br><span class="line"> </span><br><span class="line"> R4：</span><br><span class="line"> </span><br><span class="line"> ip prefix-list AS_PATH seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 44444 44444 44444</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 10.1.25.2 route-map AS_PATH in</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕以后R4的路由表如下：</span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 16, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 44444 44444 44444 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 88888 88888 88888 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br></pre></td></tr></table></figure>

<p>*<strong>方法1对比方法2：*</strong></p>
<p>两种办法都能达到操控路由的目的，最显著的区别在于AS_PATH在R4上的表现，在R1上操控AS_PATH然后对out方向EBGP邻居使用route-map的话，AS_PATH是‘100 88888 88888 88888 i’，而在R3的in方向对邻居使用route-map的话，AS_PATH是‘88888 88888 88888 100 i’。之所以结果不同是因为route-map是在Adj-RIBs-IN上使用的，而传给邻居的BGP路由是Adj-RIBs-Out中的，out中的路由传递给eBGP邻居之前加上本AS的号码。</p>
<p>在R1上操控AS_PATH然后对out方向EBGP邻居使用route-map，route-map的操控结果在Adj-RIBs-IN上已经发挥作用，route-map生效后路由变成了‘88888 88888 88888 i’，i是表示该路由通过network注入的本AS，接下来通过route-map添加的AS号88888在左边，因为AS_PATH中越靠右表示更先经历该AS，靠左边表示晚一些经过该AS。由于去往该目标地址只有这一条路由，该路由为最优，所以带有‘88888 88888 88888 i’AS_PATH的路由进入了Loc-RIB和Adj-RIBs-Out中，接下来要将该路由发送给EBGP邻居，所以要在AS_PATH中靠左的位置加上本AS的号码，最后AS_PATH为‘100  88888 88888 88888 i’。</p>
<p>在R3上操控AS_PATH然后对EBGP邻居in方向使用route-map，route-map的操控结果在Adj-RIBs-IN上发挥作用，Adj-RIBs-IN中存储的是邻居发送过来的无更改的路由，这时R1发过来的路由在AS_PATH中已经加上了AS100的号码，也就是‘100 i’然后route-map对AS_PATH进行操控，加上了88888这个AS号码，后加入的AS号要在靠左的地方，所以最后AS_PATH为‘88888 88888 88888  100  i’。</p>
<h3 id="比较Origin-Code"><a href="#比较Origin-Code" class="headerlink" title="比较Origin Code"></a>比较Origin Code</h3><h4 id="基本概念-13"><a href="#基本概念-13" class="headerlink" title="基本概念"></a>基本概念</h4><p>Origin code的优先排序为：I（IGP）&gt;E（EGP）&gt;？（Incomplete），由于EGP协议已经不再使用，所以可以简单的将该规则记为IGP&gt;Incomplete，IGP表示路由起源于IGP，由network命令引入BGP。？表示是从其他渠道学习到的，该路由来源的信息不完全，一般是由重发布引入的。可以在show ip bgp中的path最右边看到origin code。一般不建议使用origin code对BGP选路进行操控。</p>
<p><img src="/2020/10/11/14-BGP/1610940171116-a813b671-0a15-4b0d-b598-d41ae6b0c4b6.png" alt="img"></p>
<h4 id="实验验证-4"><a href="#实验验证-4" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610941989856-5799d0e9-7c5e-41fc-b98e-cc59f59abf06.jpeg" alt="img"></p>
<p>在不进行任何配置的情况下，R4上去往100.0.1.0/24及100.0.2.0/24会通过R3走，本实验通过操控origincode使得两条路由改走R5方向去往目标网段。可以在R1上不使用network的方式发布两条路由而改为使用重发布方式将两条路由引入BGP，也可以在R1上使用route-map的方式进行操控，还可以在R3的out方向用route-map操控，抑或可以在R4的in方向上进行修改。</p>
<p><strong>方法1：</strong></p>
<p>首先使用在R1上network时修改origin的方式，在R1上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map ORIGIN permit 10</span><br><span class="line"> set origin incomplete</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> network 100.0.1.0 mask 255.255.255.0 route-map ORIGIN</span><br><span class="line"> network 100.0.2.0 mask 255.255.255.0 route-map ORIGIN</span><br></pre></td></tr></table></figure>

<p>配置完R4的路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 100 ?</span><br></pre></td></tr></table></figure>

<p>此时要选出最优路由依旧得从头开始比较，Weight值的话，两者相同都是0，因为都不是首发于本地的路由，默认weight值为0；Local-Preference比较，由于路由宣告自其它AS，LP不在EBGP邻居之间传递，所以用默认值100；两条路由都不是起源于本地，nexthop都不是0.0.0.0；AS_PATH比较，两边的AS_PATH长度值都是2；比较origin code，I&gt;?，所以优选走R5方向。</p>
<p><strong>方法2：</strong></p>
<p>在R3上对R4的out方向使用route-map更改origin code从而达到在R4上优选R5路径的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list ORIGIN seq 5 permit 100.0.1.0/24</span><br><span class="line">ip prefix-list ORIGIN seq 10 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map ORIGIN permit 10</span><br><span class="line"> match ip address prefix-list ORIGIN</span><br><span class="line"> set origin incomplete</span><br><span class="line">!</span><br><span class="line">route-map ORIGIN permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map ORIGIN out</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕后R4的路由表为：</span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 13, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br></pre></td></tr></table></figure>

<p>此时要选出最优路由依旧得从头开始比较，Weight值的话，两者相同都是0，因为都不是首发于本地的路由，默认weight值为0；Local-Preference比较，由于路由宣告自其它AS，LP不在EBGP邻居之间传递，所以用默认值100；两条路由都不是起源于本地，nexthop都不是0.0.0.0；AS_PATH比较，两边的AS_PATH长度值都是2；比较origin code，I&gt;?，所以优选走R5方向。</p>
<h3 id="MED越小越优"><a href="#MED越小越优" class="headerlink" title="MED越小越优"></a>MED越小越优</h3><h4 id="基本概念-14"><a href="#基本概念-14" class="headerlink" title="基本概念"></a>基本概念</h4><p>MED为可选非传递属性，一般用于AS之间的BGP选路，用来影响进入本AS的流量。默认情况下，要比较MED值仅在所有备选路由来自同一AS才会比较MED，也就是说同一个目的地的两条路由来自不同AS时，不进行MED值的比较。MED只在直接相连的AS间影响业务，<strong>只在AS内传递MED值，不会跨AS传递，思科设备MED值默认为0。</strong></p>
<p>MED设置方法：</p>
<ul>
<li><p>将IGP路由引入BGP时关联route-map进行设置；</p>
</li>
<li><p>对BGP peer应用IN/OUT方向的route-map进行设置；</p>
</li>
<li><p>非route-map方式：1、使用network或redistribute方式将IGP路由引入BGP时，MED将继承IGP路由的Metric（直连路由及静态路由的Metric为0）；2、使用aggregate-address方式引入路由，则MED为空。</p>
</li>
</ul>
<h4 id="实验验证-5"><a href="#实验验证-5" class="headerlink" title="实验验证"></a>实验验证</h4><p>通过更改MED值，使得原来优选R3方向的路由优选走R5方向。</p>
<p><img src="/2020/10/11/14-BGP/1611026347438-ac5ad4bd-b001-4e56-8491-c16d357932e7.jpeg" alt="img"></p>
<p>在R4上进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map MED permit 10</span><br><span class="line"> set metric 200</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map MED in</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕后R4的BGP表如下：</span><br><span class="line"> </span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                200    100      0 100 i</span><br><span class="line"> * i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                200    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到配置已经生效，在Weight值相同，Local-Preference相同，都不是起源于本地的路由，AS_PATH长度相同，Origin Code相同的情况下，比较MED时，路由并没有优选MED更小的R5方向，这是为什么呢？因为默认情况下，来源于不同AS_PATH路由不比较MED值，具体来说就是来源于R3方向的路由AS_PATH中显示它是来自AS100，来源于R5方向的路由AS_PATH中显示它来自AS200，这种情况下是不比较MED的：</p>
<p><img src="/2020/10/11/14-BGP/1611027413416-ed657332-ea54-443b-8d60-2b0613c67a72.jpeg" alt="img"></p>
<p>如果想用MED来为两条路由分出优先与否，则需要配置上‘bgp  always-compare-med’这条命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#bgp always-compare-med</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置完此命令后在看BGP表：</span><br><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                200    100      0 100 i</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                200    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>配置完命令后，来自不同AS的路由也开始比较MED值，越小越优，所以路由会优选R5方向。</p>
<h3 id="优选EBGP邻居的路由"><a href="#优选EBGP邻居的路由" class="headerlink" title="优选EBGP邻居的路由"></a>优选EBGP邻居的路由</h3><h4 id="基本概念-15"><a href="#基本概念-15" class="headerlink" title="基本概念"></a>基本概念</h4><p>优选EBGP邻居发来的路由（相比较IBGP邻居学过来的），在联邦EBGP和IBGP中优选联邦EBGP邻居。</p>
<p><img src="/2020/10/11/14-BGP/1611027668707-9589d443-430b-4d17-abd7-5f5540aa9508.jpeg" alt="img"></p>
<p>例如上图中，R5同时从R4及R2收到关于100.0.1.0/24的路由，在前几个比较条件都无法分出谁优选的情况下（Weight值相同，LP值相同，都不是起源于本地的路由，AS_PATH长度都为1，Origin Code都是i，MED值都为0），会优选来自R2的路由，因为R5和R2之间是EBGP邻居，优先于R5和R4的IBGP邻居发来的路由。</p>
<h4 id="实验验证-6"><a href="#实验验证-6" class="headerlink" title="实验验证"></a>实验验证</h4><p>由于水平分割原则的存在，R4无法将从ibgp邻居R3处学到的路由发送给另一个ibgp邻居R5，为了打破水平分割原则，这里将R4配置成路由反射器，使R3的路由能够发送给R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 这时看R5的路由表：</span><br><span class="line"> </span><br><span class="line"> R5#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;                    10.1.25.2                0             0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;                    10.1.25.2                0             0 200 i</span><br></pre></td></tr></table></figure>

<p>这时R5已经从R4处学到了100.0.1.0/24，这时Weight值相同都为0，Local-Preference也相同为0，路由都不起源于本地，AS_PATH长度相同都为1，Origin Code都为 i 也相同，MED值都为0，接下来由于R2方向学到的路由为EBGP路由所以优选这条。</p>
<h3 id="优选到NEXTHOP最近的"><a href="#优选到NEXTHOP最近的" class="headerlink" title="优选到NEXTHOP最近的"></a>优选到NEXTHOP最近的</h3><h4 id="基本概念-16"><a href="#基本概念-16" class="headerlink" title="基本概念"></a>基本概念</h4><p>当路由器从两个BGP邻居各收到一条路由，这两条BGP路由有相同的路由前缀，首先这两条BGP路由的NEXT_HOP必须是不相同的，否则不具有可比性，这时候会比较到达这两个NEXT_HOP的IGP度量值，谁的Metric小，就选谁。</p>
<p><img src="/2020/10/11/14-BGP/1611038313328-86466f24-88e7-49cd-8c2c-042bbe87993a.jpeg" alt="img"></p>
<p>比如R4从R3和R5都收到了关于100.0.1.0/24的路由<img src="/2020/10/11/14-BGP/1611038676694-4b75de24-7671-452d-9f12-6ff54f777351.jpeg" alt="img">：</p>
<p>两条路由一条NEXTHOP是3.3.3.3，一条是5.5.5.5，R4会比较到这两个NEXTHOP的IGP路由的metric值，越小越优，在上图中到两个NEXTHOP的metric相同，都是11。</p>
<p><img src="/2020/10/11/14-BGP/1611047431133-bbb1ef88-4714-4ba1-861f-8db64e5dce25.jpeg" alt="img"></p>
<h4 id="实验验证1"><a href="#实验验证1" class="headerlink" title="实验验证1"></a>实验验证1</h4><p>用上面的拓扑，操控NEXTHOP的metric值，使得R4用该规则优选R5方向的路由，由于要操控的是IGP的metric值，所以可以将R4连接R3接口的COST值调大，那么R4到达NH 3.3.3.3的metric值就变大了，R4就会优选R5这条BGP路径因为到达NH 5.5.5.5的metric值较小。</p>
<p><img src="/2020/10/11/14-BGP/1611039761141-61d18f1c-ce99-4c99-97fc-f4c631c1a02a.jpeg" alt="img"></p>
<p>在对配置改动之前，e0/0接口的cost值是10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#int e0/0</span><br><span class="line">R4(config-if)#ip ospf cost 100</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1611040114929-b1c5e261-5584-4174-8d28-acfc0550bcb8.jpeg" alt="img"></p>
<p>改完COST值后，还是得从第一条BGP比较规则一条一条往下看，Weight值相同为默认的0，Local-Preference相同为默认的100，两条路由都不起源于本地，AS_PATH长度相同都为2，Origin Code相同为i，MED相同为0，路由属性相同都是ibgp邻居出来的路由，现在比较到Next Hop的IGP的Metric值，到3.3.3.3的metric值为101，到5.5.5.5的metric值为11，优选到Next Hop的metric值小的5.5.5.5。</p>
<p><img src="/2020/10/11/14-BGP/1611043967580-095b2d0f-0bb8-474c-8d0d-ae56a864ab12.jpeg" alt="img"></p>
<p>用show ip bgp 100.0.1.0来查看metric更为直观一些。</p>
<h4 id="实验验证2"><a href="#实验验证2" class="headerlink" title="实验验证2"></a>实验验证2</h4><p><img src="/2020/10/11/14-BGP/1611044324196-2557103e-08ff-44c4-85eb-fe4464c4300c.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5：</span><br><span class="line"></span><br><span class="line">R5(config)#router bgp 345</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 remote-as 345</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 up loop 0</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">R4(config-router)#router bgp 345</span><br><span class="line">R4(config-router)#neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">R3(config-if)#ip add 100.0.30.3 255.255.255.0</span><br><span class="line">R3(config)#router bgp 345</span><br><span class="line">R3(config-router)#neighbor 5.5.5.5 remote-as 345</span><br><span class="line">R3(config-router)#neighbor 5.5.5.5 next-hop-self</span><br><span class="line">R3(config-router)#network 100.0.30.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这时R5会从第一条规则开始比较，Weight值相等都为默认的0，Local-Preference相等都为默认的100，都不是起源于本地的路由因为nexthop不为0.0.0.0，AS_PATH长度相同，Origin Code相同都为i，MED相同都为0，都是IBGP邻居发来的路由，貌似优选到NextHOP最近的这条能逼出来，因为一个感觉上路由一个从R3直接发过来，另一个经由R4反射过来，实际上是这样吗？来看R5的路由：</p>
<p><img src="/2020/10/11/14-BGP/1611046578419-70901f57-e681-42b8-bdb7-c35bd646eb4f.jpeg" alt="img"></p>
<p>为什么两条路由的下一跳都是3.3.3.3呢？</p>
<p>先看R3发过来这条。因为R3和R5是ibgp邻居关系，配置了next-hop-self，如果不配置的话下一跳是10.1.13.1，R5上没有这个地址，下一跳不可达没有资格选为最优，必须配置next-hop-self。从R3发过来的这条BGP路由的IGP的metric为21。</p>
<p>然后看R4反射过来的这条。由于R4是路由反射器，在反射的时候不改变下一跳，R3和R4使用loopback建立邻居，所以下一跳也是3.3.3.3。</p>
<p>两条路由Next hop相同，所以相对应的IGP的Metric也相同。这条依旧比不出来，真正发挥作用的是后面的‘如果多条路径始发路由器ID或路由器ID相同，那么优选Cluster-Iist最短的路径’。</p>
<h3 id="BGP负载均衡"><a href="#BGP负载均衡" class="headerlink" title="BGP负载均衡"></a>BGP负载均衡</h3><h4 id="基本概念-17"><a href="#基本概念-17" class="headerlink" title="基本概念"></a>基本概念</h4><p>当前面的8条选路原则都无法优选出最优路由时，并且在BGP进程下面配置了负载均衡的命令：‘Maximum-path【ibgp】n’（n的取值范围为2-6，如果不关联ibgp关键字，则只会对External路由执行等价负载均衡，也就是只对EBGP路由负载均衡。如果要对internal路由做负载均衡，则需关联ibgp关键字。）那么将执行等价负载均衡，也就是将这些等价的路径都放入IP路由表使用，但是要注意，虽然这些路径在本地都用了，但最终<strong>只有一条</strong>BGP路径是BEST最优的。</p>
<p>具备等价负载均衡条件的候选路径需满足如下条件：</p>
<ul>
<li>必须有相同的路径属性，如Weight、LP、AS_PATH（不仅是长度，整个AS_PATH包括所经过的AS号都要相同）、Origin Code、MED及IGP的Distance值；</li>
<li>每一条路径的下一跳都不相同。</li>
</ul>
<p><strong>如果路由器没有配置maximum-paths，那么将进行到下一条选路原则进行比较。</strong></p>
<h4 id="IBGP负载均衡实验"><a href="#IBGP负载均衡实验" class="headerlink" title="IBGP负载均衡实验"></a>IBGP负载均衡实验</h4><p>将之前的拓扑进行一部分更改来看负载均衡。</p>
<p><img src="/2020/10/11/14-BGP/1611132578176-b2e997a2-6e11-4cf8-8fc5-5fd4f228135a.jpeg" alt="img"></p>
<p>配置等价负载均衡之前，R4关于100.0.1.0/24的路由如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp 100.0.1.0/24</span><br><span class="line">BGP routing table entry for 100.0.1.0/24, version 6</span><br><span class="line">Paths: (2 available, best #2, table default)</span><br><span class="line">Flag: 0x100</span><br><span class="line">  Not advertised to any peer</span><br><span class="line">  Refresh Epoch 1</span><br><span class="line">  12</span><br><span class="line">    5.5.5.5 (metric 11) from 5.5.5.5 (5.5.5.5)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal</span><br><span class="line">      rx pathid: 0, tx pathid: 0</span><br><span class="line">  Refresh Epoch 1</span><br><span class="line">  12</span><br><span class="line">    3.3.3.3 (metric 11) from 3.3.3.3 (3.3.3.3)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal, best</span><br><span class="line">      rx pathid: 0, tx pathid: 0x0</span><br></pre></td></tr></table></figure>

<p>可以看到R4从R3和R5分别收到一条去往该网段的路由，这两条路由具有相同的路径属性，Weight值为0、LP为100、AS_PATH都是AS12长度为1、Origin Code为i、MED为0，到达下一跳IGP路由的Distance值也相同，所以此时可以配置等价负载均衡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#maximum-paths ibgp 2</span><br></pre></td></tr></table></figure>

<p>这里为什么要配置成‘maximum-paths ibgp 2’呢？因为R4这两条路由都是由IBGP邻居宣告而来，如果不配置关键字‘ibgp’的话，只会对EBGP路由生效。配置过后效果如下：</p>
<p><img src="/2020/10/11/14-BGP/1611133346539-25bbfd6f-aa0b-4405-a986-70e6b646a5a9.jpeg" alt="img"></p>
<p>从BGP表中也能看出来，虽然是等价负载均衡，但只有一条路由有Best的标志，也就是说R4只会将这条Best的路由更新给邻居，而不会讲两条负载均衡的路由同时告诉邻居。</p>
<p><img src="/2020/10/11/14-BGP/1611133926460-3a2aaaa0-6797-42b0-a898-5c805faa108a.jpeg" alt="img"></p>
<p>查看100.0.1.0这条路由具体信息可知，这两条路由之间的流量比是1:1。</p>
<h4 id="EBGP等价负载均衡"><a href="#EBGP等价负载均衡" class="headerlink" title="EBGP等价负载均衡"></a>EBGP等价负载均衡</h4><p><img src="/2020/10/11/14-BGP/1611134102094-4d3f218d-6003-4491-803f-613830363da1.jpeg" alt="img"></p>
<h3 id="优选最老的EBGP邻居传来的路由"><a href="#优选最老的EBGP邻居传来的路由" class="headerlink" title="优选最老的EBGP邻居传来的路由"></a>优选最老的EBGP邻居传来的路由</h3><p>这条选路规则主要针对EBGP路由起效，但现在基本不用这条来操控路由，因为不确定性太大。最老的EBGP邻居意味着可能是最稳定的BGP邻居，所以在这里做了优选。如果配置了‘bgp bestpath compare-routerid’命令后，将跳过该规则，如果多条路径具有相同的router ID也会跳过本规则，因为这意味着这些路由都是由同一台路由器发过来的。下图中的‘Up/Down’部分显示的就是BGP邻居建立的具体时间。</p>
<p><img src="/2020/10/11/14-BGP/1611198596764-ceebc662-8fd2-4c16-aab5-31a5b27e28fe.jpeg" alt="img"></p>
<h3 id="优选RID最小的BGP邻居的路由"><a href="#优选RID最小的BGP邻居的路由" class="headerlink" title="优选RID最小的BGP邻居的路由"></a>优选RID最小的BGP邻居的路由</h3><h4 id="基本概念-18"><a href="#基本概念-18" class="headerlink" title="基本概念"></a>基本概念</h4><p>RID是路由器上的最大IP地址，一般配置成环回地址，也可以通过bgp router-id命令手工设置。如果一条路径包含RR属性，路由产生者ID（Originator）将在最优路径选择过程中代替RID。</p>
<h4 id="实验验证-7"><a href="#实验验证-7" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1611369990352-05cb9392-9d1a-44ad-be40-6b4b365a2e64.jpeg" alt="img"></p>
<p>R4从R3和R5分别获得一条去往100.0.1.0/24的路径：</p>
<p><img src="/2020/10/11/14-BGP/1611370199871-a7d50475-75ee-4218-a7a2-73da8d102526.jpeg" alt="img"></p>
<p>从输出结果可以看到，R4优选的R3发来的路由，用BGP选路规则依次比较两条路由。Weight值两者相同都为默认的0，Local-Preference两者相同都为默认的100，两条路由都不是起源于本路由器NEXTHOP都不为0.0.0.0，AS_PATH长度相同，Origin Code相同都为i，MED值相同都为0，都由IBGP邻居宣告而来，到Next hop距离相同，没有负载均衡，不是EBGP路由所以不会优选最老的EBGP邻居发过来的路由，Router ID不相同，R3的Router  ID为3.3.3.3，小于R5的Router ID5.5.5.5，优选R3的路由，比较完毕。</p>
<h4 id="补充实验"><a href="#补充实验" class="headerlink" title="补充实验"></a>补充实验</h4><p><img src="/2020/10/11/14-BGP/1611303117372-3751e049-c478-47c8-bd96-bc37cc31e322.png" alt="img"></p>
<p>R1\R2\R3三者为IBGP邻居，都在AS123中，互相之间使用loopback接口建立邻居，R2为RR，将R1上宣告的路由11.11.11.0/24反射给R3，此时R3分别从R1和R2分别各获得一条去往11.11.11.0/24的路由，此时分析哪条路由为最优。</p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 11.11.11.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 2.2.2.2 remote-as 123</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 123</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 123</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 1.1.1.1 route-reflector-client</span><br><span class="line"> neighbor 3.3.3.3 remote-as 123</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.3 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> neighbor 1.1.1.1 remote-as 123</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 1.1.1.1 next-hop-self</span><br><span class="line"> neighbor 2.2.2.2 remote-as 123</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 2.2.2.2 next-hop-self</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 这时在R3上查看关于11.11.11.0的路由：</span><br><span class="line"> </span><br><span class="line"> R3#show ip bgp 11.11.11.0</span><br><span class="line">BGP routing table entry for 11.11.11.0/24, version 2</span><br><span class="line">Paths: (2 available, best #2, table default)</span><br><span class="line">  Not advertised to any peer</span><br><span class="line">  Refresh Epoch 3</span><br><span class="line">  Local</span><br><span class="line">    1.1.1.1 (metric 11) from 2.2.2.2 (2.2.2.2)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal</span><br><span class="line">      Originator: 1.1.1.1, Cluster list: 2.2.2.2</span><br><span class="line">      rx pathid: 0, tx pathid: 0</span><br><span class="line">  Refresh Epoch 3</span><br><span class="line">  Local</span><br><span class="line">    1.1.1.1 (metric 11) from 1.1.1.1 (1.1.1.1)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal, best</span><br><span class="line">      rx pathid: 0, tx pathid: 0x0</span><br></pre></td></tr></table></figure>

<p>下面使用规则对两条路由进行分析，Weight值相同都为默认的0，Local-Preference相同都为默认的100，都不起源于本地，AS_PATH长度相同，BGP的Origin Code相同都为i，MED相同（metric）都是0，两者都是IBGP邻居发来的所以没法优选EBGP邻居，到NEXTHOP最近的会被优选两者的NEXTHOP都是1.1.1.1所以相同，没有配置负载均衡，由于是IBGP邻居不能用建立邻居时间规则来优选路由，看起来优选Router ID最小的这条规则发挥了作用，因为一个router ID是1.1.1.1，一个router ID是2.2.2.2，但实际上并不是这样。<strong>当使用了RR的时候，Originator值将代替Router ID的值</strong>，最终两条路由的下一跳都是1.1.1.1。用show ip bgp 命令看得更清楚：</p>
<p><img src="/2020/10/11/14-BGP/1611305179960-d189e78e-af1b-41d9-b5f0-b10d29099634.png" alt="img"></p>
<h3 id="优选Cluster-List最短路由"><a href="#优选Cluster-List最短路由" class="headerlink" title="优选Cluster_List最短路由"></a>优选Cluster_List最短路由</h3><h4 id="基本概念-19"><a href="#基本概念-19" class="headerlink" title="基本概念"></a>基本概念</h4><p>Cluster_List是路由反射器使用的可选非传递属性用来防止环路，在反射路由的时候才会创建或更新Cluster_list，这个值是路由传递时经过的路由反射簇的ID，长度32bit。</p>
<p><img src="/2020/10/11/14-BGP/1611373905314-2403235d-f762-4c59-8b5f-f23e2cb373a8.png" alt="img"></p>
<h4 id="实验验证-8"><a href="#实验验证-8" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1611374333641-967b3997-5898-4581-bc11-1da616a1551c.jpeg" alt="img"></p>
<p>R1\R2\R3\R4\R5两两为ibgp邻居，R1上宣告11.11.11.0/24的路由进BGP，在R5上会从R2和R4分别收到一条去往该目的地的路由，R2\R3\R4都为RR，观察R5上如何优选去往11.11.11.0/24的路由。</p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 2.2.2.2 remote-as 64512</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 64512</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.25.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 64512</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 64512</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 64512</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 64512</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 route-reflector-client</span><br><span class="line"> neighbor 4.4.4.4 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 64512</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 route-reflector-client</span><br><span class="line"> neighbor 3.3.3.3 next-hop-self</span><br><span class="line"> neighbor 5.5.5.5 remote-as 64512</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.25.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 64512</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 64512</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R5上关于11.11.11.0路由：</p>
<p><img src="/2020/10/11/14-BGP/1611374815793-a8d525e9-b445-4b20-bbcd-4cea66d798ff.jpeg" alt="img"></p>
<p>用BGP选路规则对路由进行比较。Weight值相同都是默认的0，Local-Preference值相同都是默认的100，都不是起源于本地的路由，AS_PATH长度相同都是本AS内的路由，Origin Code都为i，MED值相同都为0，都是IBGP邻居传过来的路由，到NEXTHOP的距离相同，没有配置负载均衡，由于是IBGP路由所以不比较是否是最老的EBGP邻居，由于都有RR所以Router ID都是最初被反射的R1的Router ID都是1.1.1.1，Cluster list长度不同，从R2过来这条长度为1从R4过来这条长度为2，所以优选Cluster list长度短的R2这条路由。</p>
<h3 id="优选邻居IP地址小的路由"><a href="#优选邻居IP地址小的路由" class="headerlink" title="优选邻居IP地址小的路由"></a>优选邻居IP地址小的路由</h3><p>如果前面12条规则都无法优选出路由，那么只能比较邻居的IP地址，就是配置BGP命令时‘neighbor X.X.X.X  remoteYY’中的这个X.X.X.X的地址。</p>
<h2 id="非等价负载均衡"><a href="#非等价负载均衡" class="headerlink" title="非等价负载均衡"></a>非等价负载均衡</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><img src="/2020/10/11/14-BGP/1611540954939-91c95c80-5172-4624-8648-71db1a0e9d86.jpeg" alt="img"></p>
<p>AS123内的三台路由器运行OSPF，通告各自互联接口以及Loopback  0接口，loopback0接口地址为X.X.X.X/32，X为设备编号，IBGP邻居关系基于loopback接口建立，R1在BGP中通告11网段路由，R4在BGP中通告44网段路由。</p>
<h3 id="eBGP非等价负载均衡"><a href="#eBGP非等价负载均衡" class="headerlink" title="eBGP非等价负载均衡"></a>eBGP非等价负载均衡</h3><h4 id="R4如何优选路由"><a href="#R4如何优选路由" class="headerlink" title="R4如何优选路由"></a>R4如何优选路由</h4><p>由于R4从R2及R3都收到了关于11.11.11.11的路由，所以接下来比结合之前的路由决策看看为什么优选：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *   11.11.11.11/32   10.1.34.3                              0 123 i</span><br><span class="line"> *&gt;                   10.1.24.2                              0 123 i</span><br><span class="line"> *&gt;  44.44.44.0/24    0.0.0.0                  0         32768 i</span><br></pre></td></tr></table></figure>

<p>Weight值相同都为0因为两条路由都不起源于本地而不起源于本地路由的Weight值默认为0，Local-Preference为默认的100由于从eBGP邻居发来所以不带这个属性在R4上为默认值100，两条路由都不起源于本地，AS_PATH长度相同都为1，Origin Code相同都为i，MED相同都为0，性质相同都为eBGP邻居发来的路由，NEXTHOP的距离相同，没有配置负载均衡，由于不是EBGP路由所以‘优选最老EBGP邻居’这条不适用，优选Router ID小的由于R2的Router ID2.2.2.2小于R3的Router ID3.3.3.3，所以优选下一跳是10.1.24.2这边。</p>
<h4 id="配置非等价负载均衡"><a href="#配置非等价负载均衡" class="headerlink" title="配置非等价负载均衡"></a>配置非等价负载均衡</h4><p>由于R3方向带宽比较小，所以即使R4需要双出口也不能做负载均衡，因为两边带宽差别比较大，所以这种情况下用非等价负载均衡更为合适。</p>
<p>R4配置：</p>
<p><img src="/2020/10/11/14-BGP/1611567459595-32c11f3e-1e1b-4641-81f0-46a879958943.jpeg" alt="img"></p>
<p>这里使用的是BGP的link bandwidth特性，借助的是BGP的一个扩展community来实现的，配置该属性以后，R4将会根据带宽来考量R2\R4这两个EBGP邻居，当从R2\R4收到路由时，会给收到的路由黏贴上一个扩展的community属性，这个community属性和接口的带宽是有关联的，会为BGP的非等价负载均衡提供进一步的信息。<strong>dmzlink-bw这条命令只能去指向一个EBGP邻居，不能配置给ibgp邻居。</strong></p>
<p><img src="/2020/10/11/14-BGP/1611567771897-cab47ba9-88b1-43da-8913-9aeb34e42eb7.jpeg" alt="img"></p>
<p>上面标红的的DMZ-LINK BW ……就是这个community属性，这个值是接口带宽除以8计算得来。</p>
<p><img src="/2020/10/11/14-BGP/1611567884314-5bbba951-093f-4d3a-bbc0-4e418c058141.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611567928912-758da3dc-6002-4892-aed0-ed197af5654f.jpeg" alt="img"></p>
<p>用show ip route 可以看到，路由表中已经负载均衡，进一步看11.11.11.11这条路由会发现，两者形成了非等价负载均衡，比例是60:1，但注意由于CEF的存在，CEF的默认的负载均衡是基于目标地址而不是基于每个数据包的，实际上市基于源、目的地址对的负载均衡，也就是到一个目的地址只走固定的线路：</p>
<p><img src="/2020/10/11/14-BGP/1611569614571-7a1cfd5d-45a8-436a-9c4a-1eb81971c1db.jpeg" alt="img"></p>
<p>所以要在R4的E0/0和S1/0两个接口上配置‘ip load-sharing per-packet’命令，配置后去往目标地址的数据包才会基于比例分路线走。</p>
<h3 id="iBGP的非等价负载均衡"><a href="#iBGP的非等价负载均衡" class="headerlink" title="iBGP的非等价负载均衡"></a>iBGP的非等价负载均衡</h3><p><img src="/2020/10/11/14-BGP/1611570260474-c499283e-767d-4b2f-9378-eb882404da05.jpeg" alt="img"></p>
<p>R1从R2和R3都能获取到44.44.44.44/32这条路由，但由于之前提到过的，R4两条链路带宽差别比较大的情况，R1去往R4也不适合使用等价负载均衡，而更适合使用非等价负载均衡才能让带宽有效利用。所以在R2和R3上进行配置，使得R4根据带宽黏贴在路由上的扩展community属性，能传给R1，执行非等价负载均衡。</p>
<p><img src="/2020/10/11/14-BGP/1611570592531-eb0aadba-a184-42bb-bdf7-ee1854effd6f.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611570610429-87a46ad8-a99f-4d2f-bfb9-75e01cca9208.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611570628095-bf98b7f3-6d3c-49d3-9b58-38ef634f49b8.jpeg" alt="img"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过利用BGP的Link Bandwidth特性，能够在AS边界路由器外部链路带宽不等价的情况下，实现BGP路由的非等价负载均衡。改特性通过在BGP进程的IPV4或VPNV4地址簇中使用‘bgp dmzlink-bw’命令激活。这个特性搭配BGP multipath特性，即可实现非等价负载均衡。</p>
<p>BGP Link Bandwidth 特性用于在扩展community属性中通告一条AS出口链路的带宽。</p>
<p>这个特性配置在一台AS边界路由器上，指向其EBGP邻居，那么此时该特性所描述的就是该路由器与其EBGP邻居之间的链路带宽。而且该链路带宽信息（使用扩展community描述）除了AS边界路由器自己使用（用于本地的非等价负载均衡），还可以像AS内的ibgp邻居传递，使得AS内部其他路由器也能使用该community做非等价负载均衡，当然前提是得配置send-community extended命令才行。</p>
<p>激活Link Bandwidth的预备条件：</p>
<ul>
<li><p>激活maximum-paths特性；</p>
</li>
<li><p>当要向ibgp邻居通告Link Bandwidth特性时，需send-community extended；</p>
</li>
<li><p>CEF或dCEF必须在所有彩玉该特性的路由器上打开。</p>
</li>
</ul>
<p>Link Bandwidth特性的限制：</p>
<ul>
<li><p>该特性只能配置在BGP晋城的IPV4或VPNV4地址簇下；</p>
</li>
<li><p>BGP只能够在Link Bandwidthcommunity中通告与eBGP邻居直连的链路（接口）带宽；</p>
</li>
<li><p>在IPV4及VPNV4地址簇中，ibgp及eBGP负载均衡都是支持的，但IBGP\EBGP负载均衡却只能在VPNV4地址簇中才能够支持，也就是ibgp与eBGP的负载均衡。</p>
</li>
</ul>
<h1 id="BGP策略"><a href="#BGP策略" class="headerlink" title="BGP策略"></a>BGP策略</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><p><img src="/2020/10/11/14-BGP/1612163771020-2e2171de-d1e4-46fe-9289-683ad952a202.jpeg" alt="img"></p>
<h3 id="原子字符"><a href="#原子字符" class="headerlink" title="原子字符"></a>原子字符</h3><h4 id="基本概念-20"><a href="#基本概念-20" class="headerlink" title="基本概念"></a>基本概念</h4><table>
<thead>
<tr>
<th>.</th>
<th>匹配任何单个的字符，包括空格，比如a、b、c、1、2、3都可以被.匹配到</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>一个字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>一个字符串的结束</td>
</tr>
<tr>
<td>_</td>
<td>下划线 任意的一个分隔符如^、$、空格、tab、逗号、{ 、}</td>
</tr>
<tr>
<td>|</td>
<td>管道符，表示逻辑或的关系</td>
</tr>
<tr>
<td>\</td>
<td>转义符，用来将紧跟其后的控制字符转变为普通字符</td>
</tr>
</tbody></table>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^$</th>
<th>匹配那些为空的字符串，因为起始字符和结束字符中间没有任何东西，用到AS_PATH控制列表中就是匹配那些AS_PATH为空的路由，也就是那些起源于本AS的路由，因为路由在发送给相邻AS时才会加入AS_PATH，所以起源于本AS的路由AS_PATH部分为空</th>
</tr>
</thead>
<tbody><tr>
<td>^51_</td>
<td>匹配那些以51开始后面有一个空格的字符串，比如51 66，51 100，51 888，用到AS_PATH控制列表中就是匹配那些和本AS相连最后经过AS51的路由，也就是那些从邻居AS51发来的路由</td>
</tr>
<tr>
<td>_51$</td>
<td>匹配那些以51结尾且前面有个空格的字符串，比如100 51,666 51，用到AS_PASH中就是那些起源于AS51路由</td>
</tr>
<tr>
<td><em>51</em></td>
<td>匹配那些51前后各有一个空格的字符串，比如100 51 200,666 51 888，用到AS_PATH中就是那些穿越过AS51的路由</td>
</tr>
<tr>
<td>^a.$</td>
<td>匹配一个以a开始，任意单一字符结束的字符串，如a0，a!，aa，ab等</td>
</tr>
<tr>
<td>^100_</td>
<td>匹配一个以100开始，后面跟一个分隔符的字符串，只限制了开始的字符，并没限制后边跟了多少。如100、100 200、100 300 400、100 200 500 600等，‘_’用来匹配AS号之间的空格。如果在匹配AS_PATH的时候，用^100_来匹配的话，表示匹配那些最后经过AS100的路由，也就是相邻AS号是100的路由。</td>
</tr>
<tr>
<td>^100$</td>
<td>匹配100，如果在匹配AS_PATH的时候，表示匹配只经过AS100的路由</td>
</tr>
<tr>
<td>100$|400$</td>
<td>匹配一个以100或400结束的字符串，前面有几个字符并没有规定，比如100、1400、300 400、131400、1100等都匹配这个正则表达式</td>
</tr>
<tr>
<td>^(65000)$</td>
<td>\是转义符，正则表达式会把\后面的当做常规字符而不是有特殊功能的字符去对待，该正则表达式仅仅匹配（65000），一般用于匹配联邦中的AS_PATH，联邦中的AS_PATH是用小括号括起来的</td>
</tr>
<tr>
<td>[123].[7-9]</td>
<td>[123]表示匹配123中的一个任意数字，可以是1,2或3。‘.’表示匹配任何单个字符或空格，[7-9]表示匹配7到9中的人一个数字。所以167,258,3 7,118等都符合正则表达式</td>
</tr>
<tr>
<td>100</td>
<td>由于并没配置开始和结束字符，只要字符串里有100的就可以被匹配上，比如1100，100666，abc100cba等</td>
</tr>
</tbody></table>
<h3 id="乘法字符"><a href="#乘法字符" class="headerlink" title="乘法字符"></a>乘法字符</h3><h4 id="基本概念-21"><a href="#基本概念-21" class="headerlink" title="基本概念"></a>基本概念</h4><p>一个乘法字符可以应用于一个单字符或多个字符，不能单独使用必须搭配常规字符使用，如果应用于多字符，需将字符串放入（）中。由于?和*两个字符都有出现0次的所以一定要谨慎使用，因为可能正则表达式会匹配到无穷多个结果，也就是所有都被匹配到，可能失去了使用正则表达式的意义。</p>
<table>
<thead>
<tr>
<th>*</th>
<th>匹配前面字符0次或多次出现，如果a*，表示匹配a、aaa、aaaa</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前面字符1次或多次出现</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面字符0次或1次出现</td>
</tr>
</tbody></table>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^(abc)?$</th>
<th>匹配abc出现0次或1次，也就是匹配abc或abc根本不出现，可能匹配到无穷多个结果，慎用</th>
</tr>
</thead>
<tbody><tr>
<td>^abc?$</td>
<td>匹配ab在前面，后面的c出现1次或0次，也就是ab或abc</td>
</tr>
<tr>
<td>^abc*d$</td>
<td>匹配abd、abcd、abccd、abcccd、abccccd等，只要c在abd中间出现0次或多次都可以</td>
</tr>
<tr>
<td>^abc+d$</td>
<td>匹配abcd、abccd、abcccd等，只要c在abd中间出现1次或多次都可以</td>
</tr>
<tr>
<td>^abc?d$</td>
<td>匹配abd、abcd</td>
</tr>
</tbody></table>
<h3 id="范围字符"><a href="#范围字符" class="headerlink" title="范围字符"></a>范围字符</h3><h4 id="基本概念-22"><a href="#基本概念-22" class="headerlink" title="基本概念"></a>基本概念</h4><table>
<thead>
<tr>
<th>[]</th>
<th>表示一个范围，只匹配包含在范围内的字符之一。可以在一个范围的开始使用^来排除范围内所有字符，也可以使用下划线 _ 来指定一个区间</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^[abcd]$</th>
<th>匹配只要出现了a、b、c、d的内容，[]表示包含在范围内字符之一，所以a\b\c\d四者之一都匹配这条</th>
</tr>
</thead>
<tbody><tr>
<td>[a-c 1-2]</td>
<td>匹配a、a1、b1、xyz2、nc2等内容，之所以能匹配很多结果是因为正则表达式没有写开始和结束符号，意味着只要任意一部分符合正则表达式即可</td>
</tr>
<tr>
<td>[^act]$</td>
<td>[]中加入^符号表示排除范围内所有字符，[^act]就是排除所有包含a\c\t的，后面加上表示结束的$符号，整体连起来表示排除所有以a\c\t结尾的内容</td>
</tr>
</tbody></table>
<h3 id="使用as-path-access-list匹配路由"><a href="#使用as-path-access-list匹配路由" class="headerlink" title="使用as-path access-list匹配路由"></a>使用as-path access-list匹配路由</h3><h4 id="基本概念-23"><a href="#基本概念-23" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="/2020/10/11/14-BGP/1611717862269-6ce42bb3-ffb2-44cc-9a98-eee1d59e3e6d.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611736583906-c2894a12-29ed-4f39-8b38-ae40c856c363.jpeg" alt="img"></p>
<p>一条路由的AS_PATH如果经过了123、443、579这三个AS，那么在底层它的AS_PATH是‘123_443_579’的形式存在，正则表达式‘443’就能匹配这条路由。<strong>as-path access-list中也默认隐含拒绝所有，也就是deny any</strong>。</p>
<table>
<thead>
<tr>
<th>^$</th>
<th>^表示开始，$表示结束，开始连接着结束表示中间没有任何东西，在AS_PATH访问列表中则表示匹配不包含任何AS号的AS_PATH，也就是匹配本AS内的路由，因为始发于本AS的路由没有进过任何AS，AS_PATH部分为空，只有离开本AS的时候AS_PATH才会有内容</th>
</tr>
</thead>
<tbody><tr>
<td>.*</td>
<td>点代表任意字符，<em>表示出现0次或多次，也就是任意字符可以出现0次或多次，所以就是匹配所有，等同于any，由于AS_PATH access list末尾隐藏了deny any，所以如果不想所有都被deny掉，结尾可以跟一个permit .</em></td>
</tr>
<tr>
<td>^100$</td>
<td>匹配100这个AS_PATH</td>
</tr>
<tr>
<td>^100_</td>
<td>表示以100开始的字符串，也就是100 200、100 555 666等等都匹配，在AS_PATH访问控制列表中则表示匹配那些从AS100直接发到本AS的路由，因为100在AS_PATH中最靠左说明AS100和本AS直接连接</td>
</tr>
<tr>
<td>_100$</td>
<td>匹配以100结束的AS_PATH，也就是匹配那些起源于AS100的路由，因为在AS_PATH中最靠右的AS号表示最先经历的AS，也就是起源AS</td>
</tr>
<tr>
<td>100$</td>
<td>匹配那些包含100这个数字在内结束的AS_PATH，比如1100、666100，这个和上面的区别在于是否有前面的‘_’，这个符号代表空格，有没有空格差别很大</td>
</tr>
<tr>
<td>^10[012349]$</td>
<td>匹配100、101、102、103、104、109这几个AS_PATH</td>
</tr>
<tr>
<td>^10[^0-6]$</td>
<td>匹配除了100-106以外的AS_PATH</td>
</tr>
<tr>
<td>^10.</td>
<td>匹配100-109以及10这些AS_PATH，因为‘.’也包含空格</td>
</tr>
<tr>
<td>^(100|200)$</td>
<td>匹配包含100或200的AS_PATH</td>
</tr>
<tr>
<td>12(_34)?_56</td>
<td>匹配12 56及12 34 56这两个AS_PATH</td>
</tr>
<tr>
<td>^[0-9]+$</td>
<td>‘[0-9]’表示任何在0-9之间的数字都可以被匹配，‘*’表示重复出现1次或多次，0-9重复出现1次或多次则表示任何数字，也就是匹配任何一个数字，包括但不限于1,123,1235,12363434等，‘^’表示开始，‘$’表示结束，当把这些都组合到一起时候表示，匹配单一的一个数字，这个数字可以是任何数，放到AS_PATH访问控制列表中表示任何直接连接到本AS的AS_PATH中只有单个AS的路由，换句话说就是那些起源自直连AS的路由，因为AS_PATH中只有一个数字的话，表示路由只经过一个AS后就传到了本AS且和本AS直连</td>
</tr>
<tr>
<td>^([0-9]+)_51$</td>
<td>‘_51$’表示路由起源AS为51，‘([0-9]+)’表示0-9可以出现1次或多次，也就是任意的和本AS相连的AS号都能匹配，‘_’表示空格，连起来表示匹配起自AS51，AS51在与本AS直连的AS后面，大概就是‘本AS-任意AS-AS51’这样连接的</td>
</tr>
<tr>
<td>^51_([0-9]+)$</td>
<td>‘^51_’表示路由经过的最后一个AS是AS51，‘([0-9]+)’表示任意多个任意的AS号，也就是路由AS_PATH最后的经过的一个AS为51，倒数第二个AS可以是任意的，所以在AS_PATH访问控制列表中是匹配那些和AS51直连的AS发来的路由，而AS51又和本AS直连</td>
</tr>
</tbody></table>
<h4 id="配置示例1"><a href="#配置示例1" class="headerlink" title="配置示例1"></a>配置示例1</h4><p><img src="/2020/10/11/14-BGP/1611919345029-5c7fa9cc-87ca-4240-ac54-8c1b4d073999.png" alt="img"></p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback10</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback22</span><br><span class="line"> ip address 22.22.22.22 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip prefix-list 10 seq 5 permit 172.16.10.0/24</span><br><span class="line">ip prefix-list 10 seq 10 permit 172.16.11.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list 10</span><br><span class="line"> set as-path prepend 600</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 22.22.22.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.23.3 remote-as 300</span><br><span class="line"> neighbor 10.1.23.3 route-map AS_PATH out</span><br></pre></td></tr></table></figure>

<p>在R2上一共配置了3个loopback接口，loopback10和11用来模拟从AS600发来的路由，loopback 12用来代表本AS起源的路由，来验证过滤效果。配置ip 前缀列表匹配需要增加AS_PATH的路由，也就是172.16.10.0/24和172.16.11.0/24，创建route-map来对匹配的两条路由的AS_PATH进行操控，用prepend命令为AS_PATH重增加600这个AS来模拟从AS600发来的路由，此时R3上路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   22.22.22.0/24    10.1.23.2                0             0 200 i</span><br><span class="line"> *&gt;   172.16.10.0/24   10.1.23.2                0             0 200 600 i</span><br><span class="line"> *&gt;   172.16.11.0/24   10.1.23.2                0             0 200 600 i</span><br></pre></td></tr></table></figure>

<p>现在要在R3上进行配置，目标是过滤掉所有从AS600发过来的路由，总体思路是，先用AS_PATH访问控制列表匹配AS_PATH中最近一个是600的那些路由，然后用rfilter-list从in方向上过滤掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip as-path access-list 10 deny _600$</span><br><span class="line">ip as-path access-list 10 permit .*</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> neighbor 10.1.23.2 filter-list 10 in</span><br></pre></td></tr></table></figure>

<p>‘_600&amp;’这个正则表达式匹配的是与本AS相连，起源于AS600的路由，前面加上deny就是将从AS600发来的路由过滤掉，后面的‘permit .*’就是放行所有其他路由，这个as_path访问控制列表就是讲从AS600发来的路由过滤掉，并放行其他路由。如果写完正则表达式以后不知道匹配的路由是否是自己想要的，可以用命令‘show ip bgp regexp xxxx’来验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp regexp _600$</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.10.0/24   10.1.23.2                0             0 200 600 i</span><br><span class="line"> *&gt;   172.16.11.0/24   10.1.23.2                0             0 200 600 i</span><br></pre></td></tr></table></figure>

<p>从上面验证的结果可以看出，该正则表达式的结果就是我们想要的，然后在对邻居R2的in方向上用filter-list应用AS_PATH访问控制列表，此时再看R3的路由表，已经达到了我们想要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   22.22.22.0/24    10.1.23.2                0             0 200 i</span><br></pre></td></tr></table></figure>

<h4 id="配置示例2"><a href="#配置示例2" class="headerlink" title="配置示例2"></a>配置示例2</h4><p><img src="/2020/10/11/14-BGP/1612154577098-ccfd8578-2d63-4940-a11c-dbb051e87991.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip as-path access-list 1 permit _600$</span><br><span class="line">route-map NOAS600 permit 10</span><br><span class="line"> match as-path 1</span><br><span class="line"> set community no-advertise</span><br><span class="line">!</span><br><span class="line">route-map NOAS600 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> neighbor 10.1.23.2 route-map NOAS600 in</span><br></pre></td></tr></table></figure>

<h4 id="配置示例3"><a href="#配置示例3" class="headerlink" title="配置示例3"></a>配置示例3</h4><p><img src="/2020/10/11/14-BGP/1612064079452-e2e752bc-558f-4f73-ab3f-3850b5d1377f.png" alt="img"></p>
<p>如上图所示，AS100和AS203,302,401,500为邻居，这时AS100想匹配那些起源于直连的AS（比如AS203,302,401,500）的路由以及那些起源于直连本AS的邻居AS（比如AS202,301,400）的路由。</p>
<p>用正则表达式匹配这些路由最简单直接的办法就是写出来那些需要匹配的AS号然后进行匹配，我们要匹配的AS有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">203</span><br><span class="line">203 202</span><br><span class="line">302</span><br><span class="line">302 301</span><br><span class="line">401</span><br><span class="line">401 400</span><br><span class="line">500</span><br></pre></td></tr></table></figure>

<p>在现有拓扑连接情况下要匹配这些AS只需要将他们都写入正则表达式即可，也就是写7行匹配语句，每一行如上所示，这样就能匹配所有需要的AS，但如果以后拓扑发生变化，不只有这7个AS的话正则表达式就无法匹配所有需要匹配的AS了，比如如果AS100新加了一个邻居，AS666，那么之前的正则表达式就匹配不到这个AS666了，而起源于这个AS的路由也是需要被匹配到的，因为它也是AS100的直连AS。所以考虑到拓扑的扩展可能性，必须匹配到所有可能的路由就不能这么写。</p>
<ol>
<li><p>我们知道，正则表达式得有开始和终结符号，所以‘^’和‘$’是肯定要有的；</p>
</li>
<li><p>由于匹配的目标有两个，一个是起源于直连AS的路由，另一个是起源于直连AS的邻居的路由。起源于直连AS的路由的AS_PATH只有一个AS号，暂时写为‘^X$’,X表示任意的AS号；起源于直连AS的邻居的路由有两个AS号，暂时写为‘^X  X$’；</p>
</li>
<li><p>接下来要确定‘X’这个任意的AS号如何用正则表达式匹配，因为X表示一个AS号，而AS号中肯定没有数字、括号、逗号这种特殊字符，所以它肯定是一个数字，又因为我们不知道这个数字具体是什么，它可能有一个或多个单独的数字组成，比如可能是5，10,123或1010，它代表了0-9之间所有可能的数字，这些数字可能出现1次或多次，所以用‘[0-9]+’来表示这个X，因此正则表达式可以写成：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+$</span><br><span class="line">^[0-9]+ [0-9]+$</span><br></pre></td></tr></table></figure>

<p>但这么写是不是就是最佳的表示方式呢？并不是，第一行和第二行的区别在于，第二行多了一个‘[0-9]+’，而第一行没有这个‘[0-9]+’，换句话说，‘[0-9]+’存在了0次或1次，而‘?’正好能表示字符出现 0次或1次，因此可以将这个正则表达式优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+ ([0-9]+)?$</span><br></pre></td></tr></table></figure>

<h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>在配置完正则表达式以后可以使用命令‘show ip bgp regexp’来检查所匹配的路由是否和想要的相一致，也可以用<a href="https://regexr.com/">该网页</a>检查，不过是英文版的，但有详细的正则表达式说明。</p>
<h3 id="在cisco-IOS中的应用"><a href="#在cisco-IOS中的应用" class="headerlink" title="在cisco IOS中的应用"></a>在cisco IOS中的应用</h3><p>show 和more的输出中，可使用管道符‘|’搭配正则表达式来过滤输出结果，输入‘|’的方式为‘shift+\’，‘\’在回车键的上边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show run | ?</span><br><span class="line">  append    Append redirected output to URL (URLs supporting append operation</span><br><span class="line">            only)</span><br><span class="line">  begin     Begin with the line that matches</span><br><span class="line">  count     Count number of lines which match regexp</span><br><span class="line">  exclude   Exclude lines that match</span><br><span class="line">  format    Format the output using the specified spec file</span><br><span class="line">  include   Include lines that match</span><br><span class="line">  redirect  Redirect output to URL</span><br><span class="line">  section   Filter a section of output</span><br><span class="line">  tee       Copy output to URL</span><br></pre></td></tr></table></figure>

<p>管道符后面可以接多种的限制词语，比如begin XXX就是以XXX开始的；include XXX就是显示包含XXX在内的shou run语句；section XXX就是包含XXX的章节比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show run | section router</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 10.1.13.1 remote-as 100</span><br><span class="line"> neighbor 10.1.23.2 remote-as 200</span><br><span class="line"> neighbor 10.1.23.2 route-map NOAS600 in</span><br></pre></td></tr></table></figure>

<h2 id="BGP过滤器"><a href="#BGP过滤器" class="headerlink" title="BGP过滤器"></a>BGP过滤器</h2><h3 id="Prefix-list"><a href="#Prefix-list" class="headerlink" title="Prefix-list"></a>Prefix-list</h3><p><img src="/2020/10/11/14-BGP/1612166607378-7789d9ae-f060-4c65-bfc3-743c1aada82b.png" alt="img"></p>
<p>在R2上用prefix-list只过滤掉12.12.12.0/24的路由，放行其他路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 deny 12.12.12.0/24</span><br><span class="line">ip prefix-list 1 seq 10 permit 0.0.0.0/0 le 32</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> neighbor 10.1.23.3 prefix-list 1 out</span><br></pre></td></tr></table></figure>

<p>0.0.0.0/0 le 32等同于any，当然在R1的out方向进行过滤也没问题。</p>
<h3 id="Distribute-list"><a href="#Distribute-list" class="headerlink" title="Distribute-list"></a>Distribute-list</h3><p><img src="/2020/10/11/14-BGP/1612169303385-7277153a-d0ea-4450-a0ab-c923d5c3d159.png" alt="img"></p>
<p>拓扑依旧，在R2上用distribute-list只过滤掉12.12.12.0/24的路由，放行其他路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置方式1：</span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">access-list 1 deny   12.12.12.0</span><br><span class="line">access-list 1 permit any</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> neighbor 10.1.23.3 distribute-list 1 out</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">配置方式2：</span><br><span class="line">ip prefix-list 12 deny 12.12.12.0/24</span><br><span class="line">ip prefix-list 12 permit 0.0.0.0/0 le 32</span><br><span class="line">router bgp 12</span><br><span class="line"> distribute-list prefix 12 out</span><br></pre></td></tr></table></figure>

<h3 id="Route-map"><a href="#Route-map" class="headerlink" title="Route-map"></a>Route-map</h3><h4 id="关联network命令"><a href="#关联network命令" class="headerlink" title="关联network命令"></a>关联network命令</h4><p>​                                               </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 11 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 12 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map RP2 permit 10</span><br><span class="line"> match ip address prefix-list 12</span><br><span class="line"> set community 100:12</span><br><span class="line">!</span><br><span class="line">route-map RP1 permit 10</span><br><span class="line"> match ip address prefix-list 11</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0 route-map RP1</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0 route-map RP2</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community</span><br><span class="line">ip bgp-community new-format</span><br></pre></td></tr></table></figure>

<p>分别用前缀列表11以及12抓取11.11.11.0/24，12.12.12.0.0/24，然后分别写两个route-map，对两条路由赋予community属性，然后将route-map挂在network命令后边，在宣告的时候直接打上community，也可以对邻居的out方向使用route-map。然后对邻居R2配置send community命令，使得community能够发送给R2，而后配置bgp-community new-format命令将显示的格式调整到RFC默认格式。</p>
<p><img src="/2020/10/11/14-BGP/1612237793106-0bfcedfc-e18b-4ad9-bfad-5fe96657c875.png" alt="img"></p>
<p>但必须注意的是，在network后面使用route-map影响的是所有的BGP邻居，如果除了R2以外还有其他邻居，比如R3，则这个community也会发给R3。如果只想对特定的邻居发送community，最好将route-map挂在neighbor命令后。</p>
<h4 id="关联neighbor命令"><a href="#关联neighbor命令" class="headerlink" title="关联neighbor命令"></a>关联neighbor命令</h4><p><img src="/2020/10/11/14-BGP/1612251386842-b2b7f3d9-1841-4f8c-9a0e-1b25e8771768.png" alt="img"></p>
<p>拓扑和之前相等，此时在R1上进行配置，对R2传递路由时设定11.11.11.0/24的MED值为1000；12.12.12.0/24的MED值为2000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list 11 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 12 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 10</span><br><span class="line"> match ip address prefix-list 11</span><br><span class="line"> set metric 1000</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 20</span><br><span class="line"> match ip address prefix-list 12</span><br><span class="line"> set metric 2000</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 30</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 route-map MED1 out</span><br></pre></td></tr></table></figure>

<p>由于route-map最后有deny  any的隐藏项，所以最后还是加上了‘route-map MED1 permit 30’的语句，放行其他路由，以防以后宣告的其他路由被deny掉无法传递到R2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2上输出验证route-map中的MED（metric）是否配置成功</span><br><span class="line">R2#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;  11.11.11.0/24    10.1.12.1             1000             0 100 i</span><br><span class="line"> *&gt;  12.12.12.0/24    10.1.12.1             2000             0 100 i</span><br></pre></td></tr></table></figure>

<h4 id="关联重发布命令"><a href="#关联重发布命令" class="headerlink" title="关联重发布命令"></a>关联重发布命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 route-map RP</span><br><span class="line">redistribute eigrp 100 route-mmap RP</span><br></pre></td></tr></table></figure>

<h3 id="Unsuppress-map"><a href="#Unsuppress-map" class="headerlink" title="Unsuppress-map"></a>Unsuppress-map</h3><p><img src="/2020/10/11/14-BGP/1612253858243-063560f9-ba84-4e80-8663-d6cc03756d0b.png" alt="img"></p>
<p>R1和R2为BGP邻居，R1上宣告了两条路由，1.1.1.0/24核1.1.2.0/24，在R1上进行路由汇总，将路由汇总为1.0.0.0/8，抑制明细，但希望放行1.1.1.0/24这条路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map UN permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 11.11.11.11</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.0 mask 255.255.255.0</span><br><span class="line"> network 1.1.2.0 mask 255.255.255.0</span><br><span class="line"> aggregate-address 1.0.0.0 255.0.0.0 summary-only</span><br><span class="line"> neighbor 192.168.12.2 remote-as 200</span><br><span class="line"> neighbor 192.168.12.2 unsuppress-map UN</span><br></pre></td></tr></table></figure>

<p>在R1上进行完路由汇总以后，由于要放行其中一条明细路由，所以用unsuppress-map进行操作，unsuppress-map 后面跟的route-map中被匹配到的路由不会被抑制</p>
<ul>
<li><p>先写一条前缀列表匹配（抓取）需要放行的路由‘ip prefix-list 1 seq 5 permit 1.1.1.0/24’；</p>
</li>
<li><p>由于unsuppress-map后面需要跟route-map，所以写一个匹配路由的route-map，里面只用match语句匹配该路由即可，不需要接set语句；</p>
</li>
<li><p>对邻居192.168.12.2使用unsuppress-map命令后面接之前写好的那条匹配了路由的route-map；</p>
</li>
</ul>
<p>最后的R2上查看BGP表查看配置效果：</p>
<p><img src="/2020/10/11/14-BGP/1612255401163-8f65e2b7-4edf-4842-ab33-744de6016b4a.png" alt="img"></p>
<h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><h3 id="静态路由方式"><a href="#静态路由方式" class="headerlink" title="静态路由方式"></a>静态路由方式</h3><p>在路由表中如果有‘ip route 0.0.0.0 0.0.0.0 XXX’的静态路由，在BGP进程中可以使用‘network 0.0.0.0’将此路由注入BGP进程，使得BGP中也有默认路由，该方法在BGP中引入默认路由会被传递给所有BGP邻居。</p>
<h3 id="neighbor-XXX-default-originate"><a href="#neighbor-XXX-default-originate" class="headerlink" title="neighbor XXX default-originate"></a>neighbor XXX default-originate</h3><h4 id="基本概念-24"><a href="#基本概念-24" class="headerlink" title="基本概念"></a>基本概念</h4><p>本在BGP中配置‘neighbor XXX  default-originate’则会向特定的邻居XXX传递默认路由，<strong>此配置无需路由表中存在默认路由</strong>，有点类似OSPF的default-originate always命令。</p>
<h4 id="实验验证-9"><a href="#实验验证-9" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1612342846544-f02027ac-1289-4152-8d2b-8939c27903b4.png" alt="img"></p>
<p>R1和R2为ebgp邻居，R1向R2下发一个默认路由，使得R2的默认路由指向R1，且要保证默认路由始终有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">access-list 1 permit 1.1.1.0 0.0.0.255</span><br><span class="line">!</span><br><span class="line">route-map test permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 192.168.12.2 remote-as 200</span><br><span class="line"> neighbor 192.168.12.2 default-originate route-map test</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 此时R2的BGP表为：</span><br><span class="line"> </span><br><span class="line"> R2(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 22.22.22.22</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;  0.0.0.0          192.168.12.1                           0 100 i </span><br></pre></td></tr></table></figure>

<p>只要R1的loopback接口1.1.1.1不down，R1就始终会向R2下发默认路由。</p>
<h3 id="default-information-originate"><a href="#default-information-originate" class="headerlink" title="default-information originate"></a>default-information originate</h3><p>在本地配置一条静态的默认路由，如‘ip route 0.0.0.0 0.0.0.0  null0’，默认情况下，BGP在重新发布静态路由的时候不允许注入默认路由，除非在BGP进程中配置‘default-information originate’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip rouet 0.0.0.0 0.0.0.0 null0</span><br><span class="line">router bgp X</span><br><span class="line"> default-information originate</span><br><span class="line"> redistribute static</span><br></pre></td></tr></table></figure>





<h1 id="BGP排错步骤"><a href="#BGP排错步骤" class="headerlink" title="BGP排错步骤"></a>BGP排错步骤</h1><p><img src="/2020/10/11/14-BGP/1603531401504-1a1e1779-e0d1-4348-8288-a69e1ee6f914.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531207007-db942167-4d58-4c81-af5f-0b00922ab364.png" alt="img"></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="http://ccietea.com/">BGP技术笔记by红茶三杯</a></p>
<p><a href="http://www.tcpipguide.com/free/index.htm">TCP/IP Guide</a></p>
<p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/22166-bgp-trouble-main.html">Troubleshooting BGP</a></p>
<p><a href="https://networkgeekstuff.com/networking/cisco-bgp-timers-re-explained/">Cisco BGP Timers re-Explained</a></p>
<p><a href="https://packetpushers.net/demystifying-bgp-session-establishments/">Demystifying BGP Session Establishments</a></p>
<p><a href="https://www.ciscopress.com/articles/article.asp?p=2738462">Introduction to BGP</a></p>
<p><a href="https://www.noction.com/blog/bgp-dampening">BGP Route Dampening: obsolete or still used in the industry?</a></p>
<p><a href="https://sites.google.com/site/amitsciscozone/home/bgp/bgp-route-dampening">BGP Route Dampening</a></p>
<p><a href="https://users.soe.ucsc.edu/~brad/CiscoIOSpdfs/Understanding-BGP-Regular-Expressions.pdf">Understanding BGP Regular Expressions</a></p>
<p>BGP 技术笔记</p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>16-IPV6</title>
    <url>/2022/01/20/16-IPV6/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ul>
<li><p>128bit的地址方案，为未来数十年提供了巨大的IP地址空间；</p>
</li>
<li><p>多等级层次有助于路由聚合，提高了英特网路由的效率及可扩展性；</p>
</li>
<li><p>自动配置过程允许IPV6网络中的节点更加快捷的接入V6网络；</p>
</li>
<li><p>重新编址机制使得IPV6供应商之间的转换对最终用户来说是透明的；</p>
</li>
<li><p>无需NAT；</p>
</li>
<li><p>不再有广播、不再有ARP；</p>
</li>
<li><p>IPV6的包头比IPV4更优效率，字段更少，去掉了包头校验和，更简单的包头提高了路由器的处理效率。新的扩展包头代替了IPV4的选项字段并且提供了更多的灵活性；</p>
</li>
<li><p>更有效的支持移动性和安全性；</p>
</li>
<li><p>V4到V6过渡方式丰富多彩；</p>
</li>
</ul>
<h1 id="报头分析"><a href="#报头分析" class="headerlink" title="报头分析"></a>报头分析</h1><h2 id="报头格式"><a href="#报头格式" class="headerlink" title="报头格式"></a><a href="https://www.educba.com/ipv6-header-format/">报头格式</a></h2><p><img src="/_posts/16-IPV6/1618573092654-3aef4f57-0fb1-4c3e-b2b8-68b07054b72a.png" alt="img"></p>
<h2 id="报头本体"><a href="#报头本体" class="headerlink" title="报头本体"></a>报头本体</h2><p>基本的IPV4报头长度为20个字节，总共12个字段，options和padding字段在需要时添加，IHL表示报头长度，Total Length表示总长度。</p>
<p>基本的IPV6报头为40个8bit，也就是40字节长，总共8个字段。IPV6数据包由一个基本报头加上0个或多个扩展报头再加上上层协议单元构成。</p>
<ul>
<li><p>Version：表示IP协议的版本，长度为4bit，这个字段的意义不是非常重要，因为该数据为IPV4还是IPV6并不由Version这个字段来决定，而是根据二层封装的报头字段中的协议类型来识别的。</p>
</li>
<li><p>Traffic Class：长度为8bit和IPV4报头中的Types of service功能类似（QOS），标识着IPV6数据包的优先级，当数据遭遇拥塞时，会根据Traffic Class中的优先级来处理数据，那些优先级较低的数据包会被丢弃掉；</p>
</li>
<li><p>Flow Label：流标签，长度为20bit，用来标识数据流类型，以便在网络层区分不同的报文。流标签字段由数据的起源节点（起源路由器）分配，通过流标签、源地址、目的地址的三元组，可以唯一标识一条通信流，不用像IPV4那样使用五元组方式标识（源地址、目的地址、源端口、目的端口和传输层协议号）。这样标识的好处有两个，一是流标签可以和任意的元素关联，需要标识不同类型的流（也可以是五元组）时，无需对流标签做改动；另一方面是流标签在IPV6基本头中，使用IPSec时，此区域对转发路由器可见，因此转发路由器可以在使用IPV6报文IPSec的情况下仍然可以通过三元组针对特定的流进行QOS处理。当该字节为0时，表示该IPV6数据不属于任何流；</p>
</li>
<li><p>Payload Length：有效载荷长度，长度为20bit，有效载荷长度字段是以字节为单位的，标识IPV6数据中有效的载荷部分，包含所有扩展报头的总长度，也就是除了IPV6的基本报头以外的其他部分的总长度；</p>
</li>
<li><p>Next Header：下一个头部，长度为8bit，下一个头部字段用来标识当前报头（或扩展报头）的下一个头部类型。每种扩展报头都有相对应的值。下一个头部字段定义的扩展报头类型与IPV4中的协议字段值类似，但在IPV6数据中，紧接着IPV6报头的可能不是上层协议头部（当没有扩展报头或者是最后一个扩展报头时才是上层协议头），而是IPV6扩展报头。这一机制下处理扩展报头时，因为标识了数据报头中对应的上层协议或扩展报头类型，转发路由器只需要处理必须处理的扩展报头，提高了转发效率；</p>
</li>
<li><p>Hop Limit：跳数限制，长度为8bit，类似于IPV4报文中的TTL字段，指定了报文可以有效转发的次数，报文每经过一个路由器节点，跳数减1，当此字段值减到0时，则直接丢弃该报文；</p>
</li>
<li><p>Source IP address：源IP地址，长度128bit，源IP地址字段标识了发送该IPV6报文的源地节点的IPV6地址；</p>
</li>
<li><p>Destination IP address：目的IP地址，长度128bit，标识了ipv6报文的接收节点的IPV6地址；</p>
</li>
</ul>
<h2 id="扩展报头"><a href="#扩展报头" class="headerlink" title="扩展报头"></a>扩展报头</h2><p>前面介绍了，IPV6报文中可以携带可选的IPV6扩展报头。IPV6扩展报头是跟在IPV6基本报头后面的可选报头，为了克服IPV4报头中Option字段带来的限制，在扩展报头中的字段都是使用不多的那些不关键的，真正关键的字段在IPV6报头的本体中。扩展报头的位置在上层报头和固定报头之间。由于IPV4报头中包含了几乎所有的可选项，因此每个中间路由器都必须检查这些可选项是否存在，消耗了系统资源，在IPV6中，这些相关选项被统一移动到了扩展报头中，这样，中间路由器不必处理每一个可能出现的选项（仅有‘逐跳选项<Hop by hop>’报头是必须要处理的），提高了路由器处理报文的速度和转发性能。</Hop></p>
<p>IPV6扩展报头附加在IPV6报头目的IP地址字段后面，可以有0个或多个扩展报头，当使用多个扩展报头时，通过前面报头中的Nexthead字段指明该扩展报头<strong>后</strong>的扩展报头，不同扩展报头的格式不同，但这里就不具体展开说了，有兴趣的可以自行查阅<a href="https://tools.ietf.org/html/rfc2460#page-24">RFC2460</a>。</p>
<table>
<thead>
<tr>
<th>Next Header 代码</th>
<th>报头类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>——</td>
<td>基本的IPV6报头</td>
<td></td>
</tr>
<tr>
<td>0</td>
<td>Hop by Hop选项</td>
<td>此扩展报头必须被转发路径上的所有节点处理，用于巨型数据包和路由器警报，比如RSVP资源预留协议</td>
</tr>
<tr>
<td>6</td>
<td>TCP</td>
<td>上层为TCP</td>
</tr>
<tr>
<td>17</td>
<td>UDP</td>
<td>上层为UDP</td>
</tr>
<tr>
<td>43</td>
<td>Routing Header</td>
<td>The Routing header is used by an IPv6 source to specify a list of inter-mediate nodes that a packet has to traverse on the path to its destina-tion；Routing Header是IPV6流量的源头设备用于指定流量必须经过的中间设备的列表；在数据包发往目的地的途中，该报头能够被IPV6源节点来强制数据包经过特定的路由器，当路由类型字段为0时，在路由报头中可以指定中间路由器列表，这个功能类似IPV4中的松散源路由选项。</td>
</tr>
<tr>
<td>44</td>
<td>Fragment Header</td>
<td>包含着由源设备完成的分段数据段的相关参数。在IPV6中，建议所有的节点使用PMTUD（Path MTU Discovery）机制来发现链路的MTU，这样就不需要对数据进行分段了，但如果IPV6节点不支持PMTUD，但又必须发送比路径MTU还打的数据包时，就不得不分段了，这时候需使用分段报头，节点将数据分段，使用分段报头发送每个分段。</td>
</tr>
<tr>
<td>50</td>
<td>Encapsulation Security Payload（ESP） Header</td>
<td>携带着加密的数据</td>
</tr>
<tr>
<td>51</td>
<td>Authentication Header</td>
<td>The IP Authentication Header (AH) is used to provide connectionless integrity and data origin authentication for IP datagrams (hereafter referred to as just authentication”), and to provide protection against replays. 用于为IP数据包提供无连接的完整性和数据来源认证，提供防止重放攻击的保护</td>
</tr>
<tr>
<td>59</td>
<td>No Next header</td>
<td>没有下一个报头</td>
</tr>
<tr>
<td>60</td>
<td>Destinations Options</td>
<td>由数据包的目标设备进行处理</td>
</tr>
</tbody></table>
<p>没有扩展报头的TCP数据段：</p>
<p><img src="/_posts/16-IPV6/1618648989607-a2968763-ab29-4cee-b74c-bb3edf0622c3.png" alt="img"></p>
<p>有两个扩展报头的TCP数据段：</p>
<p><img src="/_posts/16-IPV6/1618649035047-76dca1b0-a57e-4444-b435-3a0ceebab7d3.png" alt="img"></p>
<h3 id="扩展报头格式"><a href="#扩展报头格式" class="headerlink" title="扩展报头格式"></a>扩展报头格式</h3><p><img src="/_posts/16-IPV6/1618737686806-52f9234b-bf79-489d-a9aa-d0d55d161938.png" alt="img"></p>
<p><img src="/_posts/16-IPV6/1618737718259-4028ee2b-00bd-4dd3-a394-3144d9b06465.png" alt="img"></p>
<h1 id="IPV6地址"><a href="#IPV6地址" class="headerlink" title="IPV6地址"></a>IPV6地址</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="IPV6特点"><a href="#IPV6特点" class="headerlink" title="IPV6特点"></a>IPV6特点</h3><ul>
<li><p>更大的地址空间，从32bit到了128bit；</p>
</li>
<li><p>IPV4能提供42.9亿个IP地址也就是2的32次方个地址，而IPV6可以提供2的128次方个地址</p>
</li>
<li><p>无需NAT；</p>
</li>
<li><p>没有广播；</p>
</li>
<li><p>更简单的报头提高了路由器的效率；</p>
</li>
<li><p>支持移动性和安全性；</p>
</li>
<li><p>过渡方式更丰富多彩；</p>
</li>
<li><p>比IPV4灵活性更强；</p>
</li>
<li><p>可以无状态配置地址；</p>
</li>
<li><p>一个接口允许配置多个地址；</p>
</li>
<li><p>可以设置链路本地地址；</p>
</li>
</ul>
<h3 id="地址简写"><a href="#地址简写" class="headerlink" title="地址简写"></a>地址简写</h3><p>IPV6地址可以进行简写，多个前导0可以省略成一个0；比如2001:00a8:0207:0000:0000:0000;0000:8207，可以缩写成2001：a8:207:0:0:0:08207。一个或多个连续的16bit字段为0时，可以用：：表示，但整个缩写中只允许有一个：：。比如上面的例子，可以进一步缩写成2001：a8:207::8207。</p>
<p><img src="/_posts/16-IPV6/1618740903670-0e24715e-c0a7-4155-b9fe-9af0aeb3e8b6.png" alt="img"></p>
<h3 id="地址URL表示"><a href="#地址URL表示" class="headerlink" title="地址URL表示"></a>地址URL表示</h3><p>http://[ipv6地址]：8080</p>
<p>必须使用[]括起来</p>
<h3 id="IPV6和子网划分"><a href="#IPV6和子网划分" class="headerlink" title="IPV6和子网划分"></a>IPV6和子网划分</h3><p>IPV6和V4不同之处是网络前缀范围内没有保留广播号，在IPV4中，第一个和最后一个地址是被保留给网络号和广播号的，而在IPV6中，不再有广播了，而且事实上IPV6的空间地址如此之大，以至于连VLSM都不是特别有必要了。</p>
<h3 id="接口ID"><a href="#接口ID" class="headerlink" title="接口ID"></a>接口ID</h3><p>用于标识链路上的接口，在每条链路上，接口ID必须唯一，接口ID有很多用途，最常见的是用于黏贴在链路本地地址的前缀后面，形成128bit的接口链路本地地址。或者在无状态自动配置中，黏贴在获取到的IPV6全局单播前缀后面，构成接口的全局单播地址。接口ID的长度为64bit，根据IEEE的EUI-64规范将48bit的MAC地址转换为64bit的接口ID，MAC地址的唯一性保证了接口ID的唯一性。</p>
<p>过程由设备自动生成，不需人为干预，由接口的MAC地址转换得到64bit的EUI-64格式接口ID的过程如下：</p>
<p><img src="/_posts/16-IPV6/1618990388662-c0fc80f2-1b9d-478f-9376-b4026a9b5797.png" alt="img"></p>
<p>将48bit的MAC对半劈开，插入FFFE，然后设置第七位，也就是U/L位，该比特位决定了48比特的MAC地址是否唯一，一个以太网地址可以有两种含义，地址可被全球管理或本地管理。全球管理指的是使用如0800-2bxx-xxxx之类的厂商MAC，本地管理指的是使用自己的值重写MAC地址，在这种情况下，这个特殊的位=1表示本地管理，为0时表示全球管理。但在EUI-64格式中，U/L的含义正好相反，0表示本地管理，1表示全球管理，所以使用EUI-64格式的地址IPV6地址，U/L位为1，则地址是全球唯一的，如果为0，则表示本地唯一。</p>
<h2 id="地址分类"><a href="#地址分类" class="headerlink" title="地址分类"></a>地址分类</h2><p><img src="/_posts/16-IPV6/1618740577447-94dda359-ae1f-4ebc-b991-a4017dfd6bc0.png" alt="img"></p>
<ul>
<li><p>单播地址（Unicast Address）：标识一个接口，目的地址为单播地址的报文会被送到标识的接口。单播地址中又有可聚合全球单播地址、链路本地单播地址、站点本地单播地址、IPV4兼容地址和未指定的环回地址；</p>
</li>
<li><p>组播地址（Multicast Address）：标识多个接口，目的地址为组播地址的报文会被送到被标识的所有接口；</p>
</li>
<li><p>任意播地址（Anycast Address）：标识多个接口，目的为任意播地址的报文会被送到最近的一个被标识接口，最近节点是由路由协议来定义的。</p>
</li>
</ul>
<p><img src="/_posts/16-IPV6/1618741837447-3a246591-3866-4855-af2d-3e9bafb2c334.png" alt="img"></p>
<p><img src="/_posts/16-IPV6/1618741840377-2d45fe54-db48-4db0-92ac-52b9db490c83.png" alt="img"></p>
<p>200::/7保留用于网络业务接入点NSAP，当前没有使用NSAP保留空间，NSAP地址主要用于ATM技术中；2000::/3（从2000::到3FFF::）是可聚合全球单播地址空间。</p>
<h2 id="单播地址"><a href="#单播地址" class="headerlink" title="单播地址"></a>单播地址</h2><h3 id="可聚合全局单播地址"><a href="#可聚合全局单播地址" class="headerlink" title="可聚合全局单播地址"></a>可聚合全局单播地址</h3><p>全称为Aggregatable global unicast address，该地址类似于IPV4公网地址，是可以在互联网中路由的地址。目前已经分配的全球单播地址前缀都是001开头的，2000::到3FFF:FFFF:…..FFFF。</p>
<p><img src="/_posts/16-IPV6/1618742281797-df84f3a5-4fc9-4b32-849f-5dc987474a50.png" alt="img"></p>
<p>每一个组织在注册的时候拿到的时23位的，运营商拿到32位，给企业分发是48位，企业再分发的时候是64给客户，一般情况常见的都是64位掩码，可以再由自己根据需要进一步规划：</p>
<p><img src="/_posts/16-IPV6/1618968893619-1766790c-b177-4373-9f4a-9059aee0a6bf.png" alt="img"></p>
<h3 id="本地站点地址"><a href="#本地站点地址" class="headerlink" title="本地站点地址"></a>本地站点地址</h3><p>英文为Site-local address，类似于IPV4中的私有地址，以FEC0：：/10为前缀，其中前10bit固定为1111111011，紧跟着后面的是连续38bit的0，因此对于站点本地地址来说，前48bit总是固定的，在接口ID和高位48bit特定前缀之间有16bit子网ID字段，供机构在内部构建子网使用，如果想在互联网上传播，那么需要做NAT。站点本地地址不是自动生成的，是手工配置的。</p>
<p>本地站点地址永远不会用于全球IPV6因特网通信，一般用于内网通信，其实IPV6地址空间如此之庞大，以至于根本用不到Site-local地址，直接用全局单播地址即可，现网中本地站点地址用的很少。</p>
<h3 id="链路本地地址"><a href="#链路本地地址" class="headerlink" title="链路本地地址"></a>链路本地地址</h3><p>英文为Link-Local，用于和本链路内的设备进行通信，在一条链路上必须知道对方节点的链路本地地址，如果不知道是不能通信的，所以一条链路中的IPV6节点要通信必须拥有本地链路地址，而且这个链路本地地址只在一条链路中有效，<strong>也不能被路由</strong>，不同链路的链路本地地址可以重复，因为在这个地址只在链路上使用，确保在本链路上唯一即可。设备会使用DAD（Duplicate Address Detection重复地址检测）来判断链路本地地址是否唯一。</p>
<p>如果一台设备激活了IPV6功能，这台设备的每个接口都会自动配置一个链路本地地址，这个机制使得两个连接到同一链路的IPV6节点不需要做任何配置就可以通信，缺省网关建议使用链路本地地址，因为这个地址是最稳定的，只要激活IPV6就有的。也就是说，一台激活了IPV6功能的设备，<strong>可以没有</strong>IPV6的Global Unicast地址，但<strong>必须有</strong>IPV6的Link-Local地址。</p>
<p>链路本地地址以FE80::/10为前缀，11-64位为0，外加一个64bit的接口标识（一般是EUI-64）</p>
<p><img src="/_posts/16-IPV6/1618972406898-3bbf0e8a-3860-4670-99f7-8ccdf97440c6.png" alt="img"></p>
<h3 id="特殊地址"><a href="#特殊地址" class="headerlink" title="特殊地址"></a>特殊地址</h3><h4 id="未指定地址"><a href="#未指定地址" class="headerlink" title="未指定地址"></a>未指定地址</h4><p>全0的地址，也就是0:0:0:0:0:0/128，或者：/128，该地址可以表示某个接口或节点还没有IP地址，可以作为某些报文的源IP地址，比如作为DAD报文的DHCP初始化过程中客户端的起源IP。用于IPV6节点在没有获取IPV6地址时的场景。</p>
<h4 id="环回地址"><a href="#环回地址" class="headerlink" title="环回地址"></a>环回地址</h4><p>也就是0:0:0:0:0:1/128，或者 ::1/128，用于IPV6节点发送报文给自己。</p>
<h4 id="IPV4兼容地址"><a href="#IPV4兼容地址" class="headerlink" title="IPV4兼容地址"></a>IPV4兼容地址</h4><p>在过渡技术中，会使用到一些包含IPV4地址的IPV6地址，为了让IPV4地址显得更加突出一些，定义了内嵌IPV4地址的IPV6地址格式，内嵌IPV4地址格式是过渡机制中使用的一种特殊表示方法，在这种表示方法中，IPV6地址的部分使用十六进制表示，IPV4地址部分可以使用十进制格式，比如0:0:0:0:0:0192.168.1.2或  ::192.168.1.2（前边有96个0）IPV4兼容地址用于过渡机制，如自动IPV4兼容隧道以及NAT-PT。</p>
<h2 id="组播地址（Multicast）"><a href="#组播地址（Multicast）" class="headerlink" title="组播地址（Multicast）"></a>组播地址（Multicast）</h2><h3 id="地址结构"><a href="#地址结构" class="headerlink" title="地址结构"></a>地址结构</h3><p><img src="/_posts/16-IPV6/1618973856148-f1a6c486-51b7-44b4-877a-3064cfac7ae1.png" alt="img"></p>
<p>组播地址最高位的前8位固定为1，也就是FFXX：：/8；</p>
<p>Flags字段长度为4bit，当值为0000时表示永久分配或总所周知的组播地址；当值为0001时，表示是临时的。</p>
<p>Scop字段长度为4bit，用来限制组播数据流在网络中发送的范围：</p>
<ul>
<li><p>0：预留；</p>
</li>
<li><p>1：节点本地范围；单个接口有效，仅用于Loopback通讯；</p>
</li>
<li><p>2：链路本地范围；如FF02::1表示连路上所有节点；FF02::9表示连路上的所有RIP路由器；</p>
</li>
<li><p>3：本地子网范围；</p>
</li>
<li><p>4：本地管理范围；</p>
</li>
<li><p>5：本地站点范围；</p>
</li>
<li><p>8：组织机构范围；</p>
</li>
<li><p>E：全球范围；</p>
</li>
<li><p>F：预留。</p>
</li>
</ul>
<p>Group-ID，该字段长度可以为112位，用来标识组播，而112位最多可以生成2112个组ID，RFC2373并没有将所有的112位都定义为组标识，而是建议仅使用该112位的最低32位组ID，剩余的80位都置0。</p>
<h3 id="特殊组播地址"><a href="#特殊组播地址" class="headerlink" title="特殊组播地址"></a>特殊组播地址</h3><ul>
<li><p>FF01::1，节点本地范围内所有节点组播地址；</p>
</li>
<li><p>FF01::2，节点本地范围内所有路由器组播地址；</p>
</li>
<li><p>FF02::1，链路本地范围内所有节点组播地址；</p>
</li>
<li><p>FF02::02，链路本地范围内所有路由器组播地址；</p>
</li>
<li><p>FF02::9，链路上所有的RIP路由器</p>
</li>
</ul>
<h3 id="组播地址的MAC映射"><a href="#组播地址的MAC映射" class="headerlink" title="组播地址的MAC映射"></a>组播地址的MAC映射</h3><p><img src="/_posts/16-IPV6/1618976493877-37178812-f1b0-4ce1-870c-07d7d4238221.png" alt="img"></p>
<h3 id="被请求节点组播地址"><a href="#被请求节点组播地址" class="headerlink" title="被请求节点组播地址"></a>被请求节点组播地址</h3><p>在IPV6组播地址中，有一种特别的组播地址，叫做Solicited-node，被请求节点组播地址，主要用于重复地址检测（DAD）和替代IPV4中的ARP，地址前缀由FF02::1:FF00:0/104和IPV6单播地址的最后24位组成。一个IPV6单播地址对应一个Solicited-node地址，有效范围为本地链路范围。</p>
<p>地址个是：FF02:0:0:0:0:1:FFXX:XXXX，具体的对应关系如下：</p>
<p><img src="/_posts/16-IPV6/1618976846785-18fe5a66-5733-4dc4-8309-76578cb80c3a.png" alt="img"></p>
<h2 id="Anycast"><a href="#Anycast" class="headerlink" title="Anycast"></a>Anycast</h2><p>任意播地址没有专门的地址空间，使用的是单播的地址空间，一个IPV6地址被分配给多个接口，仅用于路由器，发往任意播地址的数据包被路由器分配给了任意播地址的最近的一个（由路由协议判断远近），适合于One-to-One-of-Many（一对一组中的一个）的通信场合，接收方只需要是一组接口中的一个即可，如移动用户上网就需要因地理位置的不同而接入离用户最近的一个接收站，这样才可以使得移动用户在地理位置上不受太多的限制。任意播地址只能作为目的IP，不能作为源。</p>
<h2 id="必须具备的IPV6地址"><a href="#必须具备的IPV6地址" class="headerlink" title="必须具备的IPV6地址"></a>必须具备的IPV6地址</h2><ul>
<li><p>链路本地地址：FE80::/10；</p>
</li>
<li><p>环回地址：::1;</p>
</li>
<li><p>所有节点组播地址：FF01::1，FF02::1；</p>
</li>
<li><p>分配的可聚合全球单播地址：2000::/3；</p>
</li>
<li><p>所使用的每个单播和任意播地址对应的被请求节点组播地址：FF02::1:FFxx:xxxx。其中xx:xxxx是每个单播或任意播地址的低24bit；</p>
</li>
<li><p>主机所属的所有组的组播地址：FF00::/8；</p>
</li>
</ul>
<p>上面是主机节点必备的地址，路由器的有所差异，多了以下地址：</p>
<ul>
<li><p>所有路由器组播地址：FF01::2 (interface-local)；FF02::2 (link-local)；FF05::2(site-local)。</p>
</li>
<li><p>子网路由器任意播地址：UNICAST_PREFIX:0:0:0:0。</p>
</li>
<li><p>其他任意播配置地址：2000::/3。</p>
</li>
</ul>
<h2 id="IPV6地址配置方法"><a href="#IPV6地址配置方法" class="headerlink" title="IPV6地址配置方法"></a>IPV6地址配置方法</h2><h3 id="手工配置"><a href="#手工配置" class="headerlink" title="手工配置"></a>手工配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#interface F0/0</span><br><span class="line">R1(config-if)#ipv6 enable</span><br><span class="line">R1(config-if)#ipv6 address 2001:0001::/64 eui-64</span><br></pre></td></tr></table></figure>

<p>最后这条命令的意思是，使用2001:0001::/64作为前缀，并追加64bit的EUI-64格式的接口ID，构成接口的全局唯一IPV6地址。</p>
<h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>IPV6地址的自动配置一般有两种方式：</p>
<ul>
<li>有状态地址自动配置，也就是DHCPV6；</li>
<li>无状态自动配置，为了获得这个前缀，只要在路由器和主机之间运行一个协议即可。使用NDP协议的Router Solicitation恳求和Router Advertisement通告消息。前者用于发现路由器，并促使路由器发送Router Advertisement消息通报前缀信息。RA消息中包含前缀、生存期、缺省网关等信息，大致过程如下图：</li>
</ul>
<p><img src="/_posts/16-IPV6/1618993037246-d1623a05-467a-4650-afa0-efd12a0a47fb.png" alt="img"></p>
<h1 id="ICMPV6"><a href="#ICMPV6" class="headerlink" title="ICMPV6"></a>ICMPV6</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>ICMPV6是IPV6的基础协议之一，相比之前IPV4的ICMP协议，ICMPV6协议在功能上类似，但得到了极大加强，有了很多新特性和功能上的改进，这些改进是NDP协议的一部分。协议号为58，该协议号在IPV6报头的‘下一个报头（Next Header）’字段中。</p>
<h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><p><img src="/_posts/16-IPV6/1618993540799-95f9b04d-e776-4d79-8c8d-0eb9616471c9.png" alt="img"></p>
<p><img src="/_posts/16-IPV6/1618993469698-cd62bf2f-0651-4559-840c-107a01872e96.png" alt="img"></p>
<ul>
<li>Type：类型字段，长度为8bit，表示ICMPV6消息的类型，有两种大类型的报文，差错消息（error messages，当Type字段值为0-127时）及协议消息（Informational messages，当Type字段值为128-255时），具体来说有可能这个消息是Echo Request、目标不可达或数据包过大等；</li>
</ul>
<p><img src="/_posts/16-IPV6/1618993779896-67f90591-e3c2-4389-8f3b-ebc6cb9ae167.png" alt="img"></p>
<ul>
<li>Code：代码字段，长度为8bit，用于确定ICMPV6进一步的信息，对同一类型的报文进行了更详细的分类，Code字段依赖于Type字段，比如如果Type字段表示目标地址不可达，那么Code字段会给出为什么不可达的更详细信息，比如路由器没有到达目标地址的路由；</li>
<li>Checksum：校验和，长度为16bit，用于检测ICMPV6数据是否损坏。</li>
</ul>
<h2 id="PMTUD"><a href="#PMTUD" class="headerlink" title="PMTUD"></a>PMTUD</h2><p>PMTUD，全称为Path MTU Discovery，也就是路径MTU检测协议，主要用于发现路径上的MTU，使得数据包从源转发到目的地的过程中避免分段。依赖PMTUD，源节点可以使用所发现的路径中的最大PMTU与目的地节点进行通信，这样可以避免数据包在从源传输到目的地的过程中，被中途的路由器分片，从而导致性能的下降。<strong>因此IPV6的分片不是在中间路由器上进行的，仅当路径MTU比需要传送的数据包小的时候，由源节点对数据包进行分片</strong>。</p>
<p>在RFC1981中定义了PMTU发现协议，IPV6 PMTUD使用ICMP V6 type 2消息，典型过程如下：</p>
<p><img src="/_posts/16-IPV6/1618994735904-79b3f0b0-60aa-40ff-87d5-dc540e2fe1a0.png" alt="img"></p>
<ol>
<li><p>首先Source使用1500字节作为MTU向目标节点发送一个IPV6数据包；</p>
</li>
<li><p>中间路由器A意识到数据包过大，MTU应该为1400，于是回复一个ICMPV6 Type=2的消息向Source应答，在该ICMPV6消息中指定较小的MTU=1400；</p>
</li>
<li><p>Source开始使用MTU=1400发送IPV6数据包，该数据包到了B</p>
</li>
<li><p>然而B意识到本地接口MTU为1300，于是回复一个ICMP V6 Type=2的消息向Source应答；</p>
</li>
<li><p>Source开始使用MTU=1300发送IPV6数据包，该包顺利到达了目的地；</p>
</li>
<li><p>Source和Destination之间的会话被建立起来。</p>
</li>
</ol>
<p>注意事项：</p>
<ul>
<li><p>这里的PMTU，指的是单向的，沿路上的数据包出接口MTU中最小的；</p>
</li>
<li><p>IPV6要求的链路层所支持的MTU最小为1280bytes；</p>
</li>
<li><p>用IPV6 PMTUD发现的MTU值被源节点缓存，可以使用show ipv6 mtu来显示每个缓存的目的地PMTUD的值；</p>
</li>
</ul>
<p>来看ICMPV6差错消息（error messages）的抓包：</p>
<p><img src="/_posts/16-IPV6/1618995601019-51c956d9-f59d-46a2-9035-8cf3f0cdd79f.png" alt="img"></p>
<h1 id="NDP"><a href="#NDP" class="headerlink" title="NDP"></a>NDP</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p><img src="/_posts/16-IPV6/1618995870801-c0d735c2-1880-464d-a875-cfcadc9473ce.png" alt="img"></p>
<ul>
<li><p>地址解析，用来代替IPV4中的ARP（Address Resolution Protocol）和ICMP路由器发现（Router Discovery），使用ICMP完成地址解析，使用NS（Neighbor Solicitation邻居请求）和NA（邻居通告）报文来解析三层地质对应的链路层地质；</p>
</li>
<li><p>邻居请求报文（NS，Neighbor Solicitation），Type字段值为135，Code字段值为0，在地址解析中的作用类似于ARP请求报文；</p>
</li>
<li><p>邻居通告报文（NA，Neighbor Advertisement），Type字段值为136，Code字段值为0，在地址解析中的作用类似于IPV4中的ARP应答报文；</p>
</li>
<li><p>邻居的状态跟踪，show ipv6 neighbor；</p>
</li>
<li><p>无状态自动配置；</p>
</li>
<li><p>重复地址检测；</p>
</li>
<li><p>前缀重编址；</p>
</li>
<li><p>路由器重定向，路由器向一个IPV6节点发送ICMPV6消息，通知它在相同的本地链路上存在一个更好的到达目的地网段的路由器地址；</p>
</li>
</ul>
<h2 id="为NDP定义的ICMPV6消息"><a href="#为NDP定义的ICMPV6消息" class="headerlink" title="为NDP定义的ICMPV6消息"></a>为NDP定义的ICMPV6消息</h2><p><img src="/_posts/16-IPV6/1618996977124-d4088dd3-514d-462a-8122-76fd933de3d1.png" alt="img"></p>
<h2 id="地址解析"><a href="#地址解析" class="headerlink" title="地址解析"></a>地址解析</h2><p>在IPV4中，当主机需要和目标主机通信时，必须先通过ARP协议获得目的主机的链路层地址，在IPV6中，同样需要从IP地址解析到链路层地址这个功能，邻居发现协议实现了这个功能，具体来说就是使用NS、NA和被请求节点组播地止的组合来完成，这比IPV4的ARP要高效的多，我们来看看经典的地址解析过程：</p>
<p><img src="/_posts/16-IPV6/1619251865301-9b794107-60e9-4e80-9419-7205138b9c29.png" alt="img"></p>
<ul>
<li>Host A在向Host B发送报文之前，它必须要解析出Host B的链路层地址，所以首先Host A会发送一个NS报文，其中源地址为Host A的IPV6地址，目的地址为Host B的被请求节点组播地址，需要解析的目标IP为Host B的IPV6地址，这就表示Host A想要知道Host B的链路层地址。需要同时指出的是，在NS报文的Options字段中还携带了Host A的链路层地址；</li>
<li>当Host B接收到了NS报文之后，就会回应NA报文，其中源地址为Host B的IPV6地址，目的地址为Host A的IPV6地址（使用NS报文中的Host A的链路层地址进行单播），Host B的链路层地址被放在Options字段中，这样就完成了一个地址解析的过程；</li>
</ul>
<p><img src="/_posts/16-IPV6/1618997051984-271ef167-b7d6-4c09-ab90-6d58fb8bc117.png" alt="img"></p>
<p>NS中的33:33:FF:01:00:0B是IPV6目的地址（FF02::1:FF01:B）的多播映射地址。再来看NA的抓包：</p>
<p><img src="/_posts/16-IPV6/1618997184148-be2b7024-3e04-47fb-a134-32d44819e05f.png" alt="img"></p>
<p>注意到其中的Flag字段，R位置1表示这是台路由器，S位置1表示这是相应某个邻居请求的通告，S位如果置0则为主动发送的；O位置1表示NA消息中的条目会覆盖已有条目，收到该消息的邻居会覆盖已有条目。</p>
<p>使用show ipv6 neighbor 可以查看邻居表项：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ipv6 neighbors  </span><br><span class="line">IPv6 Address             Age  Link-layer Addr    State   Interface </span><br><span class="line">2012::2                  11    cc01.0cf0.0000    STALE    Fa0/0 </span><br><span class="line">FE80::CE01:CFF:FEF0:0    11    cc01.0cf0.0000    STALE    Fa0/0 </span><br></pre></td></tr></table></figure>

<p>其中State如果为Reach表示邻居可达，如果为Stale意味着这些邻居在最后的30秒内是不可达的。</p>
<p>使用ipv6 neighbor 命令可以添加一个静态表项到邻居发现表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ipv6 neighbor 2012::2 fastEthernet 0/0 cc01.0cf0.0000 </span><br><span class="line">R1# show ipv6 neighbors</span><br><span class="line">IPv6 Address                Age  Link-layer Addr   State   Interface </span><br><span class="line">2012::2                      -    cc01.0cf0.0000   REACH   Fa0/0 </span><br></pre></td></tr></table></figure>

<p>使用命令‘clear ipv6 neighbors’会清除邻居发现表中的动态表项；</p>
<p>使用命令‘ipv6 nd ns-interval’用于调整邻居请求消息的时间间隔，默认是1000ms，也就是1S；</p>
<p>使用命令‘ipv6 nd reachable-time’，一个邻居在某个事件证实它的可达性后，在这个时间段内，这个邻居被认为是可达的，默认30S。</p>
<h2 id="邻居状态"><a href="#邻居状态" class="headerlink" title="邻居状态"></a>邻居状态</h2><p>通过邻居或到达邻居的通信，会音位各种原因而中断，包括硬件故障，接口卡的热插入等情况，如果目的地址失效，则恢复是不可能的，导致通信失败；如果路径失效，则恢复是可能的，因此需要维护一章邻居表，每个邻居都有相应的状态，状态之间可以相互迁移，RFC2461中定义了五种邻居状态：</p>
<table>
<thead>
<tr>
<th>Incomplete</th>
<th>邻居请求已经发送到目标节点的组播地址，但没有收到邻居的通告</th>
</tr>
</thead>
<tbody><tr>
<td>Reachable</td>
<td>可达，收到确认，不再继续发包确认</td>
</tr>
<tr>
<td>Stale</td>
<td>从收到上一次可达性确认后过了30秒</td>
</tr>
<tr>
<td>Delay</td>
<td>在Stale状态后发送过一个报文，并且5秒内没有可达性确认</td>
</tr>
<tr>
<td>Probe</td>
<td>每隔1秒重传邻居请求，用来主动请求可达性确认，直到收到确认</td>
</tr>
</tbody></table>
<ol>
<li><p>A发送NS，并生成缓存条目，A上条目的状态为Incomplete；</p>
</li>
<li><p>若B回复NA，则A上关于B的邻居状态就由Incomplete过渡到Reachable。但若A发出NS消息后一定时间内仍没有收到任何的回复，则由Incomplete过渡到Empty，即删除条目；</p>
</li>
<li><p>如果在Reachable状态上经过ReachableTime（默认30秒），A路由器上关于B的条目状态从Reachable变为Stale，或如果在Reachable状态上收到B的非请求NA，且链路层地址不同，则马上变为Stale状态；</p>
</li>
<li><p>在Stale状态，若A要向B发送数据，可直接发送，并从A上关于B的条目由Stale变为Delay，同时会等待应用层的提示信息，提示邻居是否可达；</p>
</li>
<li><p>如果在Delay_First_Probe_Time（默认5秒）内，有NA应答或应用层的提示信息（例如我发了ICMP包给对端，对端回复我ICMP了，那就是上层可达），则状态从Delay变为Reachable，如果没有应用层提示信息，则从Delay变为Probe；</p>
</li>
<li><p>在Probe状态，每隔RetransTimer（默认1秒）发送单播NS，发送Max_Unicast_Solicit个后，再等RetransTimer，有应答则进入Reachable状态，无应答则进入Empty状态，也就是删除条目；</p>
</li>
</ol>
<h2 id="无状态自动配置"><a href="#无状态自动配置" class="headerlink" title="无状态自动配置"></a>无状态自动配置</h2><p>无状态自动配置指的是，没有通过手工的方式获取IPV6地址，也没有通过DHCPV6获取IPV6地址，其中通过DHCPV6获取IPV6地址是典型的‘有状态自动配置’，而不管是有状态配置，还是无状态配置IPV6地址，该地址应该属于全球单播地址或本地站点地址。</p>
<p>涉及机制：</p>
<ul>
<li><p>前缀公告</p>
</li>
<li><p>DAD</p>
</li>
<li><p>前缀重新编制</p>
</li>
</ul>
<h3 id="路由器公告RA"><a href="#路由器公告RA" class="headerlink" title="路由器公告RA"></a>路由器公告RA</h3><p><img src="/_posts/16-IPV6/1619086398561-6362f6fa-f568-4400-948d-ff037418f121.png" alt="img"></p>
<p>PC收到RA（Router Advertisement）报文后会做一个检测：</p>
<ul>
<li><p>RA数据包的源地址，是否为一个Linklocal地址；</p>
</li>
<li><p>RA数据包的IPV6报头的Hop Limit是否为255，因为只有255才表示是本地网络中路由器产生的；</p>
</li>
<li><p>如果RA的数据包，包含了认证信息，那么还要认证该信息是否正确；</p>
</li>
<li><p>ICMPV6的Checksum是否正确；</p>
</li>
<li><p>ICMPV6的Code是否为0，因为在信息消息中，Code=0表示Echo request；</p>
</li>
<li><p>ICMPV6长度是否大于等于16；</p>
</li>
<li><p>所有的Options长度大于等于0；</p>
</li>
</ul>
<p>如果一台PC初始化，也可以主动发送一个RS请求关于前缀的信息。</p>
<h3 id="前缀公告"><a href="#前缀公告" class="headerlink" title="前缀公告"></a>前缀公告</h3><h4 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h4><p>前缀公告是无状态自动配置的初始机制，是指路由器在本地链路上公告自己的前缀地址，然后让IPV6主机使用前缀公告的信息，结合自己的MAC地址来自动配置本地的单播IPV6地址，这将从某种程度上减少了地址配置的复杂性，并且可以保证通过前缀公告的地址是唯一的，因为MAC地址本身就是唯一的。</p>
<p>前缀公告利用RA（ICMPV6，Type134）和所有节点的组播地址（FF02::1），路由器RA消息在本地链路上周期性的发送到FF02::1上。前缀公告信息中，源地址为本地链路地址（FE80::/10开始）公告的目标地址是FF02::1（表示公告给整个链路上的IPV6节点），公告消息为ICMPV6的134类型消息。而使用本地链路地址作为公告的源地址是为了让IPV6在重新获取链路编址的时候，仍然可以保持地址前缀公告的功能。公告目标地址FF02::1表示只要加入了这个组播组的节点都可以获取IPV6地址前缀公告的消息，默认情况下，所有IPV6节点的主机都属于这个组播组。</p>
<h4 id="路由器上公告前缀"><a href="#路由器上公告前缀" class="headerlink" title="路由器上公告前缀"></a>路由器上公告前缀</h4><p>只要在网络接口上配置了一个本地站点或区安居客聚合单播IPV6地址，以及其前缀长度，就启用了CISCO路由器上的IPV6前缀公告，自动配置过程期间和之后使用的参数如下：</p>
<ul>
<li><p>IPV6前缀：默认状态下，无状态自动配置公告的前缀程度为64位，节点收到IPV6前缀，将自己的EUI-64地址附加在本来的64位前缀后面，构成了128位IPV6地址；</p>
</li>
<li><p>生存期；</p>
</li>
<li><p>有效周期（Valid lifetime）；有效周期指的是，地址在接口上保持可用状态的时间长度。A <em>valid</em> lifetime is the time period during which an address is allowed to remain available and usable on an interface。</p>
</li>
<li><p>首选生存期（Preferred lifetime）；首选生存周期是指，地址在接口上可以完全使用的时间长度，这个时间必须小于或等于有效周期。A <em>preferred</em> lifetime is the length of time an address is intended for full use on an interface, and must be less than or equal to the address’s valid lifetime.</p>
</li>
<li><p>IPV6地址可以通过State configuration（状态化配置）和Stateless configuration（无状态配置）来获得。状态化配置是通过手工添加或通过DHCPV6获得，无状态化是通过Prefix Advertisement（前缀宣告）获得，不管哪种方式获得地址，都会有几个时间状态，主要有两个，一个是Valid Lifetime，另一个是Preferred Lifetime。首先在DAD检查阶段，在DAD success前，地址一致处于Tentative（试验状态），这时的地址是不可用状态，直到DAD success后，进入Preferred状态，也就是首选状态，这个状态过程中的IPV6 address的有效性是由preferred lifetime决定的。Valid Lifetime是一个类似于DHCP中的Lease time（租期）的参数，如果地址超过了Valid lifetime，节点就会把这个地址设置为Inactive状态，然后delete。在Preferred time和valid lifetime之间叫做deprecated状态，在这种状态算是一种buffer，大概意思叫做不赞成使用的状态，当地址在这个时间段的时候，地址不能主动的发起连接，这也是为了保证上层应用而设计的，但是过了Valid lifetime时间就会变为invalid，这时任何连接会down掉。在思科IOS上，默认的valid lifetime为30天（2592000秒），prefer time为7天（604800秒）。</p>
</li>
</ul>
<p><img src="/_posts/16-IPV6/1619165069986-e3cbf7e8-1684-4ea4-a6ed-47466435a947.png" alt="img"></p>
<ul>
<li>默认路由信息：提供关于默认路由器IPV6地址的存在和生存期信息，在IPV6中，节点使用的默认路由器地址是路由器的本地链路地址（Linklocal address），这样一来，即使前缀被重新编址，默认网关也是可达的（Linklocal address也不会变）；</li>
<li>标志/选项；</li>
</ul>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p><img src="/_posts/16-IPV6/1619165411927-c6aca834-7b89-489b-8df7-5f2db38be033.png" alt="img"></p>
<h4 id="前缀公告参数配置"><a href="#前缀公告参数配置" class="headerlink" title="前缀公告参数配置"></a>前缀公告参数配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)#ipv6 nd prefix 2001::/64 ?</span><br><span class="line">  &lt;0-4294967295&gt;   Valid Lifetime (secs) </span><br><span class="line">  at                Expire prefix at a specific time/date </span><br><span class="line">  infinite          Infinite Valid Lifetime </span><br><span class="line">  no-advertise       Do not advertise prefix </span><br><span class="line">  no-autoconfig      Do not use prefix for autoconfiguration   </span><br><span class="line">      // 当在特定前缀后开启该参数后，该前缀不能用于无状态自动配置</span><br><span class="line">  no-rtr-address    Do not send full router address in prefix advert </span><br><span class="line">  off-link          Do not use prefix for onlink determination </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">R1(config-if)#Ipv6 nd prefix 2012::/64 30 15</span><br><span class="line">     //配置Valid lifetime和prefered time，是个相对时间</span><br><span class="line">     </span><br><span class="line">配置完上面命令后，邻居R2收到前缀，如下：</span><br><span class="line">R2#sh ipv int f 0/0  </span><br><span class="line">FastEthernet0/0 is up, line protocol is up </span><br><span class="line">IPv6 is enabled, link-local address is FE80::CE00:DFF:FE48:0  </span><br><span class="line">Global unicast address(es): </span><br><span class="line">2001::CE00:DFF:FE48:0, subnet is 2001::/64 [PRE]   //状态为prefer</span><br><span class="line">valid lifetime 25 preferred lifetime 10    //两个时间不断递减</span><br><span class="line"></span><br><span class="line">当Preferred lifetime先到0时，状态变为（Deprecated），当Valid lifetime变为0时，地址抹去</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd prefix 2012::/64 at  XXXX   YYYYY</span><br><span class="line">xxxx为valid lifetime；YYYY为prefered time；</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd prefix 2012::/64 890000 720000 off-link</span><br><span class="line">off-link和L比特油管，这个比特位在RFC2461中定义，当可选的off-link关键字在CISCO IOS中被配置时，L比特被关闭，而如果L比特被打开（默认为打开状态），它表示在RA消息中的前缀是分配给本地链路的。因此，向包含这个指定前缀的地址发送数据的节点，认为目的是本地链路可达的。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd prefix 2012::/64 890000 720000 no-autoconfig</span><br><span class="line">no-autoconfig和A比特有关，RFC2461中定义的相关参数，A比特成为自治地址配置的标志，当这个可选关键字no-autoconfig在CISCO IOS中被配置，也就是配置了上门的命令后，A比特被置0，如果A比特被置1（默认不配置上面命令的情况下A比特置1），它指示本地链路的主机可以使用该前缀进行无状态自动配置。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd prefix 2012::/64 no-advertise</span><br><span class="line">该前缀不包含在RA消息中，默认情况下，思科IOS关闭这个no advertise，也就是前缀都会被包含在RA消息中。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd prefix default ?</span><br><span class="line">可以修改接口下nd前缀通告的默认参数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ipv6 nd suppress-ra</span><br><span class="line">在接口上关闭路由器公告，默认情况下，当全局命令ipv6 unicast-routing被启用，思科设备的以太网口，FDDI和令牌环接口上具有RA功能</span><br></pre></td></tr></table></figure>

<h4 id="使用RS请求RA"><a href="#使用RS请求RA" class="headerlink" title="使用RS请求RA"></a>使用RS请求RA</h4><p>PC可以主动发送RS来触发路由器，使得路由器发送RA，而不用等RA周期西行发送时间到了，PC才收到RA。为避免路由器请求消息在本地链路上泛滥，在启动时，每个节点只能发送3个RS消息。</p>
<p><img src="/_posts/16-IPV6/1619250087174-94a04773-dc11-4f3a-b70d-8b0ffc02b6d3.png" alt="img"></p>
<h3 id="调整ND参数"><a href="#调整ND参数" class="headerlink" title="调整ND参数"></a>调整ND参数</h3><ul>
<li><p>ipv6 nd ra-lifetime，配置RA消息的生存时间，默认参数为1800S；</p>
</li>
<li><p>ipv6 nd ra-interval，配置RA消息的通告间隔，这个时间应该小于或等于ra-lifetime，默认参数为200S；</p>
</li>
<li><p>ipv6 nd other-config-flag，如果配置了该命令，则主机使用DHCP配置除了IPV6地址以外的其他信息，如DNS，域名什么的，这个标志也与有状态自动配置有关，当它没有置位的情况下（默认情况没有置位），节点不应该使用有状态自动配置机制来配置除了IPV6地址以外的其他参数；</p>
</li>
<li><p>ipv6 nd managed-config-flag，配置这条命令后，该接口上的前缀信息将不能被链路上的主机用于无状态自动配置，主机必须使用有状态自动配置，例如DHCPV6来获取地址，默认情况下没有配置这条命令，也就是说，managed-config-flag为0，换而言之，主机在默认情况下可以通过无状态配置获取地址；</p>
</li>
</ul>
<p><img src="/_posts/16-IPV6/1619250287720-bdc663bb-e144-42f0-b782-ec7fca04e23c.png" alt="img"></p>
<h3 id="DAD"><a href="#DAD" class="headerlink" title="DAD"></a>DAD</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><p>DAD全称为Duplicate Address Detection，也就是重复地址检测，是在接口使用某个IPV6单播地址之前进行的，主要是为了探测是否有其他节点使用了该地址。这个机制用在无状态配置中，是节点启动时的一个NDP机制，用来保证节点准备启用的IPV6单播地址在链路上的唯一性，这个机制使用NS消息（ICMP 135），使用源地址（::），目的地址为获取到的V6地址对应的被请求节点组播地址的NS报文来完成这个任务，</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>一个地址在通过重复地址检测（DAD）之前称作Tentative地址，也就是实验地址，接口还暂时不能使用这个实验地址进行正常的单播通讯，但是会加入和tentative地址所对应的Solicited-Node组播组以及All-Nodes组播。</p>
<p>重复地址检测：IPV6的DAD和IPV4中的免费ARP类似，节点向实验地址所对应的Solicited-Node组播组发送NS报文，NS报文中目标地址即为该实验地址，如果收到某个其他站点回应的NA报文，就证明该地址已经被网络上其他设备使用，节点将不能使用该实验地址通信。如果1S后没有检测到冲突，会发送Non-Solicited advertisement（一个NA消息），宣告大家我将正式使用这个IPV6地址。</p>
<p><strong>一边检测情况：</strong></p>
<p><img src="/_posts/16-IPV6/1619253302149-d172e4fa-a6e5-4bf9-abe1-ec5337c10168.png" alt="img"></p>
<p>Host A的IPV6地址为FC00::1，为新配置地址，即FC00::1为Host A的实验地址，HostA向FC00::1的Solicited-Node组播组发送一个以FC00::1为请求的目标地址的NS报文进行重复地址检测，由于FC00::1并未正式指定，所以NS报文的源地址为未指定，当Host B收到该NS报文后，有两种处理方法：</p>
<ol>
<li>如果Host B发现FC00::1是自身的一个实验地址，则Host B放弃使用这个地址作为接口地址，并且不会发送NA报文；</li>
<li>如果Host B发现FC00::1是一个已经正常使用的地址，Host B会向FF02::1发送一个NA报文，该消息中会包含FC00::1。这样HostA收到这个NA消息后就会发现自身的实验地址是重复的，Host A上该实验地址不生效，被标记为Duplicated状态。</li>
</ol>
<p><strong>两边同时检测情况：</strong></p>
<p><img src="/_posts/16-IPV6/1619253630457-1e9ae7dc-835a-4311-a26f-810007c0dcac.png" alt="img"></p>
<ul>
<li>若两个节点配置相同地质，同时做重复地址检测时，该地址处于Tentative状态，当一方收到对方发出的DAD的NS时，则接收方将不启用该地址；</li>
<li>另一种极端的情况是，如果两端同时收到对端的NS报文，则两端都放弃该地址；</li>
</ul>
<h4 id="设置参数"><a href="#设置参数" class="headerlink" title="设置参数"></a>设置参数</h4><p>ipv6 nd dad attempts X：默认情况下，CISCO路由器启用DAD，在确定一个地址的唯一性之前，在本地链路上发送NS消息的个数为1，使用上述命令，能够修改NS消息的个数，如果配置为0则表示关闭DAD。</p>
<h3 id="前缀重新编制"><a href="#前缀重新编制" class="headerlink" title="前缀重新编制"></a>前缀重新编制</h3><p>前缀重新编制允许从以前的网络平稳过渡到新的前缀，站点内节点使用无状态自动配置（或者其他重新编制方法，但不如无状态自动配置的方法透明），这样可以使得在前缀重新编制过程中，对站点内的节点完成透明，也就是站点内节点完全‘无感知’或‘不知情’，部署的动作在路由器上完成，切换过程平滑。</p>
<p>路由器接口配置新、老两个前缀，并且都进行公告，老前缀的生存周期较短，这样站内的节点可以同时使用两个地址，当老前缀失效后，仅剩下新的前缀被使用，即可实现切换。</p>
<p>首先，站点中所有路由器继续公告当前的前缀（老前缀），但是有效和首选生存周期被减小到接近0的一个值，然后路由器开始在本地链路公告新的前缀，因此每个本地链路上至少有两个前缀存在，当旧的前缀被完全废止时（生存周期已过），路由器公告消息仅包括新前缀。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Ipv6 nd prefix 2001:0001::/64  43200  0       //老前缀</span><br><span class="line">Ipv6 nd prefix 2001:0002::/64  43200  43200  // 新前缀 </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">Ipv6 nd prefix 2001:0001::/64  at Jul 31 2012 23:59    Jul 20 2012 23:59  // 老前缀 </span><br><span class="line">Ipv6 nd prefix 2001:0002::/64  43200  43200  // 新前缀 </span><br></pre></td></tr></table></figure>

<h3 id="路由器重定向"><a href="#路由器重定向" class="headerlink" title="路由器重定向"></a>路由器重定向</h3><p>当网关设备发现报文从其他设备转发更好，它就会发送重定向报文，告知报文的发送者，让报文的发送者选择另一个网关设备。重新定向报文也承载在ICMPV6报文中，Type字段Wie137，报文中会携带更好的下一跳地址和需要重定向转发的报文的目的地址等信息。</p>
<p>在IPV6规范中，不推荐使用可聚合全球单播或本地站点地址作为下一跳地址，如果这样做，ICMPV6重新定向消息就不会工作。因此使用Linklocal地址作为下一跳，在某些场合可能更为推荐，毕竟Linklocal地址稳定且长久不变。在配置Linklocal地址作为下一跳IP时，必须关联路由器上相应的接口。</p>
<p><img src="/_posts/16-IPV6/1619336780678-6692f4e6-0253-4d8a-aa1a-685de937aa04.png" alt="img"></p>
<p>Host A要和Host B通信，A的默认网关设备是Router A，当Host A发送报文给Host B时，报文会被送到Router A，Router A收到HostA发送的报文后发现，实际上A直接发送给Router B更好，这时Router A会发送一个重定向报文给主机A，其中报文中更好的路径下一跳地址为Router B，Destination Address为Host B。主机A收到了重定向报文之后，会在默认路由表中添加一个主机地址，以后发往Host B的报文就直接发送给Router B。</p>
<p>当设备收到一个报文后，只有在如下情况下，设备会向报文发送者发送重定向报文：</p>
<ul>
<li><p>报文的目的地址不是一个组播地址；</p>
</li>
<li><p>报文并非通过路由转发给设备；</p>
</li>
<li><p>经过路由计算后，路由的下一跳出接口是接收报文的接口；</p>
</li>
<li><p>设备发现报文的最佳下一跳IP地址和报文的源IP地址处于同一网段；</p>
</li>
<li><p>设备检查报文的源地址，发现自身的邻居表项中有该地址作为全球单播地址或链路本地地址的邻居存在；</p>
</li>
</ul>
<h1 id="IPV6过渡技术"><a href="#IPV6过渡技术" class="headerlink" title="IPV6过渡技术"></a>IPV6过渡技术</h1><h2 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h2><p>由于现今无论是广域网如Internet，还是全球范围内的各种LAN，都是以IPV4居多，要切换到IPV6不可能一气呵成，这是一个总和政治、经济、政策、方法、环境等等因素的大问题，ipv4切换到V6需要一个相当长的时间，在这个过程中，势必会出现V4和V6共存的网络环境，接下去就研究V4到V6的平稳过渡技术。<strong>企业网中6to4 NAT用的比较多，ISP中一般都用6PE以及双栈。</strong></p>
<ul>
<li><p>双栈（Dual Stack）；</p>
</li>
<li><p>隧道（Tunnel）：手工隧道、自动隧道，6PE；</p>
</li>
<li><p>V6-V4协议转换；</p>
</li>
</ul>
<h2 id="双栈（Dual-Stack）"><a href="#双栈（Dual-Stack）" class="headerlink" title="双栈（Dual Stack）"></a>双栈（Dual Stack）</h2><p>网络中的主机、路由器或服务器等设备如果支持双栈（IPV4及IPV6协议栈），那么可以同时使用V4和V6的协议栈，简单来说也就是配一个IPV4的，再配一个IPV6的，这个路由器中同时又V4和V6的路由表。在双栈设备上，上层应用会优先选择IPV6协议栈，而不是IPV4。比如一个同事支持V4和V6的应用请求地址，会先请求AAAA记录，如果没有，则会再请求A记录。双栈可以在一个单一的设备上实现，也可以是一个双栈骨干网，对于双栈骨干网，其中的所有设备必须同时支持IPV4和IPV6协议栈，连接双栈网络的接口必须同时配置IPV4地址和IPV6地址。</p>
<p><img src="/_posts/16-IPV6/1619337856009-08ea477f-21bc-4729-8509-2330a4213614.png" alt="img"></p>
<h2 id="隧道（Tunnel）"><a href="#隧道（Tunnel）" class="headerlink" title="隧道（Tunnel）"></a>隧道（Tunnel）</h2><p>在V6发展的初期，必然有许多局部的纯IPV6网络，这些V6网络被V4骨干网络隔离起来，为了使这些鼓励的‘IPV6孤岛’互联起来，可以使用隧道技术的方式来解决。利用隧道将V6孤岛连接起来，逐步扩大IPV6的实现范围，这就是目前国际IPV6实验床6Bone的计划。</p>
<p>隧道（Tunnel）是一种封装技术，它利用一种网络协议来传输另一种网络协议，也就是利用一种网络传输协议，将其他协议产生的数据报文封装在自身的报文中，然后在网络中传输。隧道是一个虚拟的点对点的连接。一个Tunnel提供了一条使封装的数据报文能够传输的通路，并且在一个Tunnel的两端可以分别对数据报文进行封装及解封装。隧道技术就是指包括数据封装、传输和解封装在内的全过程，隧道技术是V4向V6过渡的一个重要手段。</p>
<p>在IPV6网络与IPV4网络间的隧道入口处，路由器将IPV6的数据分组封装入IPV4中，IPV4分组的源地址和目的地址分别是隧道入口和出口的IPV4地址，在隧道的出口处再将IPV6分组取出转发给目的节点。</p>
<p>隧道技术在实践中有四种具体形式，构造隧道，自动配置隧道，组播隧道以及6to4。</p>
<p>按大类分可以分为手动隧道和自动隧道：</p>
<p>手动隧道：边界设备不能自动获得隧道终点的IPV4地址，需要手工配置隧道终点的IPV4地址，报文才能正确发送至终点；</p>
<p>自动隧道：自动隧道边界设备可以自动获得隧道终点的IPV4地址，所以不需要手工配制终点的IPV4地址，一般的做法是隧道的两个接口的IPV6地址采用内嵌IPV4地址的特殊IPV6地址形式，这样路由设备可以从IPV6报文中的目的IPV6地址中提取出IPV4地址。</p>
<h3 id="V6-over-V4隧道"><a href="#V6-over-V4隧道" class="headerlink" title="V6 over V4隧道"></a>V6 over V4隧道</h3><p><img src="/_posts/16-IPV6/1619418880807-4eb6a947-36cc-4f90-a881-fdf21bd0e7c3.png" alt="img"></p>
<ul>
<li><p>边界设备启动V4/V6双栈协议，并配置IPV6 over IPV4隧道；</p>
</li>
<li><p>边界设备在收到IPV6网络侧发来的报文后，如果报文的目的地址不是自身，且下一跳出接口为Tunnel接口，就要把收到的IPV6报文作为数据部门，加上IPV4报头，封装成IPV4报文；</p>
</li>
<li><p>在IPV4网络中，封装后的报文被传递到对端的边界设备；</p>
</li>
<li><p>对端边界设备对报文解封装，去掉IPV4报头，然后将解封装后的IPV6报文发送到IPV6网络中；</p>
</li>
</ul>
<p>一个隧道要有一个起点和一个终点，起点和终点确定了以后，隧道也就可以确定了，IPV6 over IPV4隧道的起点的IPV4地址必须为手工配制，而终点的确定有手工配置和自动获取两种方式。根据隧道终点的IPV4地址的获取方式不同，可以将IPV6 over IPV4隧道分为手动隧道和自动隧道。</p>
<ul>
<li>手动隧道：手动隧道即边界设备不能自动获取隧道终点的IPV4地址，需要手工配置隧道终点的IPV4地址，报文才能正确发送至隧道终点；</li>
<li>自动隧道：自动隧道即边界设备能够自动获取隧道终点的IPV4地址，所以不需要手工配置终点的IPV4地址，只需要配置设备隧道的起点。一般做法是隧道的两个接口的IPV6地址，采用内嵌IPV4的特殊IPV6地址形式，这样路由设备可以从IPV6报文中的目的IPV6地址中提取出IPV4地址；</li>
</ul>
<h4 id="IPV6-over-IPV4-手工隧道"><a href="#IPV6-over-IPV4-手工隧道" class="headerlink" title="IPV6 over IPV4 手工隧道"></a>IPV6 over IPV4 手工隧道</h4><p><img src="/_posts/16-IPV6/1619419783574-4238d614-1403-4ab2-aa70-07c0c2243e2c.png" alt="img"></p>
<p>手动隧道会直接把IPV6报文封装到IPV4报文中去，IPV6报文作为IPV4报文的净载荷。手动隧道的源地址和目的地址也是手工指定的，它提供了一个点到点的连接。手动隧道可以建立在两个边界路由器之间，为IPV6网络（被IPV4网络分离开的）提供稳定的连接，或建立在终端系统与边界路由器之间为终端系统访问IPV6网络提供连接。隧道的边界设备必须支持IPV4/IPV6双栈协议。其他设备只需实现单协议栈即可。因为手动隧道要求在设备上手工配制隧道的源地址和目的地址，如果一个边界设备要与多个设备建立手动隧道，就需要在设备上配置多个隧道，配置比较麻烦，所以手动隧道通常用于两个边界路由器之间，为两个IPV6网络提供连接。</p>
<p>IPV6 over IPV4手动隧道的转发机制为：当隧道边界设备的IPV6侧收到一个IPV6报文后，根据IPV6报文的目的地址查找IPV6路由转发表，如果这个收到的V6报文是从虚拟接口转发出去的，则根据隧道接口配置的隧道源端和目的端的IPV4地址进行封装。封装后变为一个IPV4报文，交给IPV4协议栈处理。报文通过IPV4网络转发到隧道的终点。隧道终点收到一个隧道协议报文后，进行隧道解封装，然后将解封装的报文交给IPV6协议栈处理。</p>
<h4 id="IPV6-over-IPV4-GRE隧道"><a href="#IPV6-over-IPV4-GRE隧道" class="headerlink" title="IPV6 over IPV4 GRE隧道"></a>IPV6 over IPV4 GRE隧道</h4><p><img src="/_posts/16-IPV6/1619420395161-2a917d96-5d50-4b16-8f96-ecb553190195.png" alt="img"></p>
<p>IPV6 over IPV4 GRE隧道使用标准的GRE隧道技术提供了点到点的连接服务，需要手工指定隧道的端点地址。GRE隧道本身并不限制封装的协议和传输协议，一个GRE隧道中被封装的协议可以是协议允许的任何协议，比如IPV4、IPV6、MPLS等。</p>
<p>IPV6 over IPV4 GRE隧道的传输机制和IPV6 over IPV4手动隧道相同。</p>
<h4 id="IPV4兼容IPV6自动隧道"><a href="#IPV4兼容IPV6自动隧道" class="headerlink" title="IPV4兼容IPV6自动隧道"></a>IPV4兼容IPV6自动隧道</h4><p>IPV4兼容IPV6自欧东隧道，承载的IPV6报文的目的地址（即自动隧道使用的特殊地址）是IPV4兼容IPV6地址。IPV4兼容IPV6地址的前96位全部为0，后32位为IPV4地址，具体格式如下：</p>
<p><img src="/_posts/16-IPV6/1619421086054-ce3a9319-c032-4183-82af-18d50e804550.png" alt="img"></p>
<p>转发机制如下：</p>
<p><img src="/_posts/16-IPV6/1619421106327-21bfbe49-1130-4268-89e8-b4ec1ac65ee5.png" alt="img"></p>
<p>需要经过Router A发送给Router B的IPV6报文到达Router A以后，以目的地址::2.1.1.1查找IPV6路由，发现下一跳为Tunnel接口。由于Router 上的配置隧道的类型是IPV4兼容IPV6自动隧道。于是Router A对IPV6报文进行了封装。封装的时候IPV6报文被封装为IPV4报文，IPV4报文中的源地址为起点地址1.1.1.1，而目的IP地址直接从IPV4兼容IPV6地址::2.1.1.1的后32位拷贝过来即2.1.1.1。这个报文被路由器从隧道口发出后，在IPV4的网络中，被路由转发到目的地址2.1.1.1，也就是RouterB。Router B收到报文后，进行解封装，把其中的IPV6报文取出，送给IPV6协议栈进行处理，Router B返回Router A的报文也是按照这个过程来进行的。</p>
<p>如果IPV4兼容IPV6地址中的IPV4地址是广播、组播、网络广播、出接口的子网广播、全0、环回等地址，则该IPV6报文被丢弃，不会进行隧道封装处理。</p>
<p><strong>由于IPV4兼容IPV6隧道要求每一个主机都要有一个合法的IP地址，而且通讯的主机要支持双栈、支持IPV4兼容IPV6隧道，不适合大面积部署，目前该技术已经被6to4隧道所替代</strong>。</p>
<h4 id="6to4隧道"><a href="#6to4隧道" class="headerlink" title="6to4隧道"></a>6to4隧道</h4><p>6to4隧道也属于一种自动隧道，隧道也是适用内嵌在IPV6地址中的IPV4地址建立的，与IPV4兼容自动隧道不同，6to4自动隧道支持Router到Router、Host到Router、Router到Host、Host到Host。这是因为6to4地址是用IPV4地址做为网络标识，格式如下：</p>
<p><img src="/_posts/16-IPV6/1619422914398-f59e337d-0564-44ca-9f8f-fb294d111a82.png" alt="img"></p>
<ul>
<li><p>FP：可聚合全球单播地址的格式前缀（Format Prefix），其值为001；</p>
</li>
<li><p>TLA：顶级聚合标识符（Top Level Aggregator），其值为0X0002；</p>
</li>
<li><p>SLA：站点级聚合标识符（Site Level Aggregator）</p>
</li>
</ul>
<p>6to4地址可以表示为2002::/16，而一个6to4网络可以表示为2002:IPV4地址::/48。6to4地址的网络前缀长度为64bit，其中前48bit（2002:a.b.c.d）被分配给路由器上的IPV4地址决定了，用户不能改变，后16位（SLA）是由用户自己定义的。</p>
<p>6to4隧道的封装和转发过程如下：</p>
<p><img src="/_posts/16-IPV6/1619423156892-00ae0107-7d9b-424f-ba6a-5ea27a10d419.png" alt="img"></p>
<p>一个IPV4地址只能用于一个6to4隧道的源地址，如果一个边界设备连接了多个6to4网络使用同样的IPV4地址作为隧道的源地址，则使用6to4地址中的SLA ID来区分，但他们公用一个隧道。如下所示：</p>
<p><img src="/_posts/16-IPV6/1619423292132-252703fb-68f9-4926-ac52-de2383cb2ccf.png" alt="img"></p>
<p>随着IPV6网络的发展，普通IPV6网络需要与6to4网络通过IPV4网络互联互通，这样可以通过6to4中继路由方式实现。所谓6to4中继，就是通过6to4隧道转发的IPV6报文的目的地址不是6to4地址，但转发的下一跳是6to4地址，该下一跳路由器我们称之为6to4中继。隧道的IPV4目的地址依然从下一跳的6to4地址中获得。6to4中继示意图如下所示：</p>
<p><img src="/_posts/16-IPV6/1619423439268-e58abffc-98aa-4e6a-9fc7-09f1fd818522.png" alt="img"></p>
<p>如果6to4网络2中的主机要与IPV6网络互通，在其边界路由器上配置路由指向的下一跳为6to4中继路由器的6to4地址，中继路由器的6to4地址是与中继路由器的6to4隧道的源地址相匹配的。6to4网络2中去往普通IPv6网络的报文都会按照路由表指示的下一跳发送到6to4中继路由器。6to4中继路由器再将此报文转发到纯IPv6网络中去。当报文返回时，6to4中继路由器根据返回报文的目的地址（为6to4地址）进行IPv4报文头封装，数据就能够顺利到达6to4网络中了。</p>
<h4 id="ISATAP隧道"><a href="#ISATAP隧道" class="headerlink" title="ISATAP隧道"></a>ISATAP隧道</h4><p>ISATAP（Intra-Site Automatic Tunnel Addressing Protocol）是另外一种自动隧道技术。ISATAP隧道同样使用了内嵌IPv4地址的特殊IPv6地址形式，只是和6to4不同的是，6to4是使用IPv4地址做为网络前缀，而ISATAP用IPv4地址做为接口标识。其接口标识符格式如下图所示：</p>
<p><img src="/_posts/16-IPV6/1619423843637-bbf404ed-cbbd-4d8f-b75b-7336675d0d05.png" alt="img"></p>
<p>如果IPv4地址是全局唯一的，则u位为1，否则u位为0。g位是IEEE群体/个体标志。由于ISATAP是通过接口标识来表现的，所以，ISATAP地址有全局单播地址、链路本地地址、ULA地址、组播地址等形式。ISATAP地址的前64位是通过向ISATAP路由器发送请求来得到的，它可以进行地址自动配置。在ISATAP隧道的两端设备之间可以运行ND协议。ISATAP隧道将IPv4网络看作一个非广播的点到多点的链路（NBMA）。</p>
<p>ISATAP过渡机制允许在现有的IPv4网络内部署IPv6，该技术简单而且扩展性很好，可以用于本地站点的过渡。ISATAP支持IPv6站点本地路由和全局IPv6路由域，以及自动IPv6隧道。ISATAP同时还可以与NAT结合，从而可以使用站点内部非全局唯一的IPv4地址。典型的ISATAP隧道应用是在站点内部，所以，其内嵌的IPv4地址不需要是全局唯一的。</p>
<p>下图为ISATAP隧道一个典型应用场景：</p>
<p><img src="/_posts/16-IPV6/1619423858735-900ad4ce-9a62-44dd-893b-984bdeaf8449.png" alt="img"></p>
<p>如上图所示，在IPv4网络内部有两个双栈主机Host B和Host C，它们分别有一个私网IPv4地址。要使其具有ISATAP功能，需要进行如下操作：</p>
<ol>
<li><p>首先配置ISATAP隧道接口，这时会根据IPv4地址生成ISATAP类型的接口ID。</p>
</li>
<li><p>根据接口ID生成一个ISATAP链路本地IPv6地址，生成链路本地地址以后，主机就有了在本地链路上进行IPv6通信的能力。</p>
</li>
<li><p>进行自动配置，主机获得IPv6全球单播地址、ULA地址等。</p>
</li>
<li><p>当主机与其它IPv6主机进行通讯时，从隧道接口转发，将从报文的下一跳IPv6地址中取出IPv4地址作为IPv4封装的目的地址。如果目的主机在本站点内，则下一跳就是目的主机本身，如果目的主机不在本站点内，则下一跳为ISATAP路由器的地址。</p>
</li>
</ol>
<h3 id="V4-over-V6隧道"><a href="#V4-over-V6隧道" class="headerlink" title="V4 over V6隧道"></a>V4 over V6隧道</h3><p>利用隧道技术可以在IPv6网络上创建隧道，从而实现IPv4孤岛的互联，IPv4孤岛能通过IPv6公网访问其他IPv4网络。</p>
<p>在IPv4 Internet向IPv6 Internet过渡的后期，IPv6网络已被大量部署，此时可能出现IPv4孤岛。利用隧道技术可在IPv6网络上创建隧道，从而实现IPv4孤岛的互连。这类似于在IP网络上利用隧道技术部署VPN。在IPv6网络上用于连接IPv4孤岛的隧道，称为IPv4 over IPv6隧道。</p>
<p>IPv4 over IPv6隧道技术原理如下图:</p>
<p><img src="/_posts/16-IPV6/1619423922336-095c49c1-09f9-475b-acc5-6f470bc461dc.png" alt="img"></p>
<ol>
<li><p>边界设备启动IPv4/IPv6双协议栈，并配置IPv4 over IPv6隧道。</p>
</li>
<li><p>边界设备在收到从IPv4网络侧发来的报文后，如果报文的目的地址不是自身，就要把收到的IPv4报文作为负载，加上IPv6报文头，封装到IPv6报文里。</p>
</li>
<li><p>在IPv6网络中，封装后的报文被传递到对端的边界设备。</p>
</li>
<li><p>对端边界设备对报文解封装，去掉IPv6报文头，然后将解封装后的IPv4报文发送到IPv4网络。</p>
</li>
</ol>
<h1 id="单协议过渡技术"><a href="#单协议过渡技术" class="headerlink" title="单协议过渡技术"></a>单协议过渡技术</h1><h1 id="路由选择"><a href="#路由选择" class="headerlink" title="路由选择"></a>路由选择</h1><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ipv6 route 目的IPv6网络/前缀长度 &#123; 出接口 | 下一跳IP &#125; </span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line">Router(config)# ipv6 route 2222::/64 E0/0 FE80::CE00:1AFF:FEE4:0</span><br></pre></td></tr></table></figure>

<p>在配置IPV6静态路由时，不推荐使用可聚合全球单播地址或本地站点地址作为下一跳地址，如果这样做，ICMPV6重定向消息就不会工作，因此使用Linklocal地址作为下一跳，在某些场合可能更为推荐，毕竟Linklocal地址稳定且长久不变。在配置Linklocal地址作为下一跳IP时，必须关联路由器上相应的出接口，例如上面的配置那样。</p>
<h2 id="RIPNG"><a href="#RIPNG" class="headerlink" title="RIPNG"></a>RIPNG</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><ul>
<li><p>使用UDP521，也就是说源UDP端口及目的UDP端口都是521；</p>
</li>
<li><p>RIP的最大跳数依然是15跳；</p>
</li>
<li><p>携带的网络前缀是128bit，而不是32bit；</p>
</li>
<li><p>下一跳地址是128bit；</p>
</li>
<li><p>使用Linklocal地址作为协议数据包的源地址，发送RIPng消息到邻接RIPng路由器，使用FF02::9作为RIPng更新的目标地址；</p>
</li>
<li><p>Distance默认为120；</p>
</li>
</ul>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p><em><strong>激活RIPng进程及接口</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router(config)# ipv6 router rip NAME</span><br><span class="line">router(config)# interface E0/0</span><br><span class="line">router(config-if)# ipv6 router rip NAME enable</span><br></pre></td></tr></table></figure>

<p>注意，进程名本地有效，如果Router的两个接口分别启动RIPng用的是两个不同的进程名，则两个进程相互独立。</p>
<p><em>默认路由传递</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ipv6 rip 1 default-information originate</span><br><span class="line">ipv6 rip 1 default-information only</span><br></pre></td></tr></table></figure>

<p>第一条命令重发布默认路由进RIP进程，本地无需配置静态默认路由；</p>
<p>第二条命令只发布默认路由，禁止发布其他路由信息。</p>
<p><em>调整RIPng进程</em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-rtr)# distance X</span><br></pre></td></tr></table></figure>

<p>修改RIPng管理距离，默认管理距离AD为120</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-rtr)# distribute-list prefix-list XXX&#123;in | out&#125;[interface]</span><br></pre></td></tr></table></figure>

<p>对某个RIPng接口发送或接收路由更新动作执行分发列表，比如跟In或out方向，接口可选，如果不配置接口则在所有接口生效</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-rtr)# timers update expire holddown garbage-collect  </span><br></pre></td></tr></table></figure>

<p>修改计时器，默认update 为30秒，expire为180秒，holddown默认为0秒，也就是不适用抑制，garbage-collect默认为120秒</p>
<h2 id="OSPFV3"><a href="#OSPFV3" class="headerlink" title="OSPFV3"></a>OSPFV3</h2><h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><p>V2和V3相同部分：</p>
<ul>
<li><p>使用相同的基本数据类型，如Hello，DBD，LSR、LSU和LAS；</p>
</li>
<li><p>邻居发现和邻接关系形成机制是相同的；</p>
</li>
<li><p>支持在遵循RFC的NBMA和点到多点拓扑模式上的OSPFV3操作，OSPFV3也支持CISCO的其他模式，例如点到点等；</p>
</li>
<li><p>LSA泛洪和衰老机制是相同的；</p>
</li>
</ul>
<p>不同之处：</p>
<ul>
<li><p>OSPFV3运行在链路上，每条链路可以有多个OSPFV3实例；</p>
</li>
<li><p>OSPFV3的Router ID还是32bit的，如果路由器上没有配置IPV4地址，则在OSPFV3进程中需手动指定Router ID；</p>
</li>
<li><p>Link ID在OSPFV3中仍然是32bit的；</p>
</li>
<li><p>OSPFV3使用IPV6 Linklocal地址标识OSPFV3邻接的邻居；</p>
</li>
<li><p>新的LSA类型有两种，分别是链路LSA（LSA类型0X008）和区内前缀LSA（LSA类型0X2009）；</p>
</li>
<li><p>每条链路都有一个链路LSA，这个新类型提供了路由器的本地链路地址，并列出了链路的所有IPV6前缀；</p>
</li>
<li><p>OSPFV3使用组播地址：FF02::5及FF02::6；</p>
</li>
<li><p>在认证方面，不适用OSPFV2定义的认证方法，而是使用AH及ESP扩展头部作为安全机制；</p>
</li>
</ul>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>IPV6报头中的协议号仍然为89，OSPFv3的报头将V2中的认证字段都去掉了，因为IPV6报头已经有了很好的认证功能</p>
<p>Option字段变成了24位，出现在Hello包、DBD包、Router LSA、network LSA、interAreaRouter LSA、Link LSA中，这些字段都有特殊的用途。</p>
<p><img src="/_posts/16-IPV6/1619427632200-ebb683d1-d4f6-4940-b23c-56727d21a42a.png" alt="img"></p>
<p><img src="/_posts/16-IPV6/1619427654395-11aa3998-3258-4695-a37b-5480cc6b98fc.png" alt="img"></p>
<p><img src="/_posts/16-IPV6/1619427656692-1ef32206-dca7-425e-91b0-6ec1fda6b134.png" alt="img"></p>
<h3 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h3><p>启动OSPFV3进程，XX为OSPF进程号：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ipv6 router ospf XX</span><br></pre></td></tr></table></figure>

<p>指定OSPF的Router ID，长度为32bit：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-router)# router-id x.x.x.x</span><br></pre></td></tr></table></figure>

<p>路由汇总：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-router)# area XX range YYYY</span><br></pre></td></tr></table></figure>

<p>在接口上激活OSPF V3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config-if)# ipv6 ospf X area YY</span><br></pre></td></tr></table></figure>

<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/_posts/16-IPV6/1619492786124-ea4d9d63-1d07-4462-a842-807719b48412.png" alt="img"></p>
<h4 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h4><ul>
<li><p>完成基本IP配置；</p>
</li>
<li><p>根据如图所示运行OSPFV3；</p>
</li>
<li><p>对Area 1内的IPV6前缀进行汇总；</p>
</li>
<li><p>减少路由条目；</p>
</li>
<li><p>对R4重发布进来的IPV6前缀进行汇总，减少路由条目；</p>
</li>
</ul>
<h4 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Loopback1</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2001:1:1::1/64</span><br><span class="line"> ipv6 ospf 1 area 1</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2001:1:2::1/64</span><br><span class="line"> ipv6 ospf 1 area 1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:12::1/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 1</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:12::2/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:23::2/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:23::3/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:34::3/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 2</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Loopback0</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2004:1:1::1/64</span><br><span class="line"> ipv6 address 2004:1:2::1/64</span><br><span class="line"> ipv6 enable</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2001:34::4/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 2</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> redistribute connected  #重发布直连路由</span><br><span class="line">R4上之所以重发布直连路由，是因为在拓扑中这两个网段是在OSPF以外的外部路由</span><br></pre></td></tr></table></figure>

<p>基本配置完成后，在各设备上show 路由表以及邻居看邻居是否建立完毕，由于2004:1:1::/64以及2004:1:2::/64两个网段是外部重发布进OSPF的所以路由属性为OE2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line">R1#show ipv6 ospf neighbor</span><br><span class="line"></span><br><span class="line">            OSPFv3 Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Interface ID    Interface</span><br><span class="line">2.2.2.2           1   FULL/DR         00:00:32    3               Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show ipv6 route ospf</span><br><span class="line">IPv6 Routing Table - default - 11 entries</span><br><span class="line">Codes: C - Connected, L - Local, S - Static, U - Per-user Static route</span><br><span class="line">       B - BGP, HA - Home Agent, MR - Mobile Router, R - RIP</span><br><span class="line">       H - NHRP, I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea</span><br><span class="line">       IS - ISIS summary, D - EIGRP, EX - EIGRP external, NM - NEMO</span><br><span class="line">       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect</span><br><span class="line">       RL - RPL, O - OSPF Intra, OI - OSPF Inter, OE1 - OSPF ext 1</span><br><span class="line">       OE2 - OSPF ext 2, ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2</span><br><span class="line">       la - LISP alt, lr - LISP site-registrations, ld - LISP dyn-eid</span><br><span class="line">       lA - LISP away, a - Application</span><br><span class="line">OI  2001:23::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2000, Ethernet0/0</span><br><span class="line">OI  2001:34::/64 [110/30]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2000, Ethernet0/0</span><br><span class="line">OE2 2004:1:1::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2000, Ethernet0/0</span><br><span class="line">OE2 2004:1:2::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2000, Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">R2# show ipv6 ospf neighbor</span><br><span class="line"></span><br><span class="line">            OSPFv3 Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Interface ID    Interface</span><br><span class="line">3.3.3.3           1   FULL/BDR        00:00:33    3               Ethernet0/1</span><br><span class="line">1.1.1.1           1   FULL/BDR        00:00:31    3               Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2#show ipv6 route ospf</span><br><span class="line">IPv6 Routing Table - default - 9 entries</span><br><span class="line">Codes: C - Connected, L - Local, S - Static, U - Per-user Static route</span><br><span class="line">       B - BGP, HA - Home Agent, MR - Mobile Router, R - RIP</span><br><span class="line">       H - NHRP, I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea</span><br><span class="line">       IS - ISIS summary, D - EIGRP, EX - EIGRP external, NM - NEMO</span><br><span class="line">       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect</span><br><span class="line">       RL - RPL, O - OSPF Intra, OI - OSPF Inter, OE1 - OSPF ext 1</span><br><span class="line">       OE2 - OSPF ext 2, ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2</span><br><span class="line">       la - LISP alt, lr - LISP site-registrations, ld - LISP dyn-eid</span><br><span class="line">       lA - LISP away, a - Application</span><br><span class="line">O   2001:1:1::1/128 [110/10]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:1000, Ethernet0/0</span><br><span class="line">O   2001:1:2::1/128 [110/10]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:1000, Ethernet0/0</span><br><span class="line">OI  2001:34::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3000, Ethernet0/1</span><br><span class="line">OE2 2004:1:1::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3000, Ethernet0/1</span><br><span class="line">OE2 2004:1:2::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3000, Ethernet0/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">R3#show ipv6 ospf neighbor</span><br><span class="line"></span><br><span class="line">            OSPFv3 Router with ID (3.3.3.3) (Process ID 1)</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Interface ID    Interface</span><br><span class="line">2.2.2.2           1   FULL/DR         00:00:39    4               Ethernet0/0</span><br><span class="line">4.4.4.4           1   FULL/DR         00:00:35    3               Ethernet0/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">IPv6 Routing Table - default - 10 entries</span><br><span class="line">Codes: C - Connected, L - Local, S - Static, U - Per-user Static route</span><br><span class="line">       B - BGP, HA - Home Agent, MR - Mobile Router, R - RIP</span><br><span class="line">       H - NHRP, I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea</span><br><span class="line">       IS - ISIS summary, D - EIGRP, EX - EIGRP external, NM - NEMO</span><br><span class="line">       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect</span><br><span class="line">       RL - RPL, O - OSPF Intra, OI - OSPF Inter, OE1 - OSPF ext 1</span><br><span class="line">       OE2 - OSPF ext 2, ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2</span><br><span class="line">       la - LISP alt, lr - LISP site-registrations, ld - LISP dyn-eid</span><br><span class="line">       lA - LISP away, a - Application</span><br><span class="line">OI  2001:1:1::1/128 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2010, Ethernet0/0</span><br><span class="line">OI  2001:1:2::1/128 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2010, Ethernet0/0</span><br><span class="line">OI  2001:12::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:2010, Ethernet0/0</span><br><span class="line">C   2001:23::/64 [0/0]</span><br><span class="line">     via Ethernet0/0, directly connected</span><br><span class="line">L   2001:23::3/128 [0/0]</span><br><span class="line">     via Ethernet0/0, receive</span><br><span class="line">C   2001:34::/64 [0/0]</span><br><span class="line">     via Ethernet0/1, directly connected</span><br><span class="line">L   2001:34::3/128 [0/0]</span><br><span class="line">     via Ethernet0/1, receive</span><br><span class="line">OE2 2004:1:1::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:4000, Ethernet0/1</span><br><span class="line">OE2 2004:1:2::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:4000, Ethernet0/1</span><br><span class="line">L   FF00::/8 [0/0]</span><br><span class="line">     via Null0, receive</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show ipv6 ospf nei</span><br><span class="line"></span><br><span class="line">            OSPFv3 Router with ID (4.4.4.4) (Process ID 1)</span><br><span class="line"></span><br><span class="line">Neighbor ID     Pri   State           Dead Time   Interface ID    Interface</span><br><span class="line">3.3.3.3           1   FULL/BDR        00:00:31    4               Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show ipv6 route ospf</span><br><span class="line">IPv6 Routing Table - default - 11 entries</span><br><span class="line">Codes: C - Connected, L - Local, S - Static, U - Per-user Static route</span><br><span class="line">       B - BGP, HA - Home Agent, MR - Mobile Router, R - RIP</span><br><span class="line">       H - NHRP, I1 - ISIS L1, I2 - ISIS L2, IA - ISIS interarea</span><br><span class="line">       IS - ISIS summary, D - EIGRP, EX - EIGRP external, NM - NEMO</span><br><span class="line">       ND - ND Default, NDp - ND Prefix, DCE - Destination, NDr - Redirect</span><br><span class="line">       RL - RPL, O - OSPF Intra, OI - OSPF Inter, OE1 - OSPF ext 1</span><br><span class="line">       OE2 - OSPF ext 2, ON1 - OSPF NSSA ext 1, ON2 - OSPF NSSA ext 2</span><br><span class="line">       la - LISP alt, lr - LISP site-registrations, ld - LISP dyn-eid</span><br><span class="line">       lA - LISP away, a - Application</span><br><span class="line">OI  2001:1:1::1/128 [110/30]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3010, Ethernet0/0</span><br><span class="line">OI  2001:1:2::1/128 [110/30]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3010, Ethernet0/0</span><br><span class="line">OI  2001:12::/64 [110/30]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3010, Ethernet0/0</span><br><span class="line">OI  2001:23::/64 [110/20]</span><br><span class="line">     via FE80::A8BB:CCFF:FE00:3010, Ethernet0/0</span><br></pre></td></tr></table></figure>

<p>接下来在R1上对两条路由进行汇总：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> area 1 range 2001:1::/32</span><br></pre></td></tr></table></figure>

<p>再到R4上对其自身重发布进来的外部路由做汇总：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line">  summary-prefix 2004:1::/32</span><br></pre></td></tr></table></figure>

<h2 id="MP-BGP"><a href="#MP-BGP" class="headerlink" title="MP-BGP"></a>MP-BGP</h2><h3 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h3><p>BGP4+，也叫作多协议BGP，扩展BGP-4规范以支持注入IPV6\IPX\VPN等这样的新地址簇，之前只有默认的IPV4地址簇，因此BGP4+能够为IPV6和包括IPV4在内的其他协议携带路由选择信息，RFC2858和RFC2545定义了在BGP4+中处理IPV6而更新的属性，例如：</p>
<ul>
<li>Next_HOP：表示为IPV6地址，或者是一个可聚合全球单播地址及其下一跳的本地链路地址；</li>
<li>NLRI：是一组目的地，表示为一个IPV6前缀；</li>
</ul>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/_posts/16-IPV6/1619510074097-1db382ae-c0b0-405d-be28-bc0edb37f112.png" alt="img"></p>
<p>实验目标：</p>
<ul>
<li><p>R1、R2处于AS12，AS内运行OSPFV3，使得R1和R2能够学习到对方的Loopback路由；</p>
</li>
<li><p>R1、R2建立IPV6的IBGP邻居关系（基于Loopback接口）；</p>
</li>
<li><p>R2、R3建立IPV6的EBGP邻居关系，R3重发布直连路由，使得R1和R2能够学习到；</p>
</li>
</ul>
<p>实验配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Loopback0</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2001::1/128</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2012::1/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2002::2 remote-as 12</span><br><span class="line"> neighbor 2002::2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family ipv6</span><br><span class="line">  neighbor 2002::2 activate</span><br><span class="line">  neighbor 2002::2 next-hop-self</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Loopback0</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2002::2/128</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2012::2/64</span><br><span class="line"> ipv6 enable</span><br><span class="line"> ipv6 ospf 1 area 0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2023::2/64</span><br><span class="line"> ipv6 enable</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2001::1 remote-as 12</span><br><span class="line"> neighbor 2001::1 update-source Loopback0</span><br><span class="line"> neighbor 2023::3 remote-as 300</span><br><span class="line"> !</span><br><span class="line"> address-family ipv6</span><br><span class="line">  neighbor 2001::1 activate</span><br><span class="line">  neighbor 2001::1 next-hop-self</span><br><span class="line">  neighbor 2023::3 activate</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ipv6 router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">Ipv6 unicast-routing  </span><br><span class="line">！</span><br><span class="line">interface Loopback0</span><br><span class="line"> no ip address</span><br><span class="line"> ipv6 address 2003::3/128</span><br><span class="line"> ipv6 enable</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line"> ipv6 address 2023::3/64</span><br><span class="line"> ipv6 enable</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv6-nexthop</span><br><span class="line"> neighbor 2023::2 remote-as 12</span><br><span class="line"> !</span><br><span class="line"> address-family ipv6</span><br><span class="line">  redistribute connected</span><br><span class="line">  neighbor 2023::2 activate</span><br><span class="line"> exit-address-family</span><br></pre></td></tr></table></figure>

<p>必须得配置‘no bgp default ipv4-unicast’命令，如果不配置此命令，则一旦指定BGP邻居后，会默认建立IPV4邻居，本实验中路由器之间不传递IPV4前缀，因此无需IPV4的连接，直接NO掉；</p>
<p>R3上的‘redistribute connected’命令是为了将在AS300外的路由引入BGP中，然后传递给R1；</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-router-af)#do show ip bgp all</span><br><span class="line">For address family: IPv4 Unicast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For address family: IPv6 Unicast</span><br><span class="line"></span><br><span class="line">BGP table version is 3, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  2003::3/128      2002::2                  0    100      0 300 ?</span><br><span class="line"> *&gt;i  2023::/64        2002::2                  0    100      0 300 ?</span><br><span class="line"></span><br><span class="line">For address family: IPv4 Multicast</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For address family: L2VPN E-VPN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">For address family: MVPNv4 Unicast</span><br></pre></td></tr></table></figure>

<p>最后R1收到了R3上的2003::3/128，而且为最优，因为R1和R2互指了Next hop self。</p>
<h4 id="特别说明"><a href="#特别说明" class="headerlink" title="特别说明"></a>特别说明</h4><p><img src="/_posts/16-IPV6/1619575691823-e432d92c-d99b-4285-a9e8-3b4d2cdb3f21.png" alt="img"></p>
<p>某些环境下，可以使用Linklocal地址来建立BGP邻接关系，这样做的好处之一是，无需为链路分配可聚合全球IP地址。在BGP中使用Linklocal地址有一些注意事项，例如要确定目的Linklocal地址相对应的路由器物理接口，因为Linklocal地址只是本地有效。还有一个是结合Route-map修改Next_hop属性。但现网中一般不这么做。</p>
<h1 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h1><h1 id="IPV6组播"><a href="#IPV6组播" class="headerlink" title="IPV6组播"></a>IPV6组播</h1><h1 id="6PE及6VPE"><a href="#6PE及6VPE" class="headerlink" title="6PE及6VPE"></a>6PE及6VPE</h1><h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="http://www.tcpipguide.com/free/t_IPv6DatagramExtensionHeaders-2.htm">The TCP/IP Guide</a></p>
<p><a href="https://blog.csdn.net/u011784495/article/details/71693296">IPv6数据报头部格式</a></p>
<p><a href="https://blog.51cto.com/u_7658423/1340751">理解ICMPv6前缀请求与前缀公告消息</a></p>
<p><a href="https://cshihong.github.io/2018/01/29/IPv6%E9%82%BB%E5%B1%85%E5%8F%91%E7%8E%B0%E5%8D%8F%E8%AE%AE/">IPv6邻居发现协议</a></p>
<p><a href="https://cshihong.github.io/2018/01/30/IPv6%E8%BF%87%E6%B8%A1%E6%8A%80%E6%9C%AF/">IPv6过渡技术</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>17-MPLS</title>
    <url>/2022/01/20/17-MPLS/</url>
    <content><![CDATA[<p>本文大部分照搬自红茶三杯的MPLS笔记。</p>
<h1 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h1><h2 id="为什么需要MPLS"><a href="#为什么需要MPLS" class="headerlink" title="为什么需要MPLS"></a>为什么需要MPLS</h2><p><img src="/2022/01/20/17-MPLS/1612855500904-e6c4dfc1-1c43-4cc6-9f35-424b83a18385.png" alt="img"></p>
<p>让我们用上面这个拓扑举个简单的例子，图中一个ISP为两家公司，公司A和公司B提供互联网连接服务以外没有其他服务，公司A和公司B通过ISP和在另一个位置的公司分支机构进行连接。</p>
<p>为了实现客户‘总部和分支机构互联’的需求，ISP的PE（Provider Edge，运营商边缘路由器）路由器采用EBGP方式和客户的CE（Customer Edge，客户边缘路由器）路由器进行连接，这意味着ISP运营商的P（Provider，运营商骨干路由器只负责穿越流量）路由器必须运行BGP协议并形成IBGP邻居才能获取到客户A、客户B的路由前缀，否则没法为客户两端的互联提供服务。如果中间的P路由器也运行BGP协议的话，中间的P路由器需要交换至少50万条路由且P路由器之间必须两两形成IBGP邻居，虽然使用路由反射器（Route-Reflector）能够减少IBGP邻居的数量，但所有P路由器在查找路由表时，必须在50万条路由中进行查找，这种解决方案肯定不是最优的。</p>
<p>既然最终的目的仅仅是让两端客户能够维持连通性，那么不让中间的P路由器知道这些路由也可以达到同样的目的。因为只要和客户CE连接的PE设备只要如何传递数据就可以了，核心部分的P路由器并不需要知道，比如可以在PE之间建立GRE隧道，比如：</p>
<p><img src="/2022/01/20/17-MPLS/1612947312984-13eda048-6cf5-492d-81c1-dfd7b8bdfc26.png" alt="img"></p>
<p>在上图中，位于上面的两台PE会使用GRE隧道，联通公司A，位于下面的两台PE也会使用GRE隧道，联通公司B。这样配置的话，中间的P路由器就不用运行BGP协议，而只需要在PE上和CE路由器形成EBGP邻居，PE路由器之间形成IBGP邻居即可，让我们来通过一个实验验证一下上面的做法是否可行，下面的拓扑是上面拓扑的简化版，只有一个客户的两个分支机构，将配置PE1和PE2之间的GRE隧道，使得P路由器不用运行BGP协议。</p>
<p><img src="/2022/01/20/17-MPLS/1612947862078-646e3271-b557-4ba4-9ce5-bc4c86131546.png" alt="img"></p>
<p><strong>OSPF配置</strong></p>
<p>使用OSPF协议作为ISP内部互联的协议，配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P：</span><br><span class="line"></span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.34.3 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE1：</span><br><span class="line"></span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.45.5 remote-as 20</span><br></pre></td></tr></table></figure>

<p><strong>EBGP配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.12.1 remote-as 10</span><br><span class="line"></span><br><span class="line">CE1：</span><br><span class="line"></span><br><span class="line">router bgp 10</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.12.2 remote-as 1234</span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.45.5 remote-as 20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2：</span><br><span class="line"></span><br><span class="line">router bgp 20</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 5.5.5.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.45.4 remote-as 1234</span><br></pre></td></tr></table></figure>

<p><strong>GRE隧道配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line"></span><br><span class="line">PE1(config)#interface tunnel 0</span><br><span class="line">PE1(config-if)#tunnel source 2.2.2.2</span><br><span class="line">PE1(config-if)#tunnel destination 4.4.4.4</span><br><span class="line">PE1(config-if)#ip address 192.168.24.2 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line"></span><br><span class="line">PE2(config)#interface tunnel 0</span><br><span class="line">PE2(config-if)#tunnel source 4.4.4.4</span><br><span class="line">PE2(config-if)#tunnel destination 2.2.2.2</span><br><span class="line">PE2(config-if)#ip address 192.168.24.4 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这里使用了GRE隧道技术，当然这里用任何的VPN隧道技术都是可以的，比如IP-IN-IP或Q-in-Q都是没问题的</p>
<p><strong>IBGP配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 192.168.24.4 remote-as 1234</span><br><span class="line"> neighbor 192.168.24.4 next-hop-self</span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> neighbor 192.168.24.2 next-hop-self</span><br><span class="line"> neighbor 192.168.45.5 remote-as 20</span><br></pre></td></tr></table></figure>

<p>当然这里也可以使用PE1和PE2的loopback接口作为更新原地址来配置IBGP邻居，使用loopback接口建立邻居的优势是PE1和PE2之间的BGP流量不会经过隧道封装。</p>
<p><strong>配置验证</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1#traceroute 5.5.5.5 source loop 0</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 5.5.5.5</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 192.168.12.2 2 msec 1 msec 0 msec</span><br><span class="line">  2 192.168.24.4 2 msec 3 msec 2 msec</span><br><span class="line">  3 192.168.45.5 2 msec 2 msec *</span><br></pre></td></tr></table></figure>

<p>从上面的验证中可以看出，ISP核心区域的P路由器并没有运行BGP路由协议，PE1和PE2之间通过GRE隧道形成了IBGP邻居并交换了彼此的BGP路由前缀。</p>
<p><strong>配置解析</strong></p>
<p>在BGP建立邻居时，两边配置的更新原地址采用的是Tunnel0接口的地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor 192.168.24.4 remote-as 1234</span><br><span class="line">neighbor 192.168.24.2 remote-as 1234</span><br></pre></td></tr></table></figure>

<p>由于BGP协议使用TCP作为四层的协议，所以两个更新原地址之间的TCP连接必须畅通：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RE1#ping 192.168.24.4 source 192.168.24.2</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 192.168.24.4, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 192.168.24.2</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br><span class="line"></span><br><span class="line">经过PING检测发现两边的TCP连接没问题</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/17-MPLS/1613106277152-ca435381-f364-46ea-a898-ae5f859348f9.png" alt="img"></p>
<p>两端的Tunnel0口是如何联通的呢？通过查询路由表可知，到邻居的更新源地址192.168.24.4的下一跳是从Tunnel0发出，Tunnel0的源为2.2.2.2，目的为4.4.4.4，要去往4.4.4.4的下一跳是192.168.23.3，从E0/2接口发出，也就是发给路由器P：</p>
<p><img src="/2022/01/20/17-MPLS/1613106708409-4a15c01c-b389-48d9-b284-8c6da51fade3.png" alt="img"></p>
<p>通过查询路由器P的路由表可知，P路由器通过OSPF协议获得了4.4.4.4的路由，从E0/2口发出即可。来看看BGP的Open报文的抓包：</p>
<p><img src="/2022/01/20/17-MPLS/1613104707199-0007845b-3032-4d9c-94fd-ead96e77e8e6.png" alt="img"></p>
<p>抓取的数据包是192.168.24.2（PE1的Tunnel 0口的IP地址），发往192.168.24.4（PE2的Tunnel 0口的IP地址）用来建立邻居关系的Open报文。由于PE1和PE2之间使用了GRE隧道，去往192.168.24.4的数据被发往Tunnel0中，封装成源地址为2.2.2.2，目标地址为4.4.4.4的GRE包并发往P路由器，该GRE包在P路由器眼中就是个前往4.4.4.4的普通数据包且P路由器有该路由所以会被顺利转发。</p>
<p>从上面的例子可以看出，使用隧道VPN技术可以使得ISP内部不用配置BGP路由协议，从而降低ISP中心P设备的硬件消耗，在这个例子中我们使用的是GRE隧道VPN技术，其实用其他任何隧道VPN技术都可以，比如IP-in-IP，Q-in-Q或者用MPLS，这就引出了后面的部分，到底什么是MPLS？</p>
<h2 id="什么是MPLS"><a href="#什么是MPLS" class="headerlink" title="什么是MPLS"></a>什么是MPLS</h2><p>MPLS，英文全称为Multi Protocol Label Switching，中文翻译成多协议标签交换，Multi Protocol，多协议，表示除了可以支持IP协议之外，它还能支持几乎所有协议，比如IPV6、Ethernet、PPP、帧中继等等等等。。。；Label Switching，标签交换，意味着它基于标签进行转发而不是基于路由表进行转发。MPLS不仅能做VPN隧道能做到的，还有很多其他功能，比如可以用MPLS替代之前例子中的GRE隧道，首先把之前配置的GRE隧道和PE1\PE2基于GRE的邻居配置no掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1&amp;PE2</span><br><span class="line">no interface tunnel 0</span><br><span class="line"></span><br><span class="line">PE1:</span><br><span class="line">no neighbor 192.168.24.4 remote-as 1234</span><br><span class="line"></span><br><span class="line">PE2:</span><br><span class="line">no neighbor 192.168.24.2 remote-as 1234</span><br></pre></td></tr></table></figure>

<p><strong>IBGP配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 4.4.4.4 remote-as 1234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 next-hop-self</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> PE2：</span><br><span class="line"> </span><br><span class="line"> router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> neighbor 2.2.2.2 remote-as 1234</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 2.2.2.2 next-hop-self</span><br></pre></td></tr></table></figure>

<p><strong>MPLS配置</strong></p>
<p>首先要在接口上激活MPLS协议，需要在所有连接了PE1\P\PE2的接口上激活：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line">RE1(config)#interface e0/2</span><br><span class="line">RE1(config-if)#mpls ip</span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line">RE2(config)#interface e0/2</span><br><span class="line">RE2(config-if)#mpls ip</span><br><span class="line"></span><br><span class="line">P：</span><br><span class="line">P(config)#int range e0/1-2                   表示进入e0/1到e0/2的所有接口</span><br><span class="line">P(config-if-range)#mpls ip</span><br></pre></td></tr></table></figure>

<p><strong>验证配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1#ping 5.5.5.5 source loop 0</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 5.5.5.5, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 1.1.1.1</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<p>从CE1上ping位于CE2上的5.5.5.5可以ping通，但此时ISP的核心路由器P，还是没有运行BGP协议，但通过Traceroute追踪得知，数据是经过了路由器P的，它上面也没有5.5.5.5的路由，按理说P路由器应该会丢掉那些不知道目标的流量，为什么数据还能顺利发送过去呢？是因为用了MPLS协议，该协议中的标签提供了路径指引。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P#show ip route 5.5.5.5</span><br><span class="line">% Network not in table</span><br><span class="line"></span><br><span class="line">P#show ip cef 5.5.5.5</span><br><span class="line">0.0.0.0/0</span><br><span class="line">  no route</span><br><span class="line">  </span><br><span class="line">CE1#traceroute 5.5.5.5 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 5.5.5.5</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 192.168.12.2 0 msec 2 msec 1 msec</span><br><span class="line">  2  *  *  *</span><br><span class="line">  3 192.168.34.4 1 msec 3 msec 1 msec</span><br><span class="line">  4 192.168.45.5 1 msec 2 msec *</span><br></pre></td></tr></table></figure>

<p>让我们先看PE1上关于5.5.5.5的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RE1#show ip route 5.5.5.5</span><br><span class="line">Routing entry for 5.5.5.0/24</span><br><span class="line">  Known via &quot;bgp 1234&quot;, distance 200, metric 0</span><br><span class="line">  Tag 20, type internal</span><br><span class="line">  Last update from 4.4.4.4 01:05:21 ago</span><br><span class="line">  Routing Descriptor Blocks:</span><br><span class="line">  * 4.4.4.4, from 4.4.4.4, 01:05:21 ago</span><br><span class="line">      Route metric is 0, traffic share count is 1</span><br><span class="line">      AS Hops 1</span><br><span class="line">      Route tag 20</span><br><span class="line">      MPLS label: none</span><br></pre></td></tr></table></figure>

<p>‘Last update from 4.4.4.4 01:05:21 ago’表示去往5.5.5.5的话，需要将数据发送给4.4.4.4，也就是发送给PE2，此时我们不去查看路由表，而是查看一下MPLS转发表：</p>
<p><img src="/2022/01/20/17-MPLS/1613121303017-1690bc18-bf6e-40a9-9414-746a897080c5.png" alt="img"></p>
<p>MPLS转发表中的‘Label’就是路由器用来转发数据到目标地址的依据，PE1为了将数据发送到4.4.4.4，路由器会将标签‘17’嵌入数据包并将它从接口E0/2发出到路由器P。另一个快捷方式查看标签的方式是查看CEF表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RE1#show ip cef 5.5.5.5</span><br><span class="line">5.5.5.0/24</span><br><span class="line">  nexthop 192.168.23.3 Ethernet0/2 label 17</span><br></pre></td></tr></table></figure>

<p>来看看在路由器P上抓取的CE1和CE2之间通讯的数据包：</p>
<p><img src="/2022/01/20/17-MPLS/1613121837083-5d0ed496-894e-45ba-b7f4-f45e9b745c23.png" alt="img"></p>
<p>从抓包中可以看到，在二层数据链路层和三层网络层协议之间，加入了一个MPLS的头部，这也是为什么很多人管MPLS叫2.5层协议的原因，那么当P路由器收到这个数据包时会如何呢？路由器会用MPLS来决定如何转发这个数据包，因为它采用了MPLS协议，路由器会查询MPLS转发表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P(config)#do show mpls fo</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">16         Pop Label   2.2.2.2/32       19327         Et0/1      192.168.23.2</span><br><span class="line">17         Pop Label   4.4.4.4/32       19931         Et0/2      192.168.34.4</span><br></pre></td></tr></table></figure>

<p>当路由器P收到打了标签17的数据时，这个数据肯定是去往4.4.4.4的，出向标签（outgoing）写的是‘Pop label’也就是弹出标签，这意味着这个数据会在P上面将标签剥离掉，这样PE2收到的就会是一个普通的IP数据包，接下来PE2会查询路由表中关于去往5.5.5.5的路由条目，会将该数据发往CE2。当CE2收到该ICMP request数据包时，CE2会回送一个ICMP reply数据包给1.1.1.1。PE2上关于1.1.1.1的路由为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RE2#show ip route 1.1.1.1</span><br><span class="line">Routing entry for 1.1.1.0/24</span><br><span class="line">  Known via &quot;bgp 1234&quot;, distance 200, metric 0</span><br><span class="line">  Tag 10, type internal</span><br><span class="line">  Last update from 2.2.2.2 01:38:42 ago</span><br><span class="line">  Routing Descriptor Blocks:</span><br><span class="line">  * 2.2.2.2, from 2.2.2.2, 01:38:42 ago</span><br><span class="line">      Route metric is 0, traffic share count is 1</span><br><span class="line">      AS Hops 1</span><br><span class="line">      Route tag 10</span><br><span class="line">      MPLS label: none</span><br></pre></td></tr></table></figure>

<p>也就是去往1.1.1.1的数据要发送给2.2.2.2，现在来看2.2.2.2的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RE2#show ip cef 2.2.2.2</span><br><span class="line">2.2.2.2/32</span><br><span class="line">  nexthop 192.168.34.3 Ethernet0/2 label 16</span><br></pre></td></tr></table></figure>

<p>也就是去往2.2.2.2的路由要打上标签16并从E0/2接口发出给P路由器，在P上查看MPLS转发表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">16         Pop Label   2.2.2.2/32       25908         Et0/1      192.168.23.2</span><br><span class="line">17         Pop Label   4.4.4.4/32       26395         Et0/2      192.168.34.4</span><br></pre></td></tr></table></figure>

<p>路由器P的MPLS表显示去往2.2.2.2的下一个动作是将标签弹出然后从E0/1口发出给PE1，弹出标签以后这个数据就是个普通的IP数据，所以PE1收到它以后会查询路由表，进而发送给CE1完成ICMP的所有动作。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><ul>
<li><p>MPLS是一种新的转发机制，数据在MPLS网络中是根据标签信息进行转发的，也就是基于报文头部的标签进行数据转发，而不像传统网络中基于源目的IP地址进行转发，最初的目的是为了提高转发速度进而取代传统的IP转发，因为传统的进程交换（Process Switching）和快速交换（Fast Switching）的转发速度无法满足现实需求，但思科的特快转发（Cisco Express Forwarding）技术出来后已经能满足现时使用需求，MPLS目前主要用于运营商，比如MPLS VPN等业务；</p>
</li>
<li><p>MPLS全称是Multi Protocol Label Switching，中文翻译成多协议标签交换，Multi Protocol中文意思为多协议，指的是MPLS能够支持几乎所有协议，比如IP、IPV6、IPX、Ethernet、PPP等等。Label中文意思为标签，是一种短的、长度相等、易于处理、不包含拓扑信息、只具有局部意义的信息内容。Switching中文意思为交换，指的是MPLS报文交换和转发是基于标签的，当使用IP作为三层协议时，IP包在进入MPLS网络时，入口的路由器分析IP包的内容并为IP包选择合适的标签并打上标签，其他MPLS网络中的节点会依据这个标签作为转发依据，当IP包最终离开MPLS网络时，标签会被出口的边缘路由器剥离；</p>
</li>
<li><p>MPLS依赖IP路由协议，也就是说在运行MPLS协议之前需要运行一个传统的动态路由协议，比如OSPF或EIGRP，先将传统动态路由协议的路由学过来，在这个基础上再构造MPLS协议，比如标签信息等；</p>
</li>
<li><p>MPLS依赖CEF，也就是说在一台设备上没开启CEF的话，则不能使用MPLS协议；</p>
</li>
<li><p>MPLS标签对应的目的地址，涉及的前缀与传统ip转发是一样的；</p>
</li>
<li><p>MPLS的报头在英文中叫做Shim herder，位于二层和三层之间，俗称2.5层协议；</p>
</li>
</ul>
<p><img src="/2022/01/20/17-MPLS/1613359082779-94eb59e2-39b8-4ea1-a239-d4d8b5321e8b.png" alt="img"></p>
<h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p><strong>优点：</strong></p>
<ul>
<li><p>Improved up-time – By providing alternative network paths；</p>
</li>
<li><p>Improved bandwidth utilization – By allowing for multiple traffic types to traverse the network；</p>
</li>
<li><p>Reduced network congestion – By utilizing optional paths for traffic to avoid congestion；</p>
</li>
<li><p>Improved end-user experience – By allowing multiple Classes of Service to different types of traffic such as VOIP；</p>
</li>
</ul>
<p><strong>不足：</strong></p>
<p>MPLS整网必须从运营商处采购，由运营商进行支持，价格稍贵；另一个潜在的不足就是MPLS没有数据保护，但由于和运营商直连所以一般情况下来说这个不是很大问题。</p>
<h2 id="一张图概述"><a href="#一张图概述" class="headerlink" title="一张图概述"></a>一张图概述</h2><p><img src="/2022/01/20/17-MPLS/1613995111853-d16e14b2-4976-4f0e-b414-0eff3cd4d7da.jpeg" alt="img"></p>
<h1 id="MPLS标签"><a href="#MPLS标签" class="headerlink" title="MPLS标签"></a>MPLS标签</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><h3 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h3><p>LSR的全称为Label Switch Router，是一台支持MPLS协议并激活了该协议的设备，它能明白MPLS标签代表的含义，并能接收那些基于标签的数据包，LSR在MPLS网络中共有三中类型：</p>
<ul>
<li><p>Ingress  LSRs：中文翻译为入口LSR路由器，它收到那些没有标签的数据包后，会为这些数据包打上标签，然后将它发送出去；</p>
</li>
<li><p>Egress LSRs：中文翻译为出口LSR路由器，它收到那些有标签的数据包后，将标签剥离掉然后发送出去；</p>
</li>
<li><p>Intermediate LSRs：中文翻译为中间LSR路由器，它收到那些带有标签的数据包，按照标签转发信息库的信息，对标签进行替换，然后将数据发送出去。</p>
</li>
</ul>
<p>Ingress LSRs和Egress LSRs都属于边缘LSR路由器，LER（Label Edge Router）。</p>
<p><img src="/2022/01/20/17-MPLS/1613358686342-275ce264-3007-4355-aca6-54696c6181e1.png" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1613966002462-a5ffcced-db59-491b-8ac7-0174e7f6f75f.png" alt="img"></p>
<h3 id="LSP"><a href="#LSP" class="headerlink" title="LSP"></a>LSP</h3><p>LSR全称为Label Switched Path，中文为标签交换路径，LSP是数据在穿越整个MPLS网络或穿越部门MPLS网络时的路径，LSP在数据开始传输之前就已经建立\确定，LSP由LDP（Label Distribution Protocol）或RSVP-TE（Resource Reservation Protocol - Traffic Engineering）建立。</p>
<p><img src="/2022/01/20/17-MPLS/1613975432290-b28ba839-cc86-446c-9d33-276295fd6dbe.png" alt="img"></p>
<h3 id="FEC"><a href="#FEC" class="headerlink" title="FEC"></a>FEC</h3><p>FEC全称为Forwarding Equivalence Class，中文为转发等价类，FEC是那些具有相同的下一跳、出接口以及处理方式（比如QOS）的一组数据包。FEC是一个属于控制层面的概念，比较晦涩难懂，问过一个在大厂做TAC的朋友，它对这个概念也没有特别深入的理解，他认为FEC指代控制层面上等同于Label的概念，再深入的不需要了解，因为他没完全理解FEC的作用，这里仅把红茶三杯的总结贴在后面。</p>
<p>在转发过程中，具有相同处理方式的一组数据，可以通过地址、隧道、COS等方式来标识，通常在一台设备上对于一个FEC分配相同的标签，属于一个FEC的流量具有相同的转发方式、转发路径和转发待遇，但并不是所有拥有相同标签的报文都属于一个FEC，因为这些报文的EXP值（报头中的Experimental位，用于QOS）可能不同，执行方式可能不同，因此他们属于不同的FEC。决定报文属于哪一个FEC的路由器是入栈LSR，因为是它对报文进行分类和压入标签。</p>
<p>一些FEC范例：</p>
<ul>
<li><p>在第三层中，目的IP地址匹配同一个特定前缀的报文；</p>
</li>
<li><p>属于某个特定组播的组播报文；</p>
</li>
<li><p>根据进程或IP  DSCP（Differentiated Services Code Point，负责QOS，Quality Of Services）字段有相同处理方式的报文；</p>
</li>
</ul>
<p>一条FEC可以包含多个数据流，但不是一个数据流一个FEC，比如一台主机在看新浪的网页，这是一个流，又在看新浪视频，这又是一个流，这两个流在发给远程主机时，走的路径应该是相同的，所以一个FEC有多个流，但每个流并没有属于单独的FEC。</p>
<h3 id="C-CE-PE-P路由器"><a href="#C-CE-PE-P路由器" class="headerlink" title="C\CE\PE\P路由器"></a>C\CE\PE\P路由器</h3><p>C路由器是Customer  Router，也就是用户所使用的路由器；CE路由器是Customer Edge Router，也就是用户的边界路由器；PE路由器是Provider Edge Router，也就是运营商边界路由器；P路由器是Provider Router，也就是运营商路由器。</p>
<p>C和CE路由器都属于客户的网络，这些路由器不运行MPLS协议，PE路由器位于客户网络和运营商MPLS网络之间，它们是MPLS网络的起点和终点。P路由器是运营商的骨干路由器。</p>
<p><img src="/2022/01/20/17-MPLS/1613978008961-b586c337-25f8-43d0-85b9-96fcd2a89ea3.gif" alt="img"></p>
<h2 id="标签格式"><a href="#标签格式" class="headerlink" title="标签格式"></a>标签格式</h2><p><img src="/2022/01/20/17-MPLS/1613557268422-dd6fa61b-b879-4846-bf3b-0fba3da559ae.jpeg" alt="img"></p>
<p>MPLS标签报头长度为32比特。</p>
<ul>
<li><p>Label：前20比特为标签值，取值范围为<img src="/2022/01/20/17-MPLS/a06646f45c9ca05bfddd2289aa2906ca.svg" alt="img">，也就是1-1048575，但是前16个比特有特殊意义不能随便使用，标签值仅在本路由器上有意义，不对其他路由器产生任何实质性的影响，所以不同路由器上的标签值可以相同也可以不同，都没关系，每经过一个路由器，标签会根据LFIB（标签转发信息库）进行替换；</p>
</li>
<li><p>Exp：20-22比特为EXP位（全称为Experimental，中文为实验位），用于QOS服务；</p>
</li>
<li><p>Bos：第23比特为BOS位（Bottom of Stack，中文为栈底位），一个数据包可以有一个或者多个标签，当它有多个标签时，由于MPLS报头没有标识长度的字段，所以用BOS位来完成这个功能，当BOS位为1的意味着这个标签是栈底，说明它是最后一个标签，后面没有其他标签了。当它值为0时意味着它不是最后一个标签，后面还有其他标签。</p>
</li>
<li><p>TTL：24-31比特为TTL位（Time To Live，中文为生存时间），和IP报头中的TTL含义及功能相同，每经过一跳TTL的值减一，TTL位的功能是防止路由环路，当TTL值为0时，数据包被丢弃。</p>
</li>
</ul>
<h2 id="标签堆栈"><a href="#标签堆栈" class="headerlink" title="标签堆栈"></a>标签堆栈</h2><p>为了实现某些功能，数据包可能会有多个标签，比如MPLS VPN就有两层标签，这时这些标签会被打包到堆栈中，叫做MPLS Label Stack：</p>
<p><img src="/2022/01/20/17-MPLS/1613638938457-72196b29-5d84-46a1-8894-947f632481aa.png" alt="img"></p>
<p>当多个标签堆叠时，在最上面的标签叫做栈顶标签，最下面的叫做栈底标签，在顶部和底部标签之间，可以有任意多的其他标签堆叠，只有栈底标签的BOS位置1，其他标签的BOS位为0。</p>
<p><img src="/2022/01/20/17-MPLS/1613894003939-570c0334-96a6-4a1e-bd79-d398714c5860.png" alt="img"></p>
<p>比如上图封装了三层标签，对于一个LSR来说，只处理第一个标签，每一层标签都有个BOS栈底位，用来表示是否已经是标签的栈底（是否是最后一个标签），最后一个标签的BOS位=1。</p>
<h2 id="标签相关概念"><a href="#标签相关概念" class="headerlink" title="标签相关概念"></a>标签相关概念</h2><h3 id="几张表"><a href="#几张表" class="headerlink" title="几张表"></a>几张表</h3><p>涉及到MPLS的几张表：RIB（Routing Information Base）、FIB（Forwarding Information Base）、LIB（Label Information Base）、LFIB（Label Forwarding）、CEF Adjacency Table。</p>
<ul>
<li>RIB，中文叫路由表，是一个控制层面的概念，由路由协议中的算法生成，存储着来自邻居们的路由信息，RIB中没有MPLS标签信息。使用命令‘show ip route’可查看路由表。</li>
<li>FIB，中文叫转发信息表，又叫CEF表，是一个数据层面的概念，由CEF（Cisco Express Forwarding）生成，存储着路由和标签的信息，和RIB表中的条目之间有一一对应的关系，MPLS协议需要使用CEF。使用命令‘show ip cef’可以查看FIB\CEF表。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show  ip cef 4.4.4.4</span><br><span class="line">4.4.4.4/32, version 12, epoch 0, cached adjacency 10.1.12.2</span><br><span class="line">0 packets, 0 bytes</span><br><span class="line"> tag information set</span><br><span class="line">  local tag: 104 fast tag rewrite with Fa0/0, 10.1.12.2, tags imposed: &#123;203&#125;</span><br><span class="line">   via 10.1.12.2, FastEthernet0/0, 0 dependencies</span><br><span class="line">    next hop 10.1.12.2, FastEthernet0/0</span><br><span class="line">    valid cached adjacency</span><br><span class="line">    tag rewrite with Fa0/0, 10.1.12.2, tags imposed: &#123;203&#125; </span><br></pre></td></tr></table></figure>

<ul>
<li>CEF Adjacency Table，中文叫邻接表，是个数据层面的概念，和FIB表一样都是CEF（Cisco Express Forwarding）所使用的到的表，但和FIB表不同。</li>
<li>LIB，中文叫标签信息库，是一个控制层面的概念，由LDP\RSVP等基于RIB的协议产生，简单来说LIB中存储着所有已知的标签，包括自己的和邻居发来的标签。路由器为每一个IGP前缀在本地生成一个标签并分发给LDP邻居，同时也从LDP邻居收到那些为特定前缀所分发的标签。路由器将本地标签和远程标签（LDP邻居发过来的标签）存储在LIB中。使用命令‘show mpls ldp bindings’查看。</li>
</ul>
<p><img src="/2022/01/20/17-MPLS/1614048686354-1835814c-0df8-409a-b2ee-83334bbc3a8f.jpeg" alt="img"></p>
<ul>
<li>LFIB，中文叫标签转发信息库，是一个数据层面的概念，由RIB和LIB共同建立，表中存储着路由和标签。简单来说路由器使用LFIB来对MPLS数据进行转发。LSR路由器可能会收到关于某一个前缀的多个标签（从多个LDP邻居发送过来的），但它只需要使用其中的一个标签，LFIB从LIB中的众多标签中找到最优的传输标签并将它存储在LFIB中。使用命令‘show mpls forwarding-table’查看。</li>
</ul>
<p><img src="/2022/01/20/17-MPLS/1614048862779-5aab6b47-6ca1-48f1-99f6-7d3a80cc41d7.jpeg" alt="img"></p>
<h3 id="几张表的关联"><a href="#几张表的关联" class="headerlink" title="几张表的关联"></a><a href="https://community.cisco.com/t5/mpls/relationship-between-lib-fib-and-lfib/td-p/782307">几张表的关联</a></h3><p><strong>RIB&amp;FIB</strong></p>
<p>RIB中存储着来自邻居们的路由信息，但仅有这些路由信息的话，路由器无法对数据进行转发，因为路由器还不知道如何使用这些路由信息转发数据，转发数据路由器需要封装\解封装二层包头以及数据从哪个接口发出去，所以需要告诉路由器二层报头信息，以及数据如何发出，所以需要FIB表和邻接表<Adjacency table>（CEF中的邻接表中有关于下一跳所需的封装信息，FIB为每条FEC提供了一个指针，这个指针对应着邻接表中的一个或多个条目，使得LIB和FIB能相互对应起来，知道从哪个接口将数据发送出去），这两张表中包含路由器在转发数据包时使用的所有信息（例如二层地址以及出接口等），因为FIB表示基于RIB衍生出来的，经过了查找、递归等步骤，更适合。</Adjacency></p>
<p><img src="/2022/01/20/17-MPLS/1613884912056-1c6198a4-12f9-4b71-8c3d-7a44bb7468f1.png" alt="img"></p>
<p><strong>LIB&amp;LFIB</strong></p>
<p>在运行了MPLS协议的路由器上，所有的标签储存在LIB中（可能会看到一个前缀对应着多个标签的情况，因为标签仅在本路由器上有意义，其他路由器可能会对相同的前缀分配不同的标签，用LDP ID进行区别），和RIB&amp;FIB的情况类似，仅有LIB也无法对数据进行转发，所以需要LFIB，LFIB由LIB的信息映射到FIB上生成，目的是为了获取下一跳信息以便发送到下一跳的路由器上。</p>
<p><img src="/2022/01/20/17-MPLS/1613891087274-219698ef-c9af-4a73-b79f-91578ae57074.png" alt="img"></p>
<h3 id="为什么？"><a href="#为什么？" class="headerlink" title="为什么？"></a>为什么？</h3><p><strong>为什么需要这么多表？</strong></p>
<p>因为传入以及传出MPLS网络的数据包都可能有两种（带标签的数据、不带标签的传统IP包），所以就会有四种可能，需要分别查询不同的表来处理数据，如下图所示：</p>
<p><img src="/2022/01/20/17-MPLS/1613886432179-39d7f720-903d-4e46-9fd5-4bf0c21ff943.gif" alt="img"></p>
<p><strong>这么多表如何转发？</strong></p>
<ul>
<li><p>当收到的数据为IP数据，转发出的数据也为IP数据时，就是纯IP报文转发，使用FIB表项，也就是cisco的CEF；</p>
</li>
<li><p>当收到的数据为MPLS数据，转发出去的依旧为MPLS数据时，查询LFIB表；</p>
</li>
<li><p>收到IP数据，但需要以MPLS数据转发出去，那么依然走FIB（CEF）表，因为CEF表中有标签信息；</p>
</li>
<li><p>收到MPLS数据，但需要以IP数据转发出去，输入时走LFIB表，输出时使用FIB（CEF）表；</p>
</li>
</ul>
<h3 id="查哪张表"><a href="#查哪张表" class="headerlink" title="查哪张表"></a>查哪张表</h3><p>MPLS数据包查询LFIB表进行转发，IP数据包查询FIB\CEF表进行转发，那么路由器如何知道该数据是MPLS数据包还是IP数据包呢？以太网二层帧头中的EtherType字段值：</p>
<p><img src="/2022/01/20/17-MPLS/1613471169123-e5e46c6c-3f1e-41cd-947c-d694086a42be.png" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1613473710169-8e6b5d34-2949-43e9-a562-6ec00c4e47a9.png" alt="img"></p>
<p>当字段值为0X0800时，表示它是一个IPV4数据，查询FIB表；当字段值为0X8847时，表示它是一个MPLS单播数据，查询LFIB；当字段值为0X8848时，表示它是一个MPLS组播数据，查询LFIB。</p>
<p>初始路由器上，是查找FIB还是LFIB呢？由于在初始路由器上，产生的依旧是IP报文，查找的是CEF表，用‘show ip cef<ip address> detail’命令可以从输出中看到对此路由是否压入标签，分配标签的依据是根据CEF表中的前缀来分配的：</ip></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show  ip cef 4.4.4.4</span><br><span class="line">4.4.4.4/32, version 12, epoch 0, cached adjacency 10.1.12.2</span><br><span class="line">0 packets, 0 bytes</span><br><span class="line"> tag information set</span><br><span class="line">  local tag: 104 fast tag rewrite with Fa0/0, 10.1.12.2, tags imposed: &#123;203&#125;</span><br><span class="line">   via 10.1.12.2, FastEthernet0/0, 0 dependencies</span><br><span class="line">    next hop 10.1.12.2, FastEthernet0/0</span><br><span class="line">    valid cached adjacency</span><br><span class="line">    tag rewrite with Fa0/0, 10.1.12.2, tags imposed: &#123;203&#125; </span><br></pre></td></tr></table></figure>

<p>例如这条CEF条目的最后一行显示，去往4.4.4.4的数据，要压上203的标签，发送给10.1.12.2。</p>
<h3 id="标签Q-amp-A"><a href="#标签Q-amp-A" class="headerlink" title="标签Q&amp;A"></a>标签Q&amp;A</h3><p>标签和目标网段映射\绑定，而不是和接口映射\绑定。（Label are assigned to destination networks, not to interfaces.）</p>
<h2 id="BOS位"><a href="#BOS位" class="headerlink" title="BOS位"></a><a href="https://blog.ipspace.net/2014/11/handling-bottom-of-mpls-stack.html">BOS位</a></h2><h2 id="MPLS构架"><a href="#MPLS构架" class="headerlink" title="MPLS构架"></a>MPLS构架</h2><p><img src="/2022/01/20/17-MPLS/1613376957089-6945748b-492a-4b1c-a828-48ac81058743.jpeg" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1613373336055-4ad9e29c-aeb4-4f75-b90d-e8b2f7b121aa.jpeg" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1613891594623-bc415569-cb76-42ad-a38c-df4a02a4c27f.jpeg" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1613892609348-0d300f4e-ccfd-48b0-9861-42a3b198fb84.png" alt="img"></p>
<h2 id="标签处理"><a href="#标签处理" class="headerlink" title="标签处理"></a>标签处理</h2><h3 id="标签动作"><a href="#标签动作" class="headerlink" title="标签动作"></a>标签动作</h3><p>路由器对标签共有三种动作，压入标签（Push），替换标签（Swap），弹出标签（Pop）：</p>
<p><img src="/2022/01/20/17-MPLS/1613978423252-8ee00a10-7fa0-4632-8862-083d4ce54410.png" alt="img"></p>
<p><strong>Push：压入标签</strong>，过程是为数据在二层和三层报头之间加入一个新的标签，入标签由PE路由器完成。如果原数据没有标签压，例如PE路由器从客户路由器收到IP数据的情况下，并压入标签后，会将传统的IP数据包‘变为’MPLS包；如果原数据有标签，则该数据的顶部标签上层会增加一个或多个标签。</p>
<p><img src="/2022/01/20/17-MPLS/1613980321089-db8bd481-453a-4518-ac7b-fc55fcb75065.png" alt="img"></p>
<p><strong>Swap：替换标签</strong>，过程发生在MPLS网络中，由运营商的核心P路由器完成这个动作。MPLS数据的顶部标签被移除同时使用一个新的标签代替被移除的标签。<img src="/2022/01/20/17-MPLS/1613980301483-56ba8b99-4722-4e65-949b-8e54f04e3a7a.png" alt="img"></p>
<p><strong>Pop：弹出标签</strong>，过程就是将原本MPLS数据中最上层的标签弹出，报文的转发依靠标签栈中余下的标签，或将其作为无标签的IP数据转发。</p>
<p><img src="/2022/01/20/17-MPLS/1613980336914-7667f636-49e8-4615-a150-fede8ed3c5e2.png" alt="img"></p>
<p><strong>Untag：移除标签</strong>，过程是将原本MPLS数据中的整个标签栈移除，按照无标签的IP数据包的方式进行转发。</p>
<p><img src="/2022/01/20/17-MPLS/1613980361633-3d10ae5f-6509-452e-aed7-c47155b9ebb4.png" alt="img"></p>
<h4 id="POP-amp-Untag"><a href="#POP-amp-Untag" class="headerlink" title="POP&amp;Untag"></a>POP&amp;Untag</h4><p><strong>区别</strong></p>
<p>Pop金会将顶层标签头部弹出，经过Pop动作转发后的报文可以是IP数据也可以是MPLS标签数据，因为Pop只摘掉一层标签而原数据可能有一层或多层标签头，在只有一层标签头的情况下，Pop掉一层标签后会变成IP数据，如果有多层标签头的情况下，Pop掉一层标签后还有其他标签，依旧是个MPLS标签数据。</p>
<h4 id="产生原因"><a href="#产生原因" class="headerlink" title="产生原因"></a>产生原因</h4><p>Pop：收到了下游发来的分配给某前缀的标签为空时，那么本LSR向下游LSR发送去往该前缀的数据的时候，会执行Pop的动作，弹出顶层标签。此时本LSR只需要查询一次LFIB，其中有下一跳的信息，弹出顶层标签后交给下一跳即可，如果该数据只有一个标签则弹出标签后是IP包，不用再次查找FIB表。</p>
<p>Untag：弹出所有标签，随后根据下一跳（查询FIB表）转发。出现Untag有以下三种原因：</p>
<ul>
<li><p>下游不能分配标签，没有启用MPLS协议；</p>
</li>
<li><p>下游分配了标签但无法传递到本LSR上，因为LDB Neighbor没有建立；</p>
</li>
<li><p>分配标签错误，这种情况仅会出现在IGP是OSPF的情况下，因为如果用环回口做LDP的Router ID而且不是32位的地址，OSPF会自动以32位的环回地址发布，这样会导致标签分配错误；</p>
</li>
</ul>
<h3 id="总体过程"><a href="#总体过程" class="headerlink" title="总体过程"></a>总体过程</h3><p>The first label is imposed on the ingress LSR and the label belongs to one LSP. The path of the packet through the MPLS network is bound to that one LSP. All that changes is that the top label in the label stack is swapped at each hop. The ingress LSR imposes one or more labels on the packet. The intermediate LSRs swap the top label (the incoming label) of the received labeled packet with another label (the outgoing label) and transmit the packet on the outgoing link. The egress LSR of the LSP strips off the labels of this LSP and forwards the packet. For this to work, adjacent LSRs  must agree on which label to use for each IGP prefix. Therefore, each intermediate LSR must be able to figure out with which outgoing label the incoming label should be swapped </p>
<p>第一个标签是在入口LSR（Label Switch Router，运行了MPLS的路由器）上压入（Push）数据包的，这个标签属于一个LSP（Label Switched Path，标签交换路径，LSP是数据在穿越整个MPLS网络或穿越部门MPLS网络时的路径），该数据包在MPLS网络中的路径是和LSP绑定的。这个数据包在MPLS网络中所有的变化就是将顶部标签在每一跳路由器上进行替换（Swap）。入口LSR在压入标签时，可能压入（Push）了一个或多个标签，位于中间位置的LSR们会将最顶部的标签进行替换后，将数据从出口链接发送出去。LSP出口端的LSR会将弹出（Pop）这个LSP的标签，转发数据包。</p>
<p>为了做到这些，邻居LSR们必须在IGP前缀使用哪些标签上达成一致。因此，那些在中间执行标签替换的LSR必须能搞明白它们需要将入站标签替换成什么出站标签。</p>
<h3 id="IP-amp-标签查找"><a href="#IP-amp-标签查找" class="headerlink" title="IP&amp;标签查找"></a>IP&amp;标签查找</h3><p>之前说过，之所以需要RIB\FIB\LIB\LFIB这么多表是因为入向和出向数据可能是IP数据包也可能是MPLS数据包：</p>
<p><img src="/2022/01/20/17-MPLS/1613986191364-7f18a4a1-d9ab-49f2-ad4a-e6cb9abf0c39.png" alt="img"></p>
<ul>
<li>如果LSR收到一个IP数据包，这个数据去往4.4.4.0/24网段，此时路由器会查看FIB，输出如下。FIB表中最后写着‘nexthop 10.1.12.2 FastEthernet0/0 label 204’，表示下一跳是10.1.12.2，需要从F0/0口发出，要打上标签204.在思科设备上，CEF交换是唯一的一种可用于标记报文的IP转发模式，因为CEF中既有路由信息又有标签信息，因此在启用MPLS的时候必须在路由器上开启CEF。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip cef 4.4.4.0 detail </span><br><span class="line">4.4.4.0/24, epoch 0</span><br><span class="line"> local label info: global/16</span><br><span class="line"> nexthop 10.1.12.2 FastEthernet0/0 label 204 </span><br></pre></td></tr></table></figure>

<ul>
<li>当路由器收到一个带标签的报文时，则在LFIB中进行查找，LFIB表中相关的匹配条目会有针对该入栈标签的出栈动作或替换标签，以及下一跳信息。</li>
<li>当路由器收到一个带标签的数据包，并且该数据包的顶部标签不能在本地LFIB中找到，那么CISCO IOS将丢弃这个数据包。</li>
</ul>
<h2 id="标签分配过程"><a href="#标签分配过程" class="headerlink" title="标签分配过程"></a>标签分配过程</h2><p>MPLS标签分配共有两种模式，Frame-Mode和Cell-Mode，具体区别如下：</p>
<p><img src="/2022/01/20/17-MPLS/1614049675897-a84d7499-017b-40c7-ac7a-4286f37ffe2f.png" alt="img"></p>
<p>我们这里只讨论Frame-Mode的标签，这种在现网中使用。</p>
<h3 id="构建IP路由表"><a href="#构建IP路由表" class="headerlink" title="构建IP路由表"></a>构建IP路由表</h3><p><img src="/2022/01/20/17-MPLS/1614050271852-ffc9f8a8-ba2d-4e2a-9523-2543f5ab3eac.png" alt="img"></p>
<p>所有的路由器都运行路由协议，全网路由互通，然后在路由器的接口上激活LDP协议，然后这些运行了LDP协议的路由器<strong>两两之间</strong>会形成LDP邻接关系。</p>
<h3 id="分配并分发标签"><a href="#分配并分发标签" class="headerlink" title="分配并分发标签"></a>分配并分发标签</h3><p><img src="/2022/01/20/17-MPLS/1614050458629-d13a286c-2e10-4dce-9ca4-b977e66d01e6.png" alt="img"></p>
<p>激活LDP后，每台路由器会为自己本地路由表中的路有前缀分配并捆绑标签，例如上图中的X路由，所有路由器（A、B、C、D、E）都会为自己路由器上的X路由分配一个标签，然后为路由X捆绑的标签保存在本地LIB表中，接下来所有运行了LDP协议的路由器，都会把自己为各个路由前缀捆绑的标签发给它的LDP邻居，如图所示，B将给前缀X的标签发给了A\E\C这几个路由器。由于标签的分发没有水平分割的概念，所以B可能从C学到的路由X，但B仍然会将它（B）为前缀X捆绑的标签传递给C，C也会把从B学到的标签放入LIB中，不用担心有环路，因为LDP可以借助IGP路由协议来防止环路。</p>
<p><img src="/2022/01/20/17-MPLS/1614051171541-0f003c4e-d459-4ed8-8443-56c45e149dba.png" alt="img"></p>
<p>当LDP路由器从他的LDP邻居处收到邻居的捆绑标签，它会将捆绑的结果存储在自己的LIB表中，LIB表中有Local Label，这是自己为前缀分发的标签，而Remote Label是邻居为该路由前缀分发的标签。LDP邻居会将邻居分配的remote  label都放在LIB中，只会从LIB中所有可能的标签中选择出一个可能的出站标签放入LFIB中。LDP路由器根据LIB表并结合路由表构成LFIB表，如上图中A的LFIB表。</p>
<p>这里有一点要注意，E路由器中会收到自己LDB邻居B、C这两个路由器的标签捆绑信息，其中都有关于路由X捆绑的标签，那么E在LFIB表中，寸的是哪个邻居发来的Remote Label呢？存储的是C的Remote Label，因为路由X由D发过来，C才是去往X的下一跳，E会借助路由表来判断谁的标签捆绑‘更优’。</p>
<h3 id="LIB-amp-LFIB表的建立"><a href="#LIB-amp-LFIB表的建立" class="headerlink" title="LIB&amp;LFIB表的建立"></a>LIB&amp;LFIB表的建立</h3><p><img src="/2022/01/20/17-MPLS/1614060394107-65a5be51-0cf3-427f-9277-3c7af3f0a16b.png" alt="img"></p>
<p>在所有的LDP路由器都相互发送标签捆绑信息后，大家逐步建立了自己的LFIB。</p>
<p><img src="/2022/01/20/17-MPLS/1614060512690-0a37c63a-049e-46f1-8bb4-44bf2541bf54.png" alt="img"></p>
<p>当所有路由器的LFIB都构建完毕后，我们就能看到，当A收到一个IP数据包，要访问X，那么A查看自己的CEF表（因为CEF中既有路由又有标签），发现下一跳要发往B，而B上给路由X分配的标签头为201，所以要给数据包压入（Push）标签，于是它压上标签值为201的标签头，然后发给B。B收到这个标签包，由于也要以MPLS标签包转发出去，所以查询LFIB表，发现标签头中Label为201，于是查看自己的LFIB，发现201标签的Outgoing Label为301且下一跳是C，于是它将201标签替换（Swap）成301然后交给C。数据到了路由器C上，由于要以IP包形式转发出去，它在输入时走LFIB表，输出时使用FIB（CEF）表，发现301对应的Outgoing Label是Pop并且下一跳是D，所以它将标签头弹出，数据变为了IPV4数据包，C将这个数据包交给D。</p>
<h2 id="标签报文的负载均衡"><a href="#标签报文的负载均衡" class="headerlink" title="标签报文的负载均衡"></a>标签报文的负载均衡</h2><p>Equal Cost Multipath (ECMP) </p>
<h1 id="LDP协议"><a href="#LDP协议" class="headerlink" title="LDP协议"></a>LDP协议</h1><h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><p>LDP协议英文全称是Label Distribution Protocol，是MPLS用来分发标签的协议之一，简单来说就是路由器为路由前缀（比如OSPF\ISIS\EIGRP这些IGP协议的路由前缀）自动生成标签，并且和其他路由器交换的协议，由RFC3035和3036首次定义，由RFC5036更新，它实际上是思科TDP（Tag Distribution Protocol）协议的公有化。MPLS协议的基本特点之一就是所有的报文都是有标签的，如果让OSPF\EIGRP\RIP\ISIS这样的协议来分发标签是不可能的了，那么就需要一个新的协议，独立于所有的路由协议并且能够结合所有IGP路由协议一起使用，LDP就是这样一个协议，当然BGP因为运载的是外部路由，所以认为用BGP本身来分发标签更为有效，甚至非常完美，所以BGP可以实现多协议，用它来分发标签信息所产生的的影响是非常小的。而且BGP是唯一一种在AS自制系统之间分发前缀的协议。</p>
<p>对IP路由表中的每一条IGP的IP前缀来说，每一台运行LDP协议的LSR都会进行本地捆绑，也就是说，为IPV4前缀分配标签，然后LSR再将分配的标签分发给所有LSR邻居。邻居们将这些收到的标签转换为远程标签Remote Label，之后邻居们将远程标签和本地标签存储于一张特殊的表中，这个表就是标签信息库，LIB（Label Information Base）。通常一台LDP路由器会有多个邻居，那么这些邻居都会给路由分配标签然后将标签传给自己。</p>
<p>在所有捆绑在某一个前缀的Remote Label中，LSR只是用一个标签来确定该前缀的出站标签。RIB，也就是路由表来确定IPV4前缀的下一跳是什么。而LSR从下游LSR收到的远程标签中选择其路由表中达到该前缀的下一跳的标签，LSR用这样的信息来创建它自己的标签转发信息库，LFIB。</p>
<p>在思科IOS中，LDP不会为BGP的IPV4前缀捆绑标签。</p>
<p><img src="/2022/01/20/17-MPLS/1614139117334-792bdb12-0626-46fc-b789-902d19722bfa.png" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1614138723897-493e5ad4-2637-4dc2-8f5f-1668706bb227.png" alt="img"></p>
<h2 id="LDP邻居建立过程"><a href="#LDP邻居建立过程" class="headerlink" title="LDP邻居建立过程"></a>LDP邻居建立过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>运行LDP之前，先确定路由器运行了CEF协议，因为CEF中的两张表，FIB和CEF邻居表是LIB和LFIB构成的元素，如果不运行CEF表则无法构建LIB和LFIB，自然也无从运行LDP协议。LDP邻居建立过程共分两步，邻居发现过程、会话建立过程。邻居发现使用UDP组播的Hello报文实现，一旦两个路由器决定形成邻居关系，接下来它们会使用TCP建立连接，这个TCP连接用来交互标签信息，一般而言，使用Loopback接口建立邻居。</p>
<p><img src="/2022/01/20/17-MPLS/1614138623812-59f76fff-ac4f-4d52-86cb-da9777ad32ee.jpeg" alt="img"></p>
<h3 id="邻居发现阶段"><a href="#邻居发现阶段" class="headerlink" title="邻居发现阶段"></a>邻居发现阶段</h3><p><img src="/2022/01/20/17-MPLS/1614080442325-84a069b4-4de9-4432-a51f-71b274ecb403.png" alt="img"></p>
<ul>
<li>当LDP协议在路由器上激活后，会发送Hello包来发现邻居，邻居发现是借助UDP组播Hello包来进行的，LSR会在所有激活运行了LDP协议的接口上（也就是那些在接口上配置了‘mpls ip’命令的）发送Hello包，这个Hello包的源、目的端口都是UDP646，Hello包发向组播地址224.0.0.2，源地址为接口IP。收到LDP Hello包的路由器会知道有一个LDP邻居。Hello包中携带着Hold Time信息，如果在Hold time过期之前没收到其他路由器的Hello包，那么LSR会将LDP会话关闭，可以用命令‘show mpls ldp dicovery [detail]’命令来查看是否收到了LDP Hello包、Hello Interval、Hold Time等信息。‘show mpls interfaces’命令可以查看有哪些接口运行了LDP协议；‘mpls ldp discovery { hello { holdtime | interval } <em>seconds</em>’命令修改Hello\interval时间，默认的Hello interval（间隔多久发送一次Hello包）为5秒，默认的Hold time（间隔多久如果没收到对方的Hello报文会关闭LDP会话）为15秒。</li>
</ul>
<p><img src="/2022/01/20/17-MPLS/1614130485923-0f967452-1154-42fe-a9b0-e741a069c04c.jpeg" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1614130984325-75ec424e-0d2e-4c8c-b2a4-05935e3011f3.png" alt="img"></p>
<ul>
<li>发现邻居后，传输地址大的一方为主动发起方，比如上图中，传输地址分别是1.1.1.1和2.2.2.2，所以地址大的一方2.2.2.2为主动发起方，发起了TCP握手报文，源地址是本地的Transport Address，目的地址是对端的Transport Address。Transport Address默认情况下为路由器的LDP Router ID。必须保证两个Transport Address之间是路由可达的。也可以在接口下使用命令‘mpls ldp discovery transport-address interface’将Transport Address配置为直连接口的IP地址。之所以建立TCP连接是为了能够可靠的交互标签。</li>
</ul>
<h3 id="LDP会话建立阶段"><a href="#LDP会话建立阶段" class="headerlink" title="LDP会话建立阶段"></a>LDP会话建立阶段</h3><p><img src="/2022/01/20/17-MPLS/1614081207146-736f814b-6453-4489-9881-8029158be7d9.png" alt="img"></p>
<p>连接建立成功后，开始交互初始化消息，初始化消息中包含各种参数，对方也发送自己的初始化消息，并且如果接收了前者的初始化消息后，会发送一个Keep alive消息表示接受，到此LDP的邻居关系就建立起来了，接下去可以互相传递标签映射消息了。</p>
<p><strong>LDP****允许非直连邻居，这样一来邻居发现无需借助组播的Hello包而是采用单播包。</strong></p>
<h2 id="标签交互"><a href="#标签交互" class="headerlink" title="标签交互"></a>标签交互</h2><h2 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h2><h3 id="Hello报文"><a href="#Hello报文" class="headerlink" title="Hello报文"></a>Hello报文</h3><p><img src="/2022/01/20/17-MPLS/1614149966024-3c99c296-cd46-4bb9-ba7f-f0984c71e669.png" alt="img"></p>
<p>LDP邻居建立首先发送Hello包，它使用UDP，源目的端口都是646，LDP ID为6个字节（4字节的IP+2字节的Label Space），两个路由器建立LDP邻居，要保证双方到对方的LDP ID的三层可达，也可以说要有到对方LDP ID的路由，Transport Address除非手工用命令（mpls ldp discovery transport-address）指定，否则一般等于LDP ID。上面共提到了三个地址，接口IP address，Transport address和LDP ID：</p>
<p>Transport address：建立TCP连接所使用的地址，Transport address是LDP的Hello报文的一部分，</p>
<p><img src="/2022/01/20/17-MPLS/1614151686708-40cd8758-38b4-455e-8001-109e3a60f537.png" alt="img"></p>
<p>使用如下命令可以看到相关信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls ldp discovery detail</span><br><span class="line">   Local LDP Identifier: </span><br><span class="line">    1.1.1.1:0</span><br><span class="line">     Discovery Sources:</span><br><span class="line">     Interfaces: FastEthernet0/0 (ldp): xmit/recv</span><br><span class="line">      Enabled: Interface config </span><br><span class="line">      Hello interval: 5000 ms; Transport IP addr: 1.1.1.1  </span><br><span class="line">      LDP Id: 2.2.2.2:0; no host route to transport addr</span><br><span class="line">       Src IP addr: 10.1.12.2; Transport IP addr: 2.2.2.2 </span><br><span class="line">       Hold time: 15 sec; Proposed local/peer: 15/15 sec </span><br><span class="line">       Reachable via 2.2.2.0/24 </span><br><span class="line">       Password: not required, none, in use </span><br></pre></td></tr></table></figure>

<h4 id="LDP-identifier"><a href="#LDP-identifier" class="headerlink" title="LDP identifier"></a>LDP identifier</h4><p><img src="/2022/01/20/17-MPLS/1614138772730-d3130055-2691-485e-ae61-effd702397a7.png" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1614137764097-5cbb7ca3-c409-4de7-96ff-951760b24c01.png" alt="img"></p>
<p><img src="/2022/01/20/17-MPLS/1614156158063-1575cfb6-f536-4287-8248-fd768780bd2c.png" alt="img"></p>
<p>LDP ID（Identifier）是一个6bytes的字段，是LSR的LDP标识符，包含4bytes的LSR标识符（Router ID）和2bytes的标签控件（Tag Space ID），选举规则和OSPF的Router ID一样，优先使用最大的Loopback地址，如果没有Loopback接口激活，则使用最大的IP地址作为LDP ID。</p>
<ul>
<li>当存在loopback接口时，LDP ID的前4bytes，Router ID是loopback接口的最大IP，如果没有loopback接口，则前4bytes，Router ID是物理接口的最大IP，使用命令‘mpls ldp router-id <em>inerface</em>[force]’可以进行修改，比如‘mpls ldp router-id loopback0’就是把MPLS的LDP ID配置成loopback0接口，如果加上‘force’关键字则为马上生效，否则只有当前选做MPLS LDP ID的接口Down掉的时候才会进行重新选择。必须注意的是，<strong>邻居的LDP ID必须在本地有可达路由，否则LDP邻居无法建立。</strong></li>
<li>后面2bytes的Tag Space ID标签空间为0，说明是基于设备或者说基于平台（Per-platform）的标签空间。 什么叫基于平台的标签呢？比如下图中的B路由器，它为前缀X捆绑了标签34，并且将这个标签捆绑信息发布给所有的LDP邻居，A、C、D，这三台路由器上都收到了从B发从过来的关于前缀X的Remote Label，34，这就是基于平台基于设备的标签。</li>
</ul>
<p><img src="/2022/01/20/17-MPLS/1614155246106-e5e9f304-c997-436b-a2a5-7dff7b780dd5.png" alt="img"></p>
<h3 id="Initialization报文"><a href="#Initialization报文" class="headerlink" title="Initialization报文"></a>Initialization报文</h3><p><img src="/2022/01/20/17-MPLS/1614152178252-e05a2439-4b91-4a02-96f7-b05c349f0087.png" alt="img"></p>
<h3 id="Label-Mapping报文"><a href="#Label-Mapping报文" class="headerlink" title="Label Mapping报文"></a>Label Mapping报文</h3><p>一个LDP报文会承载多个标签映射消息，每个标签映射消息包含两个要素，FEC TLV和Label TLV。</p>
<p><img src="/2022/01/20/17-MPLS/1614152256771-9edf4c3b-c758-47d3-b52f-51a6a212913a.png" alt="img"></p>
<h2 id="PHP次末跳弹出机制"><a href="#PHP次末跳弹出机制" class="headerlink" title="PHP次末跳弹出机制"></a>PHP次末跳弹出机制</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>Penultimate hop popping (PHP) is a function performed by certain routers in an MPLS enabled network. It refers to the process whereby the outermost label of an MPLS tagged packet is removed by a Label Switch Router (LSR) before the packet is passed to an adjacent Label Edge Router (LER). The benefit is that the LSR has to do a label lookup anyway and it doesn’t make a difference whether this results in a label swap or pop. However, for the LER this saves one cycle of label lookup.</p>
<p>次末跳弹出机制，PHP（Penultimate hop poping）是一种在MPLS网络中特定服务器上执行的功能。它指的是MPLS数据最上层标签，在发送给LER路由器之前，被LSR剥离掉的过程。这样做的好处是LSR不管对上层标签是进行替换还是剥离动作，都得查询CEF表，但剥离了最上层标签后，最后一跳的LER路由器就省去了一次查找的过程。</p>
<p>次末跳弹出机制有两种标签，一种是POP或Implicit Null，中文为隐式空，在LDP中标签值为3；另一种是Explicit Null，中文为显式空，在LDP中标签值为0。</p>
<p>如果收到邻居发来的关于某条路由分配的标签值为3，那么本地在转发数据给邻居时，会将该标签弹出，再将内层数据转发给邻居；如果邻居关于某条路由分配的标签值为0，那么本地在转发数据给邻居时，会带上标签为0的标签头一并转发给邻居。</p>
<p>为什么显式空要带上一个标签为0的空标签而不直接去掉呢？是因为比如部署了MPLS QOS的时候，需要使用标签报头中的EXP字段，需要这个字段发挥作用，如果直接去掉了整个标签头，那么EXP字段也去掉了就没有QOS了，而QOS最后一跳必须携带EXP位，所以这里使用标签值为0的空标签头，来满足QOS的需要，配置‘mpls ldp explicit-null’来分配给特定路由的标签值为0使得次末跳弹出时采用显式空的方式来保留标签头。</p>
<h3 id="没有PHP机制"><a href="#没有PHP机制" class="headerlink" title="没有PHP机制"></a>没有PHP机制</h3><p><img src="/2022/01/20/17-MPLS/1614157324729-2118fa38-6728-4385-827e-415a76cc7268.png" alt="img"></p>
<ul>
<li><p>30.0/24这条前缀，路由器C分配的标签是23，这个映射传给了路由器B；B路由器给C分配的标签是22，这个映射传递给了A；</p>
</li>
<li><p>A下面有用户发送数据到30.0网络，于是A将数据压上了标签头，标签值为22。标签到了路由器B，B将标签替换成23，然后传递给C。</p>
</li>
<li><p>路由器C上，先查找LFIB表，发现要将标签弹出，于是C将标签弹出，然后发现是个IP报文，又查FIB表，最终将这个IP数据包转发出去。C进行了两次查找，降低了转发效率。如果标签能在次末跳，也就是路由器B上弹出，那么C只需要查找FIB表将收到的IP报文进行转发。</p>
</li>
</ul>
<h3 id="有PHP机制"><a href="#有PHP机制" class="headerlink" title="有PHP机制"></a>有PHP机制</h3><p><img src="/2022/01/20/17-MPLS/1614158443314-78803990-ef61-476a-b0e8-4da432af1a01.png" alt="img"></p>
<p>有了PHP次末跳弹出机制后，C为网段30.0/24前缀分配的标签为POP，也就是弹出，并将该标签通告给其他LDP邻居，如此一来，B收到A发送过来的标签值为22的标签包后，将会直接弹出标签将它变为IP包，然后再转发给C，路由器C只需要查找FIB表将数据转发即可。</p>
<h3 id="保留标签"><a href="#保留标签" class="headerlink" title="保留标签"></a>保留标签</h3><p>标签0-15都是被保留的标签，以下是一些有特定作用的保留标签：</p>
<ul>
<li><p>标签0：显式空标签；</p>
</li>
<li><p>标签3：隐式空标签；</p>
</li>
<li><p>标签1：路由器报警标签；</p>
</li>
<li><p>标签14：OAM报警标签；</p>
</li>
</ul>
<h4 id="隐式空标签"><a href="#隐式空标签" class="headerlink" title="隐式空标签"></a>隐式空标签</h4><p>在PHP中，我们已经了解了隐式空标签的作用，当然，隐式空标签不局限于PHP中，还可以运用在标签栈中有2-3个或多个标签的报文中，在出站LSR上使用隐式空标签（在LDP中，值为3）将会通知倒数第二跳路由器移除顶层标签，从而向出站LSR传递的带标签数据的标签数量就会少一个，这样的话，出站LSR就不需要执行两个标签的查找了。注意，使用隐式空标签并不是必须将标签中的所有标签都弹出，而是弹出顶层标签。</p>
<p>尽管隐式空标签也是用了一个标签值为3的标签，但标签3永远不会出现在MPLS报文的标签栈中，这也是其叫隐式空标签的原因。</p>
<p><img src="/2022/01/20/17-MPLS/1614227228290-2cdcbba9-542b-469a-9677-49e2b6d28e1a.png" alt="img"></p>
<p>显式空标签</p>
<p>在IPV4中，显式空标签为0，IPV6中为2。</p>
<p>上面的隐式空标签已经介绍过了，它确实可以增加效率，但也有一个问题，因为如果我收到一个下游邻居发送过来的关于某个特定前缀捆绑的隐式空标签，那么我在转发标签数据给该邻居之前，我会先将顶层标签弹出，那么这个弹出动作实际上是将整个顶层的标签头都弹出了，也就是连带着标签字段、EXP等字段都弹出了，而EXP字段用作QOS也被弹出了，意味着丢失了用于QOS的部分信息，因此又定义了显式空标签，用于应对上面描述的场景。</p>
<p><img src="/2022/01/20/17-MPLS/1614227446240-898320e5-483f-4653-beb0-1eddbf5cce34.png" alt="img"></p>
<p>上图中，C针对30.0/24的前缀捆绑了标签0，也就是显示空标签，然后将标签映射给路由器B，B也产生自己的标签映射然后发给A，那么这时候，如果B收到来自A的一个标签包，顶层标签值为20，那么B查找自己的LFIB，发现要将标签转换成0，于是B将顶层标签替换成0后发送给C，那么对于C来说它就收到了一个标签值为0的标签包，C不能通过在LFIB中查找标签值0来转发这样的报文，因为这个标签值可以分配给多个FEC，C只是仅仅弹出标签值为0的显式空标签，之后不得不进行另外一种查找，查找FIB表，虽然得进行两次查找，但C可以通过看标签头中的EXP位来获得该报文的QOS信息了。</p>
<h4 id="路由器报警标签"><a href="#路由器报警标签" class="headerlink" title="路由器报警标签"></a>路由器报警标签</h4><p>标签值为1，这个标签可以出现在标签栈的任何位置，除了栈底位以外。</p>
<p>当路由器报警标签位位于栈顶时，它向LSR发出警告说，该报文需特别注意，这样一来该报文就不会通过硬件传输，而是通过软件进程传输。一旦这个报文开始被转发，标签1首先被移除，接下来LSR在LFIB中对标签栈中的下一个标签进行查找然后执行相应的标签操作（添加、移除、交换），标签1又会被添加到标签的顶部，最后才被转发出去。</p>
<h4 id="OAM标签报警"><a href="#OAM标签报警" class="headerlink" title="OAM标签报警"></a>OAM标签报警</h4><p>OAM用于错误检测、定位和监控实施，该标签将普通报文和OAM报文区分开，思科执行MPLS OAM时不适用标签14来实现。</p>
<h2 id="标签模式"><a href="#标签模式" class="headerlink" title="标签模式"></a>标签模式</h2><p>MPLS有两种模式，一种是Frame Mode（帧模式），另一种是Cell Mode（细胞模式），但现网中用的几乎都是Frame Mode，所以一般情况下只记住关于Frame Mode的知识点就够了。</p>
<p>分配模式（Label Allocation）：Frame Mode 采用独立控制模式（Independent Control），只要本地通过IGP学习到路有前缀，就会为这条路由前缀分配标签，也会为直连路由分配POP标签。</p>
<p>分发模式（Label Distribution）：Frame Mode采用下游主动模式（Downstream Unsolicited），本地会主动将所生成的标签映射消息通告给所有LDP邻居。</p>
<p>保留模式（Label Retention）：Frame Mode采用自由模式（Liberal Retention），本地将从邻居接收到的所有标签映射消息保存在数据库中。</p>
<p>标签空间（Label Space）：Frame Mode采用基于平台的模式（Per-Platform），本地通告出去的标签映射消息对全局有意义，从不同的接口通告出去的同一FEC对应的标签相同。</p>
<h2 id="路由汇总对MPLS影响"><a href="#路由汇总对MPLS影响" class="headerlink" title="路由汇总对MPLS影响"></a>路由汇总对MPLS影响</h2><p><img src="/2022/01/20/17-MPLS/1614228556124-eec276a4-5dda-4f3e-ad54-20fc169bb1f8.png" alt="img"></p>
<p>路由器E上有条路由10.1.1.0/24被通告出来，然后在C上做了汇总，汇总路由为10.1.0.0/16并通告给B。</p>
<ul>
<li><p>路由汇总将原先的一段LSP分割成了两端；</p>
</li>
<li><p>A将数据压上标签23，到路由器B上，将标签头弹出给C（PHP机制），C收到这个IP包去查找FIB表，又将数据压上标签55交给D，D最后查找LFIB并将标签弹出为IP包，将IP包交给E，E将该IP数据转发到目的地。</p>
</li>
<li><p>在这个环境中这样使用没有太大问题，但路由汇总在点到点的LSP环境下就会有比较大的问题，比如在MPLS VPN或MPLS TE中。</p>
</li>
</ul>
<h2 id="环路检测"><a href="#环路检测" class="headerlink" title="环路检测"></a>环路检测</h2><ul>
<li><p>LDP的环路检测机制依赖于IGP协议；</p>
</li>
<li><p>如果出现环路（一般是IGP出了问题，如静态路由的配置错误），标签头中的TTL将方式标签包无尽的被转发；</p>
</li>
<li><p>标签头中的TTL与IP头中的TTL是一样的，通常拷贝自IP头中的TTL值（当一个IP包进入MPLS网络时的TTL），这是TTL的Propagation；</p>
</li>
</ul>
<h3 id="传统TTL操作"><a href="#传统TTL操作" class="headerlink" title="传统TTL操作"></a>传统TTL操作</h3><p><img src="/2022/01/20/17-MPLS/1614322971766-5febdffc-741d-4e2f-bdde-17cad05c6c06.png" alt="img"></p>
<p>数据包被路由器A压上标签，标签头的TTL值拷贝自IP报头中的TTL值（当然要先减去1），并且随着数据帧在MPLS网络中传输，MPLS头中的TTL值在递减，直到减少到0后丢弃或直到数据帧出了MPLS域，那么IP头中的TTL才开始工作，出站时，标签头中的TTL减1后拷贝到IP头中的TTL。</p>
<p>传统的TTL操作实际上存在一定的安全隐患，例如如果外人使用Traceroute命令的话，可能会暴露网络内部的结构，获取路径中所有设备的信息。</p>
<p>为什么会暴露网络内部结构呢？假设路由器A下面有路由器E，路由器E用Traceroute到D下面的F路由器的网段，那么数据会从E传给A，在A上被打上标签传递给B，在B上标签TTL递减至0，此时B丢掉数据并返回ICMP出错消息给E，然后E将原来Traceroute的TTL+1，到C后数据也被丢掉返回ICMP出错消息给E，以此类推，最终E能收到路途中每一跳路由器返回的ICMP差错消息，了解到内部网络的信息。</p>
<p>这时可以关闭TTL Propagation功能。</p>
<h3 id="关闭TTL-Propagation"><a href="#关闭TTL-Propagation" class="headerlink" title="关闭TTL Propagation"></a>关闭TTL Propagation</h3><p><img src="/2022/01/20/17-MPLS/1614326806100-9f8ca2be-a4eb-4bb1-b4ac-d2f895bce8d5.png" alt="img"></p>
<p>在A设备（一般在MPLS边界设备上）上配置‘no mpls ip propagate-ttl’特性。这样边界设备上加入标签头的时候，就不去拷贝原IP头里边的TTL值了，而是将TTL值配置为255。关闭TTL propagation可以避免MPLS网络因为Traceroute方式被暴露。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">no mpls ip propagate-ttl[forwarded | local]</span><br></pre></td></tr></table></figure>

<p>forwarded关键字表示这条命令仅针对穿越本路由器的流量生效。Local关键字表示针对本地产生的流量生效。</p>
<h3 id="TTL扩散行为"><a href="#TTL扩散行为" class="headerlink" title="TTL扩散行为"></a>TTL扩散行为</h3><p><img src="/2022/01/20/17-MPLS/1614327044811-96cb5b93-59a6-4bde-b5a2-66d5b4d76495.png" alt="img"></p>
<p>前面描述的是IP——标签包的TTL扩散过程，现在来看一下标签到标签的TTL扩散过程。</p>
<p>Swap这个过程很好理解，LSR在处理标签栈中有多个标签的标签数据时，只会处理顶层标签。因此Swap这个过程是在标签交换后，入站标签的TTL-1，然后拷贝到出站标签TTL上。</p>
<p>Push也是类似的过程，只对顶层标签操作，首先入站顶层标签的TTL249先减1，然后新压入的标签头TTL拷贝这个数值。</p>
<p>Pop则是顶层标签TTL-1然后弹出，新的TTL值被写入到出站数据的顶层标签上。</p>
<h2 id="LDP-amp-IGP同步"><a href="#LDP-amp-IGP同步" class="headerlink" title="LDP&amp;IGP同步"></a>LDP&amp;IGP同步</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><h1 id="MPLS配置"><a href="#MPLS配置" class="headerlink" title="MPLS配置"></a>MPLS配置</h1><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id loopback0      #ldp的routerID使用loopback接口的IP地址</span><br><span class="line">mpls label protocol ldp           #标签协议使用LDP（默认是LDP不用特意配置）</span><br><span class="line">mpls label range 100 199          #指定本地标签范围，方便观察现象和排错</span><br><span class="line">!</span><br><span class="line">interface e0/0</span><br><span class="line"> mpls ip                          #接口上激活mpls，实际上是激活LDP</span><br></pre></td></tr></table></figure>

<h3 id="邻居建立配置"><a href="#邻居建立配置" class="headerlink" title="邻居建立配置"></a>邻居建立配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpls ldp discovery hello interval XXX</span><br><span class="line">修改LDP的Hello消息发送间隔，默认为5秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mpls ldp discovery holdtime XXX</span><br><span class="line">修改LDP的Holetime，默认为15秒</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果两个LDP邻居的LDPHoletime配置不相同，那么其中较小那个值会被用作LDP的Holdtime时间，Cisco IOS可能会对已配置的LDP Hello间隔进行重写。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mpls ldp backoff (initial-backoff) (maximum-backoff)</span><br><span class="line">initial-backoff默认15秒，maximum-backoff默认120秒。</span><br><span class="line">两台LDP邻居在交换参数时又一次发现不匹配的话，这条命令可以减缓两台LDP LSR之间尝试去简历LDP会话的时间，如果会话建立失败，那么下一次再尝试的间隔时间回成倍数增长，直到maximum-backoff计时器超时。</span><br></pre></td></tr></table></figure>

<h3 id="show命令"><a href="#show命令" class="headerlink" title="show命令"></a>show命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip cef detail</span><br><span class="line">show tcp brief</span><br><span class="line">show mpls ldp discovery detail</span><br><span class="line">show mpls ldp parameters</span><br><span class="line">show mpls ldp neighbor</span><br><span class="line">show mpls ldp dicovery</span><br><span class="line">show mpls forwarding-table</span><br><span class="line">show mpls ldp bindings</span><br></pre></td></tr></table></figure>

<h2 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h2><p><img src="/2022/01/20/17-MPLS/1614395056568-6786a26e-203e-40ee-9dd9-abe2ee1d3269.png" alt="img"></p>
<p><strong>实验环境</strong></p>
<ul>
<li><p>R1、R2、R3、R4运行OSPF，宣告直连接口以及loopback接口，loopback接口IP为X.X.X.X/32，X为设备编号，该IP同时为LDP RouterID；</p>
</li>
<li><p>设备互联网段如图所示，例如10.1.23.0/24是R2-R3互联地址段，R2接口IP为10.1.23.2，R3接口IP为10.1.23.3，以此类推；</p>
</li>
<li><p>在所有设备上激活LDP，为了方便观察现象，为每台设备指定Label Range，如R1的Label Range为100-199，R2为200-299，以此类推；</p>
</li>
</ul>
<p><strong>实验需求</strong></p>
<ul>
<li><p>认识FIB、LIB、LFIB表；</p>
</li>
<li><p>了解LDP邻居关系建立过程；</p>
</li>
<li><p>了解数据在MPLS域中的转发过程；</p>
</li>
</ul>
<p><strong>实验配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 10.1.12.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">mpls label range 100 199</span><br><span class="line">interface e0/0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface e0/1</span><br><span class="line"> mpls ip</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">R2:</span><br><span class="line"> </span><br><span class="line">ip cef</span><br><span class="line"> !</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">mpls label range 200 299</span><br><span class="line">interface e0/0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface e0/1</span><br><span class="line"> mpls ip</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">R3:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.34.3 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">mpls label range 300 399</span><br><span class="line">interface e0/0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface e0/1</span><br><span class="line"> mpls ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.34.4 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">mpls label range 400 499</span><br><span class="line">interface e0/0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface e0/1</span><br><span class="line"> mpls ip</span><br></pre></td></tr></table></figure>

<p>配置OSPF的时候，偷懒使用了network 0.0.0.0 0.0.0.0 area 0的方式，在生产网配置的时候，还是尽量采用更规范的方式配置。</p>
<p><strong>实验现象</strong></p>
<p>完成上述配置后，可以检验一下，路由全网是互通的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls ldp neighbor</span><br><span class="line">    Peer LDP Ident: 2.2.2.2:0; Local LDP Ident 1.1.1.1:0</span><br><span class="line">        TCP connection: 2.2.2.2.62247 - 1.1.1.1.646</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 33/33; Downstream</span><br><span class="line">        Up time: 00:20:08</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/0, Src IP addr: 10.1.12.2</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.12.2       10.1.23.2       2.2.2.2</span><br></pre></td></tr></table></figure>

<p>上面是R1上显示的LDP邻居，‘Peer LDP Ident: 2.2.2.2:0;’说明邻居的LDP Router ID是2.2.2.2，Label space ID=0，说明是基于平台的标签空间（本地通告出去的标签映射消息对全局有意义，从不同的接口通告出去的同一FEC对应的标签相同）。</p>
<p>‘TCP connection: 2.2.2.2.62247 - 1.1.1.1.646’表示这个LDP连接是建立在TCP的1.1.1.1源端口646，到目的地2.2.2.2的62247端口，因为2.2.2.2的IP地址更大，所以它是发起方。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls ldp bindings             #看R1的LIB表</span><br><span class="line">  lib entry: 1.1.1.1/32, rev 2</span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: 200</span><br><span class="line">  lib entry: 2.2.2.2/32, rev 4</span><br><span class="line">        local binding:  label: 100</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: imp-null</span><br><span class="line">  lib entry: 3.3.3.3/32, rev 6</span><br><span class="line">        local binding:  label: 101</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: 203</span><br><span class="line">  lib entry: 4.4.4.4/32, rev 8</span><br><span class="line">        local binding:  label: 102</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: 201</span><br><span class="line">  lib entry: 10.1.12.0/24, rev 10</span><br><span class="line">        local binding:  label: imp-null</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: imp-null</span><br><span class="line">  lib entry: 10.1.23.0/24, rev 12</span><br><span class="line">        local binding:  label: 103</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: imp-null</span><br><span class="line">  lib entry: 10.1.34.0/24, rev 14</span><br><span class="line">        local binding:  label: 104</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: 202</span><br></pre></td></tr></table></figure>

<p>一旦LDP激活后，LDR会为路由表中的前缀在本地产生一个标签，然后和前缀捆绑在一起，将这个标签映射消息发送给所有LDP邻居。当我收到LDP邻居发来的标签（Remote Binding），针对某些前缀的标签捆绑后，路由器会将这些邻居发来的标签，以及本地为前缀捆绑的标签放置于LIB中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  lib entry: 3.3.3.3/32, rev 6</span><br><span class="line">        local binding:  label: 101</span><br><span class="line">        remote binding: lsr: 2.2.2.2:0, label: 203</span><br><span class="line">        </span><br><span class="line">比如R1的LIB中关于3.3.3.3/32这条前缀的标签，本地为该前缀捆绑的标签为101，从LDP邻居2.2.2.2（也就是R2）发来的标签为203</span><br></pre></td></tr></table></figure>

<p>当然，并不是LIB中的所有remote标签都会被用上，我们还需结合FIB表，来获得有关前缀的下一跳信息，最后形成LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">100        Pop Label  2.2.2.2/32       0             Et0/0      10.1.12.2</span><br><span class="line">101        203        3.3.3.3/32       0             Et0/0      10.1.12.2</span><br><span class="line">102        201        4.4.4.4/32       0             Et0/0      10.1.12.2</span><br><span class="line">103        Pop Label  10.1.23.0/24     0             Et0/0      10.1.12.2</span><br><span class="line">104        202        10.1.34.0/24     0             Et0/0      10.1.12.2</span><br></pre></td></tr></table></figure>

<p>现在来看一下当R1要发送数据去往R4的loopback接口4.4.4.4时，数据时如何传送的。</p>
<p>首先分析一下<strong>控制层面</strong>：</p>
<p>在R4上用命令‘show mpls ldp binding’查看R4为4.4.4.4绑定的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib entry: 4.4.4.4/32, rev 8</span><br><span class="line">      local binding:  label: imp-null</span><br></pre></td></tr></table></figure>

<p>由于4.4.4.4是R4上的loopback接口，所以R4为该前缀分配的标签为‘imp-null’也就是隐式空，R4将这个标签发送给R3，R3就知道当有MPLS数据前往4.4.4.4时，R3需要对该MPLS数据执行POP动作：</p>
<p><img src="/2022/01/20/17-MPLS/1614399239899-c825875e-9e96-488b-b726-be987368a072.png" alt="img"></p>
<p>R3上通过查询LIB表得知，R3为前缀4.4.4.4分配的标签为302，同时它还从2.2.2.2和4.4.4.4都收到了LDP邻居分配的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib entry: 4.4.4.4/32, rev 8</span><br><span class="line">      local binding:  label: 302</span><br><span class="line">      remote binding: lsr: 2.2.2.2:0, label: 201</span><br><span class="line">      remote binding: lsr: 4.4.4.4:0, label: imp-null</span><br></pre></td></tr></table></figure>

<p>然后R3将自己为4.4.4.4分配的标签302发给R2：</p>
<p><img src="/2022/01/20/17-MPLS/1614399754426-ed51ae3a-7297-4d7b-a8a2-71de3916b2b3.png" alt="img"></p>
<p>R2上通过查询LIB表得知，R2为前缀4.4.4.4分配的标签为201，同时它从1.1.1.1和3.3.3.3都收到了LDP邻居分配的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib entry: 4.4.4.4/32, rev 6</span><br><span class="line">      local binding:  label: 201</span><br><span class="line">      remote binding: lsr: 1.1.1.1:0, label: 102</span><br><span class="line">      remote binding: lsr: 3.3.3.3:0, label: 302</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/17-MPLS/1614399988211-a0663356-6874-40be-b2b6-b9422efdec0a.png" alt="img"></p>
<p>R1上通过查询LIB表得知，R1从R2收到了LDP邻居分配的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lib entry: 4.4.4.4/32, rev 8</span><br><span class="line">      local binding:  label: 102</span><br><span class="line">      remote binding: lsr: 2.2.2.2:0, label: 201</span><br></pre></td></tr></table></figure>

<p>现在来看看<strong>数据层面</strong></p>
<p>当R1要去ping 4.4.4.4时，R1查自己的FIB也就是CEF表，此时是一个IP查找：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip cef 4.4.4.4</span><br><span class="line">4.4.4.4/32</span><br><span class="line">  nexthop 10.1.12.2 Ethernet0/0 label 201</span><br></pre></td></tr></table></figure>

<p>CEF条目指示，要去往4.4.4.4，需要给IP报文压上标签成为MPLS数据，标签值为201，然后将数据丢给下一跳，10.1.12.2，从E0/0口发出，由于只有一层标签，所以BOS位为1，具体抓包如下：</p>
<p><img src="/2022/01/20/17-MPLS/1614407204777-d93d35a6-6709-4b5a-b89e-bce3be3cfa06.png" alt="img"></p>
<p>接下来看R2，当R2收到这个标签包后，从它的二层以太网帧头的字段类型得知，这是一个标签包，因为Type字段值为0X8847，因此去查找自己的LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">200        Pop Label  1.1.1.1/32       0             Et0/0      10.1.12.1</span><br><span class="line">201        302        4.4.4.4/32       590           Et0/1      10.1.23.3</span><br></pre></td></tr></table></figure>

<p>这个入站标签包的标签值为201，在R2的LFIB表中显示，要将标签Swap替换成302，然后从E0/1口发出，于是R2将标签替换成302然后发送给了R3。</p>
<p><img src="/2022/01/20/17-MPLS/1614407807099-18bd06c7-6913-4a1f-93c7-5c9dafc08757.png" alt="img"></p>
<p>R3收到了这个MPLS数据，同样先查看自己的LFIB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3# show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">300        200        1.1.1.1/32       0             Et0/0      10.1.23.2</span><br><span class="line">301        Pop Label  2.2.2.2/32       0             Et0/0      10.1.23.2</span><br><span class="line">302        Pop Label  4.4.4.4/32       570           Et0/1      10.1.34.4</span><br><span class="line">303        Pop Label  10.1.12.0/24     570           Et0/0      10.1.23.2</span><br></pre></td></tr></table></figure>

<p>R3发现，入站标签为302的MPLS数据，出站标签是POP，于是它将顶层标签（实际上只有一层标签）弹出，然后直接将弹出的数据丢给10.1.34.4，注意，此时它无需再查询FIB表，因为LFIB表中已经有下一跳信息了，最终这个数据被传到了R4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#traceroute 4.4.4.4</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 4.4.4.4</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.12.2 [MPLS: Label 201 Exp 0] 2 msec 1 msec 1 msec</span><br><span class="line">  2 10.1.23.3 [MPLS: Label 302 Exp 0] 1 msec 1 msec 1 msec</span><br><span class="line">  3 10.1.34.4 1 msec 1 msec *</span><br></pre></td></tr></table></figure>

<h2 id="关于OSPF"><a href="#关于OSPF" class="headerlink" title="关于OSPF"></a>关于OSPF</h2><p>在前面的配置中，所有设备的loopback接口都是/32位的，因此没出问题，现在我们来看看R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">100        Pop Label  2.2.2.2/32       0             Et0/0      10.1.12.2</span><br><span class="line">101        203        3.3.3.3/32       0             Et0/0      10.1.12.2</span><br><span class="line">102        201        4.4.4.4/32       0             Et0/0      10.1.12.2</span><br><span class="line">103        Pop Label  10.1.23.0/24     0             Et0/0      10.1.12.2</span><br><span class="line">104        202        10.1.34.0/24     0             Et0/0      10.1.12.2</span><br></pre></td></tr></table></figure>

<p>来看关于2.2.2.2/32这条，现在的Outgoing Label是Pop Label，也就是空标签，现在我们将R2的loopback接口改为24位掩码，也就是2.2.2.2/24，看会有什么现象。</p>
<p><img src="/2022/01/20/17-MPLS/1614408697600-c31d0b39-2996-44db-85b3-e3251763c538.png" alt="img"></p>
<p>标签从POP编程了No Label（也就是Untaged）了，为什么呢？我们修改了R2的loopback接口地址的掩码，从32位变成了24位，那么对于R2自己这个直连路由就是2.2.2.0/24，R2会为该前缀分配标签，由于是直连，所以R2给这条前缀分配了个空标签3，然后将标签映射消息发送给其他LDP邻居，比如R1和R3：</p>
<p><img src="/2022/01/20/17-MPLS/1614409192066-8f1ad9db-c8ca-4ddd-90f9-277657013d25.png" alt="img"></p>
<p>R1和R3收到了这个标签，前缀是2.2.2.0/24，标签是3，与此同时，他们也收到了R2更新过来的路由，由于loopback接口的路由被OSPF更新默认是采用/32位的方式更新的，因此R1和R3上学到的关于2.2.2.2的路由是32位的，那么就有问题了，我这条路由的条目是2.2.2.2/32，但标签信息中却是2.2.2.0/24的，不匹配。于是R1就认为通过标签到不了2.2.2.2/32，所以分配了No Label（也就是Untaged）的标签，因为R1认为MPLS到不了2.2.2.2/32，但路由中有该前缀的路由所以用传统的IP数据包肯定能到，于是将所有MPLS标签头弹出（No label\Untag）变成IP数据包再查找FIB表是符合逻辑的，在这个网络环境中貌似没什么问题，但在许多环境下，却会出现问题，比如MPLS VPN这个环境中，如何解决呢？在R2的loopback接口上配置‘ip ospf network point-2-point’或者修改掩码都可以。</p>
<h2 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h2><h3 id="TTL-Propagate"><a href="#TTL-Propagate" class="headerlink" title="TTL-Propagate"></a>TTL-Propagate</h3><p>在上面实验中，R1上Traceroute4.4.4.4的输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#traceroute 4.4.4.4</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 4.4.4.4</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.12.2 [MPLS: Label 201 Exp 0] 2 msec 1 msec 1 msec</span><br><span class="line">  2 10.1.23.3 [MPLS: Label 302 Exp 0] 1 msec 1 msec 1 msec</span><br><span class="line">  3 10.1.34.4 1 msec 1 msec *</span><br></pre></td></tr></table></figure>

<p>可以看到每一跳的地址以及标签都清晰可见，这样会有安全性上的风险，因此通过在LER边界路由器（ingress路由器和egress路由器上都要配置）上关闭ttl-propagate特性可以隐藏MPLS中间的路由信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#no mpls ip propagate-ttl</span><br><span class="line">R1(config)#do traceroute 4.4.4.4</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 4.4.4.4</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.34.4 2 msec 4 msec *</span><br></pre></td></tr></table></figure>

<h3 id="targeted邻居关系建立"><a href="#targeted邻居关系建立" class="headerlink" title="targeted邻居关系建立"></a>targeted邻居关系建立</h3><h3 id="LDP认证"><a href="#LDP认证" class="headerlink" title="LDP认证"></a>LDP认证</h3><p>LDP会话是一种TCP会话，TCP会话可能会受到TCP碎片欺骗的攻击，可以使用LDP认证来进行保护，MD5将添加一个签名，又叫做MD5摘要，到TCP分段中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpls ldp neighbor [vrf vrf-name] ip-address password [0 | 7] password-string</span><br><span class="line">例如：</span><br><span class="line">Router(config)# mpls ldp neighbor vrf vpn1 10.1.1.1 password nbrce1pwd</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">使用命令show mpls ldp neighbor [vrf vrf-name] [ip-address | interface] [detail] [graceful-restart]查看配置情况</span><br><span class="line">Router# show mpls ldp neighbor vrf vpn1 detail</span><br></pre></td></tr></table></figure>

<h3 id="LDP-autoconfig"><a href="#LDP-autoconfig" class="headerlink" title="LDP autoconfig"></a>LDP autoconfig</h3><p>通常的做法是在每个运行IGP的接口上使用‘mpls ip’来激活LDP协议，但有一种更简单的办法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> mpls ldp autoconfig area 0</span><br></pre></td></tr></table></figure>

<p>所有ospf中属于area 0的接口都将自动激活LDP，如果某个特定接口不希望激活LDP协议，可以使用‘no mpls ldp igp来关闭LDP’</p>
<p><img src="/2022/01/20/17-MPLS/1614411688860-abf76105-ebad-4587-a852-dc0e468aa3a6.png" alt="img"></p>
<h1 id="MPLS环境下的BGP路由传递"><a href="#MPLS环境下的BGP路由传递" class="headerlink" title="MPLS环境下的BGP路由传递"></a>MPLS环境下的BGP路由传递</h1><p>MPLS不会为BGP路由分配标签，但会为BGP路由的下一跳分配标签。</p>
<h2 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h2><p><img src="/2022/01/20/17-MPLS/1614412798115-45537f1e-7b89-42f2-bb5d-20322514a556.png" alt="img"></p>
<p><strong>拓扑环境描述：</strong></p>
<ul>
<li><p>R1、R2、R3、R4处于Transit AS 1234，在AS内运行的IGP协议是OSPF；</p>
</li>
<li><p>所有的互联网IP如图所示；</p>
</li>
<li><p>所有设备的loopback接口地址为x.x.x.x/32，x为设备编号；</p>
</li>
<li><p>R1与R4之间建立IBGP邻接关系，IBGP邻接关系建立在物理接口上，R1与R5，R4与R6之间建立EBGP邻接关系，也是建立在物理接口上；</p>
</li>
<li><p>在这个实验中，在OSPF中宣告R1-R5和R4-R6的直连网段；</p>
</li>
<li><p>R5和R6各自在BGP进程中宣告自己的loopback路由；</p>
</li>
</ul>
<p>由于R2\R3没有运行BGP协议，并且Core OSPF内也没有5.5.5.0及6.6.6.0的路由，因此最终结果是R5和R6虽然能够学习到彼此的路由，但却无法相互访问，因为R2\R3上出现了路由黑洞。解决办法就是用MPLS，下面我们将Core变成MPLS域：</p>
<p>分别在R1-R4四台路由器上配置MPLS的LDP Router ID，标签范围以及在接口上激活LDP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label range 100 199</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.15.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 10.1.12.1 0.0.0.0 area 0</span><br><span class="line"> network 10.1.15.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 10.1.15.5 remote-as 500</span><br><span class="line"> neighbor 10.1.34.4 remote-as 1234</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">mpls label range 200 299</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label range 300 399</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.34.3 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">mpls label range 400 499</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.34.4 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.46.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.34.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.46.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 10.1.12.1 remote-as 1234</span><br><span class="line"> neighbor 10.1.46.6 remote-as 600</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.15.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 500</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 5.5.5.5 mask 255.255.255.255</span><br><span class="line"> neighbor 10.1.15.1 remote-as 1234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R6:</span><br><span class="line"></span><br><span class="line">ip cef</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.46.6 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 600</span><br><span class="line"> bgp router-id 6.6.6.6</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 6.6.6.6 mask 255.255.255.255</span><br><span class="line"> neighbor 10.1.46.4 remote-as 1234</span><br></pre></td></tr></table></figure>

<p>R1-R4运行了LDP协议后，LDP默认不会为BGP路由分配标签，但我们也知道，BGP路由都有nexthop，这个下一跳是IGP路由可达的，LDP则会为这条（下一跳地址所在的）路由分配标签，这一点非常重要。这样一来，5.5.5.5和6.6.6.6之间就能够互访了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#ping  5.5.5.5 source 6.6.6.6</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 5.5.5.5, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 6.6.6.6</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/3 ms</span><br></pre></td></tr></table></figure>

<p>R6上关于5.5.5.5的路由为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show ip cef 5.5.5.5</span><br><span class="line">5.5.5.5/32</span><br><span class="line">  nexthop 10.1.46.4 Ethernet0/0</span><br></pre></td></tr></table></figure>

<p>于是R6将数据从E0/0口发送给R4。此时R4上的CEF表项为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip cef 5.5.5.5 detail</span><br><span class="line">5.5.5.5/32, epoch 0, flags [rib only nolabel, rib defined all labels]</span><br><span class="line">  recursive via 10.1.15.5</span><br><span class="line">    recursive via 10.1.15.0/24</span><br><span class="line">      nexthop 10.1.34.3 Ethernet0/0 label 304</span><br></pre></td></tr></table></figure>

<p>R4上路由表中关于5.5.5.5路由的下一跳为10.1.15.5，而10.1.15.5的路由下一跳为10.1.34.3，也就是R3，CEF表项在进行了递归查询以后，将该数据压上了值为304的标签头，从E0/0口发出给R3。但LDP是不会为BGP路由分配标签的，但会为BPG路由的下一跳，这里BGP路由的下一跳是10.1.15.5，为它分配标签，304。R3收到标签头为304的MPLS数据后，查询LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">300        200        1.1.1.1/32       0             Et0/0      10.1.23.2</span><br><span class="line">301        Pop Label  2.2.2.2/32       0             Et0/0      10.1.23.2</span><br><span class="line">302        Pop Label  4.4.4.4/32       0             Et0/1      10.1.34.4</span><br><span class="line">303        Pop Label  10.1.12.0/24     11482         Et0/0      10.1.23.2</span><br><span class="line">304        203        10.1.15.0/24     5016          Et0/0      10.1.23.2</span><br><span class="line">305        Pop Label  10.1.46.0/24     5196          Et0/1      10.1.34.4</span><br></pre></td></tr></table></figure>

<p>发现Local Label为304的数据接下来应该将标签Swap替换成203，然后从E0/0口发出给下一跳为10.1.23.2，也就是发送给R2。R2收到标签头为203的MPLS数据后，查询LFIB表后发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">200        Pop Label  1.1.1.1/32       0             Et0/0      10.1.12.1</span><br><span class="line">201        Pop Label  3.3.3.3/32       0             Et0/1      10.1.23.3</span><br><span class="line">202        302        4.4.4.4/32       0             Et0/1      10.1.23.3</span><br><span class="line">203        Pop Label  10.1.15.0/24     5570          Et0/0      10.1.12.1</span><br><span class="line">204        Pop Label  10.1.34.0/24     9868          Et0/1      10.1.23.3</span><br><span class="line">205        305        10.1.46.0/24     5130          Et0/1      10.1.23.3</span><br></pre></td></tr></table></figure>

<p>本地标签为203的下个标签为POP，也就是将头部标签弹出，变成了IP数据包。这里为什么会POP呢？因为这条BGP路由其实用的是它下一跳10.1.15.0的标签，而10.1.15.0是R1的直连网段，因此R1在这里为这个直连网段分配了POP的标签，将这个结果发送给了R2。然后查询过CEF表后发现，该数据的下一跳为10.1.12.1，从E0/0口发出给R1，之所以要查两个表示因为入站为MPLS数据出站为IP数据的，输入时走LFIB表，输出时使用FIB（CEF）表。于是将IP数据发给了R1，而R1上是有5.5.5.5/32的路由的，15.5和R1直连，从而完成了数据传输：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B        5.5.5.5 [20/0] via 10.1.15.5, 01:21:08</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/17-MPLS/1614419007456-0df6b8ab-545f-428b-8c91-25516316a4e5.png" alt="img"></p>
<h2 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h2><p>在上面的实验中，在Core的OSPF中宣告了R1-R5以及R4-R6的直连网段，然而在实际中不会宣告这条AS外的链路，所以现在不在OSPF中宣告10.1.15.0以及10.1.46.0这两个路由，停止宣告后由于OSPF没有了这两个直连网段的路由，那么5.5.5.5和6.6.6.6学到以后在本地就不是最优路由了，所以需要在R1对R4以及R4对R1上使用nexthopself的命令，配置过后，R4上去往5.5.5.5的下一跳为10.1.12.1，当6.6.6.6访问5.5.5.5的时候IP包到达R4，R4查CEF并且为IP包压上标签，此时R4会使用10.1.12.0这条路由的标签（因为MPLS只会给BGP的下一跳分配标签，在这里12.0就是去往5.5.5.5的下一跳），而这个标签是R3分配的，那么这个标签包被传递到了R3，R3会如何处理？R3会将标签POP变成IP包然后丢给R2，因为R2为路由10.1.12.0分配的标签就是POP，12.0是R2的直连网段，这里有次末跳弹出机制。那么这个IP包到了R2就被丢弃了，因为R2根本没有6.6.6.6和5.5.5.5的路由，该怎么办呢？用R1和R4的loopback接口建立IBGP邻居。之前使用物理接口建立IBGP邻居时为了更好的理解MPLS环境下BGP路由的问题，现在在R1\R4上使用loopback接口来建立IBGP邻居关系，这样问题就解决了。R4上去往5.5.5.5的下一跳是R1的loopback接口地址，所以R4在给去往5.5.5.5的IP包亚标签的时候，压入的是1.1.1.1/32路由的标签，R2\R3也一样，那么标签就能通过1.1.1.1/32打通的LSP一路传到R2并在R2这里弹出标签变为IP包再传递给R1，R1再将IP包发给R5。</p>
<p>因此路由器不会对BGP路由直接分配标签，而是为BGP路由通过递归后的下一跳路由分配标签，这样做是很有好处的。BGP中的路由条目相当多，如此一来我们通过MPLS，可以大大简化路由器的性能损耗，BGP的Transit AS的路由黑洞也得到了很好的解决。</p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://networklessons.com/mpls/introduction-to-mpls/">Introduction to MPLS</a></p>
<p><a href="https://community.cisco.com/t5/routing/rib-fib-lib-lfib/m-p/3917174">RIB,FIB,LIB,LFIB</a></p>
<p><a href="https://community.cisco.com/t5/mpls/relationship-between-lib-fib-and-lfib/td-p/782307">Relationship between LIB,FIB and LFIB</a></p>
<p><a href="https://community.cisco.com/t5/mpls/lfib-table/m-p/1835742">LFIB table</a></p>
<p><a href="https://blog.51cto.com/361531/1693692">MPLS 2个转发平面</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>18-MPLSVPN</title>
    <url>/2022/01/20/18-MPLSVPN/</url>
    <content><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><p>MPLS VPN的全称是Virtual Private Network，MPLS VPN是最广泛使用、最受欢迎的MPLS技术。</p>
<h2 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>VPN，Virtual Private Network，中文是虚拟专用网络 ，VPN是在公共网络上模拟建立专用网络并进行加密通讯的技术。VPN可能在OSI模型的二层或三层上进行通讯，在二层上进行通讯的VPN叫L2VPN，在三层上进行通讯的叫L3VPN。VPN通常被那些有多个分支机构的公司所使用的，因为不同分支机构之间要交互数据，必须确保数据的安全稳定可靠传输。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a><a href="https://baike.baidu.com/item/%E8%99%9A%E6%8B%9F%E4%B8%93%E7%94%A8%E7%BD%91%E7%BB%9C/8747869?fromtitle=VPN%E6%8A%80%E6%9C%AF&fromid=1897662&fr=aladdin">适用场景</a></h3><p>例如某公司员工出差到外地，他想访问企业内网的服务器资源，这种访问就属于远程访问。</p>
<p>在传统的企业网络配置中，要进行远程访问，传统的方法是租用DDN（数字数据网）专线或帧中继，这样的通讯方案必然导致高昂的网络通讯和维护费用。对于移动用户（移动办公人员）与远端个人用户而言，一般会通过拨号线路（Internet）进入企业的局域网，但这样必然带来安全上的隐患。</p>
<p>让外地员工访问到内网资源，利用VPN的解决方法就是在内网中架设一台VPN服务器。外地员工在当地连上互联网后，通过互联网连接VPN服务器，然后通过VPN服务器进入企业内网。为了保证数据安全，VPN服务器和客户机之间的通讯数据都进行了加密处理。有了数据加密，就可以认为数据是在一条专用的数据链路上进行安全传输，就如同专门架设了一个专用网络一样，但实际上VPN使用的是互联网上的公用链路，因此VPN称为虚拟专用网络，其实质上就是利用加密技术在公网上封装出一个数据通讯隧道。有了VPN技术，用户无论是在外地出差还是在家中办公，只要能上互联网就能利用VPN访问内网资源，这就是VPN在企业中应用得如此广泛的原因。</p>
<h2 id="L2VPN-VS-L3VPN"><a href="#L2VPN-VS-L3VPN" class="headerlink" title="L2VPN VS L3VPN"></a><a href="https://networkengineering.stackexchange.com/questions/51961/difference-between-l2-vpn-and-l3vpn-how-evpn-used-with-vxlan-and-mpls">L2VPN VS L3VPN</a></h2><p><img src="/2022/01/20/18-MPLSVPN/1614583691339-a5a8e068-2518-442b-943e-ca2a21b601a0.jpeg" alt="img"></p>
<p>上图出自于<a href="https://ipwithease.com/layer-2-vs-layer-3-vpn/">这个网页</a>，比较全面的概括了二层VPN和三层VPN的区别。简单来说，L2层MPLS VPN和L3层MPLS VPN的区别在于转发所基于的地址不同，L2 MPLS VPN转发基于二层PDU中的二层地址，二层PDU被封装在传输协议MPLS中；L3层MPLS VPN转发基于三层地址，三层PDU被封装在传输协议MPLS中。</p>
<table>
<thead>
<tr>
<th></th>
<th>二层VPN（L2 VPN）</th>
<th>三层VPN（L3 VPN）</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>二层VPN虚拟化了数据链路层（二层），使得物理上不在同一地址的分支机构的网络，看起来像是直连一样，在同一个局域网中</td>
<td>三层VPN虚拟化了网络层（三层），这样使得路由可以通过公网的线路（比如运营商的骨干网络）来为客户网络提供路由，L3VPN的远程站点之间不像直连一样</td>
</tr>
<tr>
<td>数据转发方式</td>
<td>运营商依据二层信息转发客户流量</td>
<td>运营商依据三层信息转发客户流量</td>
</tr>
<tr>
<td>可扩展性</td>
<td>通常来说，二层VPN的扩展性比三层VPN的扩展性要弱</td>
<td>通常来说，三层VPN的扩展性比二层VPN的扩展性要强</td>
</tr>
<tr>
<td>三层连接性</td>
<td>客户与它的远程站点建立三层（IP）连接，与运营商没有三层连接，也就是和运营商之间没有建立任何路由层面的联系</td>
<td>客户与运营商的边界路由器建立起三层连接，也就是客户的路由器和运营商路由器之间是邻居关系</td>
</tr>
<tr>
<td>运营商参与程度</td>
<td>运营商没有参与客户网络的路由</td>
<td>运营商参与了客户网络的路由</td>
</tr>
<tr>
<td>路由控制</td>
<td>如果客户希望对路由和策略有较好的掌控，L2层VPN是首选</td>
<td>当客户愿意共享路由信息及控制策略不严格的情况下，可以选择L3VPN</td>
</tr>
<tr>
<td>举例</td>
<td>LANE, IPLS, VPLS, EOMPLS, 802.1q Tunnelling</td>
<td>MPLS VPN, IPSEC P2P</td>
</tr>
</tbody></table>
<h2 id="MPLSVPN构架"><a href="#MPLSVPN构架" class="headerlink" title="MPLSVPN构架"></a>MPLSVPN构架</h2><p><img src="/2022/01/20/18-MPLSVPN/1614588767377-804573fc-391f-4120-a247-63d6ef98977c.png" alt="img"></p>
<h3 id="PE设备"><a href="#PE设备" class="headerlink" title="PE设备"></a>PE设备</h3><p>PE设备全称是：Provider Edge，中文是运营商边界设备，运行MPLS协议，PE和客户设备三层连接，和客户设备运行路由协议形成邻居（也可用静态路由），PE设备获取客户的VPN路由并将路由生成VPNV4前缀放入MPLS VPN Backbone传递到对端的PE设备上。PE设备和P设备通过Core内的IGP路由协议（通常是ISIS）交换Core路由。PE路由器之间通过MP-BGP协议形成MP-IBGP邻居交换VPN路由。PE设备和CE端相连的部分为VRF工作的区域，和P设备相连的部分为全局路由表工作区域，所以PE路由器包含两种路由表，全局路由表和VRF路由表。全局路由表包含通过CoreIGP学到的Core内的路由以及Internet路由（通过IPV4 BGP学习到的）；VRF路由表包含与所创建的VRF关联的虚拟路由表。</p>
<h3 id="P设备"><a href="#P设备" class="headerlink" title="P设备"></a>P设备</h3><p>P设备全称是Provider，中文是运营商设备，P设备不和客户设备直接相连。P设备往往并不知道VPN客户网络以及客户的路由，它只负责在Backbone内运载表数据，参与数据平面的转发。</p>
<h3 id="CE设备"><a href="#CE设备" class="headerlink" title="CE设备"></a>CE设备</h3><p>CE设备全称是Customer Edge，中文是客户边界设备，CE设备和PE设备直接相连，主要功能是将客户的路由通告给PE设备，以及从PE设备学习同一个VPN下其他站点的路由。CE路由器只是一台普通的IP路由器，支持eBGP\OSPF\EIGRP\静态路由等标准路由协议。</p>
<h2 id="VRF"><a href="#VRF" class="headerlink" title="VRF"></a>VRF</h2><p>MPLS VPN一个厉害的地方就是可以让不同客户的路由以及数据穿越运营商的MPLS VPN Backbone，而且这些路由和数据又是相互隔离和独立的，即使不同的客户拥有相同的IPV4地址空间也没关系。</p>
<p>那么作为客户路由进入MPLS Backbone的入口设备，PE就显得非常重要了。在PE上有个非常重要的概念——VRF。</p>
<p>VRF全称为Virtual Routing and Forwarding，翻译成虚拟路由及转发，它是一种VPN路由和转发实例。一台PE路由器，可能同时连接了多个VPN用户，这些用户（的路由）彼此之间需要相互隔离，那么这时候就用到了VRF。PE路由器上每一个VPN都有一个VRF。PE路由器除了维护全局IP路由表以外，还为每个VRF维护一张独立的IP路由表，这张路由表称为VRF路由表。必须注意，前面说到的全局IP路由表和每个VRF的路由表都是相互独立或相互隔离的。</p>
<p>因为每个VPN都有一张独立的VRF路由表，所以PE路由器上每一个VPN也会有一张独立的CEF表来转发这些报文，这就是VRF CEF表。</p>
<p>一旦在PE路由器上创建了一个VRF，我们就可以将特定的接口（物理或逻辑的）放入这个VRF，那么这个接口就不在属于全局IP路由表或其他任何VRF，只为该VRF服务。</p>
<p>比如下图左边，有三个VRF，分别是VRF蓝、黄、绿，这三个VRF的路由相互隔离，各自有各自的路由表（VRF蓝路由表、VRF绿路由表、VRF黄路由表），下图右边的路由器中有三个VRF（红黄蓝），可以理解为这三个VRF相当于有三个不同的路由器。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614652716260-462937d1-7e4a-4c1d-9cd0-3963a7eafc6b.png" alt="img"></p>
<p>这个概念如何理解呢？如果对DC和Marvel宇宙有了解的话，不同的VRF和路由表的概念，和漫画中的平行宇宙有点类似，漫画中有多个平行的宇宙世界，每个世界中可能有蝙蝠侠、超人这些英雄，但每个宇宙中的这些超级英雄之间是相互不知道对方，彼此之间也不产生联系的，比如地球1中的英雄只在地球1中出现，他们的所作所为不会影响到地球23中的其他英雄。</p>
<h2 id="RD值"><a href="#RD值" class="headerlink" title="RD值"></a>RD值</h2><p>由于VPN前缀是通过MP-BGP在MPLS VPN网络中扩散，那么在同一时间可能运营商的MPLS VPN网络中承载着多个客户的VPN前缀，甚至可能时使用相同空间的IPV4地址，比如192.168.1.0这个私网网段地址，很多公司可能都在用，如果同一时间使用这个私网地址的两个公司同时传输数据到运营商，运营商如何分辨哪个路由是哪个公司的呢？这就需要RD值了。RD值在VRF中进行配置。</p>
<p>RD英文全称为Route Distinguish，长度为64bit，用于在MP-BGP运载VRF前缀时确保这些前缀的唯一性，在控制层面区分路由，但RD并不会说明该前缀属于哪一个VRF（这个功能需要搭配RT值使用），RD的功能并不是VPN标识符，因为在一些复杂的VPN环境中可能一个VPN存在多个RD。RD最重要的两个功能：</p>
<ul>
<li>与32bit长的ipv4前缀一起构成96bit的VPNV4前缀；</li>
<li>如果不同的VPN客户，存在相同的IPV4空间地址，那么可以通过设置不同的RD值，保证前缀的唯一性；</li>
</ul>
<p>这个64bit的值，可以有两种表现形式：AS : NN或IP address : NN，其中NN代表编号，最常用的格式是AS：NN。其中AS代表AS号。通常AS是IANA分配给运营商的AS号，NN是运营商分配给VRF的唯一号码，比如假设AS号是300，编号为11，那么RD值可以写作‘300:11’，这个RD+IPV4构成的VPNV4前缀就是‘300：11,192.168.1.0’，和其他的VPNV4前缀，比如‘200:21,192.168.1.0’在传输中就是不同的前缀了。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614650271169-2ffbd20f-67ce-47c7-a456-3bcc14cef35c.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615626423647-f86a327e-bbd5-4b5f-b0fa-9e2675d6fe59.png" alt="img"></p>
<p>产生的VPNV4前缀通过MP-BGP在路由器之间被传递：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614649915508-2dd7230b-4106-4aab-81d2-5b85ffe53b5e.png" alt="img"></p>
<p>RD值用来标识那些位于不同VRF的路由前缀的唯一性，那么如何共享使用这些路由呢？用RT值。</p>
<h2 id="RT"><a href="#RT" class="headerlink" title="RT"></a><a href="https://community.cisco.com/t5/routing/rd-and-rt-in-mpls-vpn/td-p/726375">RT</a></h2><p>RT全称为Route Targets。用来区分VPN Customer及控制VPN路由宣告，指导VPN前缀应该导入（导出）到哪个VRF中，它是BGP community的扩展属性，在VRF中进行配置，RT跟随VPN V4前缀的后面一起呗传递，一条路由可以附加多个RT值。格式和上面的RD类似，为XXX ：YYY，比如234:2。RT分为两种，一种是Export RT，另一种是Import RT。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614671304467-692e80f6-a5da-4b30-a008-0a457e273245.png" alt="img"></p>
<h3 id="Export-RTs"><a href="#Export-RTs" class="headerlink" title="Export RTs"></a>Export RTs</h3><p>export RT -&gt; attached to the routes when exported from the VRF (VPN identifier)</p>
<p>Export RT值的作用简单来说就是，从VRF中导出VPN路由时，用Export RT值对VPN路由进行标记。</p>
<p>在VRF中定义Export RT值，使得输出的VPNV4路由携带上该RT值一起传递——用BGP扩展community的方式。这些VPNV4路由，是由VPN客户端的IPV4路由导入VRF后，加上VRF中配置的RD值所形成的。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614672157230-9c4488b0-7af8-44ec-a4bc-c9dec9543221.png" alt="img"></p>
<h3 id="Import-RT"><a href="#Import-RT" class="headerlink" title="Import RT"></a>Import RT</h3><p>import RT -&gt; Used to select which routes to be imported into the VRF from the routes received via MP-BGP (Import route filter)</p>
<p>Import RT值的作用简单来说就是，当往VRF表中导入VPN路由时，只有那些所携带的RT值与VRF表中任意一个Import RT制相符的路由才会被注入VRF表中。</p>
<p>PE会从其他MP-BGP对等体的PE那收到VPNV4的前缀，这些前缀都是携带RT值的，默认情况下，PE是不会将这些VPNV4路由以IPV4的形式装载到VRF路由表中的，除非在本地的VRF中，配置import RTs。如果Import RTs与收到的VPNV4前缀中的RT匹配的话，这些VPNV4前缀才会被以IPV4的形式装载到相应的VRF路由表中，相当于在这里RT起到一个前缀过滤或识别的作用，这个功能在许多场景中非常有用。</p>
<p>VPNV4路由可能携带不止一个RT值，只要有一个匹配Import RT即可导入到VRF路由表中。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614672394555-bda3dfa1-6f0e-46dc-845f-63164d8232ab.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1614673509840-fc780418-45b2-4238-94ee-33d0cd7fe43e.png" alt="img"></p>
<h3 id="如何使用RT值"><a href="#如何使用RT值" class="headerlink" title="如何使用RT值"></a>如何使用RT值</h3><p><img src="/2022/01/20/18-MPLSVPN/1614742826667-3bbab48e-74ce-4991-b018-19c4db981bfe.png" alt="img"></p>
<p>比如上图中，R1的RT Export值是65002:1，R2的RT import值有65002:1，那么这两个设备之间就可以相互注入VRF路由。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614743359231-7e975c6b-7741-4696-9c46-31969e15c89f.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1614743364266-1bede2b0-9186-4db7-a3ec-b33d516593db.png" alt="img"></p>
<h2 id="VRF配置"><a href="#VRF配置" class="headerlink" title="VRF配置"></a>VRF配置</h2><h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ip vrf name </span><br><span class="line">创建VRF，比如‘ip vrf Blue’就是创建名称为‘Blue’的VRF,VRF名字本地有效，大小写敏感，VRF在创建后必须设定RD值，否则不可用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-vrf)# rd route-distinguisher </span><br><span class="line">进入VRF模式后，分配rd值给该VRF，可使用ASN：XX或A.B.C.D：XX格式输入rd，建议采用ASN:XX的形式，PE路由器上每个VRF的RD必须是唯一的，比如配置‘Router(config-vrf)# rd 1:2’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-vrf)# route-target export RT </span><br><span class="line">设置当路由被从VRF导出到MP-BGP时携带的RT值，可以输入多条RT，也就是说一跳VPNV4路由运行时携带多个RT值，RT值实际上是通过BGP的扩展community属性来携带的，比如配置‘Router(config-vrf)# route-target export 1:2’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-vrf)# route-target import RT </span><br><span class="line">通过设置Import RT从而将匹配的路由放入VRF，注意，只有被匹配的路由才会被导入VRF中，可以输入多个RT，比如配置‘Router(config-vrf)# route-target import 100:1’</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config)# interface e 0/0 </span><br><span class="line">Router(config-if)# ip vrf forwarding vrf-name </span><br><span class="line">Router(config-if)# ip address 10.1.12.2 255.255.255.0</span><br><span class="line">将接口分配到特定的VRF中，一旦配置了‘ip vrf forwarding XX’命令后，该接口的IP地址将被清除，需要重新手工分配IP地址</span><br></pre></td></tr></table></figure>

<h3 id="show-命令"><a href="#show-命令" class="headerlink" title="show 命令"></a>show 命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Show ip vrf  </span><br><span class="line">Show ip vrf detail </span><br><span class="line">Show ip vrf detail interface </span><br><span class="line">Show ip vrf interface </span><br><span class="line">show ip protocol vrf</span><br><span class="line">show ip route vrf</span><br><span class="line">show ip cef vrf x</span><br></pre></td></tr></table></figure>

<h2 id="PE设备逻辑"><a href="#PE设备逻辑" class="headerlink" title="PE设备逻辑"></a>PE设备逻辑</h2><p><img src="/2022/01/20/18-MPLSVPN/1614674865488-6f55906d-91b2-41d7-8652-0084ecb8c5b5.png" alt="img"></p>
<p>PE设备是MPLS VPN部署中非常关键的一个环节。上面这张图就是一个典型的PE路由器的逻辑分解图，蓝色的框表示的是一台PE路由器，内部两个虚线框可以理解为PE使用VRF为VPN所创造的两个‘虚拟路由器’，这个PE设备创建了两个VRF，VRF-A对应的是客户A，VRF-B对应的是客户B。</p>
<p>一旦创建了两个VRF，我们就可以将特定的接口放入特定的VRF，那么这些接口将只为所属的VRF服务。上图中的PE路由器实际上有了三张路由表，两张VRF路由表和一张全局IP路由表。</p>
<p>一个PE路由器可以连接不同的VPN客户，使用类似于虚拟路由器（VRF实例）的概念，来进行逻辑上的区分，比如上图中的Virtual route for A和Virtual route for B。这些客户甚至可能使用相同的地址空间，比如客户A和B都是用192.168.0.0作为内网的IP地址，在一台PE上使用VRF路由表，将不同客户的路由进行逻辑上的隔离。这里Virtual路由表是相对我们全局IP路由的概念，从Global接口上学习到的路由，放入全局路由表，从VRF接口上学习到的路由，放入相对应的VRF路由表。不同的Virtual路由表完全隔离。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614675552594-0654550e-452b-4d7a-a544-5dedcae6651b.png" alt="img"></p>
<p>上面这个PE中，创建了VRF ABC，那么同时一并出现的还有VRF ABC的路由表以及VRF ABC的CEF表，将PE上和CE直连的接口放入VRF ABC，然后分析PE：</p>
<ul>
<li><p>PE上，会运行一个Core的IGP骨干协议，这里使用的是OSPF100，这个OSPF进程是为全局IP路由表贡献路由的，属于全局路由表。OSPF100与运营商骨干网内的其他设备形成OSPF邻居关系并且交互骨干网Core内的路由，交互这些路由的目的是，可以为后面的MP-BGP的建立而服务，因为MP-BGP往往是通过PE质检的loopback接口来建立的，MP-BGP邻居关系建立需要这些IGP路由，另外后续的LDP也依赖这个Core的IGP协议。后续的LDP也依赖于这个Core的IGP协议。通过OSPF进程100学习到的路由，放入该PE路由器的全局路由表。</p>
</li>
<li><p>PE创建了VRF，名字是ABC，就相当于出现了一台虚拟路由器叫ABC，虚拟路由器ABC有专属于ABC的VRF路由表和CEF，与之前的全局路由表相互隔离互不冲突。创建VRF的时候需要同时定义RD值、RT import和RT export值。RD值用于和IPV4前缀组装形成VPNV4路由以便通过MP-BGP传播。RT值用于识别VRF或者说识别客户。</p>
</li>
<li><p>PE上运行一个CE-PE之间的路由协议，这个路由协议可以使静态、RIP、EIGRP或BGP这些都没问题，目的是为了从VPN客户（也就是CE设备）那学到客户的路由。注意由于连接CE的接口被放入了VRF ABC中，因此通过这个接口学习到的路由，也会被放入VRF ABC的路由表。放入VRF ABC的路由表之后呢？要将路由引入到MP-BGP（MP-BGP的address-family ipv4 vrf ABC）中，如果PE-CE之间运行路由协议是BGP以外的协议，那么久需要做路由重发布，将客户的路由重新发布到address-family ipv4 vrf ABC这个地址簇下面，而如果PE-CE之间运行的已经是BGP了，那么路由当然就直接进入MP-BGP了。</p>
</li>
<li><p>PE上运行一个MP-BGP后，MP-BGP至少有两个address-family地址簇，一个是address-family vpnv4，另一个是address-familty ipv4 vrf ABC。address-family vpnv4用来和对端的PE交换VPNV4前缀；address-family ipv4 vrf ABC是和VRF ABC关联的，用于获取VPN客户（在上图中是Customer A）的路由。</p>
</li>
<li><p>现在MP-BGP已经有了VPN客户的路由，现在要将这些IPV4的路由前缀，变成VPNV4的路由前缀，通过已经建立起来的VPNV4邻接关系传递给队员PE设备。由于这些路由是属于VRF ABC的，而VRF是定义了RD和RT值的，那么这些值在这里就派上用场了。VPNV4前缀（96bit）=RT（64bit）+ipv4前缀（32bit），然后RT Export 跟随这个VPNV4前缀，被MP-BGP更新给了对端PE。</p>
</li>
</ul>
<h2 id="MPLS-VPN控制层面"><a href="#MPLS-VPN控制层面" class="headerlink" title="MPLS VPN控制层面"></a>MPLS VPN控制层面</h2><h3 id="总提传播过程"><a href="#总提传播过程" class="headerlink" title="总提传播过程"></a>总提传播过程</h3><p><img src="/2022/01/20/18-MPLSVPN/1614745353437-816ed39a-9130-46b5-aaac-6bd82899bbaf.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615018803692-1c774e45-6904-46c6-8b01-ff49b42d24d0.png" alt="img"></p>
<ul>
<li><p>左侧PE和CE之间，通过运行IGP或BGP路由协议的方式，将客户的IPV4路由宣告给PE路由器；</p>
</li>
<li><p>VRF可以在PE路由器上隔离用户路由，PE路由器通过PE-CE的路由协议（可以使IGP也可以是eBGP）从VRF接口学到客户的路由后，路由被放入VRF路由表。客户的IPV4路由注入到PE的VRF路由表中，为VRF配置RD和Import RT、Export RT值；</p>
</li>
<li><p>IPV4路由重新发布到MP-BGP中（如果CE-PE之间用的BGP协议就不需要重发布），64bit长的RD被添加到32bit长的ipv4路由上，构成96bit长的VPNV4地址，使得前缀在不运行BGP没有VRF的Core区域具有唯一性；RT值被添加到MPBGP的community扩展属性上；</p>
</li>
<li><p>两个PE路由器之间形成MP-IBGP邻居关系，并相互宣告带有MPLS标签（也就是VPN标签，由MPBGP分配给前缀），以及VPNV4路由前缀以及RT值，RT值是放在MPBGP的community属性中通过update报文传输的；</p>
</li>
<li><p>路由传递到位于右侧对端的PE后，Import RT值代表着路由会注入哪个VRF。RD从VPNV4头部移除，变成普通的IPV4路由；</p>
</li>
<li><p>右侧PE路由器上，根据RT值决定将IPV4路由注入相应的VRF路由表；</p>
</li>
<li><p>右侧PE通过和CE之间运行IGP或BGP路由协议的方式，将相应VRF路由表中的IPV4路由传递给CE路由器；</p>
</li>
</ul>
<h3 id="具体传播过程"><a href="#具体传播过程" class="headerlink" title="具体传播过程"></a>具体传播过程</h3><p><img src="/2022/01/20/18-MPLSVPN/1614757804880-36531019-03e0-45ad-833a-2ed481acd851.png" alt="img"></p>
<p>PE的动态路由协议有多种选择，如Static、RIP、EIGRP、OSPF、ISIS、BGP等等。PE-CE之间运行路由协议的目的是为了让PE学习到客户的VPN路由。由于PE上连接特定CE的接口是属于特定VRF的，因此从这个接口上学习到的客户路由都会进入该VRF的路由表。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614758851049-38a497f6-364e-4b30-bc02-59c5a76a80f9.png" alt="img"></p>
<p>PE之间运行的是MP-BGP，也就是多协议的BGP，经过扩展的BGP协议能够承载VPNV4路由。经过前面的步骤，PE的VRF路由表中已经学习到了客户的路由，接下去要让MP-BGP知道这些路由。如果PE-CE之间运行的是非BGP协议，那么当然，需要将VRF路由表中的客户路由重发布到BGP中，如果PE-CE之间运行的协议已经是BGP了，自然不用再做重发布了。</p>
<p>客户的IPV4路由被注入MP-BGP后，RD被添加到了这些IPV4路由前缀前面，构成了VPNV4路由前缀，同时RTs也被附加到VPNV4路由前缀。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614759938182-1efd791d-752c-4335-896c-88326d850755.png" alt="img"></p>
<p>由于两端PE之间已经建立起了MP-BGP连接，因此PE将VPNV4路由前缀（连同这个前缀关联的MPLS标签，RTs等属性）一并通告给另一端的PE路由器。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614760007167-245bb868-6ec9-461f-8b97-ebe987be4d5e.png" alt="img"></p>
<p>对端的PE叶霈智了VRF，VRF中定义了import RTs，它根据RTs将受到的VPNV4导入特定的VRF，RD被从VPNV4路由中移除，所以路由变成了ipv4路由。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614760077055-4f5df71b-950c-4929-b002-5c6fb73f1556.png" alt="img"></p>
<p>IPV4路由被注入到了VRF路由表中，当然这些路由现在是BGP的路由条目。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1614760133863-e778efd3-ba9e-4ae1-8a8b-80c0e8599099.png" alt="img"></p>
<p>同样的，PE-CE之间的路由协议帮助我们将PE上的IPV4路由最终更新给CE。</p>
<h2 id="MPLS-VPN的数据层面"><a href="#MPLS-VPN的数据层面" class="headerlink" title="MPLS VPN的数据层面"></a>MPLS VPN的数据层面</h2><p><img src="/2022/01/20/18-MPLSVPN/1615019033775-8e6054b5-a936-4495-8cc2-263494ce17ae.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615020171189-048cde03-bd16-4930-a5ec-dda92e123a44.png" alt="img"></p>
<h3 id="外层标签"><a href="#外层标签" class="headerlink" title="外层标签"></a>外层标签</h3><p>位于运营商两侧的公司的分站点A和B不可能使用IP数据包进行传输，因为P路由器并没有PE上才有的VRF信息，这个问题由MPLS的标签解决解决，MPLS如何分配标签呢？一般来说MPLS VPN情况下都由LDP协议进行分配（MPLS TE情况下由RSVP分配），所有运营商的P和PE路由器都运行LDP协议，使得所有的ip流量都能够使用标签传输。这时IP数据包使用标签在Ingress PE和Egress PE之间传输，当数据经过P路由器时无需根据目标地址进行查找而是进行MPLS标签转发。这个标签叫做IGP标签（也叫做外层标签，命名相对应后面的内层VPN标签而言），因为这层标签是和Backbone中全局路由表里的IPV4前缀绑定的，由于MPLS不能给BGP分配标签，所以这个标签实际上是给BGP的下一跳分配的标签，由运营商中的IGP协议宣告。外层IGP标签的作用是帮助数据包穿越MPLS域。</p>
<p>下图中，当R6（172.16.6.6）上ping R1（10.1.1.1）时，数据包到了R5以后，R5会给数据压上外层标签，但我们知道，MPLS不会为BGP分配标签，而是会给BGP的下一跳分配标签，而PE之间（在图中就是R2和R5之间）一般使用Loopback接口建立IBGP邻居，R2将BGP路由条目发送给R5，所以10.1.1.0/24路由在R5路由表上的下一跳是R2，也就是2.2.2.2，因此这个外层标签是R4给R5分配的去往2.2.2.2/32的MPLS标签。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615184195567-1afb1cb1-846e-4b24-9058-e714259907c0.png" alt="img"></p>
<h3 id="内层标签"><a href="#内层标签" class="headerlink" title="内层标签"></a>内层标签</h3><p>那么，PE如何知道数据属于哪个VRF呢？这部分信息并没在IP报头中体现，在IGP标签（外层标签）中也没有体现，因为IGP标签（外层标签）只能用来在运营商内部转发。而上面提到的RT是控制层面的概念，转发层面用不到，VPNV4路由是没法在数据层面上去做路由转发的，因为数据包的目的IP地址只能是IPV4或IPV6地址，PE收到一个例如192.168.1.0网段的内网地址就不知道该如何传递了，它可能有多个客户都是用这个内网地址，而且数据包中并没有RT值或VPNV4地址等相关信息来告诉路由器这个数据属于哪个VRF（RT这些控制层面的信息是之前通过BGP的Update传递到对端PE的）。从全局角度来说，路由器也只会有IPV4或IPV6的路由表，而没有VPNV4路由表，RD值、VPNV4路由仅仅是在控制层面区分路由，数据层面的数据包转发只能靠IPV4、IPV6路由表，FIB和MPLS。</p>
<p>解决办法是再加一层标签，也就是内层标签，又叫VPN标签，由Ingress PE通过MP-BGP分配，这层标签的作用是来告诉Egress PE路由器数据包的下一跳为哪个CE，知道下一跳为哪个CE自然知道了数据属于哪个VRF。</p>
<p>下图中内层VPN标签是由R2为R1上10.1.1.0/24路由分配的MPLS标签。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615185109644-4e9a9725-2540-41e0-80cb-6aca3c2480c9.png" alt="img"></p>
<h3 id="数据传输理论"><a href="#数据传输理论" class="headerlink" title="数据传输理论"></a>数据传输理论</h3><p><img src="/2022/01/20/18-MPLSVPN/1615188271251-15818982-8db6-4729-8359-836ea4f8d147.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615273819298-6b5870cd-d1a6-4b4c-a7a7-f301da73676a.png" alt="img"></p>
<p>数据从左侧的CE传输到Ingress PE上，因为从CE发来的数据包是IP包，PE和CE相连的接口属于特定的VRF，所以在PE上会查询VRF的CEF表，最终IP包会被压上两层标签，外层MPLS标签（IGP标签）和内层的VPN标签。内层VPN标签是为了告诉Egress PE数据包最后要发送到哪个CE客户上，从而知道数据在PE上注入哪个VRF，比如说客户A的数据就使用100的内层标签，客户B的数据使用200的内层标签，PE看到内层标签就知道该发送到哪个CE自然也就知道是哪个VRF的数据了。内层标签是由出站的Egress PE通过MPBGP分配的。但沿途的P路由器并没有和Egress形成MPBGP邻居，看不懂VPN标签，无法将数据传给Egress PE，所以使用外层IGP标签使得数据顺利传递过Core 区域，外层标签由LDP分配。在Ingress PE上，外层标签是由数据转发的下一跳（也就是PE的邻居——P路由器）分配的，标签属于出站路由器Egress PE的Loopback接口，在上图中在R2是Ingress PE，R5为Egress PE的情况下，也就是R3为5.5.5.5分配的标签，因为5.5.5.5是下一跳（在配置了Next-hop-self的情况下）。当数据从R2传到R3后，外层标签在R3上被替换，替换成R4分配给5.5.5.5的标签，到R4上由于5.5.5.5是R5直连的网段，所以R5为该网段分配的标签为POP，次末跳弹出机制，因此在R4上会把外层标签弹出，然后发送给R5。作为Egress PE的R5会根据内层VPN标签将数据交给对应的VRF及CE，至此数据传输结束。</p>
<h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><p><img src="/2022/01/20/18-MPLSVPN/1615538112791-2ebc839d-85ff-4131-9219-764d19f4e527.png" alt="img"></p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><p><strong>拓扑及环境</strong></p>
<p>这是一个典型的 MPLS VPN 基础实验环境，R2、R3、R4 为运营商的设备，其中 R2 为 PE1，R4 为 PE2。 R1 及 R5 分别是 CE1 及 CE2，代表同一个 VPN 客户的两个站点。</p>
<p>IP 编址如图所示，设备互联地址采用 10.1.xy.0/24，其中 xy 为设备编号，x 小 y 大。另外所有的设备均配置 Loopback0，地址采用 x.x.x.x/32，x 为设备编号。</p>
<p>CE1 与 PE1 之间运行的 PE-CE 路由协议是 EIGRP，EIGRP 进程号是 1； CE2 与 PE2 之间运行的 PE-CE 路由协议是 OSPF，使用的 OSPF 进程号是 1。</p>
<p>MPLS VPN Backbone 内运行的全局 IGP 是 OSPF，使用进程号 100。</p>
<p>PE1 与 PE2 之间维护 MP-iBGP 邻接关系，交互 VPNv4 路由，BGP 的 AS 号是 234。</p>
<p>R2、R3、R4 之间维护 LDP 邻接关系，交互 IGP 标签。</p>
<p><strong>需求及步骤</strong></p>
<p>\1. 完成基本 IP 配置 </p>
<p>\2.  Core 内运行 OSPF（进程号 100） ，激活 LD</p>
<p>\3. 在 PE 上创建 VRF，将 PE-CE 间的接口放入 VRF；在 PE 和 CE 之间运行 IGP 协议 </p>
<p>\4.  PE 配置 MP-BGP，建立 MP-iBGP 邻接关系 </p>
<p>\5. 完成 PE-CE 之间路由的重发布 </p>
<p><strong>配置及实现</strong></p>
<p>基本IP配置见最后的配置汇总</p>
<p>Core 内部运行OSPF进程，进程号为1，并激活LDP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">router ospf 1        #//Core内部的IGP用OSPF协议交互Core内路由</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">ip cef                         #//开启CEF是MPLS协议的前提</span><br><span class="line">mpls ldp router-id Loopback0   #//设置LDP Router ID</span><br><span class="line">mpls label range 200 299       #//设置标签范围方便观察</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> mpls ip                       #//在接口激活MPLS</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">ip cef                         #//开启CEF是MPLS协议的前提</span><br><span class="line">mpls ldp router-id Loopback0   #//设置LDP Router ID</span><br><span class="line">mpls label range 300 399       #//设置标签范围方便观察</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> mpls ip                       #//在接口激活MPLS</span><br><span class="line"> interface Ethernet0/1</span><br><span class="line"> mpls ip                       #//在接口激活MPLS</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">R4:</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.34.4 0.0.0.0 area 0</span><br><span class="line"> !</span><br><span class="line">ip cef                         #//开启CEF是MPLS协议的前提</span><br><span class="line">mpls ldp router-id Loopback0   #//设置LDP Router ID</span><br><span class="line">mpls label range 400 499       #//设置标签范围方便观察</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> mpls ip                       #//在接口激活MPLS</span><br></pre></td></tr></table></figure>

<p>配置后，R2\R3\R4之间可以建立起LDP邻居：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show mpls ldp neighbor</span><br><span class="line">    Peer LDP Ident: 4.4.4.4:0; Local LDP Ident 3.3.3.3:0</span><br><span class="line">        TCP connection: 4.4.4.4.20749 - 3.3.3.3.646</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 136/137; Downstream</span><br><span class="line">        Up time: 01:52:42</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/1, Src IP addr: 10.1.34.4</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.34.4       4.4.4.4</span><br><span class="line">    Peer LDP Ident: 2.2.2.2:0; Local LDP Ident 3.3.3.3:0</span><br><span class="line">        TCP connection: 2.2.2.2.646 - 3.3.3.3.48066</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 124/126; Downstream</span><br><span class="line">        Up time: 01:41:22</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/0, Src IP addr: 10.1.23.2</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.23.2       2.2.2.2</span><br></pre></td></tr></table></figure>

<p>在PE上创建VRF，将PE-CE之间的接口放入VRF；在PE和CE之间运行IGP协议：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">两台PE配置如下：</span><br><span class="line">R2：</span><br><span class="line">ip vrf CISCO    #//配置名为CISCO的VRF</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2    #//配置RT Export</span><br><span class="line"> route-target import 234:4    #//配置RT Import，将对端PE路由导入正确的VRF</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO    #//将接口放入VRF CISCO中</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0    #//放入VRF中接口需要重新配置地址</span><br><span class="line">!</span><br><span class="line">router eigrp 1    #//PE-CE之间的IGP协议，用于从CE学习客户路由</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO autonomous-system 1    #//要在VRF中宣告路由并指定AS否则无法建立邻居</span><br><span class="line">  redistribute bgp 234 metric 10000 100 255 1 1500</span><br><span class="line">  network 10.0.0.0</span><br><span class="line"> exit-address-family</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> R4：</span><br><span class="line"> ip vrf CISCO    #//配置名为CISCO的VRF</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:4    #//配置RT Export</span><br><span class="line"> route-target import 234:2    #//配置RT Import，将对端PE路由导入正确的VRF</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO   #//将接口放入VRF CISCO中</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0    #//放入VRF中接口需要重新配置地址</span><br><span class="line">!</span><br><span class="line">router ospf 234 vrf CISCO    #//PE-CE之间的IGP协议，用于从CE学习客户路由</span><br><span class="line"> router-id 44.44.44.44</span><br><span class="line"> network 10.1.45.4 0.0.0.0 area 0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 两台CE配置如下：</span><br><span class="line"> R1：</span><br><span class="line"> router eigrp 1</span><br><span class="line"> network 1.0.0.0</span><br><span class="line"> network 10.0.0.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 5.5.5.5 0.0.0.0 area 0</span><br><span class="line"> network 10.1.45.5 0.0.0.0 area 0</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> PE-CE之间的邻居和路由结果如下：</span><br><span class="line"> R2#show ip eigrp vrf CISCO neighbors</span><br><span class="line">EIGRP-IPv4 Neighbors for AS(1) VRF(CISCO)</span><br><span class="line">H   Address                 Interface              Hold Uptime   SRTT   RTO  Q  Seq</span><br><span class="line">                                                   (sec)         (ms)       Cnt Num</span><br><span class="line">0   10.1.12.1               Et0/0                    11 04:04:47    9   100  0  3</span><br><span class="line"></span><br><span class="line">R2#show ip route vrf CISCO</span><br><span class="line">Routing Table: CISCO</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/24 is subnetted, 1 subnets</span><br><span class="line">D        1.1.1.0 [90/409600] via 10.1.12.1, 03:30:39, Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show ip route vrf CISCO</span><br><span class="line"></span><br><span class="line">Routing Table: CISCO</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">O        5.5.5.5 [110/11] via 10.1.45.5, 03:51:11, Ethernet0/1</span><br></pre></td></tr></table></figure>

<p>两台PE都学到了CE上的路由，1.1.1.1和5.5.5.5。</p>
<p>PE之间配置MP-BGP，R2-R4之间建立MP-IBGP邻居关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> no bgp default ipv4-unicast    #//开启MP-BGP</span><br><span class="line"> neighbor 4.4.4.4 remote-as 234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate    #//在VPNV4地址簇中激活R4的VPNV4连接</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2.2.2.2 remote-as 234</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 2.2.2.2 activate</span><br><span class="line">  neighbor 2.2.2.2 send-community extended</span><br></pre></td></tr></table></figure>

<p>配置VPNV4邻居时，先在进程中配置neighbor，然后再去VPNV4地址簇中激活，注意这里PE1-PE2之间的邻接关系是建立在Loopback接口上的。</p>
<p>验证PE之间的MP-BGP邻居：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip bgp vpnv4 all summary</span><br><span class="line">BGP router identifier 2.2.2.2, local AS number 234</span><br><span class="line">BGP table version is 8, main routing table version 8</span><br><span class="line">5 network entries using 780 bytes of memory</span><br><span class="line">5 path entries using 420 bytes of memory</span><br><span class="line">4/4 BGP path/bestpath attribute entries using 672 bytes of memory</span><br><span class="line">3 BGP extended community entries using 540 bytes of memory</span><br><span class="line">0 BGP route-map cache entries using 0 bytes of memory</span><br><span class="line">0 BGP filter-list cache entries using 0 bytes of memory</span><br><span class="line">BGP using 2412 total bytes of memory</span><br><span class="line">BGP activity 5/0 prefixes, 5/0 paths, scan interval 60 secs</span><br><span class="line"></span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line">4.4.4.4         4          234     280     279        8    0    0 04:10:20        2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2#show ip bgp vpnv4 all neighbors 4.4.4.4 | in VPNv4</span><br><span class="line">    Address family VPNv4 Unicast: advertised and received</span><br><span class="line"> For address family: VPNv4 Unicast</span><br></pre></td></tr></table></figure>

<p>PE-CE之间路由重发布</p>
<p>PE——CE之间已经知道了彼此的路由，现在要将客户路由发布到BGP中形成VPNV4路由的前缀来通过MP-IBGP传递给对端PE，为了让CE之间知道对方的路由，还要在PE上将BGP路由重新发布进PE-CE之间的IGP，但必须注意，由于运营商的BGP路由条目众多，可能有一两百万路由，普通客户的CE路由器是无法承载如此大批量的路由，所以重发布时一定要谨慎，下面配置中由于路由少，所以直接将IGP和BGP之间重发布，真实网络中要做很多限制配置，确保只有必须的路由进入CE路由器，否则会直接让CE宕机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">router eigrp 1</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute bgp 234 metric 10000 100 255 1 1500</span><br><span class="line"> !</span><br><span class="line">router bgp 234</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute eigrp 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router ospf 234 vrf CISCO</span><br><span class="line"> redistribute bgp 234 subnets</span><br><span class="line"> !</span><br><span class="line">router bgp 234</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 234 match internal external 1 external 2</span><br></pre></td></tr></table></figure>

<p>注意，重发布时在IPV4地址簇下进行的，因为要对客户的路由进行区分隔离，在VRF CISCO中的路由和全局路由以及其他VRF中路由相互隔离。配置完毕后，查看两台客户端中的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        1.1.1.0/24 is directly connected, Loopback0</span><br><span class="line">L        1.1.1.1/32 is directly connected, Loopback0</span><br><span class="line">      5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">D EX     5.5.5.5 [170/307200] via 10.1.12.2, 03:06:12, Ethernet0/0</span><br><span class="line">      10.0.0.0/8 is variably subnetted, 5 subnets, 2 masks</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5# show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/24 is subnetted, 1 subnets</span><br><span class="line">O E2     1.1.1.0 [110/1] via 10.1.45.4, 03:17:37, Ethernet0/0</span><br><span class="line">      5.0.0.0/8 is variably subnetted, 2 subnets, 2 masks</span><br></pre></td></tr></table></figure>

<p>这里查看的是全局路由表，因为CE上没有VRF，只有全局路由。可以看到CE之间已经学到了对方的路由，现在进行测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#ping 5.5.5.5 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 5.5.5.5, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 1.1.1.1</span><br><span class="line">!!!!!</span><br><span class="line">Success rate is 100 percent (5/5), round-trip min/avg/max = 1/1/2 ms</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#tr 5.5.5.5 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 5.5.5.5</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.12.2 1 msec 2 msec 3 msec</span><br><span class="line">  2 10.1.23.3 [MPLS: Labels 301/403 Exp 0] 8 msec 2 msec 2 msec</span><br><span class="line">  3 10.1.45.4 [MPLS: Label 403 Exp 0] 1 msec 1 msec 1 msec</span><br><span class="line">  4 10.1.45.5 2 msec 3 msec *</span><br></pre></td></tr></table></figure>

<p>配置汇总：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname R1</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback10</span><br><span class="line"> ip address 10.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line"> network 1.0.0.0</span><br><span class="line"> network 10.0.0.0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname R2</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2</span><br><span class="line"> route-target import 234:4</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 200 299</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Loopback9</span><br><span class="line"> no ip address</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> --More--</span><br><span class="line">*Mar 12 08:38:33.923: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">router eigrp 1</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute bgp 234 metric 10000 100 255 1 1500</span><br><span class="line">  network 10.0.0.0</span><br><span class="line">  autonomous-system 1</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute eigrp 1</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname R3</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 300 399</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname R4</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:4</span><br><span class="line"> route-target import 234:2</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 400 499</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 234 vrf CISCO</span><br><span class="line"> router-id 44.44.44.44</span><br><span class="line"> redistribute bgp 234 subnets</span><br><span class="line"> network 10.1.45.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.34.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2.2.2.2 remote-as 234</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 2.2.2.2 activate</span><br><span class="line">  neighbor 2.2.2.2 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 234 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname R5</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 5.5.5.5 0.0.0.0 area 0</span><br><span class="line"> network 10.1.45.5 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="数据层面说明"><a href="#数据层面说明" class="headerlink" title="数据层面说明"></a>数据层面说明</h4><p>数据层面上，从1.1.1.1访问5.5.5.5是如何传输报文的呢？</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615549036762-52424004-c6c9-4c62-b503-08bfacaac89a.png" alt="img"></p>
<p>从Traceroute结果可以看出上面的转发过程，首先R1发出的是IPV4报文，源是1.1.1.1，目的是5.5.5.5：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615549155547-b2703f0f-0630-49d5-8650-030fe7faf560.png" alt="img"></p>
<p>数据包到达了R2后，由于是IP数据包，而且是从VRF接口收到的，所以R2查看自己的VRF CISCO的CEF表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip cef vrf CISCO 5.5.5.5</span><br><span class="line">5.5.5.5/32</span><br><span class="line">  nexthop 10.1.23.3 Ethernet0/2 label 301-(local:201) 403</span><br></pre></td></tr></table></figure>

<p>从CEF表中可以看出，去往5.5.5.5的数据需要压入两层标签，分别是外层IGP标签301和内层VPN标签403，然后交给10.1.23.3，于是R2将IPV4数据包压入标签栈，然后将标签包交给R3：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615549395639-0e3d5ce6-7638-411a-b6d6-8242bf9946b3.png" alt="img"></p>
<p>R3收到该数据后发现是个带标签的数据包，于是查看自己的LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">300        Pop Label  2.2.2.2/32       47030         Et0/0      10.1.23.2</span><br><span class="line">301        Pop Label  4.4.4.4/32       46161         Et0/1      10.1.34.4</span><br></pre></td></tr></table></figure>

<p>LFIB中显示，收到一个顶层标签为301的标签包后，需要将该数据的顶层标签POP弹出，然后交给下一跳10.1.34.4。于是R3将收到的数据中的顶层标签301弹出，然后交给10.1.34.4。注意这里其实是个PHP机制。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615549637650-3e4f3e82-b5f6-4e8b-8e62-b4bfa606b95d.png" alt="img"></p>
<p>那么R4收到了带标签的数据包后，也会查看LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">400        300        2.2.2.2/32       0             Et0/0      10.1.34.3</span><br><span class="line">401        Pop Label  3.3.3.3/32       0             Et0/0      10.1.34.3</span><br><span class="line">402        Pop Label  10.1.23.0/24     0             Et0/0      10.1.34.3</span><br><span class="line">403        No Label   5.5.5.5/32[V]    5462          Et0/1      10.1.45.5</span><br><span class="line">404        No Label   10.1.45.0/24[V]  0             aggregate/CISCO</span><br></pre></td></tr></table></figure>

<p>R4发现顶层标签为403的数据包，对应的Outgoing Label是No label，于是它将整个标签栈都弹出（实际上只剩下一层标签了），然后它将原始数据，也就是IPV4数据直接丢给10.1.45.5.数据包到了R5，也就是对端的CE。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615550465917-f803553b-158e-425c-ae1a-74d3f6707e1f.png" alt="img"></p>
<h4 id="控制层面说明"><a href="#控制层面说明" class="headerlink" title="控制层面说明"></a>控制层面说明</h4><p><img src="/2022/01/20/18-MPLSVPN/1615550880874-b5808c3f-245c-48b0-a49f-2f53b40643fb.png" alt="img"></p>
<p><strong>内层标签</strong></p>
<p>R4在通过MP-IBGP将VPNV4前缀，1:1:5.5.5.5/32，宣告给R2的时候，会为这个前缀捆绑一个VPN标签403：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">400        300        2.2.2.2/32       0             Et0/0      10.1.34.3</span><br><span class="line">401        Pop Label  3.3.3.3/32       0             Et0/0      10.1.34.3</span><br><span class="line">402        Pop Label  10.1.23.0/24     0             Et0/0      10.1.34.3</span><br><span class="line">403        No Label   5.5.5.5/32[V]    1254          Et0/1      10.1.45.5</span><br><span class="line">404        No Label   10.1.45.0/24[V]  0             aggregate/CISCO</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show ip bgp vpnv4 rd 1:1 labels</span><br><span class="line">   Network          Next Hop      In label/Out label</span><br><span class="line">Route Distinguisher: 1:1 (CISCO)</span><br><span class="line">   1.1.1.1/32       2.2.2.2         nolabel/203</span><br><span class="line">   5.5.5.5/32       10.1.45.5       403/nolabel</span><br><span class="line">   10.1.12.0/24     2.2.2.2         nolabel/204</span><br><span class="line">   10.1.45.0/24     0.0.0.0         404/nolabel(CISCO)</span><br></pre></td></tr></table></figure>

<p>LFIB中倒数第二行‘403     No Label  5.5.5.5/32[V]   1254      Et0/1    10.1.45.5’表示给5.5.5.5/32前缀捆绑的VPN标签是403，[V]表示这是一个VPN标签，这层标签用于帮助R4这个PE2识别所收到的标签数据归属于哪一个VRF，哪一个下一跳CE。那么当R2向5.5.5.5发送数据时，报文进入MPLS Backbone前要压入VPN标签403，这个标签是R2这个PE2通过MP-BGP分配的。</p>
<p><strong>外层标签</strong></p>
<p>只有MP-BGP分配的外层VPN标签是不能够让数据在MPLS Backbone中传输的，因为运营商的P路由器（R3）是不可能知道客户路由的，往往也并不知道VPNV4前缀，那么为了让这些VPN流量能够在P网络中传输，势必要增加一层标签，这就是外层的IGP标签，它由LDP捆绑并分发。当PE1（R2）要将已经压了一层VPN标签的报文放进MPLS Backbone时，外层压入的是什么标签呢？因为MPLS不会给BGP分配标签而只能给BGP的下一跳分配标签，R2去往5.5.5.5的下一跳是4.4.4.4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip route vrf CISCO</span><br><span class="line"></span><br><span class="line">Routing Table: CISCO</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">D        1.1.1.1 [90/409600] via 10.1.12.1, 03:55:39, Ethernet0/0</span><br><span class="line">      5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">B        5.5.5.5 [200/11] via 4.4.4.4, 00:08:05</span><br></pre></td></tr></table></figure>

<p>所以PE1这里使用的是P路由器（R3）分配给4.4.4.4的标签：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">300        Pop Label  2.2.2.2/32       9364          Et0/0      10.1.23.2</span><br><span class="line">301        Pop Label  4.4.4.4/32       8552          Et0/1      10.1.34.4</span><br></pre></td></tr></table></figure>

<p>所以这里捆绑的是R3给4.4.4.4分配的标签301。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615625056665-fd14cbe2-264e-4b36-a759-f27eb35cf23d.png" alt="img"></p>
<h1 id="MP-BGP"><a href="#MP-BGP" class="headerlink" title="MP-BGP"></a>MP-BGP</h1><p>MP-BGP全称是‘Multiprotocol Extensions for BGP’。BGP的多协议扩展为BGP定义了两个新的属性：多协议可达NLRI以及多协议不可达NLRI，两个属性分别用来通告路由和退回路由。两个属性都维护着两个字段：地址簇标识符AFI（Address Family Indicator）、后续地址簇标识符SAFI（Subsequent Address Family Indicator）。这两个字段用来描述BGP所承载的是什么类型的路由。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615627017539-828b4faf-c93c-4aa4-96fe-ec72a035485c.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615627024269-d71c115d-b7ba-4f48-be1f-db2d8eb74c64.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615627037457-49805870-2ebb-46e4-a61b-fe74a09369fd.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1615627149363-6028ce8a-671f-4807-8dfa-c1c81dd467fa.png" alt="img"></p>
<p>MP-BGP的Update中包含：</p>
<ul>
<li><p>VPNV4前缀</p>
</li>
<li><p>扩展Community值：RTs、SOO….</p>
</li>
<li><p>Label used for VPN packets forwarding</p>
</li>
<li><p>其他常规BGP路径属性：MED、LP、AS_PATH、Origin、Standerd community</p>
</li>
</ul>
<p>查看VPNV4路由命令是‘show ip bgp vpnv4 all’</p>
<p>查看VPNV4路由分发标签命令为‘show ip bgp vpnv4 rd x:y labels’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp vpnv4 all</span><br><span class="line">BGP table version is 9, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i 1.1.1.1/32       2.2.2.2             409600    100      0 ?</span><br><span class="line"> *&gt;  5.5.5.5/32       10.1.45.5               11         32768 ?</span><br><span class="line"> *&gt;i 10.1.12.0/24     2.2.2.2                  0    100      0 ?</span><br><span class="line"> *&gt;  10.1.45.0/24     0.0.0.0                  0         32768 ?</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show ip bgp vpnv4 rd 1:1 labels</span><br><span class="line">   Network          Next Hop      In label/Out label</span><br><span class="line">Route Distinguisher: 1:1 (CISCO)</span><br><span class="line">   1.1.1.1/32       2.2.2.2         nolabel/203</span><br><span class="line">   5.5.5.5/32       10.1.45.5       403/nolabel</span><br><span class="line">   10.1.12.0/24     2.2.2.2         nolabel/204</span><br><span class="line">   10.1.45.0/24     0.0.0.0         404/nolabel(CISCO)</span><br></pre></td></tr></table></figure>

<p>BGP运载标签</p>
<p>MPLS在MPLS VPN网络中通告VPNV4路由，但这对于正确转发VPN流量来说并不够，一个IP数据包在MPLS网络中传输，首先在出站PE上被压上一层LDP标签，那么标签包到了目的PE，也就是入站PE，PE怎么知道把它转给哪个CE？那么我们再压上一层标签，这层标签叫VPN标签，由路由的出站PE端分发，并传递给数据的出站PE，那么路由的出站PE会在本地做个标签与VPNV4路由前缀的映射，如此一来当该路由器收到一个数据包，携带了特定的VPN标签，它就会知道将该数据包扔给谁。MPBGP的BGP Update中可能包含如下内容：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1615188171086-3edd8f9a-3904-4e1f-8167-9cc3644108db.jpeg" alt="img"></p>
<p>MPLS VPN 标签传播的影响：</p>
<ul>
<li><p>VPN标签需由BGP nexthop路由器分配；</p>
</li>
<li><p>路由的nexthop属性在MP-IBGP中传递时，不能被修改例如使用nexthopself命令；</p>
</li>
<li><p>PE路由器必须是BGP next-hop；</p>
</li>
<li><p>当next-hop 发生变化时，标签会重新分配。这个现象在Inter-AS MPLS VPN的时候很常见；</p>
</li>
</ul>
<h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#router bgp XXX</span><br><span class="line">Router(config-router)#address-family vpnv4</span><br><span class="line">激活BGP的VPNV地址簇，并进入相关的地址簇配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-router-af)# neighbor A.B.C.D activate </span><br><span class="line">在VPNV4地址簇中，激活特定的MP-BGP邻居</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-router-af)# neighbor A.B.C.D route-reflector-client </span><br><span class="line">如果存在VPNV4的路由反射环境，那么RR的配置需要在VPNV4的地址簇中进行配置</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-router-af)# neighbor A.B.C.D next-hop-self </span><br><span class="line">与IPV4地址簇中的next-hop-self相同，只不过这条命令是针对VPNV4路由的next-hop的修改，谨慎使用，因为next-hop地址变了VPN标签是要重新分发的。该命令主要在域间VPN中使用</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Router(config-router)# address-family vrf XXX</span><br><span class="line">进入已经创建的VRF的BGP ipv4 vrf address-family中</span><br><span class="line">每当创建一个VRF时，都讲在BGP配置下自动创建属于该VRF的address-family地址簇</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mpls label mode vrf x protocol bgp-vpnv4 pre-prefix</span><br><span class="line">默认是基于每个前缀分配标签的，也就是一个VPNV4前缀分配一个标签</span><br><span class="line"></span><br><span class="line">mpls label mode all-vrf x protocol bgp-vpnv4 per-vrf</span><br><span class="line">可以修改成基于VRF的标签分配，也就是一个VRF分配一个标签，不建议修改</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show ip bgp all summary</span><br><span class="line">查看所有邻居簇的邻居</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show ip bgp vpnv4 all</span><br><span class="line">查看所有的vpnv4路由</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show ip bgp vpnv4 all label</span><br><span class="line">查看vpnv4路由的标签</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">clear ip bgp vpnv4 unicast</span><br><span class="line">清理bgp vpnv4单播路由</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">show ip bgp vpnv4 all [vrf x]</span><br><span class="line">查看vpnv4路由</span><br></pre></td></tr></table></figure>

<h1 id="PE-CE路由协议"><a href="#PE-CE路由协议" class="headerlink" title="PE-CE路由协议"></a>PE-CE路由协议</h1><h2 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h2><p><img src="/2022/01/20/18-MPLSVPN/1615798655647-7e62bfe7-5248-4923-9ae7-217dc7ec6ec9.png" alt="img"></p>
<p>PE1（R2）的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#ip vrf ABC</span><br><span class="line">R2(config-vrf)#rd 1:1</span><br><span class="line">R2(config-vrf)#route-target 234:2</span><br><span class="line">R2(config)#ip route vrf ABC 1.1.1.1 255.255.255.255 10.1.12.1 e0/0</span><br><span class="line">R2(config)#router bgp 234</span><br><span class="line">R2(config-router)#address-family ipv4 vrf ABC</span><br><span class="line">R2(config-router-af)#redistribute static</span><br></pre></td></tr></table></figure>

<p>‘ip route vrf ABC 1.1.1.1 255.255.255.255 10.1.12.1 e0/0’在R2上位VRF ABC路由表创建一条指向CE客户端的VPN路由，在配置静态路由时，由于VRF跟接口有关联，因此建议采取关联出接口及下一跳IP的方式来配置这条VRF静态路由。</p>
<p>在BGP的ipv4 vrf ABC中将静态VPN路由重发布进BGP，以便形成VPNV4的前缀更新给VPN对端站点。</p>
<h2 id="RIPV2"><a href="#RIPV2" class="headerlink" title="RIPV2"></a>RIPV2</h2><p><img src="/2022/01/20/18-MPLSVPN/1615877543177-cea1543f-8b66-4ef6-a521-c1ed86136a91.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1:</span><br><span class="line">router rip</span><br><span class="line"> version 2</span><br><span class="line"> network 1.0.0.0</span><br><span class="line"> network 10.0.0.0</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE1:</span><br><span class="line">router rip</span><br><span class="line"> version 2</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf ABC</span><br><span class="line">  network 10.0.0.0</span><br><span class="line">  no auto-summary</span><br><span class="line">  version 2</span><br><span class="line">  redistribute bgp 234 metric [transparent] </span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line">router bgp 2345</span><br><span class="line"> address-family ipv4 vrf ABC</span><br><span class="line">   redistribute rip</span><br><span class="line"> exit-address-family </span><br></pre></td></tr></table></figure>

<p>将BGP路由重发布进RIP以便让CE1能学习到对端Site的客户路由，当其他动态路由协议重发布进RIP的时候，默认度量值是无限大的，需要在重发布的时候指定metric，也就是RIP的跳数，如果使用Transparent关键字，则这些RIP路由将继承BGP的MED值。</p>
<h2 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/01/20/18-MPLSVPN/1615878128164-833ca895-65d9-4dca-aa96-4781d6e51497.png" alt="img"></p>
<p>如果PE-CE链路中使用OSPF协议，则需要在PE路由器上将OSPF重发布进MPBGP，并且将MPBGP重发布进OSPF。在远端PE如果它接收本地PE传过去的VPNV4路由，然后重发布进本地VPN的OSPF域后，变成外部路由就导致路由的优先级变低，另一个问题是MPLS VPNBackbone将用户的OSPF网络从设计上‘切断’了。针对这些问题，MPLS VPN有非常人性化的设计。</p>
<p>MPLS VPN在对OSPF网络的承载上有非常独特的设计。从宏观层面上来说，对于OSPF而言，MPLS VPN Backbone相当于一个OSPF超级骨干区域。实际上，来自CE的OSPF内部路由，也就是LSA1、2、3，在被重发布进MPIBGP，变成VPNV4路由再被远端PE重发布进OSPF后，其实是以3类LSA的形式注入到本地OSPF域的（也存在很多其他复杂情况，这里仅说一般情况），这么说来，这些PE在这种情况下，又有那么点ABR的问题，但其实它们的身份是ASBR。</p>
<h3 id="OSPF的VRF配置"><a href="#OSPF的VRF配置" class="headerlink" title="OSPF的VRF配置"></a>OSPF的VRF配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">ip vrf ABC</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2</span><br><span class="line"> route-target import 234:4</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding ABC</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> mpls ip</span><br><span class="line"> !</span><br><span class="line">router ospf 12 vrf ABC</span><br><span class="line"> network 10.1.12.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0 </span><br><span class="line">mpls label range 200 299 </span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.23.2 0.0.0.0 area 0</span><br><span class="line"> !</span><br><span class="line"> router bgp 234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf ABC</span><br><span class="line">  redistribute ospf 12 match internal external 1 external 2</span><br><span class="line">  </span><br><span class="line">  将OSPF VRF ABC注入到BGP中从而形成VPNV4路由</span><br></pre></td></tr></table></figure>

<p>VRF ABC中的router ospf 12进程用于和CE客户建立邻居关系，OSPF 1进程用于和MPLS Backbone内交互路由以便简历邻接关系为LDP服务。</p>
<h3 id="BGP-community"><a href="#BGP-community" class="headerlink" title="BGP community"></a>BGP community</h3><p>想让OSPF路由的特征能够穿越MPLS VPN骨干网络，需要额外定义一些BPG扩展community，这些community使得OSPF路由可以在远端PE上重建，从而保持OSPF网络设计的一致性，可以通过MP-BGP传递的OSPF特性包括：</p>
<ul>
<li><p>路由类型</p>
</li>
<li><p>区域号</p>
</li>
<li><p>OSPF路由器ID</p>
</li>
<li><p>域ID</p>
</li>
<li><p>OSPF外部路由的度量值类型1或2</p>
</li>
</ul>
<p><img src="/2022/01/20/18-MPLSVPN/1615883414062-365ec0cd-1637-47b5-b92f-b7497af385f3.png" alt="img"></p>
<p>上图中，Domain ID是一个域ID，默认情况下等于OSPF的进程号，Domain ID告诉远端PE路由器，通告的是否为一跳域外的OSPF路由。如果OSPF路由类型为LSA1、2、3，且本地PE及远端PE的OSPF VRF进程号相同，则路由重发布到远端PE的OSPF域后是以LSA3的形式注入。</p>
<p>如果PE路由器所收到的路由的Domain ID与本地OSPF VRF进程的Domain ID不一致的话（说白了就是两个PE上OSPF VRF进程的进程号不一致），这条路由将会以一跳OSPF外部路由，也就是LSA5类的形式通告，以提供对网络中不同OSPF进程之间重发布IP路由的支持。</p>
<p>如果Domain ID能够匹配OSPF进程ID，该路由将以LSA3的形式通告。</p>
<p>如果两端PE的OSPF进程号相同，传递过来的路由又是内部路由，但又希望路由重发布到本地OSPF以后，以外部路由的形式注入，那么可以在P路由器上修改Domain ID，命令如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1 vrf ABC</span><br><span class="line"> domain-id ? </span><br></pre></td></tr></table></figure>

<p>修改以后可以使用‘show ip ospf 1’来查看。</p>
<p>OSPF Route-type 后面路由类型的含义：</p>
<table>
<thead>
<tr>
<th>1:0或2:0</th>
<th>表示是LSA1类路由</th>
</tr>
</thead>
<tbody><tr>
<td>3:0</td>
<td>表示是内部LSA3类路由</td>
</tr>
<tr>
<td>5:0或5:1</td>
<td>表示是外部LSA5类路由。前者为类型1后者为类型2</td>
</tr>
<tr>
<td>7:0或7:1</td>
<td>表示是NSSA7类路由，前者为类型1后者为类型2</td>
</tr>
</tbody></table>
<h3 id="OSPF网络设计"><a href="#OSPF网络设计" class="headerlink" title="OSPF网络设计"></a>OSPF网络设计</h3><p>可能遇到的所有情况如下：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616212140032-4bc75f04-9b55-47bb-8ed8-e073481ef78a.png" alt="img"></p>
<h4 id="Case1"><a href="#Case1" class="headerlink" title="Case1"></a>Case1</h4><p><img src="/2022/01/20/18-MPLSVPN/1616212170086-043c441e-92a4-4053-8052-ecafc3e6477c.png" alt="img"></p>
<p>当PE1和PE2的VRF OSPF都采用相同的进程ID时：</p>
<p>PE1、PE2在VRF上跑OSPF，与各自的PE建立邻接关系，PE1、PE2上VRF OSPF进程号相同，CE1上的1.1.1.0属于Area0,1.1.2.0属于Area1，CE2上的网段5.5.5.0为重发布，那么CE1上学到的5.5.5.0路由为OE，CE2上学到的1.1.1.0路由为OIA，学到的1.1.2.0路由为OIA，在PE2上修改OSPF进程号（与PE1的进程号）不同，或修改Domain ID，则上述路由均变成OE类型。下面来看实验验证：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616224631837-40850374-32c6-4a44-b9e4-c30df099a952.png" alt="img"></p>
<p>配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1：</span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname PE1</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 123:1</span><br><span class="line"> route-target import 123:2</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 100 199</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.14.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1 vrf CISCO</span><br><span class="line"> router-id 11.11.11.11</span><br><span class="line"> redistribute bgp 123 subnets</span><br><span class="line"> network 192.168.14.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 123</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2.2.2.2 remote-as 123</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 2.2.2.2 activate</span><br><span class="line">  neighbor 2.2.2.2 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 1 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2：</span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname PE2</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 123:2</span><br><span class="line"> route-target import 123:1</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 200 299</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.25.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1 vrf CISCO</span><br><span class="line"> router-id 22.22.22.22</span><br><span class="line"> redistribute bgp 123 subnets</span><br><span class="line"> network 192.168.25.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 123</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 1.1.1.1 remote-as 123</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 1.1.1.1 activate</span><br><span class="line">  neighbor 1.1.1.1 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 1 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE1:</span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname CE1</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 1.1.2.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.14.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 1.1.1.0 0.0.0.255 area 0</span><br><span class="line"> network 1.1.2.0 0.0.0.255 area 1</span><br><span class="line"> network 192.168.14.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2:</span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname CE2</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.25.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> redistribute connected subnets</span><br><span class="line"> network 192.168.25.5 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">P:</span><br><span class="line">version 15.7</span><br><span class="line">service timestamps debug datetime msec</span><br><span class="line">service timestamps log datetime msec</span><br><span class="line">no service password-encryption</span><br><span class="line">!</span><br><span class="line">hostname P</span><br><span class="line">!</span><br><span class="line">boot-start-marker</span><br><span class="line">boot-end-marker</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no aaa new-model</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">clock timezone EET 2 0</span><br><span class="line">mmi polling-interval 60</span><br><span class="line">no mmi auto-configure</span><br><span class="line">no mmi pvc</span><br><span class="line">mmi snmp-timeout 180</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 300 399</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">redundancy</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 123</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line">!</span><br><span class="line">control-plane</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">line con 0</span><br><span class="line"> exec-timeout 0 0</span><br><span class="line"> logging synchronous</span><br><span class="line">line aux 0</span><br><span class="line">line vty 0 4</span><br><span class="line"> login</span><br><span class="line"> transport input none</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>接下来看CE1和CE2上的路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/8 is variably subnetted, 3 subnets, 2 masks</span><br><span class="line">C        1.1.1.1/32 is directly connected, Loopback0</span><br><span class="line">C        1.1.2.0/24 is directly connected, Loopback2</span><br><span class="line">L        1.1.2.5/32 is directly connected, Loopback2</span><br><span class="line">      5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">O E2     5.5.5.5 [110/20] via 192.168.14.1, 00:08:55, Ethernet0/0</span><br><span class="line">      192.168.14.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.14.0/24 is directly connected, Ethernet0/0</span><br><span class="line">L        192.168.14.4/32 is directly connected, Ethernet0/0</span><br><span class="line">O IA  192.168.25.0/24 [110/11] via 192.168.14.1, 00:08:55, Ethernet0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/32 is subnetted, 2 subnets</span><br><span class="line">O IA     1.1.1.1 [110/21] via 192.168.25.2, 00:08:53, Ethernet0/0</span><br><span class="line">O IA     1.1.2.5 [110/21] via 192.168.25.2, 00:08:53, Ethernet0/0</span><br><span class="line">      5.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">C        5.5.5.5 is directly connected, Loopback0</span><br><span class="line">O IA  192.168.14.0/24 [110/11] via 192.168.25.2, 00:08:53, Ethernet0/0</span><br><span class="line">      192.168.25.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.25.0/24 is directly connected, Ethernet0/0</span><br><span class="line">L        192.168.25.5/32 is directly connected, Ethernet0/0</span><br></pre></td></tr></table></figure>

<p>CE1上的5.5.5.5路由为OE，CE2上1.1.1.1和1.1.2.5路由为OIA。如果在PE2上修改OSPF进程号，将进程号改为与PE1不同，或修改Domain ID，则CE2上的路由类型会变为OE：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE2(config)#router ospf 1 vrf CISCO</span><br><span class="line">PE2(config-router)#domain-id 6.6.6.6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/32 is subnetted, 2 subnets</span><br><span class="line">O E2     1.1.1.1 [110/11] via 192.168.25.2, 00:00:26, Ethernet0/0</span><br><span class="line">O E2     1.1.2.5 [110/11] via 192.168.25.2, 00:00:26, Ethernet0/0</span><br></pre></td></tr></table></figure>





<h4 id="Case2"><a href="#Case2" class="headerlink" title="Case2"></a>Case2</h4><p><img src="/2022/01/20/18-MPLSVPN/1616212380468-ccfd7f99-c511-4624-8a49-e60f9b73210e.png" alt="img"></p>
<p>PE1、PE2在VRF上跑OSPF，与各自的CE建立邻接关系，且两个PE上的VRF OSPF进程号相同时，CE1上1.1.1.0属于Area1，PE1与CE1在Area1建立邻接关系，CE2上的5.5.5.0路由为重发布，CE1上学到的5.5.5.0路由为OE，CE2上学到的1.1.1.0路由为OIA。</p>
<h4 id="Case3"><a href="#Case3" class="headerlink" title="Case3"></a>Case3</h4><p><img src="/2022/01/20/18-MPLSVPN/1616212504093-92d780df-0669-4ea6-abb4-fa92cf664df7.png" alt="img"></p>
<p>PE1、PE2在VRF上跑OSPF，与各自的CE建立邻接关系，PE1、PE2上VRF OSPF进程号相同时，CE1上1.1.1.0属于Area1 , 1.1.2.0为重发布，PE1与CE1在Area1建立邻接关系，CE2上5.5.5.0属于Area0，CE2上学习到的1.1.1.0路由为OIA，1.1.2.0位OE路由。CE2的Area0里无法学习到1.1.1.0与1.1.2.0路由，因为CE2没有将这些三类LSA转进Area0。PE2上能收到CE2发送的5.5.5.0的LSA3，但不会装在进路由表，自然CE1无法学习到5.5.5.0。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul>
<li><p>MPLS VPN在OSPF站点之间存在一个超级骨干区域（Superbackbone），这当然不是一个OSPF区域，不过它扮演了一个骨干区域（Area0）的角色，同时PE也扮演了一个ABR的角色（通过查看PE产生的1类LSA也能证明这一点）</p>
</li>
<li><p>从客户的角度，可以将Superbackbone看做一个Cost=0的Area0</p>
</li>
<li><p>如果一个VRF的多个站点有一台PE在Area0中，那么这个Area0倍分割成了多块，通常来说，被分割的骨干区域需要使用Virtual-link来连接，但在MPLS VPN中由于有IBGP来运载OSPF路由，因此不需要虚链路，OSPF路由会在PE路由器上重建（Superbackbone不会直接泛红LSA）</p>
</li>
<li><p>PE路由器扮演了ABR的角色。它将Type3 LSA通告给CE路由器，CE路由器可以在Area0中，也可以在其他区域中，但如果一个站点拥有多个区域，PE路由器就必须在Area0中，因为它们是ABR，如果它们不在Area0中，就需要在PE上创建Virtual-link来确保PE和Area0的连接</p>
</li>
<li><p>一个CE从Area0中发送的路由，在另一端CE的Area0中显示为区域间路由</p>
</li>
</ul>
<h3 id="Metric传递"><a href="#Metric传递" class="headerlink" title="Metric传递"></a>Metric传递</h3><p><strong>1、PE1和PE2的VRF OSPF进程号相同的情况下，OSPF内部路由的Metric传递：</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616235074209-ec2c3833-64f0-4fbc-866e-bed43fb62002.png" alt="img"></p>
<p>在PE路由器上将OSPF内部和外部路由重发布进BGP的时候，PE路由器将使用OSPFmetric来设置BGP MED，例如上图中，CE1穿了一条OSPF路由过来（实际上是LSA），该LSA的cost为1，那么R2通过VRF的OSPF进程学习到之后，再类加上本地的cost值（为1）以后，最终在VRF路由表中的Cost=2.现在R2（PE1）将VRF路由表中OSPF的路由注入BGP后，路由的COST将会拷贝到BGP路由的MED上，然后传递出去。</p>
<p>在对端PE2上，要将BGP路由注入回OSPF，那么产生的OSPF路由为3类LSA，metric也是从BGP的MED中拷贝。如果这里过来的BGP路由没有携带MED值，那么OSPF将使用默认的种子Metric。</p>
<p><strong>2、PE1及PE2的VRF OSPF进程号相同的情况下，OSPF外部路由的Metric传递：</strong></p>
<p>R1始发的OSPF路由1.1.1.1/32是一条OE2的外部路由，那么这条路由在PE1学习到以后，在它的VRF路由表中的Metric还是11。现在PE1将OSPF路由重发布到BGP，11这个Cost值将会被拷贝到VPNV4前缀1:1:1.1.1.1/32的MED属性中。路由被传递到了PE2，那么PE2将BGP路由重发布进OSPF形成了OE2的外部路由1.1.1.1/32，这条路由的Metric仍然拷贝BGP的MED。</p>
<p><strong>3、PE1及PE2的VRF OSPF进程号不同的情况下，OSPF内部路由的Metric传递：</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616235761812-aaa09a85-6846-4f68-9ee7-4006a1113ad2.png" alt="img"></p>
<p>注意，这里PE1和PE的VRF OSPF进程ID不同，那么CE1上始发的OSPF内部路由，携带COST=1，到了PE1被注入到BGP后，MED属性拷贝COST值2，然后传递给PE2，到了PE2，BGP重发布到OSPF后，由于Domain ID不匹配因此形成外部路由1.1.1.1/32，这个路由的Metric同样拷贝BGP路由的MED属性值。</p>
<p><strong>4、非OSPF始发路由的Metric传递：</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616236160027-60fa08eb-3259-4c86-8bac-e014a731570f.png" alt="img"></p>
<p>CE1——PE1之间运行的是RIPV2协议，那么这条路由传递到PE1上以后，跳数为1，重发布进BGP后，VPNV4前缀携带的MED属性值为1，这是直接拷贝的RIP路由的Metric。那么VPNV4前缀传递到PE2后，重发布进OSPF，形成OE2的外部路由1.1.1.1/32，同样的，也是拷贝了BGP路由的MED属性值，所以Cost=1。</p>
<h3 id="Down-Bit"><a href="#Down-Bit" class="headerlink" title="Down Bit"></a>Down Bit</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>An additional bit – down bit has been introduced in the Options field of the OSPF LSA header</p>
<p>PE routers set the down bit when redistributing routes from MP-BGP into OSPF</p>
<p>PE routers never redistribute OSPF routes with the down bit set into MP-BGP </p>
<p>Down bit位于OSPF LSA头部的Option字段内，当PE路由器将MP-BGP路由重发布进OSPF协议时，会将Down Bit置1。当OSPF路由的Down Bit置1时，PE路由器绝对不会将该OSPF路由重发布进MP-BGP中。</p>
<h4 id="具体理论"><a href="#具体理论" class="headerlink" title="具体理论"></a>具体理论</h4><p><img src="/2022/01/20/18-MPLSVPN/1616237259322-f5d72125-7d79-4af7-aae6-1d222f73f6e3.png" alt="img"></p>
<p>上图中，右侧VPN站点有两个PE：PE2、PE3。</p>
<p>当PE2通过已经建立好的MP-IBGP连接从PE1学习到CE1客户路由，它将路由重发布到本地的OSPF进程中，这样CE2就能学习到这些客户路由。但是由于还有PE3的存在，如果PE3上部署了OSPF-BGP的双向重发布，CE2有可能会将路由更新给PE3，由于OSPF的AD比是110，比IBGP的200要小，那么从CE2处学到的路由就会比从PE1上学到的路由优先级高，能进入路由表。比如CE1上如果有一条路由1.1.1.0/24，这条路由传递给PE2以后，PE2传递给CE2，然后CE2上这条AD为110的OSPF的1.1.1.0/24的路由，就会比从PE1发过来的AD值为200的IBGP的1.1.1.0/24更优先，更优先的OSPF路由就会加入PE3的路由表中，这种情况下如果PE3要发送数据给1.1.1.0/24就会经过CE2-PE2-PE1这条次优路线。这显然是我们不希望看到的情况。</p>
<p>因此又了Down Bit的设计，在PE2将从PE1学习来的BGP路由注入到本地VRF的OSPF进程时，如果是以3类LSA的形式注入，那么这些3类LSA会做特殊的置位，也就是Down Bit会置1，那么当PE3收到PE2从BGP重发布到OSPF的3类LSA，发现这些路由都设置了Down Bit，PE3在计算路由时，会直接忽略掉做这些Down Bit置1的LSA，自然这些路由也就不会被PE3从OSPF再重发布回BGP，可以起到防环作用。</p>
<p>Down Bit只出现在3类LSA中，在RFC 2547-BGP/MPLS VPNs中定义：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616238321644-da88b4cd-c2d2-40ff-aa1e-5101739a8bde.png" alt="img"></p>
<p>可以用show ip ospf database summary X.X.X.X查看：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616238395204-38008a7d-e56a-4291-88ba-b75905e7898e.png" alt="img"></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p><img src="/2022/01/20/18-MPLSVPN/1616238445377-e2916d0e-65ea-4171-a7e1-192c255c300f.png" alt="img"></p>
<p>上面这种拓扑，当PE3从OSPF（CE1发送而来）和MP-IBGP（PE2发送而来）同时学到了Site1的路由，它将如何选择呢？虽然OSPF路由的AD值110小于MP-IBGP的200，但由于OSPF的路由是经过PE2重发布的，由PE2从MP-BGP发布进OSPF的，所以OSPF路由的Down Bit置1，当PE3收到PE2从BGP重发布到OSPF的3类LSA，发现这些路由都设置了Down Bit，PE3在计算路由时，会直接忽略掉做这些Down Bit置1的LSA，自然这些路由也就不会被PE3从OSPF再重发布回BGP，可以起到防环作用。</p>
<h4 id="特别提醒"><a href="#特别提醒" class="headerlink" title="特别提醒"></a>特别提醒</h4><p>由于3类LSA的传播范围只有一个区域，且Down bit只在MPLS VPN情况下出现，一个Down bit置1的3类LSA，传播到另一个区域中会经由Area中间的ABR重新生成一个新的3类LSA，新生成这条3类LSA的ABR路由器很可能不在MPLS VPN区域，此时Down bit就会被消除掉。比如下图中，R3-PE1上进行了OSPF-BGP的双向重发布，当BGP重发布进OSPF时，R3-PE1生成了3类LSA，由于此时该路由器在MPLS VPN环境，所以重分布的OSPF的LSA为3类（两端PE的OSPF VRF进程号相同则重发布到远端PE的OSPF域后是3类LSA）且带有Down bit，这条3类LSA进入Area0后，会经由CE2传递到Area1（3类LSA会从骨干区域范洪到非骨干区域）。由于3类LSA的传播范围只有一个区域，CE2作为ABR会重新生成这条3类LSA，因为CE2不在MPLS VPN环境，会删除掉Down bit置位，这条3类LSA丧失掉了防环作用。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616834399003-f0a1202b-a154-4d56-afd5-27d43ce927e1.png" alt="img"></p>
<h3 id="Domain-tag"><a href="#Domain-tag" class="headerlink" title="Domain-tag"></a>Domain-tag</h3><p><img src="/2022/01/20/18-MPLSVPN/1616379721965-12574cf8-7559-4e51-a3ac-2f025cbadd41.png" alt="img"></p>
<p>Domain-tag和Down Bit功能类似，只不过它是用于OSPF外部路由。</p>
<p>如上图，在PE2上，将BGP路由重发布进OSPF后，如果是以外部路由的形式进入OSPF，则这些路由会被打上Tag（这个tag有默认的设置方式，参照RFC1745，也可以通过Domain-tag命令在PE路由上手工配置）。</p>
<p>这些路由在Site内，如果传递到本Site的另一台PE路由器PE3，那么一旦它自己本地设置的Domain-tag匹配到了这个路由携带的tag，这条路由就不会被重发布进BGP（这些OSPF路由不会被转载进VRF路由表，自然无法被发布进BGP）。</p>
<p>默认情况下，Domain-tag的设置是根据RFC1745来进行的，BGP的AS号码将会在无意义的16bit中被编码为OSPF外部路由标记。在上图中，PE2上BGP重发布到OSPF后，这些路由会被打上TAG，tag中包含BGP的AS号，路由传递到PE3后，PE3发现这些OSPF路由的tag与本地的BGP的AS号匹配，那么它就只将LSA放入OSPF的Database而不将路由装载进路由表，因此PE3上，对于这些远端站点的路由仍然是优先通过BGP学习到的路由传递数据，忽略从CE的OSPF学到的路由。但如果在PE2上，做BGP向OSPF路由重发布的时候，手工修改Domain-tag，使得与PE3的tag不匹配，那么PE3同时从OSPF及BGP学到这些外部路由，并且TAG不匹配，那么PE3会优选OSPF路由，因为OSPF的AD值110小于BGP的AD值200。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#sh ip ro 1.1.2.0 </span><br><span class="line">Routing entry for 1.1.2.0/24</span><br><span class="line"> Known via &quot;ospf 1&quot;, distance 110, metric 20</span><br><span class="line"> Tag Complete, Path Length == 1, AS 234, , type extern 2, forward metric 1 </span><br><span class="line"> Last update from 10.1.45.4 on FastEthernet0/0, 00:00:00 ago</span><br><span class="line"> Routing Descriptor Blocks: </span><br><span class="line"> * 10.1.45.4, from 44.44.44.44, 00:00:00 ago, via FastEthernet0/0 </span><br><span class="line"> Route metric is 20, traffic share count is 1 </span><br><span class="line"> Route tag 3489661162 </span><br></pre></td></tr></table></figure>

<p>上面的tag3，489661162 ，将它转换成二进制： 11010000000000000000000011101010，最后的16bit，在转换成10进制，就是BGP的AS号，234。</p>
<p>TAG值在OSPF域之间传递，也就是在不同的OSPF域间传递，不会丢失，这个特性非常有用。</p>
<p>TAG值也可手工设置：redistribute….tag XXX，这样路由被重发布进OSPF后，tag值就是这个手工设置的值。</p>
<p>修改本地OSPF进程的Domain-tag：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router os 1 vrf ABC </span><br><span class="line">R4(config-router)#domain-tag ? </span><br><span class="line">  &lt;1-4294967295&gt;    OSPF domain tag - 32-bit value </span><br></pre></td></tr></table></figure>





<h2 id="EIGRP"><a href="#EIGRP" class="headerlink" title="EIGRP"></a>EIGRP</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>PE路由器在做EIGRP到BGP重发布的时候，可以通过诸如BGP扩展community属性等来保存EIGRP路由的部分内容，包括metric、AS、TAG以及对外部路由而言的远程AS号、远程ID，远程协议和远程度量值，这些都是可以在EIGRP的拓扑表中找到的EIGRP特征。</p>
<p>如果EIGRP所通告的路由是内部路由，并且BGP扩展community属性中所携带的源AS号码能够匹配到目的AS号的话，这条路由会以内部路由的形式通告给远端站点，如果AS号不匹配，则这条路由会背重建为一跳EIGRP外部路由。</p>
<p>关于EIGRP的BGP扩展community属性：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616394637280-b298ad10-7e95-4f5d-9b62-f8c41fd1cd0b.png" alt="img"></p>
<p>来看一跳EIGRP内部路由在PE上重发布进BGP后的输出：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE2#sh ip bgp vpnv4 all 1.1.1.0 （内部路由）</span><br><span class="line">BGP routing table entry for 234:2:1.1.1.0/24, version 1489 </span><br><span class="line">Paths: (1 available, best #1, table ABC) </span><br><span class="line">Flag: 0x820 </span><br><span class="line">  Not advertised to any peer </span><br><span class="line">  Local, imported path from 234:1:1.1.1.0/24 </span><br><span class="line">    2.2.2.2 (metric 3) from 2.2.2.2 (2.2.2.2) </span><br><span class="line">      Origin incomplete, metric 156160, localpref 100, valid, internal, best </span><br><span class="line">      Extended Community: RT:234:1 Cost:pre-bestpath:128:156160  </span><br><span class="line">        0x8800:32768:0 0x8801:1:130560 0x8802:65281:25600 0x8803:65281:1500 </span><br><span class="line">      mpls labels in/out nolabel/21 </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">PE2#sh ip b vpnv4 all 1.1.2.0 (外部路由) </span><br><span class="line">BGP routing table entry for 234:1:1.1.2.0/24, version 1486 </span><br><span class="line">Paths: (1 available, best #1, table ABC) </span><br><span class="line">Flag: 0x820 </span><br><span class="line">  Not advertised to any peer </span><br><span class="line">  Local </span><br><span class="line">    2.2.2.2 (metric 3) from 2.2.2.2 (2.2.2.2) </span><br><span class="line">      Origin incomplete, metric 261120, localpref 100, valid, internal, best </span><br><span class="line">      Extended Community: RT:234:1 Cost:pre-bestpath:129:261120 0x8800:0:0  </span><br><span class="line">        0x8801:1:5120 0x8802:65281:256000 0x8803:65281:1500 0x8804:0:16843009  </span><br><span class="line">        0x8805:11:0 </span><br><span class="line">      mpls labels in/out nolabel/19 </span><br></pre></td></tr></table></figure>

<p>这些扩展的community值能够很好的保持EIGRP路由的特性，使得EIGRP路由在从一个站点经过MPLS VPN Backbone传输到另一个站点后，这些路由能在远端PE上被很好的还原。</p>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><p><img src="/2022/01/20/18-MPLSVPN/1616395252159-7c0fb782-cb2e-4819-b442-f4ac20a31f9f.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">router eigrp 1 </span><br><span class="line">  no auto-summary </span><br><span class="line">  network 10.0.0.0 </span><br><span class="line">  network 1.0.0.0 </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">router eigrp 1 </span><br><span class="line">  no auto-summary </span><br><span class="line">  address-family ipv4 vrf ABC       #在地址族下配置 </span><br><span class="line">    network 10.1.12.0 0.0.0.255 </span><br><span class="line">    no auto-summary </span><br><span class="line">    autonomous-system 1             #eigrp的as号，必须和CE上的匹配</span><br><span class="line">    redistribute bgp 234  </span><br></pre></td></tr></table></figure>

<p>EIGRP VRF的配置也是在ipv4 vrf地址簇中进行的。</p>
<h2 id="EBGP"><a href="#EBGP" class="headerlink" title="EBGP"></a>EBGP</h2><h3 id="配置-2"><a href="#配置-2" class="headerlink" title="配置"></a>配置</h3><p><img src="/2022/01/20/18-MPLSVPN/1616395420453-89ec6db0-ffa7-48ea-a749-05f32089ff43.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616399276349-93e8cbbe-f7ce-40f5-b2e0-48592079034d.png" alt="img"></p>
<p>AS65531内CE1的F0/0接口IP为10.1.12.1/24；PE1的F0/0为10.1.12.2/24.重点看CE1和PE1的配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">关键配置：</span><br><span class="line">R1:</span><br><span class="line">router bgp 65531</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 10.1.12.2 remote-as 234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2</span><br><span class="line"> route-target import 234:4</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  neighbor 10.1.12.1 remote-as 65531</span><br><span class="line">  neighbor 10.1.12.1 activate</span><br><span class="line"> exit-address-family</span><br></pre></td></tr></table></figure>

<p>记得指向CE的neighbor指令不能在全局BGP进程里去指，因为F0/0这个接口，是在VRF CISCO中的，全局路由表中没有该直连网段。</p>
<p>VPNV4地址簇的邻居，需要在BPG主进程中先指neighbor，再去VPNV4地址簇中激活，使用show ip bgp vpnv4 vrf CISCO查看vrf 中BGP邻居是否建立。记得MPLS VPN有内外两层标签，内层标签由MP-BGP分配，外层标签由LDP分配，出现问题时分别排查内外标签。</p>
<h3 id="Allowas-in"><a href="#Allowas-in" class="headerlink" title="Allowas-in"></a>Allowas-in</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="/2022/01/20/18-MPLSVPN/1616401435519-8e870834-7c62-4a1d-809a-b913fc107c03.png" alt="img"></p>
<p>注意这是个Hub&amp;Spoke环境，客户要求Spoke之间的通信，需要通过Hub长点，这样一来Spoke的站点路由需要先经过MPLS Backbone AS1然后传递到Hub，然后再从Hub传回Backbone AS1再传到另一个Spoke站点。</p>
<p>这样一来，对于PE3来说就有问题了，有可能在路由的AS_PATH中看到自己的AS号，当路由器在一条路由更新中看到自己的AS号时，它不会接受这条路由更新。这时可使用Allowas-in特性。</p>
<h4 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h4><p><img src="/2022/01/20/18-MPLSVPN/1616413329217-05a2b40f-6814-4be2-8873-26921b829642.png" alt="img"></p>
<p>上面的拓扑环境中，两个站点用的都是相同的AS号，AS12，这样的情况下，由于AS_PATH放环机制的存在，如果一个路由器收到的路由更新中的AS_PATH中，包含着本AS的AS号在内，则路由器不会接受路由更新。通常情况下这种放环机制是很有作用的，但在某些情况下需要打破这种防环机制。</p>
<p><strong>基本配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE1：</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:1</span><br><span class="line"> route-target import 234:2</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  neighbor 192.168.12.1 remote-as 12</span><br><span class="line">  neighbor 192.168.12.1 activate</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2:</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2</span><br><span class="line"> route-target import 234:1</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 192.168.34.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2.2.2.2 remote-as 234</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 2.2.2.2 activate</span><br><span class="line">  neighbor 2.2.2.2 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  neighbor 192.168.45.5 remote-as 12</span><br><span class="line">  neighbor 192.168.45.5 activate</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE1:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 5.5.5.5 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.45.4 remote-as 234</span><br></pre></td></tr></table></figure>

<p>CE1和CE2都有一个宣告进BGP进程的loopback接口，先来看对端的PE是否收到了这两个loopback接口的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1#show ip bgp vpnv4 all</span><br><span class="line">BGP table version is 4, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;   1.1.1.1/32       192.168.12.1             0             0 12 i</span><br><span class="line"> *&gt;i  5.5.5.5/32       4.4.4.4                  0    100      0 12 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2#show ip bgp vpnv4 all</span><br><span class="line">BGP table version is 4, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i  1.1.1.1/32       2.2.2.2                  0    100      0 12 i</span><br><span class="line"> *&gt;   5.5.5.5/32       192.168.45.5             0             0 12 i</span><br></pre></td></tr></table></figure>

<p>可以看到，两个PE都收到了对端CE的loopback接口路由，那么两个PE将路由发给对端的CE了吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1#show ip bgp vpnv4 all neighbors 192.168.12.1 advertised-routes</span><br><span class="line">BGP table version is 4, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i  5.5.5.5/32       4.4.4.4                  0    100      0 12 i</span><br><span class="line"></span><br><span class="line">Total number of prefixes 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2#show ip bgp vpnv4 all neighbors 192.168.45.5 advertised-routes</span><br><span class="line">BGP table version is 4, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i  1.1.1.1/32       2.2.2.2                  0    100      0 12 i</span><br><span class="line"></span><br><span class="line">Total number of prefixes 1</span><br></pre></td></tr></table></figure>

<p>从上面的输出中可以看到，CE也将路由发送给了对端的PE，那么CE路由器的路由表有路由吗？</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1# show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       0.0.0.0                  0         32768 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   5.5.5.5/32       0.0.0.0                  0         32768 i</span><br></pre></td></tr></table></figure>

<p>可以看到CE上只有自身宣告进BGP的路由，为什么它们拒绝接受从PE发来的路由呢？用debug命令看一下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1#debug ip bgp all updates </span><br><span class="line">BGP updates debugging is on for all address families</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后重启BGP进程</span><br><span class="line">CE1#clear ip bgp *</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">来看看CE1上的信息提示：</span><br><span class="line">CE1# BGP(0): 192.168.12.2 rcv UPDATE about 5.5.5.5/32 -- DENIED due to: AS-PATH contains our own AS;</span><br></pre></td></tr></table></figure>

<p>和理论分析一致，CE1拒绝了路由更新，因为它从路由更新中发现了自己的AS号在AS_PATH中，这时有两种解决办法：</p>
<ul>
<li>使用Allow-AS特性打破防环机制；</li>
<li>使用AS Override改变PE上的AS号打破防环机制；</li>
</ul>
<p>这里我们使用allow as这个特性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1(config)#router bgp 12</span><br><span class="line">CE1(config-router)#neighbor 192.168.12.2 allowas-in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2(config)#router bgp 12</span><br><span class="line">CE2(config-router)#neighbor 192.168.45.4 allowas-in</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE1上的debug如下：</span><br><span class="line">CE1#</span><br><span class="line">BGP(0): Revise route installing 1 of 1 routes for 5.5.5.5/32 -&gt; 192.168.12.2(global) to main IP table</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后再看CE1和CE2的路由表：</span><br><span class="line">CE1#show ip route 5.5.5.5</span><br><span class="line">Routing entry for 5.5.5.5/32</span><br><span class="line">  Known via &quot;bgp 12&quot;, distance 20, metric 0</span><br><span class="line">  Tag 234, type external</span><br><span class="line">  Last update from 192.168.12.2 00:01:46 ago</span><br><span class="line">  Routing Descriptor Blocks:</span><br><span class="line">  * 192.168.12.2, from 192.168.12.2, 00:01:46 ago</span><br><span class="line">      Route metric is 0, traffic share count is 1</span><br><span class="line">      AS Hops 2</span><br><span class="line">      Route tag 234</span><br><span class="line">      MPLS label: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip route 1.1.1.1</span><br><span class="line">Routing entry for 1.1.1.1/32</span><br><span class="line">  Known via &quot;bgp 12&quot;, distance 20, metric 0</span><br><span class="line">  Tag 234, type external</span><br><span class="line">  Last update from 192.168.45.4 00:01:55 ago</span><br><span class="line">  Routing Descriptor Blocks:</span><br><span class="line">  * 192.168.45.4, from 192.168.45.4, 00:01:55 ago</span><br><span class="line">      Route metric is 0, traffic share count is 1</span><br><span class="line">      AS Hops 2</span><br><span class="line">      Route tag 234</span><br><span class="line">      MPLS label: none</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#ping 1.1.1.1 source loop 0</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 1.1.1.1, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 5.5.5.5</span><br><span class="line">!!!!!</span><br><span class="line">两侧也顺利ping通</span><br></pre></td></tr></table></figure>

<h3 id="AS-Override"><a href="#AS-Override" class="headerlink" title="AS-Override"></a>AS-Override</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p><strong>没有AS-Override时</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616400604640-d1568a12-4801-412f-b89e-e9aff6cf898d.png" alt="img"></p>
<p>CE与PE之间运行EBGP，CE1和CE2使用相同的AS号，AS213，当路由10.1.1.0/24从CE1传递到CE2的时候，该路由的AS_PATH中有115和213两个AS号，CE2收到该路由后发现AS_PATH中出现了自己的AS号，因此双方都会忽略源自对方的路由更新。</p>
<p><strong>配置了AS-Override后：</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616400877313-8229edf3-11ec-4bb7-824c-4be0d52ab0cb.png" alt="img"></p>
<ul>
<li><p>如果AS_PATH中的AS号与该PE的CE（EBGP对等体，在上图中也就是CE2）的AS号相同，则将该AS号213替换成Provider的AS号，也就是中间的AS号115；</p>
</li>
<li><p>如果这个AS号在AS_PATH中重复出现了（可能上游使用了as-path prepend命令），比如AS_PATH是213 213，那么在配置了AS-Override命令后，所有的重复AS号都会被替换，AS_PATH会变成115 115；</p>
</li>
<li><p>在上述替换完成后，Provider的AS号会在此插入到AS_PATH中。</p>
</li>
</ul>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><img src="/2022/01/20/18-MPLSVPN/1616482262230-1ff308ad-eb76-4862-8d2b-6b15b6d51783.png" alt="img"></p>
<p>拓扑和前面Allow AS-in的相同，上面的拓扑环境中，两个站点用的都是相同的AS号，AS12，这样的情况下，由于AS_PATH放环机制的存在，如果一个路由器收到的路由更新中的AS_PATH中，包含着本AS的AS号在内，则路由器不会接受路由更新。通常情况下这种放环机制是很有作用的，但在某些情况下需要打破这种防环机制。</p>
<p><strong>基本配置</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">P：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE1：</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:1</span><br><span class="line"> route-target import 234:2</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 234</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  neighbor 192.168.12.1 remote-as 12</span><br><span class="line">  neighbor 192.168.12.1 activate</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2:</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 234:2</span><br><span class="line"> route-target import 234:1</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 192.168.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">router ospf 234</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 192.168.34.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 2.2.2.2 remote-as 234</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 2.2.2.2 activate</span><br><span class="line">  neighbor 2.2.2.2 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  neighbor 192.168.45.5 remote-as 12</span><br><span class="line">  neighbor 192.168.45.5 activate</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE1:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 234</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 5.5.5.5 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.45.4 remote-as 234</span><br></pre></td></tr></table></figure>

<p>PE1和PE2都向对端的CE1和CE2宣告了路由，但CE1和CE2由于路由更新中有自身的AS_PATH号，触发了防环机制，并没将路由更新放入路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1#show ip bgp all neighbors 192.168.12.1 advertised-routes</span><br><span class="line">For address family: VPNv4 Unicast</span><br><span class="line">BGP table version is 7, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i  5.5.5.5/32       4.4.4.4                  0    100      0 12 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2#show ip bgp vpnv4 all neighbors 192.168.45.5 advertised-routes</span><br><span class="line">BGP table version is 4, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 1:1 (default for vrf CISCO)</span><br><span class="line"> *&gt;i  1.1.1.1/32       2.2.2.2                  0    100      0 12 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE1#show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       0.0.0.0                  0         32768 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   5.5.5.5/32       0.0.0.0                  0         32768 i</span><br></pre></td></tr></table></figure>

<p>这里使用as-override来打破环路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PE1(config)#router bgp 234</span><br><span class="line">PE1(config-router)#address-family ipv4 vrf CISCO</span><br><span class="line">PE1(config-router-af)#neighbor 192.168.12.1 as-override</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PE2(config)#router bgp 234</span><br><span class="line">PE2(config-router)#address-family ipv4 vrf CISCO</span><br><span class="line">PE2(config-router-af)#neighbor 192.168.45.5 as-override</span><br></pre></td></tr></table></figure>

<p>配置完毕以后再看CE1和CE2的路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CE1#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;   5.5.5.5/32       192.168.12.2                           0 234 234 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       192.168.45.4                           0 234 234 i</span><br><span class="line"> *&gt;   5.5.5.5/32       0.0.0.0                  0         32768 i</span><br></pre></td></tr></table></figure>

<p>路由更新进入了路由表。</p>
<h1 id="MPLS-VPN高级特性"><a href="#MPLS-VPN高级特性" class="headerlink" title="MPLS VPN高级特性"></a>MPLS VPN高级特性</h1><h2 id="限制VRF中路由数量"><a href="#限制VRF中路由数量" class="headerlink" title="限制VRF中路由数量"></a>限制VRF中路由数量</h2><p>运营商提供MPLS VPN服务，如果PE-CE之间采用BGP连接，由于BGP往往用于承载大量的路由前缀信息，因此实际上PE设备承担着一定的风险，例如CE网络中的攻击行为，或路由条目过多导致PE设备过载等等，因此需要针对特定客户分配的资源进行限制。思科提供了两种方法：</p>
<ol>
<li>限制从BGP邻居收到的路由前缀条目；</li>
<li>限制VRF中的路由条目数量；</li>
</ol>
<h3 id="限制BGP路由数量"><a href="#限制BGP路由数量" class="headerlink" title="限制BGP路由数量"></a>限制BGP路由数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 2345</span><br><span class="line">  address-family ipv4 vrf ABC </span><br><span class="line">  neighbor 5.5.5.5 maximum-prefix YYY</span><br><span class="line">  限制从邻居接收的前缀最大数量，如果超出了这个数字，路由器就会关闭与该邻居的BGP连接，在使用clear ip bgp 命令之前都不会再次建立BGP会话</span><br><span class="line">  </span><br><span class="line">  neighbor maximum-prefix XX restart YY</span><br><span class="line">  当从邻居接收的前缀数量超过XX这个数量后，断开与邻居的BGP连接，Y分钟后才能重新连接</span><br><span class="line">  </span><br><span class="line">  neighbor maximum-prefix 300 90% warning-only</span><br><span class="line">  当从邻居接收的前缀数量超过了最大数字300的90%时（默认75%），生成一条日志消息</span><br></pre></td></tr></table></figure>

<h3 id="限制VRF路由数量"><a href="#限制VRF路由数量" class="headerlink" title="限制VRF路由数量"></a>限制VRF路由数量</h3><p>VRF路由表中的路由学习来源有两个，分别是从CE（PE-CE之间的IGP），以及VPNV4（也就是MP-BGP），那么这个特性的限制对这两个途径学习到的路由都有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip vrf ABC</span><br><span class="line"> maximum XXX</span><br></pre></td></tr></table></figure>

<h2 id="SOO"><a href="#SOO" class="headerlink" title="SOO"></a>SOO</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>SOO全称是Site Of Origin，SOO是一个扩展BGP community，用来标识路由的起源站点的唯一性，防止从VRF路由表进入BGP路由表的路由又回到起源站点，防止出现路由环路（对于那些连接着多个PE的CE来说，如果CE只连接了单PE则不需要该属性防环）或出现次优路径。</p>
</li>
<li><p>SOO用于PE-CE之间是IGP协议时，或当AS_PATH作为防环手段不再可靠的BGP环境中（比如使用了AS-Override或Allow-as-in）。</p>
</li>
<li><p>如果在PE上为一个CE配置了SOO时，当这个PE从VPNV4邻居处收到一个带有同样SOO的VPNV4路由更新后，PE不会将这个VPNV4路由更新放入VRF路由表，也不会更新给CE。所以SOO是在VRF上配置的。</p>
</li>
<li><p>所有从CE学到的路由都会被赋予相同的SOO值，即使来自该站点的路由来自不同的PE路由器。这样才能确保来自单一CE的这些路由进入BGP时都带有该SOO，才能防止环路出现。比如如果CE1同时连接了PE1和PE2，那么PE1和PE2都要对CE1使用SOO特性。</p>
</li>
<li><p>当PE-CE之间是EBGP邻居关系时，SOO在PE上用route-map方式进行配置；当PE-CE之间是其他IGP路由协议时，SOO在适当的VRF接口上配置。</p>
</li>
</ul>
<p><img src="/2022/01/20/18-MPLSVPN/1616572487007-a7ebc56a-e3f7-44a0-bea1-aea40ff67e4d.png" alt="img"></p>
<p>比如上图中的CE2，和PE3以及PE2相连接，在PE2和PE3上都要对CE2通告过来的，进入VRF中的路由赋予相同的SOO值，1:100，这样来自CE2的路由不管从哪个途径进入BGP，试图重新传回CE2或和CE2相连的PE时，都会携带SOO，当PE收到重新传回的那些带有SOO的VPNV4路由时，不会被放入VRF路由表中。</p>
<h3 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EBGP情况：</span><br><span class="line">route-map test permit 10</span><br><span class="line">  set extcommunity soo 1:100</span><br><span class="line">router bgp 1</span><br><span class="line">  address-family ipv4 vrf ABC</span><br><span class="line">    neighbor 10.10.2.1 remote-as 1</span><br><span class="line">    neighbor 10.10.2.1 route-map test in</span><br><span class="line">在EBGP情况下，直接使用route-map命令，然后在neighbor中进行关联</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">非BGP情况：</span><br><span class="line">interface e0/0</span><br><span class="line">  ip vrf sitemap test</span><br><span class="line">在恰当的vrf interface 的ip vrf sitemap中配置</span><br></pre></td></tr></table></figure>

<p>也可以在直连和静态路由重发布到BGP的时候关联设置SOO的route-map。</p>
<h2 id="选择性Import-Export"><a href="#选择性Import-Export" class="headerlink" title="选择性Import\Export"></a>选择性Import\Export</h2><h3 id="选择性import"><a href="#选择性import" class="headerlink" title="选择性import"></a>选择性import</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip vrf ABC</span><br><span class="line">  import map test</span><br><span class="line">  route-target import 2345:10</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">access-list 10 permit 10.1.1.0</span><br><span class="line">route-map test </span><br><span class="line">  match ip address 10</span><br></pre></td></tr></table></figure>

<p>路由在导入VRF路由表前，先经过RT过滤一遍，再经过Import map后跟的route-map过滤一遍。VRF路由表学习路由的来源有两个途径，一个是通过CE学习到，另一个是通过VPNV4路由，也就是MP-BGP学习到，那么这个选择性Import的特性，过滤的路由是针对VPNV4学习到的路由。前面通过maximum限制路由最大数量的命令则对MP-BGP和VPNV4学习到的路由都生效。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616579232205-f9d2ac49-68c0-4020-87ce-f7fef5fcb964.png" alt="img"></p>
<p>两条VPNV4路由到达PE，两条VPNV4路由的RT都是115:317，符合VRF配置的RTimport，但由于VRF上还配置了import map，还要根据名为RTMAP的route-map再过滤一遍，由于这个route-map需要match192.168.30.0网段的地址，所以来自192.168.31.0网段的那条VPNV4地址无法导入VRF。</p>
<h3 id="选择性export"><a href="#选择性export" class="headerlink" title="选择性export"></a>选择性export</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip vrf ABC</span><br><span class="line">  export map test</span><br><span class="line">  route-target export 2345:20</span><br><span class="line"></span><br><span class="line">access-list 10 permit 10.2.2.0</span><br><span class="line">route-map test</span><br><span class="line">  match ip address 10</span><br><span class="line">  set extcommunity rt 2345:2020 additive</span><br></pre></td></tr></table></figure>

<p>‘export map test’并不能起到过滤导出路由的作用，而是给匹配route-map test的路由附加额外配置的RT值，就是‘set extcommunity rt 2345:2020 additive’中配置的RT值，如果后面不加additive，则为覆盖原有RT值，加上additive，则为额外增加一个RT值。这个命令只针对从VRF导入MP-BGP的路由生效，而且只能set RT值。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616581105854-566fc16c-4cd2-4658-8fbf-5405aa70018d.png" alt="img"></p>
<p>上图中，配置了export map，其中access-list匹配的是192.168.30.0网段，附加的RT值是115:273且应用了additive命令，所以这条192.168.30.0的VPNV4路由除了原有的115:317，还有一个额外的RT值，115:273。</p>
<h1 id="MPLS-VPN双PE防环"><a href="#MPLS-VPN双PE防环" class="headerlink" title="MPLS VPN双PE防环"></a>MPLS VPN双PE防环</h1><h2 id="实验1：CE运行OSPF"><a href="#实验1：CE运行OSPF" class="headerlink" title="实验1：CE运行OSPF"></a>实验1：CE运行OSPF</h2><h3 id="拓扑及环境"><a href="#拓扑及环境" class="headerlink" title="拓扑及环境"></a>拓扑及环境</h3><p><img src="/2022/01/20/18-MPLSVPN/1616658316278-db5f9ed6-5ce4-4164-8f68-e3c5405e0c96.png" alt="img"></p>
<p>左右两个Site，两边的PE-CE路由协议都是OSPF，R5为RR，PE1、PE2、PE3都是它的Client。左右两个Site都将客户路由发送给PE，最终要实现Site之间能够互访。R3-R5，R4-R5，R5-R6之间均为MP-IBGP关系，R5为RR。</p>
<p>本实验重点关注两个Site在各种OSPF网络设计的情况下，网络的特征和产生的变化，以及Site1双PE在各种环境下的问题和解决办法。</p>
<h3 id="OSPF单区域情况"><a href="#OSPF单区域情况" class="headerlink" title="OSPF单区域情况"></a>OSPF单区域情况</h3><h4 id="配置-3"><a href="#配置-3" class="headerlink" title="配置"></a>配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 10.1.12.1 0.0.0.0 area 0</span><br><span class="line"> network 10.1.13.1 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.24.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.12.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.24.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3:</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:1</span><br><span class="line"> route-target export 3456:12</span><br><span class="line"> route-target import 3456:3</span><br><span class="line"> route-target import 3456:12</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 300 399</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.35.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1 vrf CISCO</span><br><span class="line"> redistribute bgp 3456 subnets</span><br><span class="line"> network 10.1.13.3 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 3456</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"> network 10.1.35.3 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 3456</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 5.5.5.5 remote-as 3456</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 5.5.5.5 activate</span><br><span class="line">  neighbor 5.5.5.5 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 1 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4:</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:2</span><br><span class="line"> route-target export 3456:12</span><br><span class="line"> route-target import 3456:12</span><br><span class="line"> route-target import 3456:3</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 400 499</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.24.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1 vrf CISCO</span><br><span class="line"> redistribute bgp 3456 subnets</span><br><span class="line"> network 10.1.24.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 3456</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.45.4 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 3456</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 5.5.5.5 remote-as 3456</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 5.5.5.5 activate</span><br><span class="line">  neighbor 5.5.5.5 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 1 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.35.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> --More--</span><br><span class="line">*Mar 27 17:33:26.911: %SYS-5-CONFIG_I: Configured from console by console</span><br><span class="line"> ip address 10.1.56.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 3456</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 3456</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 3.3.3.3 remote-as 3456</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 3456</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> neighbor 6.6.6.6 remote-as 3456</span><br><span class="line"> neighbor 6.6.6.6 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 3.3.3.3 activate</span><br><span class="line">  neighbor 3.3.3.3 send-community extended</span><br><span class="line">  neighbor 3.3.3.3 route-reflector-client</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line">  neighbor 4.4.4.4 route-reflector-client</span><br><span class="line">  neighbor 6.6.6.6 activate</span><br><span class="line">  neighbor 6.6.6.6 send-community extended</span><br><span class="line">  neighbor 6.6.6.6 route-reflector-client</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R6:</span><br><span class="line">ip vrf CISCO</span><br><span class="line"> rd 1:3</span><br><span class="line"> route-target export 3456:3</span><br><span class="line"> route-target import 3456:12</span><br><span class="line">!</span><br><span class="line">ip cef</span><br><span class="line">no ipv6 cef</span><br><span class="line">!</span><br><span class="line">multilink bundle-name authenticated</span><br><span class="line">mpls label range 600 699</span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.56.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> mpls ip</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding CISCO</span><br><span class="line"> ip address 10.1.67.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1 vrf CISCO</span><br><span class="line"> redistribute bgp 3456 subnets</span><br><span class="line"> network 10.1.67.6 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router ospf 3456</span><br><span class="line"> router-id 6.6.6.6</span><br><span class="line"> network 6.6.6.6 0.0.0.0 area 0</span><br><span class="line"> network 10.1.56.6 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 3456</span><br><span class="line"> bgp router-id 6.6.6.6</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 5.5.5.5 remote-as 3456</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 5.5.5.5 activate</span><br><span class="line">  neighbor 5.5.5.5 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf CISCO</span><br><span class="line">  redistribute ospf 1 match internal external 1 external 2</span><br><span class="line"> exit-address-family</span><br><span class="line">!</span><br><span class="line">ip forward-protocol nd</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">no ip http server</span><br><span class="line">no ip http secure-server</span><br><span class="line">!</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">!</span><br><span class="line">mpls ldp router-id Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R7:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.67.7 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> no ip address</span><br><span class="line"> shutdown</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> network 7.7.7.7 0.0.0.0 area 0</span><br><span class="line"> network 10.1.67.7 0.0.0.0 area 0 </span><br></pre></td></tr></table></figure>

<h4 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h4><p><img src="/2022/01/20/18-MPLSVPN/1616837998259-85a6d527-f14c-46b0-a7a6-2bf493ee5c57.png" alt="img"></p>
<p>假设先配置的是PE1，然后配置的是PE2，来看看路由传递的过程，关键看VPNV4路由从R5传递给PE1后，PE1将路由注入到OSPF，形成3类LSA，这些3类LSA的DownBit都置为1了，因此即使再经过Site1内的OSPF网络被传到PE2，PE2也不会用这些3类LSA参与路由的计算，因为DownBit置1的路由会被路由器直接忽略掉，也不会加载进路由表，更不会在PE2上经过OSPF到BGP的重发布倒灌回BGP。注意，此刻PE2是恒定忽略掉DownBit置1的3类LSA的，即使Shutdown掉PE2连接R5的接口也一样，在此环境中，得益于OSPF的DownBit设计，网络显得很可靠。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616838263010-02f87f4d-759f-4587-b213-cccd72e62732.png" alt="img"></p>
<p>假设PE1先配置的OSPF到BGP的重发布，那么Site1内的客户路由，被PE1注入到MP-BGP形成了VPNV4的前缀，经由RR反射给了PE2，这时对于PE2来说，一遍是VRF的OSPF路由进程学习到Site1内的路由，另一方面，从MP-IBGP也学习到这些路由，OSPF进程的AD为110，MP-IBGP的AD为200，OSPF的AD小于MP-IBGP的AD值，所以优选OSPF路由，不会造成次优路由的问题。</p>
<h3 id="OSPF多区域情况"><a href="#OSPF多区域情况" class="headerlink" title="OSPF多区域情况"></a>OSPF多区域情况</h3><p><img src="/2022/01/20/18-MPLSVPN/1616895442518-b668c113-9451-4388-9697-1dd8dc4cdeaf.png" alt="img"></p>
<p>首先看PE1上发生了什么，PE1上首先通过BGP学习到了7.7.7.7这条Site2内的路由，然后将BGP路由重新发布到OSPF，形成Down bit置1的3类LSA。那么CE1就能学习到关于7.7.7.7的OIA路由，并且继续将3类LSA传递给CE2，CE2也收下了，由于它是ABR，从Area0收到3类LSA，于是CE2重新生成了一条3类LSA传递给PE2，此时这条3类LSA中的Downbit置1已经被清除，失去了防环功能，因为CE2并没有在MPLS VPN环境中，Downbit是只有在该环境中重发布时才会置位的。这还不是最糟糕的，更糟糕的是，3类LSA被传递给PE2以后，对于OSPF来说，MPLS VPN Backbone就是一个Super backbone area超级骨干区域，那么PE2一边连着Area1，另一边连着这个Super backbone area，既是一台ASBR又是一台ABR，ASBR是因为它引入了BGP的外部路由，ABR是因为它连接着Area 0和Area1。PE2是一台ABR，但却从Area1收到了3类LSA，这违反了OSPF关于‘3类LSA必须经过Area0中转’这一原则，因此PE2会忽略在Area1上收到的任何来自CE2的3类LSA，当然产生自CE2的Area1内的区域内部的1类LSA还是会接收的。</p>
<p>正是由于PE2的ABR属性，造成另一个问题是，来自Site1内Area0的路由，经由CE2以3类LSA的形式通告给PE2，PE2在路由计算的时候也照样忽略它们，这将导致接下去产生次优路径的问题。PE1上学到了Site1内的OSPF路由，它将这些OSPF重发布到BGP，并经由RR反射给了PE2，于是PE2从BGP学习到了这些Site 1内的路由，另一方面PE2又忽略了CE2更新过来的关于Site1内部路由的3类LSA，因此PE2的路由表里关于Site1中Area0的路由全是BGP的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">B        1.1.1.1 [200/11] via 3.3.3.3, 01:27:08 </span><br><span class="line">B        1.1.1.1 [200/11] via 3.3.3.3, 01:27:08 </span><br><span class="line">B        7.7.7.7 [200/11] via 6.6.6.6, 01:27:08 </span><br><span class="line">B        10.1.12.0/24 [200/20] via 3.3.3.3, 01:27:08 </span><br><span class="line">B        10.1.13.0/24 [200/0] via 3.3.3.3, 01:27:08 </span><br><span class="line">B        10.1.67.0/24 [200/0] via 6.6.6.6, 01:27:08 </span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/18-MPLSVPN/1616897304347-e142a67c-b15c-4300-a019-443b1834faa9.png" alt="img"></p>
<p>刚才描述的过程，可以用上面的图片来描述，即使将PE2上连接RR的接口Shutdown，PE2依旧会直接忽略从CE2传来的3类LSA，这种情况下PE2的VRF路由表变成了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">O                2.2.2.2 [110/11] via 10.1.24.2, 00:10:48, Ethernet0/0 </span><br></pre></td></tr></table></figure>

<p>只有一条Area 1内的路由，但查看PE2的OSPF Database发现，还是有许多CE2发过来的3类LSA，很明显验证了前面的说法，PE2认为它是个ABR，直接忽略了CE2发过来的3类LSA。</p>
<p>由于PE2路由表中存在的这个次优路径，加上PE2又做了OSPF和BGP的双向重发布，那么PE2上，这些从PE1倒灌过来的关于Site1内的路由，此时在PE2的路由表中是BGP路由，在BGP到OSPF的重发布动作后，这些路由又被倒灌回了Site1：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616897569443-7579f181-6c1d-4488-93bc-9e2fa6048010.png" alt="img"></p>
<p>现在来看CE2上:</p>
<ul>
<li><p>对于Site1内Area0中的路由，从Area0学到的是1类LSA和2类LSA，从PE2倒灌回来的是3类LSA，CE2当然优选1类LSA和2类LSA的路由，所以这里天然防环。</p>
</li>
<li><p>对于对端站点Site2内的路由，CE2同时能学到PE1和PE2更新过来的3类LSA，此时会比较Metric，最后优选PE2作为下一跳。</p>
</li>
<li><p>关键点，这里有个细节，R2是一台ABR，既然是ABR，那么当它收到PE2重发布进来的OSPF的3类LSA的时候，即使将3类LSA放进了LSDB也是应该忽略掉的，因为它从常规区域Area1收到的这些3类LSA，违法了‘3类LSA必须经过Area0中转’这一原则，但实际上在这个环境中，CE2不但将LSA装载进了LSDB，并且，这些LSA还参与了路由计算。但这些3类LSA，CE2自己是收下了也参与了路由计算，却不会将它们泛洪到Area0中，也就是说，只影响了CE2自己。</p>
</li>
</ul>
<p><strong>综上所述，当Site1内规划成多区域时，有可能引发一系列潜在的问题，所以：</strong></p>
<ul>
<li><p>MPLS VPN环境中，OSPF网络的设计要非常谨慎；</p>
</li>
<li><p>上面的问题，可以考虑在CE2和PE2之间，建立一个Virtual-link；</p>
</li>
<li><p>再有就是可以利用一些策略工作过滤掉路由；</p>
</li>
</ul>
<h3 id="OSPF单区域进程号不同"><a href="#OSPF单区域进程号不同" class="headerlink" title="OSPF单区域进程号不同"></a>OSPF单区域进程号不同</h3><p><img src="/2022/01/20/18-MPLSVPN/1616898647954-fca24c81-fe33-45a5-88a3-1588263ddd11.png" alt="img"></p>
<p>两边VRF OSPF进程号不同，Site 2的路由被PE1注入进OSPF后，会以5类LSA的形式注入，然后：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616898721205-78eaa576-af97-408c-b818-e7a41663c130.png" alt="img"></p>
<p>之前笔记中写过，Domain-tag功能和Down bit类似，不过DownBit是用于内部路由而Domain-Tag用于外部路由，由于两边VRF的OSPF进程号不同，所以重发布进OSPF的BGP路由，是以带有Domain-tag的5类LSA进入的OSPF区域，经由CE1-CE2传到PE2的时候，PE2收到这条5类LSA发现携带着Domain-tag值，且和本地的Domain-tag值匹配，因此这些5类LSA不会参与路由计算，可以达到防止次优路径的目的。同样也不用担心Site1内的路由被PE1注入到BGP然后经由RR反射回PE2，这里直接比AD值，反射回PE2的路由为AD值是200的IBGP路由，而PE2还收到了AD值为110的OSPF路由，BGP落败，就不会有次优路由的问题了。</p>
<h2 id="双PE运行EIGRP"><a href="#双PE运行EIGRP" class="headerlink" title="双PE运行EIGRP"></a>双PE运行EIGRP</h2><p><img src="/2022/01/20/18-MPLSVPN/1616899875611-3e813db7-31e7-4e15-a2c8-0585ce9cbb93.png" alt="img"></p>
<h3 id="一边EIGRP一边非EIGRP"><a href="#一边EIGRP一边非EIGRP" class="headerlink" title="一边EIGRP一边非EIGRP"></a>一边EIGRP一边非EIGRP</h3><p><img src="/2022/01/20/18-MPLSVPN/1616900070110-d7f60e1b-7b25-46c5-bdbc-70517652061e.png" alt="img"></p>
<p>实验中，Site1使用EIGRP，Site2使用OSPF，首先来看Site1内部路由的传递问题。</p>
<p>拿路由1.1.1.1举例，CE2及PE1都能学到这条EIGRP内部路由，那么在CE2及PE1上，1.1.1.1为EIGRP内部路由，且Metric都是537600，现在R2将这条路由更新给了PE2，那么在PE2上，路由的Metric是563200。</p>
<p>另一方面，PE1上，由于路由表中有了EIGRP路由1.1.1.1，且Metric为537600，因此这条路由在EIGRP到BGP的重发布过程中，被注入到了BGP，而这条路由的一些EIGRP特性，比如带宽、负载、延迟、AS号等等都被放进BGP路由的扩展community中，与前缀一并传递给了RR，RR将路由反射给了PE2。</p>
<p>现在关键问题就在PE2上，PE2将同时从EIGRP以及BGP学习到这条路由，PE2会如何选择？在OSPF-BGP环境下，会比较OSPF和BGP的AD值最后OSPF胜出，但这里情况不同，PE2在EIGRP环境中不会去比较AD值而是去比较Metric值。</p>
<p>为什么会这样？因为Site1内的EIGRP路由被PE1将路由注入到BGP后，这些EIGRP路由的许多特性都被很好的保存在BGP的扩展Community中，随着路由被一起运载到了PE2上，那么PE2可以根据这些扩展community值去还原EIGRP路由。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3-PE1#sh ip b vpnv4 all 1.1.1.1 </span><br><span class="line">BGP routing table entry for 1:1:1.1.1.1/32, version 1072 </span><br><span class="line">Paths: (1 available, best #1, table cisco) </span><br><span class="line">  Advertised to update-groups: </span><br><span class="line">    4   </span><br><span class="line">  Local </span><br><span class="line">    10.1.13.1 from 0.0.0.0 (3.3.3.3) </span><br><span class="line">    Origin incomplete, metric 409600, localpref 100, weight 32768, valid, sourced, best </span><br><span class="line">       0x8800:32768:0 0x8801:1:153600 0x8802:65281:256000 0x8803:65281:1500</span><br><span class="line">       !! 丰富的扩展 community 值很好的保护了 EIGRP 路由的原始生态特征 </span><br><span class="line">    mpls labels in/out 313/nolabel </span><br></pre></td></tr></table></figure>

<p>因此，对于EIGRP来说，此刻MPLS VPN Backbone就相当于一个透明区域，所以PE2虽然同时从EIGRP以及MP-IBGP收到1.1.1.1/32，但它不会去比较AD而是比较Metric。CE2将EIGRP路由更新给PE2，PE2经由CE2去往1.1.1.1的Metric是563200，而从MPLS VPN这一侧通过PE1走，Metric是537600，因此最终，PE2优选BGP的1.1.1.1路由放进了路由表。</p>
<p>这样一来就出问题了，对于PE2而言，去往1.1.1.1走的是MPLS VPN Backbone这条次优路径，而且更郁闷的是，由于这条路由在PE2的VRF路由表里是BGP的，而PE2又部署了BGP与EIGRP的双向重发布，这条次优路由又被倒灌回了EIGRP，这也是我们非常不想看到的。</p>
<p>解决的办法，可以考虑在PE1及PE2上，BGP进程中过滤掉Site1内的路由而防止自己从MP-IBGP再学习到这些路由，这种方法有个潜在的问题是，如果CE1-CE2之间的链路断掉的话，那么CE1-CE2之间的连通性就丢失了。另一个用于解决该问题的方法是采用SOO，同样的也存在刚才说的那个缺陷。</p>
<p><strong>下面来看另一种情况：</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616982359431-a2d931f6-1d58-4bc2-afd3-5ca8b80a5aca.png" alt="img"></p>
<p>如果R1始发的1.1.1.1路由不是EIGRP内部路由，而是由直连重发布所产生的路由，那么情况就大不一样了。</p>
<p>这条路由首先是分别被PE1和PE2学习到，那么假设我们先在PE1上做的EIGRP到BGP的重发布，那么这条路由又通过MP-IBGP传递给了PE2，所以症结又在PE2这里了，PE2会如何选择？此时PE2不再比较Metric了，而是比较AD值，所以PE2路由表里装的1.1.1.1路由，还是EIGRP的。</p>
<p>为什么一会儿比较AD一会儿比较Metric呢？来看PE1发出的VPNV4前缀：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3-PE1#sh ip b vpnv4 all 1.1.1.1  </span><br><span class="line">BGP routing table entry for 1:1:1.1.1.1/32, version 1049 </span><br><span class="line">Paths: (2 available, best #2, table cisco) </span><br><span class="line">  10.1.13.1 from 0.0.0.0 (3.3.3.3) </span><br><span class="line">    Origin incomplete, metric 537600, localpref 100, weight 32768, valid, sourced, best </span><br><span class="line">    Extended Community: RT:3456:12   !! 扩展 Community 里只有 RT </span><br><span class="line">    mpls labels in/out 300/nolabel </span><br></pre></td></tr></table></figure>

<p>可以看到，PE1学习到的这条EIGRP外部路由，在注入BGP后，并没有像内部路由那样，将各个参数保存到BGP的扩展community中，这样的一个直接后果就是，在路由被RR反射到PE2后，PE2完全没有足够的信息将路由还原成EIGRP路由，既然如此，PE2就当该路由是一条纯粹的从MP-IBGP学习到的路由，自然而然的就与另一侧的EIGRP去PK路由协议的AD值，最终EIGRP外部的170AD值小于MP-IBGP的200的AD值，EIGRP外部路由胜出。</p>
<p><strong>Site2路由传播</strong></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616983810308-04f465e7-8a16-4e2f-82b0-725485645aa8.png" alt="img"></p>
<p>再看Site2的路由传播，假设PE1先做的重发布，那么7.7.7.7的路由被注入到了EIGRP中，由于这条路由的来源是OSPF协议，因此路由是以外部路由的方式注入到EIGRP中，这条EIGRP外部路由最终更新给了PE2，而PE2也从MP-IBGP学习到了这条路由，这里毫无疑问是要比较这两个路由的AD值的，因为都是外部路由，所以最终PE2的路由表里存放的关于7.7.7.7的路由是EIGRP的，因为EIGRP的外部路由AD值为170小于MP-IBGP的AD值200。</p>
<p>由于PE2上又做了EIGRP到BGP的重发布，因此这条路由又被倒灌回了MP-BGP。解决的办法是在PE1和PE2上，将BGP路由注入到EIGRP的时候关联一个route-map，给路由打上Tag，然后在EIGRP向BGP重发布时，将这些打了Tag的路由Deny掉，放行其他即可。</p>
<h3 id="两边均为EIGRP"><a href="#两边均为EIGRP" class="headerlink" title="两边均为EIGRP"></a>两边均为EIGRP</h3><h4 id="两端AS号一致"><a href="#两端AS号一致" class="headerlink" title="两端AS号一致"></a>两端AS号一致</h4><p><img src="/2022/01/20/18-MPLSVPN/1616985053771-8e8d660f-f1cf-4295-b4bc-ac2615bc8c6d.png" alt="img"></p>
<p>在该环境中，Site2运行的PE-CE协议为EIGRP，且AS号也为1.现在来看Site2到Site1的路由传递过程。</p>
<p>7.7.7.7这条EIGRP内部路由，被PE3注入到EIGRP后，形成了一条VPNV4前缀，同时还携带着用于保留EIGRP特性的那些扩展community。路由分别被传递到了PE1和PE2。</p>
<p>假设在PE1上先行配置的BGP到EIGRP的重发布，那么这条BGP路由被PE1注入了EIGRP，得益于路由携带的扩展community属性，这条路由被还原成了一条EIGRP内部路由，然后被放进了Site1的EIGRP域。这样一来这条路由就会经过R2最终传递给了PE2。</p>
<p>现在PE2上从EIGRP学到了一条内部路由7.7.7.7，另一方面，也从MP-IBGP学习到了这条路由，该怎么办？这里不会比较EIGRP和MP-IBGP的AD值，而是去比较Metric值。因为MP-IBGP传递过来的这条路由中的扩展community能够使得路由在PE2上的BGP重发布到EIGRP后被还原成了一条EIGRP内部路由，此时从PE2的视角来看，MPLS VPN Backbone相当于完全透明的，相当于：</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616985930750-9c2a2c8a-379a-4904-9d13-9e4ad472a441.png" alt="img"></p>
<p>上面这个情况，PE2在面对两条内部EIGRP路由的情况下，会比较Metric值。也就是说当EIGRP路由在穿越MPLS VPN Backbone时，如果路由的各项特性能够完好的保存下来，此时MPLS VPN Backbone对于EIGRP相当于透明的。</p>
<h4 id="两端AS号不同"><a href="#两端AS号不同" class="headerlink" title="两端AS号不同"></a>两端AS号不同</h4><p><img src="/2022/01/20/18-MPLSVPN/1616986054417-ff70c96f-54d3-4bac-bc70-33feb6162f61.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1616986310799-2210388b-33a0-4ab8-96fe-bc1ffb5a52e7.png" alt="img"></p>
<h1 id="Inter-AS-MPLS-VPN"><a href="#Inter-AS-MPLS-VPN" class="headerlink" title="Inter-AS MPLS VPN"></a>Inter-AS MPLS VPN</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>Inter-AS MPLS VPN是一种牛逼的解决方案，到目前为止，接触的MPLS VPN中，Backbone都属于一个单一的AS，单一的ISP，如果两端的站点分布在两个不同的ISP下属的MPLS VPN网络呢？这就需要考虑域间的MPLS VPN解决方案了，Inter-AS MPLS VPN是一种基于基础MPLS VPN构架的扩展，在RFC 2547中定义。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616987726192-18f674b8-db3a-4e68-8d0a-c642f37b0cec.png" alt="img"></p>
<p>最终目的非常简单，就是在两个AS之间传递VPN路由，使得各VPN客户的不同站点能够互访。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616987874975-9e67b2f1-ef38-4112-a7ce-49e07a9977b7.png" alt="img"></p>
<p>总结起来Inter-AS MPLS VPN有四种方式，分别是option A、B、C和C+，根据场景需要使用不同的方案，简单场景一般用Option A，复杂场景使用Option C。</p>
<p><img src="/2022/01/20/18-MPLSVPN/1616988154084-871ff450-6347-4b3f-9ae4-9288005932bd.png" alt="img"></p>
<p><img src="/2022/01/20/18-MPLSVPN/1617253894572-45521ab8-71af-463a-b210-3b9f0bde3d0e.png" alt="img"></p>
<h2 id="Option-A"><a href="#Option-A" class="headerlink" title="Option A"></a>Option A</h2><h3 id="模型解析"><a href="#模型解析" class="headerlink" title="模型解析"></a>模型解析</h3><h4 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h4><ul>
<li><p>当PE-ASBRs之间在一条物理连接的情况下可以考虑部署，并建议只部署在少量VRFs要求的环境中；</p>
</li>
<li><p>两个PE-ASBRs之间只有一条物理线路连接；</p>
</li>
<li><p>两个PE-ASBRs各自将对方视为一台CE，两者之间可使用任意一种PE-CE动态路由协议；</p>
</li>
<li><p>在两个PE-ASBRs之间流量传递的是传统的IP流量，两台ASBR之间不维护任何MP-BGP邻接关系，也不维护任何LDP邻接关系；</p>
</li>
<li><p>这种Inter-AS MPLS VPN方案最简单，但是很明显，扩展性非常差，当有大量VRF的情况下无法胜任；</p>
</li>
<li><p>不同ISP之间的ASBR都会把对方ASBR看成是CE，在两端ASBR上创建VRF并形成邻居，彼此之间传输的是IPV4路由，但会把对方传过来的路由加入VRF表；</p>
</li>
</ul>
<h4 id="数据交互过程"><a href="#数据交互过程" class="headerlink" title="数据交互过程"></a>数据交互过程</h4><p><img src="/2022/01/20/18-MPLSVPN/1617004873930-01baca44-a2c0-4a18-a76a-03efda003ad8.png" alt="img"></p>
<h3 id="实验说明-1"><a href="#实验说明-1" class="headerlink" title="实验说明"></a><a href="http://ciskonetwork.blogspot.com/2015/08/inter-as-mpls-vpn-option-back-to-back.html">实验说明</a></h3><p><img src="/2022/01/20/18-MPLSVPN/1617104739673-a6d3bb2f-2567-4cd0-9a11-651e74163869.png" alt="img"></p>
<p>MPLS标签范围为路由器编号，比如R1的label range为100-199。R3为RR，PE-ASBR1及ASBR2之间两边接口都不能运行LDP，使用一个OSPF协议来作为PE-CE的IGP，双方互相将对方视为自己的VRF客户。CE1-PE1、CE2-PE2以及SP1ASBR-SP2ASBR之间都运行BGP协议。</p>
<h3 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">基础配置：</span><br><span class="line">CE-R1:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 10</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 10.1.12.2 remote-as 100</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-PE1-R2:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 10.1.23.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-P-R3:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.34.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-ASBR-R4:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 10.1.34.4 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP2-ASBR-R5:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.56.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 567</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 5.5.5.5 0.0.0.0 area 0</span><br><span class="line"> network 10.1.56.5 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP2-P-R6:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.56.6 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.67.6 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 567</span><br><span class="line"> router-id 6.6.6.6</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP2-PE1-R7:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.67.7 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> no ip address</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 567</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> network 7.7.7.7 0.0.0.0 area 0</span><br><span class="line"> network 10.1.67.7 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">CE2-R8:</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 8.8.8.8 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.78.8 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 20</span><br><span class="line"> bgp router-id 8.8.8.8</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 10.1.78.7 remote-as 200</span><br><span class="line"> network 8.8.8.8 mask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>AS100和AS200两个Backbone的内部路由用OSPF打通确保彼此之间有到对方Loopback接口的路由，确保外部MPLS标签不出问题，CE1和CE2客户路由的BGP已经配置上，目的是让两个CE之间的Loopback接口能够通信，下面配置ISP内部设备。</p>
<p>首先CE-PE之间建立邻居关系，为了隔离不同客户之间的路由，先设置VRF，这里CE1这端用VRF BLUE，CE2那端用VRF RED，然后建立两端PE-CE之间的邻居关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP1-PE1-R2:</span><br><span class="line">ip vrf BLUE</span><br><span class="line"> rd 100:100</span><br><span class="line"> route-target export 100:100</span><br><span class="line"> route-target import 100:100</span><br><span class="line">！</span><br><span class="line"> interface Ethernet0/0</span><br><span class="line"> ip vrf forwarding BLUE</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">验证VRF的配置：</span><br><span class="line">R2#show ip vrf</span><br><span class="line">  Name                             Default RD            Interfaces</span><br><span class="line">  BLUE                             100:100               Et0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来配置PE-CE间BGP邻居</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf BLUE</span><br><span class="line">  neighbor 10.1.12.1 remote-as 10</span><br><span class="line">  neighbor 10.1.12.1 activate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">验证是否收到了1.1.1.1路由</span><br><span class="line">R2#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 2, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 100:100 (default for vrf BLUE)</span><br><span class="line"> *&gt;   1.1.1.1/32       10.1.12.1                0             0 10 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">在SP2-PE1-R7上做类似的配置：</span><br><span class="line">ip vrf RED</span><br><span class="line"> rd 200:200</span><br><span class="line"> route-target export 200:200</span><br><span class="line"> route-target import 200:200</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip vrf forwarding RED</span><br><span class="line"> ip address 10.1.78.7 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R7#show ip vrf</span><br><span class="line">  Name                             Default RD            Interfaces</span><br><span class="line">  RED                              200:200               Et0/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 7.7.7.7</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> !</span><br><span class="line"> address-family ipv4 vrf RED</span><br><span class="line">  neighbor 10.1.78.8 remote-as 20</span><br><span class="line">  neighbor 10.1.78.8 activate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R7收到了8.8.8.8的路由：</span><br><span class="line">R7#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 2, local router ID is 7.7.7.7</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 200:200 (default for vrf RED)</span><br><span class="line"> *&gt;   8.8.8.8/32       10.1.78.8                0             0 20 i</span><br></pre></td></tr></table></figure>

<p>在单ISP的MPLS VPN情况下，PE之间会建立VPNV4邻居，但在本实验拓扑中，PE位于不同的AS中，所以它们彼此之间无法建立VPNV邻居。拓扑中，SP1-ASBR和SP2-ASBR这两个在ISP边缘的路由器，在这里我们把它们看作是是连接客户的PE路由器。接下来要建立SP1-PE1和SP1-ASBR之间，以及SP2-PE2和SP2-ASBR之间的VPNV4邻居关系，BGP的TCP连接由OSPF协议打通：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP1-ASBR:</span><br><span class="line">ip vrf BLUE</span><br><span class="line"> rd 100:100</span><br><span class="line"> route-target export 100:100</span><br><span class="line"> route-target import 100:100</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-PE1-R2:</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 4.4.4.4 activate</span><br><span class="line">  neighbor 4.4.4.4 send-community extended</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">来看PE1和ASBR之间的VPNV4邻居是否建立： </span><br><span class="line">R4#show ip bgp vpnv4 all summary</span><br><span class="line">BGP router identifier 4.4.4.4, local AS number 100</span><br><span class="line">BGP table version is 3, main routing table version 3</span><br><span class="line">1 network entries using 156 bytes of memory</span><br><span class="line">1 path entries using 84 bytes of memory</span><br><span class="line">1/1 BGP path/bestpath attribute entries using 168 bytes of memory</span><br><span class="line">1 BGP AS-PATH entries using 24 bytes of memory</span><br><span class="line">1 BGP extended community entries using 24 bytes of memory</span><br><span class="line">0 BGP route-map cache entries using 0 bytes of memory</span><br><span class="line">0 BGP filter-list cache entries using 0 bytes of memory</span><br><span class="line">BGP using 456 total bytes of memory</span><br><span class="line">BGP activity 1/0 prefixes, 1/0 paths, scan interval 60 secs</span><br><span class="line"></span><br><span class="line">Neighbor        V           AS MsgRcvd MsgSent   TblVer  InQ OutQ Up/Down  State/PfxRcd</span><br><span class="line">2.2.2.2         4          100      28      27        3    0    0 00:21:39        1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">验证ASBR是否收到了PE1发来的VPNV4路由：</span><br><span class="line">R4#show ip bgp vpnv4 all</span><br><span class="line">BGP table version is 3, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 100:100 (default for vrf BLUE)</span><br><span class="line"> *&gt;i  1.1.1.1/32       2.2.2.2                  0    100      0 10 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP2-ASBR-R5:</span><br><span class="line">ip vrf RED</span><br><span class="line"> rd 200:200</span><br><span class="line"> route-target export 200:200</span><br><span class="line"> route-target import 200:200</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 7.7.7.7 remote-as 200</span><br><span class="line"> neighbor 7.7.7.7 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 7.7.7.7 activate</span><br><span class="line">  neighbor 7.7.7.7 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP2-PE1-R7:</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 7.7.7.7</span><br><span class="line"> no bgp default ipv4-unicast</span><br><span class="line"> neighbor 5.5.5.5 remote-as 200</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> !</span><br><span class="line"> address-family vpnv4</span><br><span class="line">  neighbor 5.5.5.5 activate</span><br><span class="line">  neighbor 5.5.5.5 send-community extended</span><br><span class="line"> exit-address-family</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">此时SP2-ASBR-R5也收到了8.8.8.8这条路由：</span><br><span class="line">R5#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 3, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 200:200 (default for vrf RED)</span><br><span class="line"> *&gt;i  8.8.8.8/32       7.7.7.7                  0    100      0 20 i</span><br></pre></td></tr></table></figure>

<p>在Option A（Back-to-Back VRF）中，ASBR将对方对接的路由器看成客户设备，所以SP1-ASBR会把自己看做PE而把对端的SP2-ASBR看做CE，反之亦然。</p>
<p>如果有多个客户，也就是有多个VRF，这种情况下可以为每个客户配置不同的子接口，用子接口来交换路由信息。在本实验中，我们用VLAN100来配置，在两端的ASBR上分别配置位于不同VRF的子接口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP2-ASBR-R5:</span><br><span class="line">interface Ethernet0/0.100</span><br><span class="line"> encapsulation dot1Q 100</span><br><span class="line"> ip vrf forwarding RED</span><br><span class="line"> ip address 10.1.45.5 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-ASBR-R4:</span><br><span class="line">interface Ethernet0/1.100</span><br><span class="line"> encapsulation dot1Q 100</span><br><span class="line"> ip vrf forwarding BLUE</span><br><span class="line"> ip address 10.1.45.4 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#ping vrf BLUE 10.1.45.5</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 10.1.45.5, timeout is 2 seconds:</span><br><span class="line">.!!!!</span><br><span class="line">Success rate is 80 percent (4/5), round-trip min/avg/max = 1/1/1 ms</span><br></pre></td></tr></table></figure>

<p>两端连通性搞定以后，就可以在两端ASBR上运行IGP或BGP来交换路由信息，在这里我们使用BGP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SP2-ASBR-R5:</span><br><span class="line">router bgp 200</span><br><span class="line"> address-family ipv4 vrf RED</span><br><span class="line">  neighbor 10.1.45.4 remote-as 100</span><br><span class="line">  neighbor 10.1.45.4 activate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SP1-ASBR-R4:</span><br><span class="line">router bgp 100</span><br><span class="line"> address-family ipv4 vrf BLUE</span><br><span class="line">  neighbor 10.1.45.5 remote-as 200</span><br><span class="line">  neighbor 10.1.45.5 activate</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 200:200 (default for vrf RED)</span><br><span class="line"> *&gt;   1.1.1.1/32       10.1.45.4                              0 100 10 i</span><br><span class="line"> *&gt;i  8.8.8.8/32       7.7.7.7                  0    100      0 20 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 100:100 (default for vrf BLUE)</span><br><span class="line"> *&gt;i  1.1.1.1/32       2.2.2.2                  0    100      0 10 i</span><br><span class="line"> *&gt;   8.8.8.8/32       10.1.45.5                              0 200 20 i</span><br></pre></td></tr></table></figure>

<p>可以看到，两个ISP的ASBR都收到了对方CE的路由，然后由VPNV4通过P-PE-CE发送到用户，先看AS100中的ISP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 100:100 (default for vrf BLUE)</span><br><span class="line"> *&gt;   1.1.1.1/32       10.1.12.1                0             0 10 i</span><br><span class="line"> *&gt;i  8.8.8.8/32       4.4.4.4                  0    100      0 200 20 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">C        1.1.1.1 is directly connected, Loopback0</span><br><span class="line">      8.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">B        8.8.8.8 [20/0] via 10.1.12.2, 00:05:57</span><br></pre></td></tr></table></figure>

<p>接下来看AS200中ISP的路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R7#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 7.7.7.7</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 200:200 (default for vrf RED)</span><br><span class="line"> *&gt;i  1.1.1.1/32       5.5.5.5                  0    100      0 100 10 i</span><br><span class="line"> *&gt;   8.8.8.8/32       10.1.78.8                0             0 20 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R8#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      1.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">B        1.1.1.1 [20/0] via 10.1.78.7, 00:07:34</span><br></pre></td></tr></table></figure>

<p>此时两边CE已经有对端的路由了，但此时依旧无法Ping通，因为MPLS VPN的外部标签还没配置，也就是ISP内部的MPLS还没配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mpls ldp router-id loop 0</span><br><span class="line">mpls label range X00 X99</span><br><span class="line">比如在R3上标签的范围就是300 399，在R4上就是400 499</span><br><span class="line"></span><br><span class="line">在R2的E0/1，R3的E0/0-1，R4的E0/0，R5的E0/1,R6的E0/0-1,R7的E0/0上配置：</span><br><span class="line">mpls ip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看MPLS LDP邻居建立：</span><br><span class="line">R6#show mpls ldp neighbor</span><br><span class="line">    Peer LDP Ident: 5.5.5.5:0; Local LDP Ident 6.6.6.6:0</span><br><span class="line">        TCP connection: 5.5.5.5.646 - 6.6.6.6.37958</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 112/112; Downstream</span><br><span class="line">        Up time: 01:32:24</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/0, Src IP addr: 10.1.56.5</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.56.5       5.5.5.5</span><br><span class="line">    Peer LDP Ident: 7.7.7.7:0; Local LDP Ident 6.6.6.6:0</span><br><span class="line">        TCP connection: 7.7.7.7.22578 - 6.6.6.6.646</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 11/11; Downstream</span><br><span class="line">        Up time: 00:03:26</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/1, Src IP addr: 10.1.67.7</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.67.7       7.7.7.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3#show mpls ldp neighbor</span><br><span class="line">    Peer LDP Ident: 2.2.2.2:0; Local LDP Ident 3.3.3.3:0</span><br><span class="line">        TCP connection: 2.2.2.2.646 - 3.3.3.3.53179</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 114/114; Downstream</span><br><span class="line">        Up time: 01:32:38</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/0, Src IP addr: 10.1.23.2</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.23.2       2.2.2.2</span><br><span class="line">    Peer LDP Ident: 4.4.4.4:0; Local LDP Ident 3.3.3.3:0</span><br><span class="line">        TCP connection: 4.4.4.4.45468 - 3.3.3.3.646</span><br><span class="line">        State: Oper; Msgs sent/rcvd: 58/59; Downstream</span><br><span class="line">        Up time: 00:44:54</span><br><span class="line">        LDP discovery sources:</span><br><span class="line">          Ethernet0/1, Src IP addr: 10.1.34.4</span><br><span class="line">        Addresses bound to peer LDP Ident:</span><br><span class="line">          10.1.34.4       4.4.4.4</span><br><span class="line">          </span><br><span class="line">          </span><br><span class="line">内外层标签均配置完毕后，查看CE1和CE2的连通性：</span><br><span class="line">R1#ping 8.8.8.8 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Sending 5, 100-byte ICMP Echos to 8.8.8.8, timeout is 2 seconds:</span><br><span class="line">Packet sent with a source address of 1.1.1.1</span><br><span class="line">!!!!!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1#tr 8.8.8.8 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 8.8.8.8</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.12.2 0 msec 0 msec 1 msec</span><br><span class="line">  2 10.1.23.3 [MPLS: Labels 302/403 Exp 0] 2 msec 1 msec 2 msec</span><br><span class="line">  3 10.1.45.4 [MPLS: Label 403 Exp 0] 2 msec 2 msec 1 msec</span><br><span class="line">  4 10.1.45.5 2 msec 2 msec 1 msec</span><br><span class="line">  5 10.1.56.6 [MPLS: Labels 602/16 Exp 0] 3 msec 3 msec 2 msec</span><br><span class="line">  6 10.1.78.7 [MPLS: Label 16 Exp 0] 1 msec 5 msec 1 msec</span><br><span class="line">  7 10.1.78.8 2 msec 4 msec *</span><br></pre></td></tr></table></figure>

<h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><h4 id="控制层面"><a href="#控制层面" class="headerlink" title="控制层面"></a>控制层面</h4><p><img src="/2022/01/20/18-MPLSVPN/1617181831285-48da6bc0-6d49-481d-ba0f-203d6fa06a6c.png" alt="img"></p>
<p>CE1-R1和SP1-PE1-R2之间通过BGP协议的方式，将IPV4路由宣告给PE路由器的VRF BLUE路由表，为VRF BLUE配置了RD以及RT，所以64bit长的RD被添加到32bit的Ipv4路由上，构成了96bit长的VPNV4地址，使得前缀在ISP中具有唯一性，RT值被添加到MPBGP的community扩展属性上。PE1和ASBR形成了MP-IBGP邻居关系，互相宣告带有MPLS标签（也就是VPN标签，由MPBGP分配给前缀）以及VPNV4路由前缀以及RT值，VPNV4路由宣告给ASBR后，导入IPV4 VRF以后，再到IPV4路由的形式宣告给SP2-ASBR，而后IPV4导入VRF中，然后前缀加上RD以后变成了96bit长的VPNV4前缀，宣告给了MP-IBGP邻居R7，由R7以IPV4形式通过BGP传递给了R8。R4和R5之间是纯IP形式交互，Option A可以理解成两个MPLS VPN在跨域的时候用IP形成了缝合。</p>
<h4 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h4><h3 id><a href="#" class="headerlink" title></a><img src="/2022/01/20/18-MPLSVPN/1617177518966-4f3a0c17-9dd0-4eb2-aaba-47413d2a65e4.png" alt="img"></h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#tr 8.8.8.8 source 1.1.1.1</span><br><span class="line">Type escape sequence to abort.</span><br><span class="line">Tracing the route to 8.8.8.8</span><br><span class="line">VRF info: (vrf in name/id, vrf out name/id)</span><br><span class="line">  1 10.1.12.2 0 msec 0 msec 1 msec</span><br><span class="line">  2 10.1.23.3 [MPLS: Labels 302/403 Exp 0] 2 msec 1 msec 2 msec</span><br><span class="line">  3 10.1.45.4 [MPLS: Label 403 Exp 0] 2 msec 2 msec 1 msec</span><br><span class="line">  4 10.1.45.5 2 msec 2 msec 1 msec</span><br><span class="line">  5 10.1.56.6 [MPLS: Labels 602/16 Exp 0] 3 msec 3 msec 2 msec</span><br><span class="line">  6 10.1.78.7 [MPLS: Label 16 Exp 0] 1 msec 5 msec 1 msec</span><br><span class="line">  7 10.1.78.8 2 msec 4 msec *</span><br></pre></td></tr></table></figure>

<p>从Traceroute中可以看出，CE1发出来的数据是纯IP，到了PE1以后路由器发现收到的是个数据包，会查CEF表，因此：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip cef vrf BLUE 8.8.8.8 detail</span><br><span class="line">8.8.8.8/32, epoch 0, flags [rib defined all labels]</span><br><span class="line">  recursive via 4.4.4.4 label 403</span><br><span class="line">    nexthop 10.1.23.3 Ethernet0/1 label 302-(local:201)</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">R2#show ip cef vrf BLUE 8.8.8.8/32</span><br><span class="line">8.8.8.8/32</span><br><span class="line">  nexthop 10.1.23.3 Ethernet0/1 label 302-(local:201) 403</span><br></pre></td></tr></table></figure>

<p>MPLS VPN有两层标签，先看外层标签，由LDP分配，因为MPLS不会为BGP分配标签但会为BGP的下一跳分配标签，PE1和PE2由loopback接口建立邻居，更新原地址是彼此的loopback接口，所以下一跳是4.4.4.4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 100:100 (default for vrf BLUE)</span><br><span class="line"> *&gt;   1.1.1.1/32       10.1.12.1                0             0 10 i</span><br><span class="line"> *&gt;i  8.8.8.8/32       4.4.4.4                  0    100      0 200 20 i</span><br></pre></td></tr></table></figure>

<p>4.4.4.4的outgoing标签是302由LDP分配，所以外层标签是302，这个外层标签是由R3分配的，从标签范围上也可能看出来。路由表中4.4.4.4的下一跳是10.1.23.3，所以递归后，到8.8.8.8的下一跳是10.1.23.3，也就是发给R3。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">201        302        4.4.4.4/32       0             Et0/1      10.1.23.3</span><br></pre></td></tr></table></figure>

<p>内层标签由MP-BGP分配，具体来说就是由SP1-ASBR-R3分配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">403        No Label   8.8.8.8/32[V]    2302          Et0/1.100  10.1.45.5</span><br></pre></td></tr></table></figure>

<p>所以最后这个IP包压上两层标签，内层标签为403，外层标签为302，下一跳是10.1.23.3，然后将数据发给SP1-P-R3，R3收到该数据后，由于是个MPLS标签包，所以查看LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">302        Pop Label  4.4.4.4/32       42891         Et0/1      10.1.34.4</span><br><span class="line">303        Pop Label  2.2.2.2/32       41172         Et0/0      10.1.23.2</span><br></pre></td></tr></table></figure>

<p>对于外层标签是302的标签包，R3会将最外层标签包弹出（Pop label），然后下一跳是4.4.4.4，也就是叫给SP1-ASBR-R4。标签头是403的MPLS包到了R4以后，查询LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">403        No Label   8.8.8.8/32[V]    2302          Et0/1.100  10.1.45.5</span><br></pre></td></tr></table></figure>

<p>标签头是403的MPLS包下一跳是10.1.45.5，动作是No Label，也就是将所有标签都剥掉，所以发给SP2-ASBR-R5的是一个IP包，R5收到这个IP包以后会查询自己的CEF表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip cef vrf RED 8.8.8.8</span><br><span class="line">8.8.8.8/32</span><br><span class="line">  nexthop 10.1.56.6 Ethernet0/1 label 602-(local:503) 16</span><br></pre></td></tr></table></figure>

<p>CEF上显示，下一步动作是打上外部标签602以及内部标签16，先看外层标签，由LDP分配，因为MPLS不会为BGP分配标签但会为BGP的下一跳分配标签，SP2-ASBR-R5和SP2-PE1-R7用loopback接口建立邻居，所以更新原地址是对方的loopback接口，所以下一跳是7.7.7.7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">503        602        7.7.7.7/32       0             Et0/1      10.1.56.6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5#show ip route</span><br><span class="line">      7.0.0.0/32 is subnetted, 1 subnets</span><br><span class="line">O        7.7.7.7 [110/21] via 10.1.56.6, 06:47:19, Ethernet0/1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5#show bgp vpnv4 unicast all</span><br><span class="line">BGP table version is 4, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">Route Distinguisher: 200:200 (default for vrf RED)</span><br><span class="line"> *&gt;i  8.8.8.8/32       7.7.7.7                  0    100      0 20 i</span><br></pre></td></tr></table></figure>

<p>到7.7.7.7的outgoing标签是602由LDP分配，所以外层标签是602，由R6分配该标签，路由表中7.7.7.7的下一跳是10.1.56.6，也就是发送给R6。</p>
<p>接下来看内层标签，内层标签由MP-BGP分配，具体来说是由SP2-PE1-R7分配：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R7#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">16         No Label   8.8.8.8/32[V]    1824          Et0/1      10.1.78.8</span><br></pre></td></tr></table></figure>

<p>所以最后这个IP包压上两层标签，外层标签为602，内层标签为16，然后发送到下一跳10.1.56.6，也就是R6，R6收到MPLS包后会查看LFIB：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">602        Pop Label  7.7.7.7/32       52717         Et0/1      10.1.67.7</span><br></pre></td></tr></table></figure>

<p>由于Outgoing是Pop label，R6会将顶部的外层标签602弹出，只剩下了内层标签16，然后将数据交给10.1.67.7，也就是R7，当MPLS数据到R7以后查询R7的LFIB表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R7#show mpls forwarding-table</span><br><span class="line">Local      Outgoing   Prefix           Bytes Label   Outgoing   Next Hop</span><br><span class="line">Label      Label      or Tunnel Id     Switched      interface</span><br><span class="line">16         No Label   8.8.8.8/32[V]    1824          Et0/1      10.1.78.8</span><br></pre></td></tr></table></figure>

<p>标签16的outgoing标签为No label，所以R7会将该标签包的所有标签剥离，变成一个IP数据，然后交给10.1.78.8，也就是发送给R8，最终顺利到达R8上的loopback0接口。</p>
<p><a href="https://blog.csdn.net/weixin_45821358/article/details/108396786">https://blog.csdn.net/weixin_45821358/article/details/108396786</a></p>
<p><a href="http://ciskonetwork.blogspot.com/2015/08/inter-as-mpls-vpn-option-back-to-back.html">http://ciskonetwork.blogspot.com/2015/08/inter-as-mpls-vpn-option-back-to-back.html</a></p>
<p><a href="http://www.amolak.net/mpls-l3vpn-inter-as-vpn-option-a/">http://www.amolak.net/mpls-l3vpn-inter-as-vpn-option-a/</a></p>
<p><a href="https://ccieblog.co.uk/mpls/difference-between-the-rd-and-rt">https://ccieblog.co.uk/mpls/difference-between-the-rd-and-rt</a></p>
<p><a href="https://www.networkfuntimes.com/route-distinguishers-vs-route-targets-what-are-they-why-do-we-need-them-both/">https://www.networkfuntimes.com/route-distinguishers-vs-route-targets-what-are-they-why-do-we-need-them-both/</a></p>
<p><a href="https://ipwithease.com/rd-vs-rt-in-mpls/">https://ipwithease.com/rd-vs-rt-in-mpls/</a></p>
<p><img src="/2022/01/20/18-MPLSVPN/1614667690580-549e5760-c735-497b-8111-2d5a2009c4e8.png" alt="img"></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>19-Switch</title>
    <url>/2022/01/20/19-Switch/</url>
    <content><![CDATA[<h1 id="以太网"><a href="#以太网" class="headerlink" title="以太网"></a>以太网</h1><h2 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h2><ul>
<li>Ethernet，以太网发明与20世纪70年代中期，由Xerox公司分部，Palo Alto研究中心开发的，Xerox最早发明的是一个2Mbps的以太网，后来又和Intel以及DEC合作开发出了10Mbps的以太网，俗称Ethernet 2或Ethernet DIX。后来IEEE通过802委员会把Ethernet标准化为IEEE802.3，它和Ethernet2十分相似。在TCP/IP中，以太网IP数据报文的封装格式由RFC894定义格式，IEEE802.3网络的IP数据报文封装由RFC1042定义，当今最常用的封装格式是RFC894定义的格式，通常称为Ethernet 2或Ethernet DIX。</li>
<li>管理MAC表。show mac address-table，clear mac address-table，绑定mac地址到一个接口：mac address-table static</li>
</ul>
<h2 id="以太网的数据链路层"><a href="#以太网的数据链路层" class="headerlink" title="以太网的数据链路层"></a>以太网的数据链路层</h2><p>在以太网中，针对不同的双工模式，提供不同的介质访问方法：</p>
<ul>
<li>半双工模式下采用的是CSMA/CD的访问方式。</li>
<li>全双工模式下则可以直接进行收发，不用预先判断链路的忙闲状态。</li>
</ul>
<p>半双工和全双工是物理层的概念，而针对物理层的双工模式提供不同的访问方式则是数据链路层的概念，这样就形成了以太网的一个重要特点，数据链路层和物理层是相关的。</p>
<p>由于以太网的物理层和数据链路层是相关的，针对物理层的不同工作模式，需要提供特定的数据链路层来访问。这给涉及和应用带来了一些不便，为此一些组织和厂家提出把数据链路层进行分层，分为逻辑链路控制子层（Logical Link Control，LLC）和媒体访问控制子层（Media Access Control），这样不同的物理层对应不同的MAC子层，LLC子层可以完全独立。</p>
<h3 id="MAC子层"><a href="#MAC子层" class="headerlink" title="MAC子层"></a>MAC子层</h3><p>MAC子层负责如下任务：</p>
<ul>
<li><p>提供物理链路的访问；</p>
</li>
<li><p>链路级站点标识：在数据链路层识别网络上的各个站点。</p>
</li>
<li><p>也就是说，在该层次保留了一个站点地址，也就是MAC地址，来标识网络上的唯一一个站点。</p>
</li>
<li><p>链路级的数据传输：从LLC子层接收数据，附加上MAC地址和控制信息后，把数据发送到物理链路上；在这个过程中提供校验等功能。</p>
</li>
</ul>
<p>MAC子层是物理相关的，也就是说，不同的物理层有不同的MAC子层来进行访问。在以太网中，主要存在两种MAC：</p>
<ul>
<li>半双工MAC：物理层运行模式是半双工时提供访问。</li>
<li>全双工MAC：物理层运行模式是全双工时提供访问。</li>
</ul>
<p>这两种MAC都集成在网卡中，网卡初始化的时候一般进行自动协商，根据自动协商的结果决定运行模式，然后根据运行模式选择相应的访问MAC。</p>
<p>MAC地址是烧录在网卡（Network Interface Controller，NIC）的ROM里的</p>
<p><img src="/2022/01/20/19-Switch/1617264140004-2ff7c56f-5a0d-4e4d-ac5f-51e9bfcd88cd.png" alt="img"></p>
<ul>
<li>高位是Individual/Group位，当它的值为0时，就可以认为这个地址实际上是设备的MAC地址。当它的值为1时，就可以认为这个地址表示以太网中的广播地址或组播地址，或者表示TR和FDDI中的广播地址或功能地址。</li>
<li>下一位是G/L位（也叫做U/L，这里的U表示全局）当这一位设置为0时，就表示一个全局管理地址（由IEEE分配），当这一位为1时，表示一个在管理上局部本地的地址（就像在DECnet中一样）。以太网一直使用全局唯一地址。</li>
</ul>
<h3 id="以太网帧格式"><a href="#以太网帧格式" class="headerlink" title="以太网帧格式"></a>以太网帧格式</h3><p>二层以太网的封装格式，能够见到的有四种，分别是TCP/IP协议使用、目前基本大一统的Ethernet II，IEEE的802.3、802.3LLC、802SNAP，常见的封装格式有两种：IEEE802.3和Ethernet II（以太网2），之所以有两种帧封装格式，是因为OSI七层以及TCP/IP两种模型定义了两种不同的封装格式，他们的差别主要是在帧头封装部分，之前规定的结果是控制层面使用802.3格式封装，转发层面的使用以太网2封装，但基本上目前是以太网一统天下，所以在这里就不说关于802.3的相关东西了。对这个有兴趣的可以看看论坛的帖子：<a href="https://community.cisco.com/t5/switching/ethernet-802-3-vs-ethernet-ii-frame/td-p/2718996">Ethernet 802.3 vs. Ethernet II Frame</a>和<a href="https://community.cisco.com/t5/switching/ether-frames-802-3-naming-conventions/td-p/2076323">Ether Frames 802.3 naming conventions</a>，这里贴一段总结的比较好的话：</p>
<p>if you are going to look at an IPv4 or IPv6 communication, it will be practically always encapsulated into Ethernet II frames because those are the most efficient in terms of overhead. 802.3 + LLC frames are used nowadays mostly for older protocols authored by IEEE itself, such as STP/RSTP/MSTP. SNAP frames are often used for vendor-proprietary Layer2 protocols - Cisco uses it for CDP, DTP, VTP and PAgP, to name a few.</p>
<p>如果你观察IPV4和IPV6的通信，它们实际上都是用以太网2进行封装的，因为从开销方面来说，这是最有效的封装方式，802.3+LLC子层的帧格式绝大部分时候出现在IEEE便携的较老的协议上，比如STP/RSTP/MSTP等协议。SNAP帧格式经常出现在厂家私有协议的二层协议中，比如思科在CDP，TDP，VTP和PAGP等协议上。</p>
<p>为什么以太网2格式使用的更广泛呢？</p>
<p>To run TCP/IP over IEEE 802.3, the SNAP format has to be used. That requires 8 bytes of the data field to identify the kind of data the frame is carrying: three bytes for the Logical Link Control, three bytes for the SNAP header, and two bytes for the Protocol Type field. That means the data field shrinks from the standard range of 46 to 1500 bytes down to a range of 38 to 1492. This is the reason most network managers stay with Ethernet II.</p>
<p>在TCP/IP协议上运行IEEE802.3封装时，必须使用SNAP格式，它需要8字节的数据字段来标识帧所携带的数据类型。这8个字节由3个字节的逻辑子层控制、3字节的SNAP报头、2个字节的协议类型字段组成。这意味着能携带的数据部分将从46-1500，缩小到38-1492字节。数据部分缩小是绝大多数网络使用以太网2封装的原因。</p>
<p><img src="/2022/01/20/19-Switch/1617269241080-767d3cfd-c2f9-4422-b375-26ac5b9e1191.jpeg" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617265708413-f5ba315f-2aa3-4564-bf48-3649e0de7a92.png" alt="img"></p>
<table>
<thead>
<tr>
<th>前导（Preamble）</th>
<th>包括7个字节的签到码（一串1、0间隔，用于信号同步）及1个字节的帧起始定界符</th>
</tr>
</thead>
<tbody><tr>
<td>类型（Type）</td>
<td>802.3使用长度字段，但Ethernet帧使用字段类型来识别网络层的协议。在Ethernet2帧中，两字节的类型字段用于标识数据字段中的高层协议，也就是说，该字段告诉接收设备如何解释数据字段。在以太网中，多种协议可以在局域网中同时共存，因此在Ethernet2的类型字段中设置相应的十六进制值提供了在局域网中支持多协议传输的机制。类型字段取值为0800的帧代表IP协议帧；类型字段取值为0806的帧代表ARP协议帧；类型字段取值为0835的帧代表RARP协议帧；类型字段取值为8137的帧代表IPX和SPX传输协议帧；802.3不能识别上层协议，因此必须与专用的LAN（比如IPX）一起使用。</td>
</tr>
<tr>
<td>数据（Data）</td>
<td>46-1500字节；在接口下设置的mtu xxx命令，指的就是这个，并且一般不允许手动修改。ip mtu指的是ip报文的最大值。</td>
</tr>
<tr>
<td>帧校验序列FCS（Frame Check Sequence）</td>
<td>这部分的作用是让接收端在收到数据的时候检查收到的帧是否正确无误，如果校验和结果错了，会丢掉此帧；如果校验和结果正确，再去判断帧的目的硬件地址（MAC地址）是否符合自己的接收条件，看帧校验和是二层解封装后的第一步。以太网使用CRC（Cyclic redundancy check）这种方式校验，所以在以太网里，可以暂且把两者看成是同一个东西，但从概念上来讲，要知道二者是不同的。</td>
</tr>
</tbody></table>
<p>目前我们所使用到的以太网帧基本都是Ethernet2帧。</p>
<h1 id="二层交换"><a href="#二层交换" class="headerlink" title="二层交换"></a>二层交换</h1><h2 id="VLAN"><a href="#VLAN" class="headerlink" title="VLAN"></a>VLAN</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><img src="/2022/01/20/19-Switch/1617269394100-5e7ab195-cf71-4f29-8442-b8a2f323c2f7.png" alt="img"></p>
<ul>
<li><p>一个VLAN中所有设备都是在同一广播域内，不同的VLAN为不同的广播域；</p>
</li>
<li><p>VLAN之间相互隔离，广播不能跨越VLAN传播，因此不同VLAN之间的设备一般无法相互访问，不同的VLAN间需通过三层设备实现相互通信；</p>
</li>
<li><p>一个VLAN一般为一个逻辑子网，由被配置为此VLAN成员的设备组成；</p>
</li>
<li><p>VLAN中成员大多基于交换机的端口分配，划分VLAN就是对交换机的接口划分；</p>
</li>
<li><p>VLAN工作域OSI参考模型的第二层；</p>
</li>
<li><p>VLAN是二层交换机的一个非常根本的工作机制；</p>
</li>
</ul>
<h3 id="VLAN通信原理"><a href="#VLAN通信原理" class="headerlink" title="VLAN通信原理"></a>VLAN通信原理</h3><p>为了提高处理效率，交换机内部的数据帧一律带有VLAN Tag，以统一方式处理。当一个数据帧进入交换机端口时，如果没有带VLAN Tag，并且该端口上配置了PVID（Port VLAN ID），那么该数据帧就会被标记上端口的PVID，如果该数据已经带有了VLAN Tag，那么即使端口已经配置了PVID，交换机不会再给数据帧标记VLAN Tag。默认情况下，整台交换机的所有端口均属于同一个广播域。</p>
<p>PVID是端口缺省VLAN ID的意思，即一个端口缺省属于的VLAN。</p>
<p>由于端口类型不同，交换机对帧的处理过程也不同，下面将根据不同的端口类型分别介绍。</p>
<h4 id="Access接口处理帧过程"><a href="#Access接口处理帧过程" class="headerlink" title="Access接口处理帧过程"></a>Access接口处理帧过程</h4><p>Access端口处理VLAN帧的过程如下：</p>
<ol>
<li><p>收到二层帧。</p>
</li>
<li><p>判断帧是否有Vlan Tag：如果没有Tag，则标记上Access端口的PVID，进行下一步处理；如果有Tag，则比较帧的VLAN Tag和端口的PVID，如果两者一致则进行下一步处理，如果不一致则丢弃帧。</p>
</li>
<li><p>二层交换机根据帧的MAC地址和VLAN ID查找VLAN配置信息，决定从哪个端口把帧发送出去。</p>
</li>
<li><p>交换机根据查到的出接口发送数据帧：</p>
</li>
</ol>
<ul>
<li><p>当数据帧从Access端口发出时，交换机先剥离帧的VLAN Tag，然后再发送出去；</p>
</li>
<li><p>当数据帧从Trunk端口发出时，直接发送帧；</p>
</li>
<li><p>当数据帧从Hybrid端口发出时，交换机判断VLAN在本地端口的属性是Untag还是Tag，如果是Untag，会先剥离帧的VLAN Tag，再发送；如果是Tag，则直接发送帧；</p>
</li>
</ul>
<h4 id="Trunk端口处理帧过程"><a href="#Trunk端口处理帧过程" class="headerlink" title="Trunk端口处理帧过程"></a>Trunk端口处理帧过程</h4><p>Trunk端口处理VLAN帧的过程如下：</p>
<ol>
<li><p>收到一个二层帧。</p>
</li>
<li><p>判断帧是否有VLAN Tag。如果没有Tag，则标记上Trunk端口的PVID，进行下一步处理。如果有Tag，则判断该Trunk端口是否允许VLAN帧进入。允许进入则进行下一步，否则丢弃帧。</p>
</li>
<li><p>二层交换机根据帧目的MAC地址和VLAN ID查找VLAN配置信息，决定从哪个端口把帧发送出去。</p>
</li>
<li><p>交换机根据查到的出接口发送数据帧：</p>
</li>
</ol>
<ul>
<li><p>当数据帧从Access端口发出时，交换机先剥离帧的VLAN Tag，然后再发送出去；</p>
</li>
<li><p>当数据帧从Trunk端口发出时，直接发送帧；</p>
</li>
<li><p>当数据帧从Hybrid端口发出时，交换机判断VLAN在本地端口的属性是Untag还是Tag，如果是Untag先剥离帧的VLAN Tag，再发送，如果是Tag，直接发送帧；</p>
</li>
</ul>
<h3 id="Protected-Port"><a href="#Protected-Port" class="headerlink" title="Protected Port"></a>Protected Port</h3><p><img src="/2022/01/20/19-Switch/1617348883508-d16e6d99-9a57-46eb-b24d-870913c1c398.png" alt="img"></p>
<ul>
<li><p>Protected Port虽然同处一个VLAN，但Protected Port接口之间彼此无法相互通信；</p>
</li>
<li><p>Protected Port智能与unprotected port（默认）互相通信；</p>
</li>
<li><p>Protected Port特性无法跨交换机实现；</p>
</li>
</ul>
<p>将端口配置为Protected Port的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">switchport protected</span><br></pre></td></tr></table></figure>

<h2 id="Trunk"><a href="#Trunk" class="headerlink" title="Trunk"></a>Trunk</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><img src="/2022/01/20/19-Switch/1617353951725-fb4f4915-c22d-43ff-9694-ae6059e218aa.png" alt="img"></p>
<ul>
<li><p>当一条链路，需要承载多VLAN信息时候，需使用trunk来实现；</p>
</li>
<li><p>Trunk两端的交换机需采用相同的干道协议；</p>
</li>
<li><p>一般见于交换机之间或交换机与路由器、服务器之间；</p>
</li>
</ul>
<h3 id="封装协议"><a href="#封装协议" class="headerlink" title="封装协议"></a>封装协议</h3><p><img src="/2022/01/20/19-Switch/1617354034253-82bb9ee4-f05a-412a-820b-bb4fd2b48df5.png" alt="img"></p>
<p>ISL是思科私有的VLAN封装协议，只有在全思科网络环境下才可能使用，但已经很少见到了，基本是DOT1Q（802.1Q）一统江湖，所以接下来不会涉及到ISL的知识。</p>
<p>对于那些大于1500字节但小于2000字节的帧，Dot1Q的MTU为1522。</p>
<p>DOT1Q的VLAN范围是1-4094个VLAN。</p>
<p><strong>链路聚集模式：</strong></p>
<ul>
<li><p>Trunk：永久链路聚集模式，强制trunk，发送DTP帧；</p>
</li>
<li><p>Nonegotiate：永久链路聚集模式，必须手动将邻居配为干道，不发送DTP帧，一般用于对端设备不支持DTP的情况；</p>
</li>
<li><p>Desirable：主动尝试将链路设置成干道（Trunk，默认为该模式），发送DTP帧，如果邻接接口为Trunk\Desirable\AUTO，那么此接口成为Trunk；</p>
</li>
<li><p>Auto：接口愿意成为Trunk，如果临街接口设置为Trunk或Desirable，那么接口就成为Trunk；</p>
</li>
<li><p>Access：永久的Nontrunking模式，并且与对端接口协商，使其成为nontrunking链路；</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617434654840-c21a78c0-83ce-4dce-ae98-37a1f3f4bbb4.png" alt="img"></p>
<h3 id="Dot1Q"><a href="#Dot1Q" class="headerlink" title="Dot1Q"></a>Dot1Q</h3><h4 id="帧格式"><a href="#帧格式" class="headerlink" title="帧格式"></a>帧格式</h4><p><img src="/2022/01/20/19-Switch/1617434706610-29308387-141d-4cc8-bf25-92e16aec01b0.png" alt="img"></p>
<p>802.1Q（Dot1Q）为共有协议，默认情况下，在802.1Q Trunk上，对所有的VLAN打Tag，除了Native VLAN，交换机根据以太网帧头信息来转发数据包。</p>
<p>802.1Q Tag包含四个字段，含义如下：</p>
<ul>
<li><p>EtherType：长度为2字节，表示帧类型，当取值为0X8100时表示802.1Q Tag帧，如果不支持802.1Q的设备收到EtherType为0X8100的帧，会将其丢掉；</p>
</li>
<li><p>PRI：Priority，长度为3比特，表示帧的优先级，取值范围为0-7，值越大优先级越高，用于当交换机阻塞时，优先发送优先级高的数据包；</p>
</li>
<li><p>CFI：Canonical Format Indicator，长度为1比特，表示MAC地址是否为经典格式，CFI为0时说明是经典格式，CFI为1时表示为非经典格式，用于区分以太网帧、FDDI（Fiber Distributed Digital Interface）帧和令牌环网帧。</p>
</li>
<li><p>VID，VLAN ID，长度为12比特，表示该帧所属的VLAN，在VRP中，可配置的VLAN ID取值范围为1-4096。</p>
</li>
</ul>
<h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>缺点是破坏了原始以太网帧的格式而且要重新计算FCS。802.1Q支持4096个VLAN，最大帧长度为1518+4=1522。</p>
<h4 id="Native-Vlan"><a href="#Native-Vlan" class="headerlink" title="Native Vlan"></a>Native Vlan</h4><p>在802.1Q的Native vlan是不打标签的，使用Dot1Q的交换机把所有未标记的Frame转发到Native vlan中。</p>
<ul>
<li><p>Native VLAN所属的帧在经过Trunk时不打标签；</p>
</li>
<li><p>Native VLAN在Trunk两端必须匹配，否则会出现VLAN流量互串；</p>
</li>
<li><p>默认的Native vlan是vlan 1；</p>
</li>
<li><p>为了安全起见，建议将一个生僻的非vlan1的vlan定位Native vlan；</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617436832422-f659aab0-fec4-4d79-9c5d-1b39c7691088.png" alt="img"></p>
<p>上面拓扑中，两台交换机Trunk 两端Native vlan不一样，会有什么问题？首先两端的vlan2通信肯定是没问题的：VLAN2的PC发出的数据，到达左边交换机以后会打上VLAN2的Tag，然后经过中间802.1Q的Trunk链路时，不会对数据进行改变，到达右边交换机时，由于数据有Tag，Trunk端口会判断该端口是否允许属于该VLAN的数据进入，答案是允许进入，因为右侧也有vlan2，然后交换机会根据数据帧的VLAN ID，属于vlan2，从属于VLAN2的端口发出，由于右边属于VLAN2的端口连接的是PC，因此该端口应该是Access端口，带有VLAN2  tag的数据从access口发出时，交换机会先剥离掉VLAN2的Tag，然后发送给PC，两端完成通信。</p>
<p>但两端属于VLAN3和VLAN4的PC通信就有问题了，先看VLAN3：从VLAN3的PC发出的数据帧到达左边交换机后，由于是Access接口，所以会打上VLAN3的Tag，然后从Trunk接口发出的时候，由于Native vlan是vlan3，Native vlan在通过trunk接口时不打标签，因此从trunk发出数据帧时，不带标签。这个不带标签的数据帧到达右侧交换机后，由于右侧交换机的Native vlan是vlan 4，交换机会认为该数据是属于vlan4的，通信就出现问题了。属于vlan4的PC通信也是类似情况。</p>
<p><strong>Native vlan相关命令：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">在Trunk接口上设置native vlan:</span><br><span class="line">Switch(config-if)#switchport trunk native vlan X</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">对Native vlan也打标签</span><br><span class="line">Switch(config)#vlan dot1q tag native</span><br></pre></td></tr></table></figure>

<h4 id="vlan范围"><a href="#vlan范围" class="headerlink" title="vlan范围"></a>vlan范围</h4><table>
<thead>
<tr>
<th>vlan范围</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>0,4095</td>
<td>保留，系统使用</td>
</tr>
<tr>
<td>1</td>
<td>cisco默认vlan</td>
</tr>
<tr>
<td>2-1001</td>
<td>for Ethernet Vlans给vlan使用</td>
</tr>
<tr>
<td>1002-1005</td>
<td>Cisco默认为FDDI及Tokenring定义</td>
</tr>
<tr>
<td>1006-4094</td>
<td>只能为Ethernet使用，在一些特殊平台被保留使用</td>
</tr>
</tbody></table>
<h3 id="DTP"><a href="#DTP" class="headerlink" title="DTP"></a>DTP</h3><p>DTP全称为Dynamic Trunking Protocol，翻译成中文就是动态中继协议，是思科私有协议，用于协商两个支持VLAN的交换机之间链路上对的中继，以及用于协商要使用的中继封装的类型。Trunk可以通过手工静态配置或通过DTP协商而来，在实际配置Trunk链路时，为了避免出现问题，还是尽量直接手工配置（比如使用switchport mode trunk或switchport mode access），避免用DTP协商。</p>
<p>DTP协议通过DTP Message尝试帮助端口沟通并建立Trunk 链路，DTP有两个模式，分别是Desirable和Auto，简单来说Desirable就是主动模式，Auto就是被动模式，具体如下：</p>
<p><img src="/2022/01/20/19-Switch/1617448276650-68c83a46-9c4c-45b0-96dc-e11afaf03a6d.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617448288290-4e10c47b-08fb-4e17-b2a5-f4b559b98470.png" alt="img"></p>
<h3 id="Trunk配置命令"><a href="#Trunk配置命令" class="headerlink" title="Trunk配置命令"></a>Trunk配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将接口设置为Access模式:</span><br><span class="line">Switch(config-if)#switchport mode access</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">如果接口设置为Trunk，设置Trunk协议类型：</span><br><span class="line">Switch(config-if)#switchport mode encapsulate &#123;dot1q | ISL&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将接口设置为DTP动态协商，可选择auto或desirable两种类型：</span><br><span class="line">Switch(config-if)#switchport mode dynamic &#123;auto | desirable&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将接口设置为nonegotiate，不发送DTP帧，如果配置为非协商，就必须手工配置接口模式，为access或trunk：</span><br><span class="line">Switch(config-if)#switchport nonegotiate</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/19-Switch/1617449025393-17798873-bbc7-4603-aef9-bb9b3f680269.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW1(config)# interface fast0/23 </span><br><span class="line">SW1(config-if)#switchport trunk encapsulate dot1q</span><br><span class="line">SW1(config-if)#switchport mode trunk</span><br><span class="line">SW1(config-if)#switchport native vlan 1</span><br><span class="line">SW1(config-if)#switchport nonegotiate</span><br><span class="line">SW1(config-if)#switchport trunk allowed vlan X</span><br></pre></td></tr></table></figure>

<h3 id="VTP"><a href="#VTP" class="headerlink" title="VTP"></a>VTP</h3><p>VTP的全称是Virtual Trunking Protocol，也是思科的私有协议，主要用于VLAN管理。在有VTP的情况下，在某一台交换机上配置完VLAN后，该所有的VLAN信息能够自动同步到其他所有交换机上，省去了很多配置。VTP共有三个版本，version1、2、3，其中version1和2在设计上有些缺陷，可能会让交换机的vlan出现灾难性的问题，比如可能所有交换机上的VLAN信息都被清除掉，所以尽量谨慎使用VTP协议。</p>
<p><img src="/2022/01/20/19-Switch/1617454409203-dc429e39-5c9e-4661-8767-8650a9017d72.png" alt="img"></p>
<h4 id="VTP类型"><a href="#VTP类型" class="headerlink" title="VTP类型"></a>VTP类型</h4><p><img src="/2022/01/20/19-Switch/1617454537830-da3c64fc-8985-46cc-b2c7-d7891fe9ce2c.png" alt="img"></p>
<h4 id="VTP的运作"><a href="#VTP的运作" class="headerlink" title="VTP的运作"></a>VTP的运作</h4><ul>
<li><p>VTP协议通过组播地址0100-0CCC-CCCC在Trunk链路上发送VTP公告；</p>
</li>
<li><p>VTP Server和Client以修订号作为同步的基础，会将修订号最高的信息同步到自身设备上；</p>
</li>
<li><p>VTP协议每隔5分钟发送一次VTP通告或在有变化发生时通告；</p>
</li>
</ul>
<h4 id="VTP配置"><a href="#VTP配置" class="headerlink" title="VTP配置"></a>VTP配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置VTP域名</span><br><span class="line">Switch(config)#vtp domain XXX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置本设备VTP模式</span><br><span class="line">Switch(config)#vtp mode &#123;server |client |transparent&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可以配置密码</span><br><span class="line">Switch(config)#vtp password XXX</span><br></pre></td></tr></table></figure>

<h4 id="VTP的问题"><a href="#VTP的问题" class="headerlink" title="VTP的问题"></a>VTP的问题</h4><p><img src="/2022/01/20/19-Switch/1617454928718-20214183-29b8-4004-b59f-1634204efb73.png" alt="img"></p>
<p>两台交换机，如果VTP Client的配置修订号（Revision11）比Server的高，那么Client也是能够将Server的vlan信息覆盖的，这种情况下可能会出现问题，比如一台新接入网络的交换机，之前的vlan信息没有清除，配置修订号比现网使用的其他交换机的配置修订号高，此时它就会将现网中原本配置好的vlan信息冲掉，造成灾难性的后果。</p>
<p><img src="/2022/01/20/19-Switch/1617455099519-68cb4a91-4360-4be0-aef0-d86d254dccc0.png" alt="img"></p>
<p>上图中Server及Client的配置修订号相同，但vlan信息则不同，这时会报错，提示md5 digest checksum mismatch。</p>
<h4 id="VTP-Pruning"><a href="#VTP-Pruning" class="headerlink" title="VTP Pruning"></a>VTP Pruning</h4><p>VTP Pruning中文翻译成VTP修剪，VTP协议能确保处于VTP域中的所有交换机都能拥有所有的VLAN信息，但有些时候，VTP会制造一些不必要的流量，那些无用流量会充斥着整个网络：</p>
<p><img src="/2022/01/20/19-Switch/1617456279305-7e7d0aa9-e726-4de6-873c-e1892cb1a0d9.jpeg" alt="img"></p>
<p>比如上图的拓扑中，Switch1中只有VLAN1和VLAN2，经过修剪后，VLAN3的流量就不会在Switch1上出现，被修剪了，减少了不必要的流量。</p>
<p>VTP的配置非常简单，只需在VTP Server中输入‘vtp pruning’即可自动搞定，整个VTP domain中的交换机都会自动激活该功能。</p>
<h3 id="MTU"><a href="#MTU" class="headerlink" title="MTU"></a>MTU</h3><p>MTU全称是Maximum Transmission Unit，中文翻译为最大传输单元，在思科IOS上，interface X接口模式下：</p>
<ul>
<li>MTU ？：指的是二层的MTU，是接口MTU，指的是不含二层帧头的、Payload的MTU，整个MTU一般是不能手工修改的，这个相当于Juniper的Default IP MTU，Default IP MTU（1500字节）=TCP Header（20字节）+IP Header（20字节）+TCP Segment Length（1460字节）。这样一来，思科路由器支持的二层数据帧最大值就是1500的Payload加上二层帧头及二层FCS：目的MAC地址（6字节）+源MAC地址（6字节）+类型字段（2字节）+FCS（4字节），所以总数是1518字节。相当于Juniper的Default Media MTU[1518字节，1500 （Default IP MTU） + 14（encapsulation overhead，6字节的目的MAC＋6字节的源MAC＋2字节的帧类型）]但不包含FCS部分（4字节）。</li>
<li>IP MTU？：指的是三层的MTU，这个值可以手工修改，但最大值必须小于接口的二层MTU值，也就是要小于1500，这个MTU指的是三层IP包的总大小，如果接口发出的包大于这个接口的IP MTU则这个IP包将被分片。</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617457562934-c181c8b1-c84c-4562-9cae-f3eacb43ba8c.png" alt="img"></p>
<p>比如上图中，R1的F0/0接口的IP MTU为1500，现在去ping 1.1.1.2 repeat 1 size 1500，会发现R1直接将一个ICMP包发出去了，没有分片，报文如下：</p>
<p><img src="/2022/01/20/19-Switch/1617457634610-f9494c9a-9035-49e5-9319-839a0bf9eacd.png" alt="img"></p>
<p>从报文中可以看到，IP包的大小为1500字节。其中IP报头20字节，ICMP报头8字节，ICMP Data 载荷1472字节，刚好1500字节，因此在思科IOS设备上，ping 后面跟着的size指的就是发出去的IP包整个大小。如果在R1上ping 1.1.1.2 repeat 1 size 1501，则由于这个IP包大于MTU1500，会被分片，然后在R2上这两个分片被重组。</p>
<h2 id="私有VLAN"><a href="#私有VLAN" class="headerlink" title="私有VLAN"></a>私有VLAN</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li><p>私有VLAN全称是Private VLAN，中文是私有VLAN；</p>
</li>
<li><p>将一个VLAN划分成几个单独的VLAN，这些VLAN都是用同一个IP网段；</p>
</li>
<li><p>可以提高安全性，降低子网数量，提高IP利用率；</p>
</li>
<li><p>尽管网络设备处于同一个子网中，但它们属于不同的Pvlan，Pvlan之间的通信还是必须通过默认网关来实现；</p>
</li>
<li><p>每个Pvlan包括一个主VLAN以及多个辅助VLAN。所有的辅助VLAN都映射到主VLAN；</p>
</li>
<li><p>辅助VLAN分为团体VLAN和隔离VLAN；</p>
</li>
<li><p>相同的团体VLAN能够相互通信，但是团体VLAN之间必须通过设置SVI或者路由器接口才能通信，也就是要通过三层才能通信；</p>
</li>
<li><p>相同的隔离VLAN内部以及隔离VLAN之间都是不能够相互通信的，只能与混杂接口通信；</p>
</li>
<li><p>一个主VLAN只能有一个Isolate VLAN；</p>
</li>
<li><p>混杂端口能够与Pvlan中的任何设备通信，不管对方是处于主VLAN还是辅助VLAN；</p>
</li>
</ul>
<h3 id="PVLAN端口类型"><a href="#PVLAN端口类型" class="headerlink" title="PVLAN端口类型"></a>PVLAN端口类型</h3><ul>
<li><p>Isolated：中文翻译为隔离端口，隔离端口只能与混杂端口通信，不能与其他类型端口通信；</p>
</li>
<li><p>Promiscuous：中文翻译为混杂端口，可以和所有类型的端口通信；</p>
</li>
<li><p>Community：中文翻译为公共端口，与公共vlan相关的任何交换机端口都可以相互通信，并与混杂端口通信；</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617506769185-c658aab9-0458-434c-8378-d40f5876ccf4.jpeg" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617506774009-41ce5e07-5f6d-4324-8718-c9c672c65ef2.png" alt="img"></p>
<h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>Pvlan必须配置在透明模式的交换机上，禁止将第三层的VLAN接口配置为辅助VLAN，VTP并不支持Pvlan，所以必须手动在各个交换机上配置VLAN信息。</p>
<h3 id="Pvlan配置命令"><a href="#Pvlan配置命令" class="headerlink" title="Pvlan配置命令"></a>Pvlan配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建主VLAN</span><br><span class="line">vlan 100</span><br><span class="line">  private-vlan primary</span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">创建辅助VLAN</span><br><span class="line">vlan 101</span><br><span class="line">  private-vlan community</span><br><span class="line">vlan 102</span><br><span class="line">  private-vlan isolate</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置主vlan，将二层辅助vlan关联到主vlan</span><br><span class="line">vlan 100</span><br><span class="line">  private-vlan association 101,102</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">配置接口为主机接口</span><br><span class="line">interface e0/1</span><br><span class="line">  switchport mode private-vlan host</span><br><span class="line">  switchport private-vlan host-association 100 101</span><br><span class="line">  #关联主vlan和辅助vlan到接口</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">配置接口为混杂接口</span><br><span class="line">interface e0/2</span><br><span class="line">  switchport mode private-vlan promiscuous</span><br><span class="line">  switchport private-vlan mapping add 100 101</span><br><span class="line">  #将端口映射到pvlan</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">查看及验证：</span><br><span class="line">show pvlan mapping</span><br></pre></td></tr></table></figure>

<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2022/01/20/19-Switch/1617507772486-1126e9e8-24a9-4ff6-9439-d13cc6e06b46.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sw(config)#vtp transparent</span><br><span class="line">sw(config)#vlan 201</span><br><span class="line">sw(config-vlan)#private-vlan isolated</span><br><span class="line">sw(config)#vlan 202</span><br><span class="line">sw(config-vlan)#private-vlan community</span><br><span class="line">sw(config)#vlan 100</span><br><span class="line">sw(config-vlan)#private-vlan primary</span><br><span class="line">sw(config-vlan)#private-vlan association 201，202</span><br><span class="line">！</span><br><span class="line">sw(config)#interface f0/24</span><br><span class="line">sw(config-if)#switchport mode private-vlan promiscuous</span><br><span class="line">sw(config-if)#switchport private-vlan mapping 100 201,202</span><br><span class="line">sw(config)#interface f0/1-2</span><br><span class="line">sw(config-if)#switchport mode private-vlan host</span><br><span class="line">sw(config-if)#switchport private-vlan host-association 100 202</span><br><span class="line">sw(config)#interface range f0/3-4</span><br><span class="line">sw(config-if)#switchport mode private-vlan host</span><br><span class="line">sw(config-if)#switchport private-vlan host-association 100 201</span><br></pre></td></tr></table></figure>

<h1 id="Spanning-tree"><a href="#Spanning-tree" class="headerlink" title="Spanning-tree"></a>Spanning-tree</h1><h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><p><img src="/2022/01/20/19-Switch/1617508413192-8b039fc0-f6eb-4199-837e-ac1a56809ff3.png" alt="img"></p>
<ul>
<li><p>如果接入层交换机单链路上联，会存在单点故障，如果任意一个汇聚交换设备宕机，将直接导致下联的接入层网络挂掉；</p>
</li>
<li><p>如果接入层交换机采取双链路上联到两台汇聚设备，构成一个物理链路冗余的二层环境，可以解决单链路故障问题，但二层存在环路问题；</p>
</li>
<li><p>生成树可以解决二层环路问题，通过生成树协议，在逻辑上将特定的端口Block，从而实现物理上存在冗余链路，而二层上又组织环路的产生；</p>
</li>
<li><p>当拓扑发生变化的时候，生成树协议能够探测到这些变化，并且及时自动的调整接口状态，从而适应网络拓扑的变化，实现链路冗余；</p>
</li>
</ul>
<h2 id="协议基础"><a href="#协议基础" class="headerlink" title="协议基础"></a>协议基础</h2><h3 id="生成树种类"><a href="#生成树种类" class="headerlink" title="生成树种类"></a>生成树种类</h3><table>
<thead>
<tr>
<th>协议</th>
<th>共有or私有</th>
<th>别称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>STP（PVST）</td>
<td>公有</td>
<td>802.1 D</td>
<td></td>
</tr>
<tr>
<td>PVST+</td>
<td>思科私有协议</td>
<td></td>
<td>包含了Portfast、uplinkfast、Backbonefast特性</td>
</tr>
<tr>
<td>RSTP</td>
<td>公有</td>
<td>802.1 W</td>
<td>集成了PVST的功能并公有化</td>
</tr>
<tr>
<td>MST</td>
<td>公有</td>
<td>802.1 S</td>
<td></td>
</tr>
</tbody></table>
<h3 id="BPDU结构及参数"><a href="#BPDU结构及参数" class="headerlink" title="BPDU结构及参数"></a>BPDU结构及参数</h3><p><img src="/2022/01/20/19-Switch/1617511489661-76968eff-16e7-495f-8d47-2fc8849b0c61.png" alt="img"></p>
<p>BPDU全称为Bridge Protocol Data Units，翻译成中文是网桥协议数据单元，里面包含了有关生成树协议的帧。也就是交换机用来在彼此之间传输STP信息的帧，一个网络中应该只有Root交换机（根交换机）发送BPDU，不过当交换机刚启动时，它会认为自己试根交换机，而发送BPDU，知道它收到一个包含Bridge ID较小的BPDU，才知道自己在Root switch的选举中失利而停止发送BPDU。BPDU默认2秒发送一次，接收到的BPDU会被存储20秒（Max-age），也就是说如果交换机超过20秒没收到BPDU，就会判断Root交换机已经挂掉，会再次认为它自己试Root交换机，再次发送BPDU。</p>
<ul>
<li><p>Root ID：网桥ID，长度8字节，由网桥优先级（2字节）+网桥MAC（6字节）构成，缺省优先级为32768，取值范围从0-65535，前4bit表示优先级，后8bit作为system ID，为协议扩展使用，越小越优，取值是4096的倍数。</p>
</li>
<li><p>Port ID：端口ID，长度2字节，由端口优先级（1字节）+端口ID（1字节）组成，缺省优先级为128，组织范围从0-255，越小越优。思科交换机端口ID中的优先级默认为128（优先级8bit）。</p>
</li>
<li><p>Cost：路径开销，表示从本交换机到达根交换机路径的总开销，越小越优，和端口带宽有关:</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617511816073-3efa545e-2f2c-4a2f-ba6b-b487c949c82f.png" alt="img"></p>
<h2 id="802-1D协议"><a href="#802-1D协议" class="headerlink" title="802.1D协议"></a>802.1D协议</h2><h3 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="端口类型"><a href="#端口类型" class="headerlink" title="端口类型"></a>端口类型</h4><ul>
<li><p>根端口(RP，Root Port）：对象是非根设备，每个非根设备有且仅有一个，除了根以外，离根最近的端口，用来接收来自根交换机的BPDU；</p>
</li>
<li><p>指定端口（DP，Designated Port）：每条链路上有且仅有一个DP。离根最近，也就是cost最小，用来发送BPDU。一般来说根交换机的端口都是DP，因为离根最近且用来发送BPDU。</p>
</li>
<li><p>非制定端口（None Designated Port）：每个环形拓扑有且仅有一个，用来阻塞数据防止环路。</p>
</li>
</ul>
<h4 id="端口状态"><a href="#端口状态" class="headerlink" title="端口状态"></a>端口状态</h4><table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>Disable</td>
<td>无效连接，忽略所有接收到的数据包</td>
</tr>
<tr>
<td>Block</td>
<td>仅接收BPDU数据包</td>
</tr>
<tr>
<td>Listen</td>
<td>接收及传送BPDU数据包</td>
</tr>
<tr>
<td>Learn</td>
<td>接收、发送BPDU数据包，并且学习MAC地址</td>
</tr>
<tr>
<td>Forward</td>
<td>接收、发送BPDU数据包，学习MAC地址，发送数据</td>
</tr>
</tbody></table>
<p><img src="/2022/01/20/19-Switch/1617605112708-7220ec4f-ef38-474d-b38d-6c787258385b.png" alt="img"></p>
<h4 id="选举规则"><a href="#选举规则" class="headerlink" title="选举规则"></a>选举规则</h4><p>简单版：根桥ID、根路径开销、发送者BID、发送接口BID，越小越优先；</p>
<p>具体版：选举根交换机（Root Switch）、选举根端口（Root Port）、选举指定端口（Designated Port），具体参见后文‘STP的运行’部分。</p>
<h3 id="BPDU报文"><a href="#BPDU报文" class="headerlink" title="BPDU报文"></a>BPDU报文</h3><p>BPDU有两种类型，配置BPDU以及TCN BPDU，由于交换机在一开始又叫网桥，所以字段中的Bridge其实指代的就是交换机。在网络收敛后的正常情况下，交换机只会从它的Root Port上收到配置BPDU，但绝对不会主动发送配置BPDU给根交换机。</p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><p><strong>配置BPDU</strong></p>
<p><img src="/2022/01/20/19-Switch/1617527884418-61fdcb8b-9772-47e2-ad9b-61f03a20219a.png" alt="img"></p>
<table>
<thead>
<tr>
<th>字节</th>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td>协议Protocol ID</td>
<td>代表上层协议，BPDU，当协议为802.1D时该值总为0</td>
</tr>
<tr>
<td>1</td>
<td>版本Protocol Version ID</td>
<td>802.1D的该值总为0</td>
</tr>
<tr>
<td>1</td>
<td>BPDU种类BPDU Type</td>
<td>配置BPDU值为0X00，TCN BPDU值为0X80</td>
</tr>
<tr>
<td>1</td>
<td>标志Flags</td>
<td>Flags位有两种可能：Topology change（TC）位，表示在通往根桥的路径被中断了。此时由根交换机TC位置1的配置BPDU，通告下游交换机链路发生了变化，涉及的交换机如何在端口上进行相应的改变；Topology change acknowledge（TCA）位，当该位置1时，表示确认收到了TC位置1的配置BPDU；</td>
</tr>
<tr>
<td>8</td>
<td>根IDRoot ID</td>
<td>根ID字段会列出2字节的优先级以及6字节的MAC地址ID来表示根桥。当交换机刚启动的时候，这个字段和交换机的根桥ID相同，因为一开始生成树协议还未选举完毕，每台交换机都认为自己就是根桥，随着选举的完毕，最低根桥ID将取代本地根桥ID，以识别根交换机。</td>
</tr>
<tr>
<td>4</td>
<td>路径开销Root Path Cost</td>
<td>路径开销，表示从本交换机发送配置信息到根桥的开销，每台交换机的路径开销都不同。</td>
</tr>
<tr>
<td>8</td>
<td>网桥IDBridge ID</td>
<td>网桥ID包含着本设备网桥优先级和MAC地址ID。这个字段可以让根交换机了解BPDU的来源，也可以用来识别从交换机到跟交换机的多条路径。当跟交换机从其他交换机收到多条不同路径开销的BPDU时，它会知道有两条不同的路径并使用开销较低的那条。</td>
</tr>
<tr>
<td>2</td>
<td>端口IDPort ID</td>
<td>端口ID表示发送生成树相关信息的端口号，这个字段允许检测和纠正交换机产生的环路。（优先级+端口号）</td>
</tr>
<tr>
<td>2</td>
<td>消息寿命Message age</td>
<td>从根桥发出BPDU之后的秒数，代表着这个BPDU存活了多长时间，每经过一个网桥都减1，所以它本质上是到达根交换机的跳数。</td>
</tr>
<tr>
<td>2</td>
<td>最大寿命Max age</td>
<td>当一段时间内未收到任何BPDU，生存时间到达MAX Age时，交换机会认为该端口连接的链路发生故障，也可以理解为这个BPDU的最大寿命，默认时间为20秒。</td>
</tr>
<tr>
<td>2</td>
<td>Hello时间Hello Time</td>
<td>根交换机发送BPDU之间的间隔时间，默认为2秒。</td>
</tr>
<tr>
<td>2</td>
<td>转发延迟Forward Delay</td>
<td>在监听和学习状态所停留的时间间隔。默认15秒。</td>
</tr>
</tbody></table>
<p><img src="/2022/01/20/19-Switch/1617535206167-5f496a19-ed98-4a4e-83e5-68039d3075e0.png" alt="img"></p>
<p>如果英文还不错可以到<a href="https://www.ii.pwr.edu.pl/~kano/course/module4/4.1.2.5/4.1.2.5.html">这个网页</a>看一下，老外做了一个BPDU每个字段的解释以及抓包的页面，很详细。</p>
<p><strong>TCN BPDU</strong></p>
<p><img src="/2022/01/20/19-Switch/1617596833582-6d47ab06-f324-4f91-a304-4f0017718984.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617596888375-2fedad6a-7213-4799-b679-a6012919e597.png" alt="img"></p>
<p>Configuration BPDUs -are originated by the Root Bridge and flow outward along the active paths that radiate away from the Root Bridge.</p>
<p>Topology Change Notification BPDUs - flow upstream (toward the Root Bridge) to alert the Root Bridge that the active topology has changed.</p>
<p>Type - Determines which of the two BPDU formats the frame contains (Configuration BPDU or TCN BPDU).</p>
<p>Type of BPDU can be one of the following</p>
<p>0x00 (Binary: 0000 0000) Configuration BPDU</p>
<p>0x80 (Binary: 1000 0000) Topology Change Notification (TCN) BPDU</p>
<p>Robert, A non root switch originates a TCN BPDU in two conditions:</p>
<p>=It transitions a port into the Forwarding state and it has at least one Designated Port.</p>
<p>=It transitions a port from either the Forwarding or Learning states to the Blocking state.</p>
<p>These situations construe a change in the active topology and require notification be sent to the Root Bridge. Assuming that the current bridge is not the Root Bridge, the current bridge begins this notification process by sending TCN BPDU out its Root Port. It continues sending the TCN BPDU every Hello Time interval seconds until the TCN message is acknowledged</p>
<p>Now the second part of the question :</p>
<p>Difference between TC message type and TC flag</p>
<p>Flags- are Used to handle changes in the active topology and is a field of COnfig BPDU</p>
<p>Flags can be :</p>
<p>LSB = Topology Change (TC) flag</p>
<p>MSB = Topology Change Acknowledgment (TCA) flag</p>
<p>In a nutshell, the FLAG is set to Topology Change (TC) by the Root Bridge/Switch to notify the downstream bridges/switches who are involved and need to know regarding the change.</p>
<p><a href="https://community.cisco.com/t5/switching/bpdu-message-types-and-flags/td-p/1004067">https://community.cisco.com/t5/switching/bpdu-message-types-and-flags/td-p/1004067</a></p>
<p>The designated bridge acknowledges the TCN by immediately sending back a normal  configuration BPDU with the topology change acknowledgement (TCA) bit set</p>
<p><a href="https://community.cisco.com/t5/switching/tcn-acknowlegement-in-stp/td-p/2390425">https://community.cisco.com/t5/switching/tcn-acknowlegement-in-stp/td-p/2390425</a></p>
<h4 id="配置BPDU"><a href="#配置BPDU" class="headerlink" title="配置BPDU"></a>配置BPDU</h4><p>配置BPDU用来在交换机之间交换配置信息，用于生成树协议的计算，比如选举根交换机、DP或RP接口等，每隔两秒发送一次（Hellotime字段），以组播形式发送到01:80:C2:00:00:00这个地址，在DP上发送。</p>
<p>在网络刚开始运行，生成树进行初始化的时候，所有的交换机都会从所有的端口上发送配置BPDU，所有的交换机都会认为自己是根交换机，随着配置BPDU的泛洪和收集，根据BPDU中所包含的信息，所有交换机PK出来个结果，Root交换机被选出来了。在此之后Root以默认的2秒为周期发送BPDU，所有的非Root交换机从自己的根端口收到BPDU，再从自己的指定端口产生BPDU发出，有点像我们从Root倒一盆水下来，水顺着这颗无环的树，从上往下不断的流，另外被Block的非制定端口会源源不断的收到连路上的BPDU并一直监听，当其在一定时间内没有再收到BPDU，则认为链路出现了故障，开始进入了新的收敛阶段。</p>
<p>“When a switch receives a configuration BPDU that contains superior information (lower bridge ID, lower path cost, and so forth), it stores the information for that port. If this BPDU is received on the root port of the switch, the switch also forwards it with an updated message to all attached LANs for which it is the designated switch. </p>
<p>If a switch receives a configuration BPDU that contains inferior information to that currently stored for that port, it discards the BPDU. If the switch is a designated switch for the LAN from which the inferior BPDU was received, it sends that LAN a BPDU containing the up-to-date information stored for that port. In this way, inferior information is discarded, and superior information is propagated on the network.” </p>
<p>当交换机收到一个包含着更优信息（更低的根桥ID，更少的路径开销或者其他）的配置BPDU后，交换机会储存该端口的信息，如果这个BPDU是从根端口上收到的，交换机还会将那个更优的BPDU信息，由DP端口（Designated port指定端口）通过update信息发送给其他连接的交换机。</p>
<p>如果交换机收到的配置BPDU比它自身存储的BPDU更差，它会丢弃收到的BPDU。如果交换机收到更差的BPDU的接口为DP，那么它还会通过该DP端口将更优的BPDU发送出去，这样一来较差的BPDU信息被丢弃而更优的BPDU会在网络上传播开。</p>
<h4 id="TCN-BPDU"><a href="#TCN-BPDU" class="headerlink" title="TCN BPDU"></a>TCN BPDU</h4><p>TCN BPDU在网络拓扑变化时产生。Type字段为0X80。</p>
<p>当网络拓扑发生变化的时候，最先意识到变化的交换机会从根端口发送TCN（Type字段为0X80）到上一层交换机（朝向根交换机的方向），然后一直到根交换机，用来警告根交换机，拓扑发生了变化。</p>
<p>一台非根桥交换机会在两种情况下发送TCN BPDU：</p>
<ul>
<li>当这台交换机的一个接口进入转发状态，而且它至少有一个DP口时；</li>
<li>当这台交换机的一个接口从转发或学习状态进入封闭状态；</li>
</ul>
<p>以上这两种情况说明拓扑发生了变更，并且需要让根桥知道。</p>
<h3 id="STP的运行"><a href="#STP的运行" class="headerlink" title="STP的运行"></a>STP的运行</h3><h4 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h4><p>STP采用四步来解决二层环路问题：</p>
<ol>
<li><p>在一个交换网络中选举出一个Root Bridge，也就是选举出一个根交换机；</p>
</li>
<li><p>在每个非交换机上，选举出一个根端口（RP，Root Port）；</p>
</li>
<li><p>为每个网段选举一个指定端口（DP，Designated Port）；</p>
</li>
<li><p>阻塞非指定端口；</p>
</li>
</ol>
<h4 id="比较原则"><a href="#比较原则" class="headerlink" title="比较原则"></a>比较原则</h4><p>STP需要网络设备互相交换信息来检测桥接环路，该消息就是之前说过的BPDU，网桥协议数据单元，阻塞端口也会不断收到BPDU，以保证故障发生的时候，仍然可以计算出一颗新的STP生成树。要理解STP工作的过程，非常重要的一点是要理解BPDU中各字段的含义，因为这些都是STP赖以工作的根本。</p>
<p>生成树构造一个无环路拓扑时，总是使用相同的四步来判定：</p>
<ul>
<li><p>最低根桥ID，交换机根桥ID由优先级+MAC地址构成，先比较优先级后比较MAC地址；</p>
</li>
<li><p>到根桥的最低路径成本；</p>
</li>
<li><p>最低的发送者网桥ID；</p>
</li>
<li><p>最低的发送者端口ID；</p>
</li>
</ul>
<p>交换机使用这四步来保存各个端口收到最佳的BPDU的一个副本，每个BPDU到达时，都会按照这四步来进行检查，看收到的BPDU和端口保存的BPDU哪个更优，如果收到的BPDU更优，则会更新端口保存的BPDU。</p>
<p>当一个交换机开始工作后，它的每个端口都是每2秒发送一个BPDU（BPDU中的Hello time字段），当一个端口收到一个比现在发送的更优的BPDU时，本地端口会停止发送，如果在一段时间内（默认为20秒，Forward Delay字段）后它不再收到来自邻居的更优的BPDU，则它将会再次发送自己的BPDU。因此对于802.1D来说，根桥会不停的向所有接口发送BPDU，而非根桥会从自己的根端口收到BPDU，并且从自己的指定端口发送该BPDU，非指定端口是不会发送BPDU的，只会监听。</p>
<h4 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h4><ul>
<li><p>根桥的角色是可抢占的；</p>
</li>
<li><p>桥ID中的MAC，是交换机的背板MAC，端口ID中的MAC是交换机的端口MAC，查看交换机上的所有Mac，可以用命令‘show interface | include bia’；</p>
</li>
<li><p>二层交换机的端口MAC就是在这里使用的；</p>
</li>
</ul>
<h4 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h4><p><strong>案例1</strong></p>
<p><img src="/2022/01/20/19-Switch/1617612485588-ec12db09-6665-43b0-a0d1-f352b0c25cff.png" alt="img"></p>
<ul>
<li><p>选举Root根桥：先比较优先级，优先级都是32768相同，所以比较MAC地址，从左往右一位一位的比较MAC地址，最小的0C00.1111.0000胜出，所以SW1为根桥；</p>
</li>
<li><p>选举RP根端口：所有的非根交换机上都要选择出一个根端口，根端口就是离根桥最近的开销最小的端口，用于接收BPDU信息，由于SW1是根端口，所以SW2、SW3和SW1相连的端口是RP；百兆链路的开销为19，SW2和SW1相连的端口开销为19，SW2和SW3相连的接口开销为19+19=38，所以SW2上联SW1的接口为根端口；</p>
</li>
<li><p>选举DP指定端口：每一个网段上都有一个DP，指定端口就是cost最小，用来发送BPDU的端口，一般来说根桥的端口都是根端口，因为根桥的BPDU最优，需要往外发送自身的BPDU，所以SW1上的两个端口为DP；SW2和SW3之间的链路上，谁是DP呢？最低根桥ID相同，因为根桥ID都是SW1的BPDU，相同，这时这两个端口到达根交换机的开销相同，所以比较发送BPDU交换机的ID，也就是比较优先级-MAC地址，优先级相同，MAC地址小的SW2胜出，所以SW2上和SW3相连的接口为DP。</p>
</li>
<li><p>选举非指定端口：SW3上和SW2相连的接口既不是DP也不是RP，所以是非指定端口，被Block掉；</p>
</li>
</ul>
<p>结果为：</p>
<p><img src="/2022/01/20/19-Switch/1617613891954-c63eda6b-fdc2-455d-a58d-eb7df4b947e3.png" alt="img"></p>
<p><strong>案例2</strong></p>
<p><img src="/2022/01/20/19-Switch/1617691752385-47693e95-10d1-4b45-b123-99a1e2d068f1.png" alt="img"></p>
<ul>
<li><p>选举Root根桥：先比较优先级，优先级都是32768相同，所以比较MAC地址，从左往右一位一位的比较MAC地址，最小的0C00.1111.0000胜出，所以SW1为根桥；</p>
</li>
<li><p>选举RP根端口：所有的非根交换机上都要选择出一个根端口，根端口就是离根桥最近的开销最小的端口，用于接收BPDU信息，首先看开销，100兆链路的开销为19，10兆的开销为100，所以SW2与SW1连接的接口开销为19，而SW2和SW3连接接口的开销为19+100=119，因此SW2和SW1连接的接口为RP，因为开销最小；SW3上的RP接口为SW2和SW3连接的接口，开销为19+19=38，小于SW3和SW1接口开销的100。</p>
</li>
<li><p>选举DP指定端口：每一个网段上都有一个DP，指定端口就是cost最小，用来发送BPDU的端口，一般来说根桥的端口都是根端口，因为根桥的BPDU最优，需要往外发送自身的BPDU，所以SW1上的两个端口为DP；SW2和SW3之间的链路，左边SW2的接口为DP，因为每条链路上都要有一个DP。</p>
</li>
<li><p>选举非指定端口：SW3上和SW1相连的接口既不是DP也不是RP，所以是非指定端口，被Block掉；</p>
</li>
</ul>
<p>结果为：</p>
<p><img src="/2022/01/20/19-Switch/1617692184670-c591a953-7116-4e23-adfa-4ab286427f5e.png" alt="img"></p>
<p><strong>案例3</strong></p>
<p><img src="/2022/01/20/19-Switch/1617693370658-95168a3b-9090-47da-b2af-eedb825ef543.png" alt="img"></p>
<ul>
<li><p>选举Root根桥：先比较优先级，优先级都是32768相同，所以比较MAC地址，从左往右一位一位的比较MAC地址，最小的0C00.1111.0000胜出，所以SW1为根桥；</p>
</li>
<li><p>选举RP根端口：所有的非根交换机上都要选择出一个根端口，根端口就是离根桥最近的开销最小的端口，用于接收BPDU信息，首先看开销，假设每条链路都是100兆开销为19，10兆的开销为100，SW2和SW1连接的端口，SW3和SW1连接的端口均为RP，因为上面的端口相比下面的端口来说离根桥最近；接下来看SW4上哪个端口是RP，SW4上两个端口的开销都是19+19=38，相同，所以比较下一个属性，发送者网桥ID，发送者网桥ID由优先级+MAC地址构成，优先级相同而SW2的MAC地址更小，所以SW4左边接口的发送者网桥ID更优，因此SW4左边的接口为RP。</p>
</li>
<li><p>选举DP指定端口：每一个网段上都有一个DP，指定端口就是cost最小，用来发送BPDU的端口，一般来说根桥的端口都是根端口，因为根桥的BPDU最优，需要往外发送自身的BPDU，所以SW1上的两个端口为DP；SW2下连SW4的接口为DP，因为每条链路上都有一个DP；SW3和SW4之间的链路谁是DP呢？首先看开销，SW4接口开销为19+19=38，而SW3和SW4相连的接口开销为19，所以SW3上的接口为DP。</p>
</li>
<li><p>选举非指定端口：SW4上和SW3相连的接口既不是DP也不是RP，所以是非指定端口，被Block掉；</p>
</li>
</ul>
<p>结果为：</p>
<p><img src="/2022/01/20/19-Switch/1617693942166-74fd5303-af4c-43b5-a569-876ec49b7198.png" alt="img"></p>
<p><strong>案例4</strong></p>
<p><img src="/2022/01/20/19-Switch/1617694323746-a9bf9f0c-e295-44d8-8bf0-d138f1c8ff91.png" alt="img"></p>
<ul>
<li><p>选举RP根端口：所有的非根交换机上都要选择出一个根端口，根端口就是离根桥最近的开销最小的端口，用于接收BPDU信息，首先看开销，由于两条链路到根桥的开销相同，所以比较下一项，发送者网桥ID，但由于发送者网桥ID也都是SW1的网桥ID，依旧相同，所以比较下一项，发送端口ID（由端口优先级+端口ID构成），假设两个接口优先级相同，接下来就要比较端口ID了，最终F0/1的端口ID更小，因此SW2的F0/1接口为RP。</p>
</li>
<li><p>选举DP指定端口：每一个网段上都有一个DP，指定端口就是cost最小，用来发送BPDU的端口，一般来说根桥的端口都是根端口，因为根桥的BPDU最优，需要往外发送自身的BPDU，所以SW1上的两个端口为DP。</p>
</li>
<li><p>选举非指定端口：SW2的F0/2既不是DP也不是RP，所以是非指定端口，被Block掉；</p>
</li>
</ul>
<p>注意，此时如果试图在SW2上将F0/2的接口优先级调小并没有用，因为看的是发送者的端口ID，也就是SW1的两个端口的ID，只有在SW1上将F0/2的端口优先级调小，SW2上的F0/2才会胜出称为根端口。</p>
<p>结果为：</p>
<p><img src="/2022/01/20/19-Switch/1617694512268-f4f5276f-1d79-4eff-a367-2556cd9db03f.png" alt="img"></p>
<h3 id="STP端口状态"><a href="#STP端口状态" class="headerlink" title="STP端口状态"></a>STP端口状态</h3><p>由于网络设备存在固有的滞后，所以交换网络中也就存在传播延迟，基于上述原因，拓扑变更可能发生在网络中的不同时间和不同网段。如果二层接口直接从生成树的Block状态切换到转发状态，就可能会出现暂时的数据环路。为了缓解这种问题，在开始转发数据帧之前，端口应当等待新的拓扑信息传播到整个交换网络中。</p>
<h4 id="接口状态"><a href="#接口状态" class="headerlink" title="接口状态"></a>接口状态</h4><p><img src="/2022/01/20/19-Switch/1617697371239-ec236f20-90ff-46b0-a22a-7a2c188860d7.png" alt="img"></p>
<h4 id="端口计时器"><a href="#端口计时器" class="headerlink" title="端口计时器"></a>端口计时器</h4><ul>
<li><p>Hello时间：根桥发送配置BPDU的时间间隔，默认为2秒；</p>
</li>
<li><p>转发延迟时间：从侦听到学习状态或学习状态到转发状态所需要的时间，默认为15秒；</p>
</li>
<li><p>最大存活期：在丢弃BPDU之前，网桥用来存储BPDU的时间，缺省为20秒，也就是连续收不到10个BPDU，开始进入Listening状态；</p>
</li>
</ul>
<p>网络中生成树拓扑依附于根桥的计时器，根交换机将BPDU中的计时器传递给二层所有的其他交换机。</p>
<p>从阻塞到转发状态通常要转发状态通常要30-50秒，默认50秒，即20+15+15，也就是20秒的最大存活期内收不到BPDU，认为链路发生了问题，然后端口进入侦听状态，侦听状态15秒到学习状态，再一个15秒由学习状态到转发状态。</p>
<h4 id="端口切换过程"><a href="#端口切换过程" class="headerlink" title="端口切换过程"></a>端口切换过程</h4><p><img src="/2022/01/20/19-Switch/1617697704180-dcca6979-4032-462b-a482-c5c955fa1be6.png" alt="img"></p>
<h3 id="STP拓扑变更"><a href="#STP拓扑变更" class="headerlink" title="STP拓扑变更"></a>STP拓扑变更</h3><h4 id="TCN-BPDU概述"><a href="#TCN-BPDU概述" class="headerlink" title="TCN BPDU概述"></a>TCN BPDU概述</h4><p>当网络拓扑出现变更的时候，最先意识到变化的交换机将发送TCN BPDU。</p>
<p>在发生在以下时机时，交换机发送TCN BPDU：</p>
<ul>
<li><p>对于处于转发和监听状态的接口，过渡到Block状态，也就是链路发生故障的情况；</p>
</li>
<li><p>端口进入转发状态，并且网桥已经拥有指定端口；</p>
</li>
<li><p>非根桥交换机在它的指定端口（DP）收到TCN；</p>
</li>
</ul>
<h4 id="TCN-BPDU-1"><a href="#TCN-BPDU-1" class="headerlink" title="TCN BPDU"></a>TCN BPDU</h4><p>TCN BPDU包含3个字段，它与配置BPDU除了Type字段之外的前三个字段完全相同。</p>
<h4 id="拓扑变更过程"><a href="#拓扑变更过程" class="headerlink" title="拓扑变更过程"></a>拓扑变更过程</h4><p>最先意识到拓扑变更的交换机发送TCN BPDU，发送的方向是根桥方向，指定网桥收到TCN并且立刻回送一个TCA被置位的正常BPDU来确认收到了表示拓扑变化的TCN BPDU。在该网桥确认这个TCN之前，负责通知拓扑变更的网桥将持续发送TCN BPDU。</p>
<p>接下来该指定网桥将为自己的根端口产生另外的TCN，从RP发出给上游更靠近根交换机的其他交换机，并且这个过程一路持续发到根交换机为止。</p>
<p>一旦根桥意识到网络中发生拓扑变更的情况，它将发送TC被置位的BPDU，网络中每台交换机都将传递这些被置位的BPDU，进而便于每个单独的网桥都意识到拓扑变更的情况。</p>
<h4 id="拓扑变更示例"><a href="#拓扑变更示例" class="headerlink" title="拓扑变更示例"></a>拓扑变更示例</h4><p><img src="/2022/01/20/19-Switch/1617698857935-198699fb-7d75-4249-8878-4bc29cb7c894.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617698872474-e3ba745d-38a0-4a4c-99d4-936a03a79866.png" alt="img"></p>
<ul>
<li><p>Switch A挂掉；</p>
</li>
<li><p>Switch B最先检测到拓扑变化，因为A挂掉后，SwitchB会无法接受到对方的BPDU，过20秒（Max Age）后就会知道对方挂了，于是产生TCN BPDU从根端口发送出去（因为根端口是朝向着根桥的方向），B连续发送TCN BPDU直到指定交换机C发送TCN ACK进行确认，这个TCN ACK就是一个TCA被置位的正常配置BPDU；</p>
</li>
<li><p>Switch C收到这个TCN BPDU后，回送一个TCN ACK（TCA被置位为1的正常的配置BPDU）给B表示收到了TCN BPDU，同时向自己的根端口转发这个TCN BPDU；</p>
</li>
<li><p>根桥交换机收到这个TCN BPDU，同时回送一个TCN ACK（TCA被置位为1的正常的配置BPDU）给C；</p>
</li>
<li><p>根桥交换机（Root）修改自己的配置BPDU，用修改后的BPDU来通告整个交换网络关于拓扑变更的情况。Root会在配置BPDU中设置一段时间（转发延迟+Max Age，默认时间为15+20，也就是35秒）的拓扑变更（Flags字段中的TC位置1），以此通告下游交换机，链路发生了变化，</p>
</li>
<li><p>当下游交换机收到Root发出的这个TC置位的配置BPDU后，它们使用转发延迟计时器（默认15秒）来更新其MAC地址表中的条目，也就是说MAC地址条目的默认寿命由原来的300秒变为15秒，这样能保证MAC地址条目更快速的刷新。交换机将持续这个过程，直到不再从Root收到TC BPDU消息为止。</p>
</li>
</ul>
<p>我们会发现，当拓扑变更的时候就会产生TCN BPDU，而有些情况下，TCN的过渡泛洪可能会对网络造成不必要的影响，通过在接入层交换机上，将连接PC终端设备的接口设置为Portfast可以在一定程度上优化网络，防止由于PC开关机导致的接入层交换机端口UP\DOWN而产生过多的TCN。</p>
<h4 id="STP命令"><a href="#STP命令" class="headerlink" title="STP命令"></a>STP命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW#show spanning-tree</span><br><span class="line"></span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol ieee</span><br><span class="line">  Root ID    Priority    24577</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    24577  (priority 24576 sys-id-ext 1)</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time 300</span><br><span class="line">             </span><br><span class="line">             </span><br><span class="line">上面显示的Spanning tree enabled protocol ieee表示运行的820.1D</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置vlan的优先级</span><br><span class="line">switch(config)#spanning-tree vlan Y priority XX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置接口cost值</span><br><span class="line">Switch(config-if)#spanning-tree vlan Y cost XX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置接口优先级，默认128</span><br><span class="line">Switch(config-if)#spanning-tree vlan Y port-priority XX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">设置vlan的时间参数</span><br><span class="line">Switch(config)# spanning-tree vlan Y hello-time XX</span><br><span class="line">Switch(config)# spanning-tree vlan Y forward-time XX</span><br><span class="line">Switch(config)# spanning-tree vlan Y max-age XX</span><br></pre></td></tr></table></figure>

<h3 id="STP特性"><a href="#STP特性" class="headerlink" title="STP特性"></a>STP特性</h3><h4 id="Portfast"><a href="#Portfast" class="headerlink" title="Portfast"></a>Portfast</h4><p>配置了Portfast特性的端口，一旦接入了设备，接口可以绕过Listening和Learning状态直接进入Forwarding状态，Portfast特性一般在连接PC或服务器的端口上配置，如果连的是交换机，这个接口仍然要接受Spanning-tree的计算结果，如果计算结果是Block，那么这个接口仍然会被Block，所以如果在Cisco IOS设备上敲入Portfast命令后，IOS会提示可能造成短暂的环路。</p>
<p>配置命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局配置命令会将所有非Trunk接口激活portfast特性</span><br><span class="line">switch(config)# spanning-tree portfast default </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接口上配置portfast特性</span><br><span class="line">Switch(config-if)# spanning-tree portfast [trunk] </span><br></pre></td></tr></table></figure>

<p>portfast 特性不嫩直接配置在Trunk模式的接口上，即使配上去了，IOS也不生效，除非该接口变为access模式，如果确实需要在Trunk上配置该特性，例如该接口连接了一台支持Trunk的服务器，那么久在Spanning-tree portfast命令上增加Trunk关键字。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config-if)# switchport mode host </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">switchport mode access</span><br><span class="line">spanning-tree portfast</span><br><span class="line">disables port-channeling</span><br></pre></td></tr></table></figure>

<p>上面的‘switchport mode host’命令是一条简化命令，相当于在接口上配置了下面的三条命令，也就是指定接口的mode为access模式，开启portfast特性并关闭端口汇聚。</p>
<h4 id="BPDU-Guard"><a href="#BPDU-Guard" class="headerlink" title="BPDU Guard"></a>BPDU Guard</h4><p>配置命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">接口上配置命令：</span><br><span class="line">Switch(config-if)# spanning-tree bpduguard enable</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">全局配置命令：</span><br><span class="line">SW3(config)# spanning-tree portfast bpduguard default</span><br></pre></td></tr></table></figure>

<p>配置完该命令后：</p>
<ul>
<li><p>该接口在收到BPDU报文后，会立刻切换到err-disable状态；</p>
</li>
<li><p>通常搭配portfast特性在接口上一起使用，用于连接主机的接口；</p>
</li>
<li><p>可在接口模式上激活，也可以在全局模式上配置，两者有所不同，在接口模式下配置，该接口收到BPDU报文后会立刻切换到err-disable状态；在全局模式下配置，该命令会在所有激活Portfast特性的接口上激活bpduguard特性；</p>
</li>
</ul>
<h4 id="BPDU-Filter"><a href="#BPDU-Filter" class="headerlink" title="BPDU Filter"></a>BPDU Filter</h4><p>该特性可以在全局模式下配置，也可以在接口模式下配置，区别如下：</p>
<p>全局配置为：spanning-tree portfast bpduguard default</p>
<ul>
<li><p>启用了portfast的接口将激活bpdu filter特性；</p>
</li>
<li><p>接口在link up后瞬间会发送一些bpdu，此后不再发送任何bpdu；</p>
</li>
<li><p>接口在收到bpdu后立刻丢失portfast及bpdu filter特性，成为一个普通的spanning-tree接口；</p>
</li>
</ul>
<p>接口配置为：spanning-tree bpdufilter enable</p>
<ul>
<li><p>该接口不会发送BPDU，也忽略接收到的BPDU；</p>
</li>
<li><p>在接口上激活BPDU filter特性相当于在上面禁用了生成树，可能会造成二层环路；</p>
</li>
<li><p>在接口上配置，不一定必须和portfast特性一起使用，可独立配置。当然建议搭配portfast特性使用；</p>
</li>
</ul>
<h4 id="UplinkFast"><a href="#UplinkFast" class="headerlink" title="UplinkFast"></a>UplinkFast</h4><p><img src="/2022/01/20/19-Switch/1617769356656-f73a9eaf-e7c3-4813-8a70-64468edd2287.png" alt="img"></p>
<p>SW2为Root，SW1的F0/2是Forwarding状态，F0/1处于block状态，当F0/2的链路挂掉时，SW1会立刻进行STP计算，不过F0/1由block状态转到forwarding的状态需要30秒（15+15，端口进入侦听状态，侦听状态15秒到学习状态，再一个15秒由学习状态到转发状态），而等待30秒对于网络来说是不可接受的，因此思科提出的解决方案为uplinkfast，启动了uplinkfast的switch会选择一个Block状态的端口设置为standby状态，当RP端口挂掉时，standby的port立刻转换成Forwarding状态，节省30秒时间。</p>
<p>配置命令为在全局模式下：spanning-tree uplinkfast；</p>
<p>查看命令为：show spanning tree uplinkfast；</p>
<p><img src="/2022/01/20/19-Switch/1617768483961-18b7201d-7ee7-4221-9721-7ae99e812f1f.png" alt="img"></p>
<ul>
<li>配置Uplink fast的交换机需为末梢交换机，或网络三层结构中的接入层交换机，不能在根桥上配置；</li>
<li>激活Uplinkfast特性后，交换机会自动调整一些参数：</li>
</ul>
<ol>
<li><p>交换机的默认网桥优先级会增加到一个比缺省值更高的值，使得该交换机不会成为Root根交换机；</p>
</li>
<li><p>交换机的所有端口的默认Cost值会增加3000，以使得该交换机的端口不会被选举为指定端口；</p>
</li>
<li><p>非默认的（指手工配置的）Priority与cost不变；</p>
</li>
</ol>
<p>When the spanning tree reconfigures the new root port, other interfaces flood the network with multicast  packets, one for each address that was learned on the interface. You can limit these bursts of multicast traffic by reducing the max-update-rate parameter (the default for this parameter is 150 packets per second). However, if you enter zero, station-learning frames are not generated, so the spanning-tree topology converges more slowly after a loss of connectivity.</p>
<p>当生成树重新设置了RP端口时，其他端口会泛洪组播数据包，每个端口上学习到的地址都有一个。可以通过降低最大更新速率来限制这些组播流量的爆发，默认速率是每秒150个包。如果将速率配置为0，那么将不会生成Learing的帧，因此在失去连接后，拓扑收敛速度会非常慢。</p>
<h4 id="Backbone-Fast"><a href="#Backbone-Fast" class="headerlink" title="Backbone Fast"></a>Backbone Fast</h4><p><img src="/2022/01/20/19-Switch/1617782508364-002cc1c4-2459-48af-a431-15c51ac987de.png" alt="img"></p>
<ul>
<li><p>在没有Backbone Fast的情况下，SW3有一个接口被Block，这个接口将不会发送BPDU报文；</p>
</li>
<li><p>当Link 1 Down掉后，SW2将无法从ROOT收到BPDU，于是它会认为他自己就是ROOT，开始向SW3发送BPDU；</p>
</li>
<li><p>SW3收到这个BPDU后，发现SW2的BPDU不如自己本地存储的BPDU，因此忽略该BPDU；</p>
</li>
<li><p>Max age（默认20秒）计时器超时后，SW3上F0/3存储的BPDU老化，该接口进入侦听状态，并发送和接收BPDU；</p>
</li>
<li><p>SW2收到SW3发送的更优的BPDU后，停止发送它自己的BPDU；</p>
</li>
<li><p>SW3的F0/3从Listening到Forwarding，需花费20（Max age）+30（两倍的Forward delay）秒；</p>
</li>
</ul>
<p><strong>接下来看看有BackboneFast的特性：</strong></p>
<p><img src="/2022/01/20/19-Switch/1617783034983-3bee11b1-0381-4291-99ce-31bf75e56e3b.png" alt="img"></p>
<ul>
<li><p>部署了Backbone Fast以后，SW3一收到SW2发来的次优BPDU，会立刻进行一系列步骤以重新计算根端口。SW3会从根端口向根桥发送RLQ请求；</p>
</li>
<li><p>Root收到RLQ请求后，立刻以RLQ相应进行回复，以告知自己仍然存活；</p>
</li>
<li><p>SW3立刻老化掉存储在F0/3上的BPDU，端口F0/3进入Listening状态并开始发送BPDU；</p>
</li>
<li><p>SW2从SW3收到BPDU，经过计算得出自己的F0/2为根端口；</p>
</li>
</ul>
<p>配置命令为：‘spanning-tree backbonefast’</p>
<h4 id="Root-Guard"><a href="#Root-Guard" class="headerlink" title="Root Guard"></a>Root Guard</h4><p>Root Guard可以保护STP的Root，免受Switch Priority小的交换机抢走根桥角色，因为根桥的角色是可抢占的。但如果规划好的根桥角色轻易被别的交换机抢夺走，整个网络就会和规划的有所差别，所以要杜绝这种情况。</p>
<p>配置命令为：SW1(config-if)#spanning-tree guard root</p>
<p>查看命令为：show spanning-tree inconsistentports</p>
<p>当配置了Root Guard的接口插入了一个优先级比Root小的交换机，这个端口会处于Root inconsistent状态，它会被Block而不会传送或接收数据，比如下图中的F0/8接口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW1#show spanning-tree inconsistentports</span><br><span class="line"> </span><br><span class="line"> Name                 Interface              Inconsistency</span><br><span class="line"> -------------------- ---------------------- ------------------</span><br><span class="line"> VLAN0001             FastEthernet0/8        Root Inconsistent</span><br><span class="line"> </span><br><span class="line"> Number of inconsistent ports (segments) in the system : 1</span><br><span class="line"> </span><br><span class="line"> SW1#show spanning-tree vlan 1 | begin Interface</span><br><span class="line"> Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line"> ---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line"> Fa0/1            Desg FWD 19        128.1    P2p</span><br><span class="line"> Fa0/8            Desg BKN*19        128.8    P2p *ROOT_Inc</span><br><span class="line"> Gi0/1            Desg FWD 4         128.9    Edge P2p</span><br></pre></td></tr></table></figure>

<p>inconsistent和err-disable的区别在于，err-disable会disable掉整个接口，而inconsistent是针对特定VLAN的。</p>
<h4 id="UDLD"><a href="#UDLD" class="headerlink" title="UDLD"></a>UDLD</h4><p>UDLD全称为Unidirectional Link Detection，用于单向链路检测，主要用于光纤链路。需要两端设备都支持UDLD，开启UDLD以后，端口会不断向对方发出检测，如果对方有回应，表示运作正常，但如果收不到对方的回应，UDLD会认为出现了单向故障，会administratively shut down整个接口，并提示用户。单向链路会引发各种问题，其中包括spanning-tree环路。</p>
<p>UDLD有两种模式：normal（默认为该模式）和aggressive模式.</p>
<p>Normal模式配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">normal模式配置</span><br><span class="line">在全局模式上配置会启动所有接口的UDLD的normal模式</span><br><span class="line">SW1(config)#udld enable</span><br><span class="line">或在端口上为某个端口配置</span><br><span class="line">SW1(config-if)#udld port</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">用show udld命令查看配置情况，DULD预设每7秒发从一次检测报文，如果5秒内收不到恢复则判断为单向链路故障</span><br><span class="line"></span><br><span class="line">SW1#show udld</span><br><span class="line"> </span><br><span class="line"> Interface Fa0/1</span><br><span class="line"> ---</span><br><span class="line"> Port enable administrative configuration setting: Enabled</span><br><span class="line"> Port enable operational state: Enabled</span><br><span class="line"> Current bidirectional state: Unknown</span><br><span class="line"> Current operational state: Advertisement</span><br><span class="line"> Message interval: 7</span><br><span class="line"> Time out interval: 5</span><br><span class="line"> No neighbor cache information stored</span><br></pre></td></tr></table></figure>

<p>Aggressive模式配置：</p>
<p>在aggressive模式中，端口变为err-disable</p>
<p>全局配置命令为：SW1(config)#udld aggressive</p>
<p>端口设定命令为：SW1(config-if)#udld port aggressive</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW1#show udld</span><br><span class="line"> </span><br><span class="line"> Interface Fa0/1</span><br><span class="line"> ---</span><br><span class="line"> Port enable administrative configuration setting: Enabled / in aggressive mode</span><br><span class="line"> Port enable operational state: Enabled / in aggressive mode</span><br><span class="line"> Current bidirectional state: Unknown</span><br><span class="line"> Current operational state: Advertisement</span><br><span class="line"> Message interval: 7</span><br><span class="line"> Time out interval: 5</span><br><span class="line"> No neighbor cache information stored</span><br></pre></td></tr></table></figure>

<h4 id="LoopGuard"><a href="#LoopGuard" class="headerlink" title="LoopGuard"></a>LoopGuard</h4><p>UDLD只能防止光纤单向链路故障而导致的环路，但收不到BPDU也可能由其他问题引起，例如交换机的硬件问题或CPU满载而无法处理收到的BPDU，另一个办法是用Loopguard。如果端口开启了Loop Guard，当它收不到BPDU超过Max age的话会转成Loop Inconsistent状态避免发生环路。不过必须注意，LoopGuard和LoopGuard无法同时启动。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局打开命令：</span><br><span class="line">SW1(config)#spanning-tree loopguard default</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">端口打开命令：</span><br><span class="line">SW1(config-if)#spanning-tree guard loop</span><br></pre></td></tr></table></figure>

<p><img src="/2022/01/20/19-Switch/1617787895551-f019fd9c-6fa0-4183-bab3-33d071c0d952.png" alt="img"></p>
<h2 id="PVST"><a href="#PVST" class="headerlink" title="PVST+"></a>PVST+</h2><h3 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h3><p>传统的STP，也就是802.1D，是所有的VLAN共用一颗生成树，这样一来的好处是交换机不用耗费过多的资源去计算多颗生成树，不足是，通过Block固定的端口，导致流量只走一侧，而部分链路一点流量都没有，浪费了带宽。</p>
<p>PVST+在这方面做出了改进。PVST+全称为Per Vlan Spanning Tree Plus，中文是增强的按VLAN生成树，是思科的私有协议，一个VLAN对应一颗生成树，如此一来交换机将基于VLAN计算生成树，可以通过单独的VLAN生成树调节优先级等相关参数，从而影响生成树的计算，最终实现合理的链路带宽利用：</p>
<p><img src="/2022/01/20/19-Switch/1617867288530-d44f11b7-2675-4389-860a-85acdf82dc4a.png" alt="img"></p>
<p>比如上图中，内网存在两个VLAN，10和20，这里让SW1成为VLAN10的主根，将它的优先级配置为最低，SW2成为VLAN10的次根，SW3优先级最高，如此一来将Block掉SW3上连接SW2的上联口，相对的VLAN20也通过参数调节，Block掉SW3连接SW1的上联接口。这样，vlan10用户出去将走左侧链路，vlan20用户走右侧用户，两边链路都得到了合理的使用，实现了负载均衡。</p>
<h3 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h3><ul>
<li><p>Cisco 交换机的MAC地址池最多容纳1024个地址，交换机的型号决定了可用MAC的数量，并不是所有型号的交换机都能支持这么多的MAC；</p>
</li>
<li><p>这些MAC地址作为VLAN生成树中网桥ID的MAC地址部分。不同交换机型号支持不同的可用MAC地址数目。交换机依照次序分配MAC地址；</p>
</li>
<li><p>show run interface | include bia 能看到所有的MAC地址，第一个MAC地址将被生成树所使用，也就是CPU的  MAC。接下来是每个以太网接口的MAC；</p>
</li>
<li><p>我们知道交换机能够支持的VLAN数据是很庞大的，如果开启PVST+，每个VLAN一个生成树，而每颗生成树都要有一个独立的标识，都需要消耗一个MAC地址的话，那么MAC地址池肯定是无法承受的；</p>
</li>
<li><p>因此需要使用到MAC地址缩减方案</p>
</li>
</ul>
<p>在PVST+中，一个VLAN一颗生成树，在每台交换机上，对于每一颗生成树，需要有一个唯一的标识符，也就是网桥ID要唯一，网桥ID之前说过，就是优先级和MAC地址构成的，在MAC地址缩减方案中，同一台交换机的所有生成树的根桥ID中，MAC地址都是用自己交换机CPU的MAC，同时将16bit的优先级进行扩展，变成4bit的优先级+12bit的系统ID，通过这个系统ID来标识不同的VLAN。在Cisco IOS中，这个系统ID用的就是VLAN ID。</p>
<p><img src="/2022/01/20/19-Switch/1617868713939-ae3626b6-16f7-490e-ae0f-cf136b124af9.png" alt="img"></p>
<p>如此一来，优先级就成为了最高的4bit，系统ID取值VLAN ID，比如VLAN10的生成树，在本交换机的根桥ID就是‘4bit的优先级+12bit的sysid’，SYSID还作为VLAN或MST实例的标识。</p>
<p>为什么优先级必须是4096的倍数呢，因为在使用Extended System ID的情况下，每个VLAN的MAC地址可以相同，BID被要求包含VLAN ID信息，解决的办法是从优先级域的16个bit中拿出低位的12个bit，称为扩展的System ID，用来唯一标识每个VLAN号，剩下的4个bit用来表示交换机的优先级，这种情况下优先级的取值只有24=16个，2的12次方=4096，是4096的倍数。</p>
<h2 id="RSTP（802-1W）"><a href="#RSTP（802-1W）" class="headerlink" title="RSTP（802.1W）"></a>RSTP（802.1W）</h2><p>使用传统的802.1D协议时，当拓扑发生改变时，整个网络需要30秒或以上才能恢复稳定状态，这是现代网络所不能接受的，想象一下，如果证券交易服务因为生成树的30秒收敛时间而中断交易，那么将损失惨重，所以为了网络更快收敛，又开发出了RSTP协议，全称为Rapid Spanning Tree Protocol，快速生成树协议，由STP协议改进而来，主要改进了STP收敛慢的问题。</p>
<h3 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="RSTP端口状态"><a href="#RSTP端口状态" class="headerlink" title="RSTP端口状态"></a>RSTP端口状态</h4><p><img src="/2022/01/20/19-Switch/1617872380822-1db0d41c-48b3-4316-80b3-0033164d9bb2.png" alt="img"></p>
<h4 id="RSTP端口角色"><a href="#RSTP端口角色" class="headerlink" title="RSTP端口角色"></a>RSTP端口角色</h4><p>RSTP保留了Root Port和Designated的设计，选择方法与STP相同，另外增加了Alternate Port和Backup Port，以便加快收敛时间。</p>
<ul>
<li><p>Root Port，根端口，<strong>交换机上最接近Root Switch</strong>的端口（即Root cost最小）成为RP根端口，每个交换机上只会有一个根端口，用来接收来自根交换机的BPDU；</p>
</li>
<li><p>Designated Port，指定端口，在没有RP的情况下，<strong>网段里****最接近根桥</strong>的端口成为根端口，用来发送BPDU，每个网段只会有一个Designated Port；</p>
</li>
<li><p>Alternate Port，替代端口，处于丢弃状态，Discarding状态，交换机除了根端口外，其他到根路径的端口，如果活跃的根端口发生故障，替代端口将成为根端口，所以替代端口也可以理解为根端口的可替代者，A是R的替代端口，5秒内完成转换；</p>
</li>
<li><p>Backup Port，备份端口，处于丢弃状态，Discarding状态，备份端口是指定端口的备份，出现在一台交换机有两个端口连接到同一个共享介质的时候，B是DP的备份端口，1秒内完成转换。</p>
</li>
</ul>
<p>当Alternate Port和Backup Port有一天被唤醒而需要转发数据时，会先进入Learning状态（非常短时间）然后进入Forwarding状态。</p>
<p><img src="/2022/01/20/19-Switch/1617873273748-f4fb2be7-0082-4a1d-8ea9-fa84cd6cb375.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617873423388-b98691a9-d4ee-40a6-a6be-aa5669d2782a.png" alt="img"></p>
<h3 id="BPDU格式和操作"><a href="#BPDU格式和操作" class="headerlink" title="BPDU格式和操作"></a>BPDU格式和操作</h3><h4 id="BPDU格式"><a href="#BPDU格式" class="headerlink" title="BPDU格式"></a>BPDU格式</h4><p>RSTP只在802.1D的基础上对BPDU做了少量修改，RSTP的BPDU协议是2，版本是2，还有就是在802.1D中，Type字段只是用了最高位和最低位，来表示TC以及TCA，RSTP对该字段进行了扩展：</p>
<p><img src="/2022/01/20/19-Switch/1617874264697-421baf3a-5e55-4a5b-8366-e5adf34d4e09.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1617874249653-c469d7b9-3402-4dbd-b342-8bf7c195f6b8.png" alt="img"></p>
<h4 id="BPDU操作"><a href="#BPDU操作" class="headerlink" title="BPDU操作"></a>BPDU操作</h4><p>在802.1D中，非根交换机只有从根端口收到根桥发送的BPDU，自己才能产生BPDU，而在RSTP中，即使非根交换机没有从根交换机收到BPDU，自己也以Hello间隔（默认为2秒）发送BPDU。</p>
<h4 id="Faster-Aging-of-information"><a href="#Faster-Aging-of-information" class="headerlink" title="Faster Aging of information"></a>Faster Aging of information</h4><p>在特定的接口，如果连续三个周期（3X2=6秒）没有收到BPDU或者Max age超时，接口上的STP协议数据将迅速老化，如此一来，BPDU又有点类似交换机之间的Keep-alive机制，这种快速老化的机制有助于对拓扑变化的快速响应。</p>
<h4 id="accepts-Inferior-BPDUs"><a href="#accepts-Inferior-BPDUs" class="headerlink" title="accepts Inferior BPDUs"></a>accepts Inferior BPDUs</h4><p>这个机制与思科的BackboneFast非常类似，当交换机从其他指定交换机或根桥收到次优BPDU时，802.1D遇到这种情况是首先忽略这些次优BPDU，而RSTP是立刻接收这些次优BPDU同时回传一个更优的BPDU。</p>
<p><img src="/2022/01/20/19-Switch/1617874734696-f181a373-ec5b-4a29-83bb-1de586323bf6.png" alt="img"></p>
<p>在802.1D的初始状况下，交换机C的一个接口被选举为非指定端口而被Block掉，B会从指定端口发送BPDU给C，当ROOT和B之间的链路发生故障，由于C上面链接B的端口被Block，C不会发送BPDU给B，因此B在过了Maxage以后会认为自己是Root，于是B向C发送自己为Root的BPDU，而这时由于C的接口上还存储着B的BPDU信息，而这个之前存储的BPDU信息比B现在发送给自己的BPDU更优，因此C会直接忽略掉这些次优BPDU，一直到Maxage超时以后，C接口上存储的此前B发送过来的BPDU才会老化，这时接口进入Listening状态，才会开始发送Root的最优BPDU给B，此时B收到Root的BPDU才会知道自己不是跟，将B和C连接的接口角色变为根端口。</p>
<p>在RSTP的情况下，C收到次优BPDU以后，会立刻回送自己存储的ROOT发来的更优的BPDU，好让B了解拓扑的情况，这个机制和BackboneFast非常类似。</p>
<h3 id="Link-Type"><a href="#Link-Type" class="headerlink" title="Link Type"></a>Link Type</h3><p>RSTP的一个重要改进就是端口的快速过渡，传统的STP算法在一个接口过渡到Forwarding状态之前，需要经过几个计时器，加起来至少要30-50秒，为了让网络快速收敛，我们可能会去调节计时器，但这么做有可能影响网络的稳定性，RSTP的设计使得可以不依赖计时器的调整并且还能让接口快速过渡到转发状态。</p>
<p>Link Type是RSTP新增的概念，RSTP将Link氛围Edge Port、Point-To-Point Non-edge Port以及Shared Non-edge Port三种。</p>
<h4 id="Edge-Port"><a href="#Edge-Port" class="headerlink" title="Edge Port"></a>Edge Port</h4><p><img src="/2022/01/20/19-Switch/1617951524655-97ead16a-6c30-4bba-a6f0-bc2d22f703f2.png" alt="img"></p>
<p>Edge Port接口的中文叫做边缘接口，RSTP定义的这种端口类型和Portfast十分类似，因为这些接口用于连接主机，所以一般不会产生环路，这些端口可以跳过Listening或Learning阶段直接进入转发状态，并且这些接口的up和down的时候都不会引起拓扑变更。另外，边缘接口一旦收到BPDU，则会立刻丢失掉边缘接口的特征，变成一个普通的Spanning-tree接口，配置命令就是在接口上输入portfast来开启。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW(config)#int fastEthernet 1/0/3</span><br><span class="line">SW(config-if)#spanning-tree portfast</span><br><span class="line">SW(config-if)#end</span><br><span class="line">SW#show spanning-tree</span><br><span class="line"></span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    24577</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    24577  (priority 24576 sys-id-ext 1)</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time 300</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Fa1/0/1          Desg FWD 19        128.3    P2p</span><br><span class="line">Fa1/0/2          Desg FWD 19        128.4    Shr</span><br><span class="line">Fa1/0/3          Desg FWD 19        128.5    Edge P2p</span><br></pre></td></tr></table></figure>

<h4 id="Point-to-Point-Non-edge-Port"><a href="#Point-to-Point-Non-edge-Port" class="headerlink" title="Point to Point Non-edge Port"></a>Point to Point Non-edge Port</h4><p>RSTP会把全双工的网口定义为Point-to-Point Non-edge port，并会使用RSTP和对方进行沟通（Synchronization Process）。</p>
<h4 id="Shared-Non-edge-Port"><a href="#Shared-Non-edge-Port" class="headerlink" title="Shared Non-edge Port"></a>Shared Non-edge Port</h4><p>半双工接口会成为Shared Non-edge Port，只能用传统的STP方法进行沟通。下图中的F1/0/1是P2P non-edge port，F1/0/2是shared non-edge port：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW#show spanning-tree</span><br><span class="line"></span><br><span class="line">VLAN0001</span><br><span class="line">  Spanning tree enabled protocol rstp</span><br><span class="line">  Root ID    Priority    24577</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    24577  (priority 24576 sys-id-ext 1)</span><br><span class="line">             Address     0016.468f.xxxx</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line">             Aging Time 300</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Fa1/0/1          Desg FWD 19        128.3    P2p</span><br><span class="line">Fa1/0/2          Desg FWD 19        128.4    Shr</span><br><span class="line">Fa1/0/3          Desg FWD 19        128.5    Edge P2p</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">也可以用命令强制设置Link Type：</span><br><span class="line">SW(config-if)#spanning-tree link-type ?</span><br><span class="line">  point-to-point  Consider the interface as point-to-point</span><br><span class="line">  shared          Consider the interface as shared</span><br></pre></td></tr></table></figure>

<h3 id="RSTP-VS-802-1D"><a href="#RSTP-VS-802-1D" class="headerlink" title="RSTP VS 802.1D"></a>RSTP VS 802.1D</h3><h4 id="802-1D场景"><a href="#802-1D场景" class="headerlink" title="802.1D场景"></a>802.1D场景</h4><p><img src="/2022/01/20/19-Switch/1617952784105-d05d7e44-753a-4a9c-87db-30c2a3fef84d.png" alt="img"></p>
<ul>
<li><p>A和ROOT之间新增链路Link1；</p>
</li>
<li><p>A及Root在Link1两端的接口都进入Listening状态，A将收到Root发出来的BPDU；</p>
</li>
<li><p>A将BPDU从自己的指定端口发送出去，BPDU被泛洪到网络中；</p>
</li>
<li><p>B和C收到这个更优的BPDU，继续向网络中泛洪；</p>
</li>
<li><p>数秒后，D收到这个BPDU，Block掉端口P1；</p>
</li>
</ul>
<p>由于缺乏Feedback机制，A连接Root的接口从Listening到Forwarding，需要经历15X2也就是30秒的延迟，此时A、B、C下联的用户流量就出现问题了，因为D在收到更优的BPDU后，P1接口就Block掉了，这时候A、B、C相当于在A的端口过渡到Forwarding之前都处于网络的‘隔离地带’</p>
<h4 id="RSTP场景"><a href="#RSTP场景" class="headerlink" title="RSTP场景"></a>RSTP场景</h4><p><img src="/2022/01/20/19-Switch/1617953054296-ef01b9ea-15ae-4fdc-997f-312995223944.png" alt="img"></p>
<p>A及Root之间新增链路Link1。</p>
<p><img src="/2022/01/20/19-Switch/1617953093993-8e520ffb-4692-4110-81a0-a9d6e87a4729.png" alt="img"></p>
<p>A及Root，在Link1两端口up之后进入了Designated Blocking，然后双方交互BPDU信息，这个过程实际上是一个协商的过程。</p>
<p><img src="/2022/01/20/19-Switch/1617953218187-32af3a94-66e9-4fc5-ad5f-8c1e7ff96fe2.png" alt="img"></p>
<ul>
<li>A在收到Root发送的BPDU后，将自己的所有非边缘接口Block掉（这个过程称作同步，Synchronization mechanism），并且回送一个Agreement消息给Root；</li>
<li>在此之后，Root以及A在Link1上的端口like过渡到转发状态，而且此时网络是没有环路的，因为A的下联接口都是切断的；</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1617953399784-d1a11cae-7e54-42af-8b44-b994bbe7afeb.png" alt="img"></p>
<p>A、B、C之间，开启新一轮的协商，B、C收到A发送的BPDU后，完成同步过程，将自己的非边缘端口Block掉，然后都会向A回送Agreement消息，同时，A、B、C互相连接的接口进入转发状态，在和B、C同步操作的过程中，B下联的权势主机，所以没有被Block的接口，此时它已经完成了同步。而C要Block掉连接D的端口。</p>
<p><img src="/2022/01/20/19-Switch/1617953540009-a16a833a-65ed-49d6-9448-edb4628080a2.png" alt="img"></p>
<p>完成上一步之后，生成树状态如上图，最终BPDU到达D，D将P1接口Block掉。</p>
<p><strong>总结：</strong></p>
<p>在RSTP收敛过程中，RSTP用同步机制取代了基于计时器（Listening过15秒到Learning再过15秒到Forwarding）的机制，耗费的时间仅仅是BPDU从ROOT泛洪到网络末端的时间，不受到任何Timer的限制，直接绕过两个转发延迟的时间，因此收敛速度很快。</p>
<p><img src="/2022/01/20/19-Switch/1617956210092-1ca39512-8945-48a3-b411-9c099e99b3a8.png" alt="img"></p>
<p>还需要注意两点：</p>
<ul>
<li>交换机之间的这种协商机制只在P2P链路上执行；</li>
<li>边缘端口的配置非常重要，如果配置不当，可能会在同步过程中被Block掉；</li>
</ul>
<h4 id="P-amp-A机制"><a href="#P-amp-A机制" class="headerlink" title="P&amp;A机制"></a>P&amp;A机制</h4><p>全称是Proposal/Agreement Sequence，对于802.1D来说，当一个端口被选举为指定端口，它从Blocking到Forwarding至少需要30秒的时间，然而在RSTP中，Proposal &amp; Agreement机制使得接口可以在几秒内完成迅速可靠的过渡。</p>
<p><img src="/2022/01/20/19-Switch/1617956431094-2f27ed30-1101-4b86-81bb-ebabc4d89629.png" alt="img"></p>
<ul>
<li><p>当Root和A之间新增了一跳链路，链路两端的接口在收到对方发送的BPDU之前是Designated Block状态，当一个被选举为指定端口的接口，在Discarding或Learning（在且只在这个状态），它在其发送的BPDU中进行Proposal bit置位，这就是步骤1的P0情况，也就是<strong>Proposal</strong>（When a designated port is in a discarding or learning state (and only in this case), it sets the proposal bit on the BPDUs it sends out）；</p>
</li>
<li><p>A收到一个最优的BPDU，它立刻知道P1就是新的根端口，接下来A将启动一个同步进程，这个同步过程用来确定A上所有的端口，是否已经和最新收到的这个最优的BPDU了（Switch A then starts a sync to verify that all of its ports are in-sync with this new information）。</p>
</li>
<li><p>A怎么确定它的端口是否已经完成了同步呢？当端口处于Blocking状态（意味着拓扑已经稳定）或者当这个接口是一个边缘端口角色时，表示该接口已经同步完成（A port is in sync if it meets either of these criteria:The port is in the blocking state, which means discarding in a stable topology；The port is an edge port.）；如果接口不满足上述两个条件，也就是说如果接口既不是边缘端口，也不处于Block状态，那么这个接口将被Block而进入Discarding状态完成同步。也就相当于A把所有接口Block掉，完成同步。</p>
</li>
<li><p>现在具体看A，它上面的三个端口其中P2是Alternated port，替代端口，是处于Discarding状态的，也就是完成了同步；P4端口时Edge port，边缘端口，符合完成同步的标准，也就是完成了同步；P3是Designated port，指定端口，不符合完成同步的标准，所以还没完成同步；为了让P3完成同步，A于是将P3端口Block掉，让该端口处于Discarding状态，这样的话，所有的端口都完成了同步，然后A会发送Agreement消息给Root，这个Agreement消息是之前Proposal BPDU消息的拷贝，但Proposal位不置1，而是agreement bit置1，这样的话P0接口就能知道该agreement回应的是哪个proposal报文了。</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1618042999330-4f9d3d9a-7d4e-4854-bb41-f45a629dbf90.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618042833462-8de957cf-6ed8-4939-a124-1458efd7b8fc.png" alt="img"></p>
<ul>
<li>当Root的P0接口收到agreement报文后，它立刻进入Forwarding状态；A的P3接口之前是指定端口，在Proposal\agreement这个过程同步完成后，会执行和P0一样的Proposal\agreement步骤，开始对A的邻居发送Proposal报文，收到agreement报文后会马上进入Forwarding状态。</li>
</ul>
<p>总结：</p>
<ul>
<li>Proposal\Agreement机制运行的速度非常快，它并不受限于计时器，它会非常快速的传遍整个网络，在拓扑变更后，能使网络快速收敛。</li>
<li>如果处于Discarding状态的指定端口（DP）在发送完Proposal后没有收到Agreement的回复，那么它会慢慢的过渡到Forwarding状态，‘退化’成为802.1D的listening-learning-forwarding 过程。这种情况可能出现在对端交换机不理解RSTP的BPUD时，或是对端交换机被Block掉的情况下。</li>
</ul>
<h3 id="拓扑变更机制"><a href="#拓扑变更机制" class="headerlink" title="拓扑变更机制"></a>拓扑变更机制</h3><h4 id="检测机制"><a href="#检测机制" class="headerlink" title="检测机制"></a>检测机制</h4><p>在RSTP中，只有当非边缘端口过渡到Forwarding状态才会触发状态变更，也就是说一个端口如果丢失了连接，则不再认为是一次拓扑变更，这是与802.1D是有区别的。</p>
<p>当一个RSTP交换机检测到一次拓扑变更，它将：</p>
<ul>
<li><p>为根端口及所有的非边缘指定端口启动一个TC While timer，该timer的值等于2倍的hello-time计时器；</p>
</li>
<li><p>向上述端口泛洪MAC表；</p>
</li>
<li><p>注意TC while timer在端口上计时，端口发送出去的BPDU就会进行TC bit置位，该BPDU也会从根端口往外发送；</p>
</li>
</ul>
<h4 id="传递机制"><a href="#传递机制" class="headerlink" title="传递机制"></a>传递机制</h4><p>当一台RSTP交换机收到TC bit置位的BPDU，它将：</p>
<ul>
<li>清除从所有交换机接口学到的MAC表项，但不清楚收到TC BPDU的那个接口。这个动作虽然有可能导致网络中存在短暂的突发性泛洪，但也有利于刷新CAM表，清除表项；</li>
<li>激活TC while timer，然后从所有的非边缘指定端口及根端口往外发送TC置位的BPDU，通过这种方式，拓扑变更信息会迅速在网络中泛洪；</li>
</ul>
<p>通过这种方式，TC消息会被迅速的泛洪到整个网络。而不像802.1D那样需要等到消息传递到Root，然后再由Root来通知拓扑进行变更。</p>
<h3 id="补充帖子"><a href="#补充帖子" class="headerlink" title="补充帖子"></a>补充帖子</h3><p><a href="https://community.cisco.com/t5/switching/rstp-convergence-few-questions/td-p/1856300">https://community.cisco.com/t5/switching/rstp-convergence-few-questions/td-p/1856300</a></p>
<p><a href="https://community.cisco.com/t5/switching/rstp-proposal-agreement-process/td-p/2303537">https://community.cisco.com/t5/switching/rstp-proposal-agreement-process/td-p/2303537</a></p>
<p><a href="https://community.cisco.com/t5/routing/rstp-proposal-agreement-sync-process/td-p/2095718">https://community.cisco.com/t5/routing/rstp-proposal-agreement-sync-process/td-p/2095718</a></p>
<p><a href="https://community.cisco.com/t5/switching/rstp-working-how-to-use-bpdu-agreement-flag/td-p/1606059">https://community.cisco.com/t5/switching/rstp-working-how-to-use-bpdu-agreement-flag/td-p/1606059</a></p>
<h2 id="MSTP（802-1S）"><a href="#MSTP（802-1S）" class="headerlink" title="MSTP（802.1S）"></a>MSTP（802.1S）</h2><p>从STP到RSTP，主要是速度的加快，而从RSTP到MSTP，则是硬件资源和管理层级式的进化，MSTP（又叫802.1S）继承了RSTP的Synchronization Process带来的高效率收敛，而比RSTP更优秀的是，MSTP可以把多个Spanning-tree分配给不同的实例（Instance），从而减少整个生成树系统的拓扑数量。</p>
<h3 id="RSTP的问题"><a href="#RSTP的问题" class="headerlink" title="RSTP的问题"></a>RSTP的问题</h3><ul>
<li>消耗硬件资源较大。思科所有支持RSTP的生成树都是Pervlan的，也就是一个VLAN一张生成树，如果有100个VLAN，那么就要维护100个生成树的拓扑，对交换机的CPU和内存都有很大影响；MSTP提出了实例（Instance）的概念，把多个VLAN分组成不同的Instance，同一组Instance的VLAN共用一组生成树，比如网络中共有VLAN101至VLAN200共100组VLAN，把VLAN101至150编入Instance1，余下的VLAN151至200编入Instance2，这样生成树拓扑的数量由100下降到2个；</li>
<li>缺乏区域概念，难于管理。MSTP把整个网络分区（Region）管理，每个Region之间不会互相干扰拓扑，每个Region会构成一个巨大的虚拟Switch，每个虚拟交换机之间会运行独立的生成树，称为Common and Internal Spanning Tree（CIST），不会影响每个Region里的拓扑。</li>
</ul>
<h3 id="区域（Region）"><a href="#区域（Region）" class="headerlink" title="区域（Region）"></a>区域（Region）</h3><p>在同一个Region中的交换机只会处理相同Region中的BPDU消息，从而计算出生成树拓扑。要判断是否在同一Region，交换机会比较生成树中的三个参数，只有三个参数完全相同才算处于同一个Region：</p>
<ul>
<li><p>Configuration Name：用命令‘name’设置；</p>
</li>
<li><p>Revision Number：设定的版本编号，习惯上每次更改MST设定都会把Revision Number加1，设定命令为revision；</p>
</li>
<li><p>vlan及Instance对应表：设置Instance所包含的VLAN，命令为Instance X vlan Y。要注意，思科会将Instance 0用作CIST，不能用作Region用。</p>
</li>
</ul>
<h3 id="扩展系统ID"><a href="#扩展系统ID" class="headerlink" title="扩展系统ID"></a>扩展系统ID</h3><p><img src="/2022/01/20/19-Switch/1618049203053-32429cb0-0cdf-4364-a6a8-63c1e7a5edbd.png" alt="img"></p>
<h3 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h3><p><img src="/2022/01/20/19-Switch/1618049509389-3ac3aff2-7533-460f-9fc0-ce06642095d8.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW1(config)#spanning-tree mode mst</span><br><span class="line">SW1(config)#spanning-tree mst configuration</span><br><span class="line">SW1(config-mst)#name Region1</span><br><span class="line">SW1(config-mst)#revision 1</span><br><span class="line">SW1(config-mst)#instance 1 vlan 11-13</span><br><span class="line">SW1(config-mst)#instance 2 vlan 21-23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SW2(config)#spanning-tree mode mst</span><br><span class="line">SW2(config)#spanning-tree mst configuration</span><br><span class="line">SW2(config-mst)#name Region1</span><br><span class="line">SW2(config-mst)#revision 1</span><br><span class="line">SW2(config-mst)#instance 1 vlan 11-13</span><br><span class="line">SW2(config-mst)#instance 2 vlan 21-23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SW3(config)#spanning-tree mode mst</span><br><span class="line">SW3(config)#spanning-tree mst configuration</span><br><span class="line">SW3(config-mst)#name Region1</span><br><span class="line">SW3(config-mst)#revision 1</span><br><span class="line">SW3(config-mst)#instance 1 vlan 11-13</span><br><span class="line">SW3(config-mst)#instance 2 vlan 21-23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来查看MSTP：</span><br><span class="line">SW1#show spanning-tree mst configuration</span><br><span class="line">Name      [Region1]</span><br><span class="line">Revision  1     Instances configured 3</span><br><span class="line"></span><br><span class="line">Instance  Vlans mapped</span><br><span class="line">--------  ---------------------------------------------------------------------</span><br><span class="line">0         1-10,14-20,24-4094</span><br><span class="line">1         11-13</span><br><span class="line">2         21-23</span><br></pre></td></tr></table></figure>

<p>MSTP会把其他的VLAN放入Instance0中，一共有3个Instance在运行中，除了Instance1和2以外，还有一个预设的Instance0，用来做CIST用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW1#show spanning-tree</span><br><span class="line"></span><br><span class="line">MST0</span><br><span class="line">  Spanning tree enabled protocol mstp</span><br><span class="line">  Root ID    Priority    32768</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32768  (priority 32768 sys-id-ext 0)</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 2000000   128.1    Shr</span><br><span class="line">Et0/1               Desg FWD 2000000   128.2    Shr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MST1</span><br><span class="line">  Spanning tree enabled protocol mstp</span><br><span class="line">  Root ID    Priority    32769</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32769  (priority 32768 sys-id-ext 1)</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 2000000   128.1    Shr</span><br><span class="line">Et0/1               Desg FWD 2000000   128.2    Shr</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MST2</span><br><span class="line">  Spanning tree enabled protocol mstp</span><br><span class="line">  Root ID    Priority    32770</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             This bridge is the root</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">  Bridge ID  Priority    32770  (priority 32768 sys-id-ext 2)</span><br><span class="line">             Address     aabb.cc00.0400</span><br><span class="line">             Hello Time   2 sec  Max Age 20 sec  Forward Delay 15 sec</span><br><span class="line"></span><br><span class="line">Interface           Role Sts Cost      Prio.Nbr Type</span><br><span class="line">------------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0               Desg FWD 2000000   128.1    Shr</span><br><span class="line">Et0/1               Desg FWD 2000000   128.2    Shr</span><br></pre></td></tr></table></figure>

<p>如果这里希望MST2由SW2来做Root，可以修改Priority，与STP/RSTP不同的是，MSTP要改的是Instance的参数而不是VLAN的参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SW2(config)#spanning-tree mst 2 priority 28672</span><br><span class="line">SW2(config)#exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SW2#show spanning-tree mst 1-2</span><br><span class="line"></span><br><span class="line">##### MST1    vlans mapped:   11-13</span><br><span class="line">Bridge        address aabb.cc00.0500  priority      32769 (32768 sysid 1)</span><br><span class="line">Root          address aabb.cc00.0400  priority      32769 (32768 sysid 1)</span><br><span class="line">            port    Et0/1           cost      2000000              rem hops 19</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0            Desg FWD 2000000   128.1    Shr</span><br><span class="line">Et0/1            Root FWD 2000000   128.2    Shr</span><br><span class="line"></span><br><span class="line">##### MST2    vlans mapped:   21-23</span><br><span class="line">Bridge        address aabb.cc00.0500  priority      28674 (28672 sysid 2)</span><br><span class="line">Root          this switch for MST2</span><br><span class="line"></span><br><span class="line">Interface        Role Sts Cost      Prio.Nbr Type</span><br><span class="line">---------------- ---- --- --------- -------- --------------------------------</span><br><span class="line">Et0/0            Desg FWD 2000000   128.1    Shr</span><br><span class="line">Et0/1            Desg FWD 2000000   128.2    Shr</span><br></pre></td></tr></table></figure>

<h3 id="CIST"><a href="#CIST" class="headerlink" title="CIST"></a>CIST</h3><p>如果此时网络中又出现了另一个Region，MSTP会如何处理呢？MSTP会把Region当成一个大的虚拟交换机（Virtual Switch）去看待：</p>
<p><img src="/2022/01/20/19-Switch/1618050131358-1a0ce80a-d00d-471f-8071-765870016b26.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618050171999-c7e32564-6df4-42a1-8847-71f94454ada1.png" alt="img"></p>
<h1 id="三层交换"><a href="#三层交换" class="headerlink" title="三层交换"></a>三层交换</h1><h2 id="CAM-amp-TCAM"><a href="#CAM-amp-TCAM" class="headerlink" title="CAM&amp;TCAM"></a>CAM&amp;TCAM</h2><h3 id="CAM"><a href="#CAM" class="headerlink" title="CAM"></a>CAM</h3><p>CAM是交换机用于二层交换时所查的表，Content Addressable Memory Table，内容可寻址内存，在查表时使用二进制的0、1进行匹配，并且需要严格匹配，也就是目的MAC与CAM表中的MAC需要完全匹配，查找的结果如果是完全匹配，则根据返回的端口号将数据转发出去。CAM表只能输出两种结果：0表示真，也就是匹配，1表示为假，也就是不匹配。所以CAM表在构建那些需要精确匹配的表格（比如MAC地址表）的时候就非常有用，因为MAC地址为48位，需要每位都匹配才能使得数据帧从一个接口发出去。（CAM performs quick lookup based on exact match on the given search key. In essence, a CAM looks up a single record - the one matches the search key precisely——出自<a href="https://community.cisco.com/t5/switching/cam-tcam-backplane-speed/td-p/1970089">这个帖子</a>）</p>
<p>查看CAM表使用命令：show mac address-table dynamic [address mac-address | interface type mod/num | vlan vlan-id]</p>
<p>查看CAM表大小使用命令：show mac address-table count</p>
<p><img src="/2022/01/20/19-Switch/1618214813472-12f54ac0-cbee-4779-a9bf-80819f072410.png" alt="img"></p>
<p>CAM (Content Addressable Memory) is memory that can be addressed by content, rather than a numeric memory address. You can look up the interface by presenting the memory with the MAC address. This is done in a single CPU cycle vs. the traditional programming of searching through a table, which will cost many CPU cycles.</p>
<h3 id="TCAM"><a href="#TCAM" class="headerlink" title="TCAM"></a>TCAM</h3><p>TCAM（Ternary Content Addressable Memory）是路由模块或路由器用于三层时转发所查的表，用于ip寻址，也用在ACL、QOS等情况下使用。（TCAM performs quick lookups based on search key and a mask that identifies which bits of the search key must be matched.while a TCAM looks up an entire set of similar records that match the “interesting” bits of a search key (the “interesting” bits are identified by the mask).）因为TCAM可以提供三种结果，0,1和无所谓（don’t care）。TCAM对于构建那些需要最长匹配的东西，比如IP路由表，非常有用。</p>
<p>查看TCAM表占用率的命令：show tcam counts；</p>
<h3 id="扩展阅读"><a href="#扩展阅读" class="headerlink" title="扩展阅读"></a>扩展阅读</h3><p>CAM和TCAM比传统意义上的DRAM内存要贵得多，因为它们的性能更强大，在普通PC上看不到它们的身影，只在专门做数据转发的设备，比如路由器或交换机上才会有它们。</p>
<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>CAM (Content Addressable Memory) VS TCAM (Ternary Content Addressable Memory)</p>
<h2 id="CAM-VS-TCAM"><a href="#CAM-VS-TCAM" class="headerlink" title="CAM VS TCAM"></a>CAM VS TCAM</h2><p>Multilayer switches forward frames and packets at wire speed by using ASIC hardware. Specific Layer 2 and Layer 3 components, such as routing tables or Access Control Lists (ACLs), are cached into hardware. Routing, switching, ACL and QoS tables are stored in a high-speed table memory so that forwarding decisions and restrictions can be made in high-speed hardware. Switches perform lookups in these tables for result information, such as to determine whether a packet with a specific destination IP address is supposed to be dropped according to an ACL.</p>
<p>Cisco Catalyst switches deploys these memory tables using specialized memory architectures, referred to as CAM and TCAM.</p>
<h2 id="CAM-Content-Addressable-Memory"><a href="#CAM-Content-Addressable-Memory" class="headerlink" title="CAM (Content Addressable Memory)"></a>CAM (Content Addressable Memory)</h2><p>CAM stands for <strong>Content Addressable Memory</strong> which is a special type of memory used by Cisco switches. In the case of ordinary RAM the IOS uses a memory address to get the data stored at this memory location, while with CAM the IOS does the inverse. It uses the data and the CAM returns the address where the data is stored. Also the CAM is considered to be faster than the RAM since the CAM searches the entire memory in one operation.</p>
<p>CAM tables provide only two results: 0 (true) or 1 (false). CAM is most useful for building tables that search on exact matches such as MAC address tables. The CAM table is the primary table used to make Layer 2 forwarding decisions. In the case of Layer 2 switching tables, the switch must find an exact match to a destination MAC address or the switch floods the packet out all ports in the VLAN.</p>
<p>The table is built by recording the source address and inbound port of all frames. As frames arrive on switch ports, the source MAC addresses are learned and recorded in the CAM table. The port of arrival and the VLAN are both recorded in the table, along with a timestamp. If a MAC address learned on one switch port has moved to a different port, the MAC address and timestamp are recorded for the most recent arrival port. Then, the previous entry is deleted. If a MAC address is found already present in the table for the correct arrival port, only its timestamp is updated.</p>
<p>When a frame arrives at the switch with a destination MAC address of an entry in the CAM table, the frame is forwarded out through only the port that is associated with that specific MAC address. The information a switch uses to perform a lookup in a CAM table is called a key. For example, a Layer 2 lookup would use a destination MAC address and a VLAN ID as a key.</p>
<p>To view the contents of the CAM table, you can use the following EXEC command:</p>
<p>Switch# show mac address-table dynamic [address <em>mac-address</em> | interface <em>type mod/num</em> | vlan <em>vlan-id</em>]The entries that have been dynamically learned will be shown. You can add the <strong>address</strong> keyword to specify a single MAC address, or the <strong>interface</strong> or <strong>vlan</strong> keywords to see addresses that have been learned on a specific interface or VLAN.</p>
<p>To see the CAM table’s size, use the <strong>show mac address-table count</strong> command.</p>
<p>The problem with CAM is that it can only do exact matches on ones and zeros (binary CAMs), and here comes TCAM.</p>
<h2 id="TCAM-Ternary-Content-Addressable-Memory"><a href="#TCAM-Ternary-Content-Addressable-Memory" class="headerlink" title="TCAM (Ternary Content Addressable Memory)"></a>TCAM (Ternary Content Addressable Memory)</h2><p>TCAM stands for <strong>Ternary Content Addressable Memory</strong> which can match a third state, which is any value. This makes TCAM a very important component of Cisco Layer 3 switches and modern routers, since they can store their routing table in the TCAMs, allowing for very fast lookups, which is considerably better than routing tables stored in ordinary RAM. TCAM is a specialized CAM designed for rapid table lookups.</p>
<p>TCAM provides three results: 0, 1, and “don’t care.” TCAM is most useful for building tables for searching on longest matches such as IP routing tables organized by IP prefixes. The TCAM table stores ACL, QoS and other information generally associated with upper-layer processing. As a result of using TCAM, applying ACLs does not affect the performance of the switch.</p>
<p>Most switches have multiple TCAMs so that both inbound and outbound security, as well as QoS ACLs, can be evaluated simultaneously or entirely in parallel with a Layer 2 or Layer 3 forwarding decision.</p>
<p>The term VMR (Value, Mask and Result) refers to the format of entries in TCAM. The “value” in VMR refers to the pattern that is to be matched; examples include IP addresses, protocol ports, DSCP values, and so on. The “mask” refers to the mask bits associated with the pattern and determines the prefix. The “result” refers to the result or action that occurs in the case where a lookup returns a hit for the pattern and mask.</p>
<p>This result might be a “permit” or “deny” in the case of a TCAM for ACLs, values for QoS policies in case of QoS or a pointer to an entry in the hardware adjacency table that contains the next-hop MAC rewrite information in the case of a TCAM used for IP routing.</p>
<p>To see the current TCAM resource usage, use the <strong>show tcam counts</strong> EXEC command. To see the current TCAM partitioning, you can use the <strong>show sdm prefer</strong> EXEC command.</p>
<p>Most of the traditional Layer 2 Cisco switches has only CAM for Layer 2 switching, while some Layer 2 Cisco switches has TCAM for QoS and not for routing, while layer 3 switches has the routing TCAM. CAM and TCAM are the most important parts of the so called ASICs that Cisco switches leverage for line-speed fast switching.</p>
<p>Catalyst switch architecture supports the ability to perform multiple lookups into multiple distinct CAM and TCAM regions in parallel. As a result of this ability to perform multiple lookups simultaneously, Catalyst switches do not suffer any performance degradation by enabling additional hardware-switching features such as QoS and IP ACL processing.</p>
<p>出自<a href="https://community.cisco.com/t5/networking-documents/cam-content-addressable-memory-vs-tcam-ternary-content/ta-p/3107938">这个帖子</a></p>
<p>CAM stands for Content Addressable Memory which is a special type of memory used by Cisco switches, in the case of ordinary RAM the IOS uses a memory address to get the data stored at this memory location, while with CAM the IOS does the inverse, it uses the data and the CAM returns the address where the data is stored, also the CAM is considered to be faster than the RAM since the CAM searches the entire memory in one operation.</p>
<p>The problem with CAM is that it can only do exact matches on ones and zeros (binary CAMs), and here TCAM (Ternary CAM) comes, since it can match a third state which is any, this makes TCAM a very important component of Cisco layer 3 switches and modern routers, since they can store their routing table in the TCAMs, allowing for very fast lookups, which is considerably better than routing tables stored in ordinary RAM.</p>
<p>CAM and TCAM are the most important parts of the so called ASICs that Cisco switches leverage for line-speed fast switching.</p>
<p>Well to keep it simple, a multilayer switch uses sets of TCAMs, each set of TCAMs are used for a certain feature (Routing, QoS, ACLs …), and it does parallel lookups to get all the required results using the VMR combination (Value, Mask and Result), these results can be permit and deny in the case of ACLs, values for QoS policies in case of QoS or pointers to a next-hop in the routing table in case of routing, most of the traditional layer 2 Cisco switches has only CAMs for only layer 2 switching, while some layer 2 Cisco switches has TCAMs for QoS and not for routing, while layer 3 switches has the routing TCAMs.</p>
<p>出自<a href="https://community.cisco.com/t5/switching/cam-vs-tcam/td-p/988524">这个帖子</a></p>
<h2 id="VLAN间路由"><a href="#VLAN间路由" class="headerlink" title="VLAN间路由"></a>VLAN间路由</h2><h3 id="单臂路由"><a href="#单臂路由" class="headerlink" title="单臂路由"></a>单臂路由</h3><p><img src="/2022/01/20/19-Switch/1618296871746-92611ec6-3546-4b12-8663-4724048bbb32.png" alt="img"></p>
<p>在二层环境下，一个VLAN就是一个广播，不同VLAN处于不同的广播域，一般也都是不同的逻辑子网，相互隔离无法相互访问，这样能起到隔绝广播的作用。但世纪网络中往往有VLAN之间需要相互访问的需求，例如一个公司不同的部门被划分到不同的VLAN中，这些部门之间也会有数据来往的需求，这时二层交换机就无法实现了，需要借助三层设备。最简单的办法就是使用路由器，最经典的解决方案就是单臂路由（router-on-a-stick）：</p>
<p><img src="/2022/01/20/19-Switch/1618296997059-b50631b1-91dc-496b-abf3-7a8d1a635a66.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618297213051-f20cb0e7-2d4e-46e3-a90a-9a4c60891323.jpeg" alt="img"></p>
<p>所谓的单臂路由（router-on-a-stick），就是在路由器的以太网口上（必须是百兆以上的），来承载VLAN之间的流量，让路由器和交换机之间跑一个Trunk，使用Dot1Q封装，这时候，为了让路由器的以太网口支持Dot1Q并识别承载VLAN流量，那么需要对物理接口进行子接口的划分，比如上图中划分了F0/0.1和F0/0.2两个子接口，分别承担不同VLAN的流量，并配置封装协议Dot1Q，同时为流量打上VLAN的Tag，这样一来，交换机和路由器之间起了一个Trunk，路由器的这两个子接口分别配置两个VLAN的网关IP，作为VLAN用户的网关。</p>
<p>配置方式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface F0/0</span><br><span class="line"> no shutdown</span><br><span class="line">interface F0/0.10</span><br><span class="line"> encapsulate dot1Q 10</span><br><span class="line"> ip address 192.168.10.254 255.255.255.0</span><br><span class="line"> no shutdown</span><br><span class="line">interface F0/0.20</span><br><span class="line"> encapsulate dot1Q 20</span><br><span class="line"> ip address 192.168.20.254 255.255.255.0</span><br><span class="line"> no shutdown</span><br></pre></td></tr></table></figure>

<p>encapsulate dot1Q 20表示F0/0.20属于VLAN20，encapsulate dot1Q 10表示F0/0.10属于VLAN10。</p>
<p>使用单臂路由能够解决VLAN数据间互访的问题，但也存在弊端，比如中间的Trunk 链路，也就是路由器和交换机这条链路，承载流量较大，因为流量需要二次进出，扩展性差，存在单点故障可能。</p>
<h3 id="园区网构架"><a href="#园区网构架" class="headerlink" title="园区网构架"></a>园区网构架</h3><p><img src="/2022/01/20/19-Switch/1618298412191-acf34f63-715b-4508-9dc1-2c0a647c0b59.png" alt="img"></p>
<p>过去，交换机基于硬件转发，路由基于软件转发，因此园区网更多采用交换网络设计，比如左图中的构架设计。</p>
<p>现今，路由已经几乎和交换一样快速，也能够基于硬件做转发，与此同时，路由的设计很好的解决了交换网络的二层环路问题，以及vlan的隔离问题，所以现在的园区网更多采用有图的设计。</p>
<h3 id="Switch-Virtual-Interfaces（SVI）"><a href="#Switch-Virtual-Interfaces（SVI）" class="headerlink" title="Switch Virtual Interfaces（SVI）"></a>Switch Virtual Interfaces（SVI）</h3><p><img src="/2022/01/20/19-Switch/1618300474133-19804cbd-1b4a-43c4-8dc8-41b85ce28e2a.png" alt="img"></p>
<p>下面来看看三层交换机是如何实现VLAN间的数据互访的，我们从这里为切入点，开始理解并部署三层交换机。我们知道二层交换机是可以实现二层交换的，它看的是二层的数据帧，对帧头的二层信息进行读取并且根据自己的CAM表进行转发。而三层交换机相当于在二层交换机的基础上，多了个路由模块，于是它就支持路由功能了：支持路由选择协议，支持三层数据的转发，支持IP路由查找，支持三层接口等等。</p>
<p>先来人事一下第一种三层接口，SVI，交换式虚拟接口，SVI中的V是Virtual，也就是虚拟的意思，也就是说它不是一个物理接口，当我们在交换机上创建了一个VLAN后，紧接着就可以创建一个与这个VLAN相对应的SVI接口，例如在三层交换机上穿件了一个VLAN10，那么VLAN10所对应的SVI接口就是Interface VLAN10或者叫SVI10这个三层接口。可以为这个三层SVI借口配置IP地址，配置的地址与VLAN10内的PC用户的IP地址为同一网段，那么这样一来，VLAN10内的用户就能够将网关指向这个SVI接口，当VLAN10的PC需要访问其他网段的数据时，这些PC就会将需要跨网段的数据交给三层的SVI10这个接口，由这个SVI接口再去做路由及数据转发这种三层才能完成的工作。在这个过程中，可以用单臂路由这个模型来类比。</p>
<p>上图中，在三层交换机上创建了两个VLAN，VLAN10和VLAN20，同时为两个VLAN的三层SVI接口分配了地址作为各自VLAN的用户网关，这样一来，这台交换机的路由表里就有了两个VLAN网段的路由。那么当两个VLAN之间要互访时，VLAN10的用户将数据丢给自己的网关，VLAN10的SVI接口，数据到了SVI10以后，三层交换机查表，发现目的IP是VLAN20所在的网段，因此将数据从VLAN20的SVI扔出去，最终到达目的地，VLAN20的PC上。</p>
<p>举个不是特别恰当的例子，可以把VLAN想象成一个独立的班级，PC是学生，SVI是班主任，当班级之间的学生（PC）相互通信的时候，由于都在一个班里边（同一个VLAN中），彼此都相互认识，如果要和别的班的同学通信，也就是跨网段通信，需要经过班主任去对接其他班级的班主任，因为同学之间不认识。</p>
<h3 id="三层交换机的端口"><a href="#三层交换机的端口" class="headerlink" title="三层交换机的端口"></a>三层交换机的端口</h3><h4 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="/2022/01/20/19-Switch/1618302381892-875363a2-f676-4e99-a377-0170714b9acd.png" alt="img"></p>
<p>总的来说，三层交换机包括两类端口，二层接口L2和三层接口L3：</p>
<ul>
<li>二层接口（Switchport）：二层接口包括了常见的Access mode和Trunk Mode，交换机的所有物理接口默认是二层接口，也就是Switchport。</li>
<li>三层接口：路由接口（no switchport或叫做routed port）、SVI接口。SVI是一个虚拟接口，而routed port是一个和路由器上接口相同的物理接口。三层交换机支持将物理接口变为一个类似路由器物理接口的三层接口，具体的配置就是进入接口以后，使用‘no switchport’命令，这样该接口就变为了一个L3的路由接口，可以给该接口配置IP地址，就像操作路由器的接口一样类对待它。</li>
</ul>
<h4 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">开启三层交换机的路由功能</span><br><span class="line">Switch(config)# ip routing </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">关闭三层交换机的路由功能</span><br><span class="line">Switch(config)#no ip routing </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">创建VLAN并命名</span><br><span class="line">Switch(config)# vlan 10 </span><br><span class="line">Switch(config-vlan)# name XXX</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置VLAN对应的SVI接口</span><br><span class="line">witch(config)#interface Vlan10</span><br><span class="line">Switch(config-if)#ip address 192.168.10.254 255.255.255.0</span><br><span class="line">Switch(config-if)#no shutdown</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置三层接口</span><br><span class="line">Switch(config)# interface fast 0/1</span><br><span class="line">Switch(config-if)# no switchport </span><br><span class="line">Switch(config-if)# ip address 192.168.255.1 255.255.255.0</span><br><span class="line">Switch(config-if)# no shutdown</span><br></pre></td></tr></table></figure>

<h4 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/2022/01/20/19-Switch/1618365566128-bea7494e-0693-41f3-9e7b-819797709fe2.png" alt="img"></p>
<p>两台PC通过两台二层交换机接入网络，二层交换机上联三层交换机，这是一个在小型网络中常见的拓扑结构，二层交换机放在楼层配线间，通过光纤和担负核心职责的三层交换机相连。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">L2-SWITCH2:</span><br><span class="line">vlan 10</span><br><span class="line">exit</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport access vlan 10</span><br><span class="line"> switchport mode access</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L2-SWITCH3:</span><br><span class="line">vlan 20</span><br><span class="line">exit</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport access vlan 20</span><br><span class="line"> switchport mode access</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L3-SWITCH:</span><br><span class="line">vlan 10,20</span><br><span class="line">exit</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> switchport trunk encapsulation dot1q</span><br><span class="line"> switchport mode trunk</span><br><span class="line">!</span><br><span class="line">interface Vlan10</span><br><span class="line"> ip address 192.168.10.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Vlan20</span><br><span class="line"> ip address 192.168.20.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">L3_SWTICH#show ip route</span><br><span class="line">Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP</span><br><span class="line">       D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area</span><br><span class="line">       N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2</span><br><span class="line">       E1 - OSPF external type 1, E2 - OSPF external type 2</span><br><span class="line">       i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2</span><br><span class="line">       ia - IS-IS inter area, * - candidate default, U - per-user static route</span><br><span class="line">       o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP</span><br><span class="line">       a - application route</span><br><span class="line">       + - replicated route, % - next hop override, p - overrides from PfR</span><br><span class="line"></span><br><span class="line">Gateway of last resort is not set</span><br><span class="line"></span><br><span class="line">      192.168.10.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.10.0/24 is directly connected, Vlan10</span><br><span class="line">L        192.168.10.254/32 is directly connected, Vlan10</span><br><span class="line">      192.168.20.0/24 is variably subnetted, 2 subnets, 2 masks</span><br><span class="line">C        192.168.20.0/24 is directly connected, Vlan20</span><br><span class="line">L        192.168.20.254/32 is directly connected, Vlan20</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VPC5:</span><br><span class="line">VPCS&gt; ip 192.168.20.1 192.168.20.254</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">VPC4:</span><br><span class="line">VPCS&gt; ip 192.168.10.1 192.168.10.254</span><br><span class="line">VPCS&gt; trace 192.168.20.1</span><br><span class="line">trace to 192.168.20.1, 8 hops max, press Ctrl+C to stop</span><br><span class="line"> 1   192.168.10.254   0.575 ms  0.550 ms  0.702 ms</span><br><span class="line"> 2   *192.168.20.1   2.737 ms (ICMP type:3, code:3, Destination port unreachable)</span><br></pre></td></tr></table></figure>

<p>PC上配置好IP地址和网关；两个二层交换机上分别创建属于这个交换机的VLAN，然后就将连接PC的接口配置成access模式并将接口划入相应的VLAN，两个二层交换机不配置对方交换机的VLAN是没问题的，也就是说SWITCH2上只有VLAN10，SWTICH3上只有VLAN20不影响数据通信。上联L3交换机的接口配置成Trunk，使得可以通行多VLAN；三层交换机上创建VLAN10和20，然后进入这两个VLAN的SVI接口配置IP地址（interface VLAN10，ip address X.X.X.X），并将下联到L2交换机的接口配置成Trunk以便通行多VLAN。</p>
<p>从L3交换机的路由表中可以看出，配置完毕以后它已经有了10.0和20.0网段的路由，因此可以转发二层交换机无法转发的数据。从192.168.10.1这台PC的Traceroute中也能看出，发往192.168.20.1的数据先发给了所在的10.0网段的网关192.168.10.254，这个10.254就是L3交换机上VLAN10的SVI这个三层接口，然后发给了目的地址，所以整体的数据走向是：</p>
<p><img src="/2022/01/20/19-Switch/1618369005307-216c36d8-cb06-4191-acf4-977da4901f3f.png" alt="img"></p>
<p>假设所有设备中的MAC地址表都为空，PC1的数据通过Access接口发送到上联的二层交换机以后，会打上Access端口的PVID也就是VLAN10的TAG，然后交换机对数据解封装，将PC1的MAC地址和接口的对应信息放入CAM表中，根据数据帧中的目的MAC地址，查询本地MAC地址表，由于MAC地址表为空，所以会发送ARP广播来查找网关的MAC地址，这个广播会经过Trunk链路打上VLAN10的TAG，然后发送给L3交换机。L3交换机收到带VLAN10TAG的广播以后，会回复interface VLAN10的MAC地址给L2交换机，然后L2交换机将发送到20.1的数据帧重新封装二层地址（源地址为连接PC端口的MAC地址，目的为网关的MAC地址）：</p>
<p><img src="/2022/01/20/19-Switch/1618370329311-321839e4-b1fe-4b45-b383-5f0486e59ac7.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618370373063-dc157d37-4608-4d9d-9dc0-3818ea2fcf8f.png" alt="img"></p>
<p>L2交换机将重新封装好的数据发送给L3交换机（此时数据之前在进入Access口时打上了VLAN10的TAG所以Trunk不需要重新打标签），L3交换机收到数据后解封装二层，发现是发给自己VLAN10的SVI接口的，于是继续将数据解封装至三层，发现目标IP地址为192.168.20.1，在自己的VLAN20的Interface接口上，接下来发送ARP查找对应的MAC地址，发送给右边的L2交换机，然后L2-SWTICH3将它的E0/1口的MAC地址回复给广播ARP，L3Switch获知MAC地址后重新封装数据包，交给L2-SWTICH3。</p>
<p>这里注意，L3的access口并不会发送ARP的广播，但Trunk口会。</p>
<p>补充帖子：</p>
<p><a href="https://community.cisco.com/t5/switching/switch-svi/td-p/2386970">https://community.cisco.com/t5/switching/switch-svi/td-p/2386970</a></p>
<p><a href="https://community.cisco.com/t5/switching/l2-l3-vlan/td-p/990201">https://community.cisco.com/t5/switching/l2-l3-vlan/td-p/990201</a></p>
<h2 id="交换机的管理"><a href="#交换机的管理" class="headerlink" title="交换机的管理"></a>交换机的管理</h2><h3 id="二层交换机的管理"><a href="#二层交换机的管理" class="headerlink" title="二层交换机的管理"></a>二层交换机的管理</h3><h4 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h4><p>在一个园区网中，数量最多的设备一般是交换机，其中二层交换机的数量居多，二层交换机在典型的三层网络构架中属于“接入层”主要任务是为终端的PC和用户提供接入，同时划分VLAN隔离广播域，再或者运行STP来提供二层的放环机制。一个中小型的园区网，二层交换机一般都有几十上百台，这些设备在客户现场被拆箱后，一般是由工程师现场用Console线缆一台台的调试，这些交换机在调试好之后，会被安装到客户现场的各个机房或弱电配线间去，一切妥当后就正式上线运行了。在设备上线后，如果需要变更设备的配置，管理这些就交换机怎么办？不可能拿着笔记本一个配线间一个配线间的去跑，可以通过Telnet或者其他方式来远程管理，只要三层可达，就能Telnet到设备。</p>
<p>二层交换机无法识别三层报文，它根本不会去看三层的报头，但这并不影响二层交换机自己拥有一个IP地址。在路由器上，我们始终是给路由器的物理接口配置IP地址，而二层交换机，是在Interface VLAN口上配置IP地址，也就是SVI虚拟接口，跟VLAN对应的一个逻辑的虚拟的接口。一台二层交换机只能给一个VLAN接口分配IP地址，但二层交换机的‘SVI’地址并不是一个完全意义上的SVI地址，完全意义上的SVI接口要能执行三层策略，比如路由、ACL等，而二层交换机的‘SVI’只是个管理接口，没有那些功能。</p>
<p><img src="/2022/01/20/19-Switch/1618390415484-756e3e26-71df-44fb-ade3-5bd9143439b5.png" alt="img"></p>
<p>如上图左侧，PC想要Telnet交换机，首先PC要能PING通交换机，其次交换机上要激活VTP并配置密码。那么我们在二层交换机上创建一个VLAN10，将F0/1接口划入VLAN10，同时给二层交换机的VLAN10逻辑接口配置一个IP地址，与PC在同一网段。这样一来PC就能访问到交换机了，可问题来了，这样一来，PC与交换机就在同一网段同一个VLAN了，万一下面有PC配置的IP地址与交换机配置的管理地址有冲突就麻烦了，因此我们可以考虑给交换机划分一个单独的VLAN用于管理这些交换机，这个VLAN适用于整个交换网络，统一的VLAN统一的IP规划，它就是管理VLAN，因此管理VLAN并不是一个特定的VLAN，更不是VLAN1，这是很多人的误解，一般情况下，我们会使用一个较为‘生僻的’VLAN ID和IP编制，例如VLAN255，以及网段192.168.255.0/24。</p>
<p>问题来了，给交换机单独一个管理VLAN固然可以起到与用户VLAN隔离的作用，但这样一来，用户就无法访问到交换机了，因为同一交换机上不同的VLAN之间是隔绝广播域无法访问的，就需要借助三层设备，比如路由器或三层交换机了，与此同时，由于二层交换机没有路由功能，无法像路由器那样拥有一个IP路由表，因此还需要给交换机配置一个默认网关，就像用路由器模拟PC那样。</p>
<h4 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h4><p><img src="/2022/01/20/19-Switch/1618390845477-03be0fd1-b3e2-4f40-90a9-ed0b55565545.png" alt="img"></p>
<p>交换机下联 2 台 PC，又连接了一台路由器。路由器作为内网 VLAN10、VLAN20 用户的网关。交换机增加一个 VLAN255用于其自身的设备管理，交换机的管理 IP 为 192.168.255.1，网关在路由器上； 交换机创建 VLAN10、VLAN20，这是用户 VLAN，是 PC 用户的 VLAN；路由器 FE0/0 口划分子接口做单臂，作为 VLAN10、VLAN20 及 VLAN255 的网关；要求 VLAN10、VLAN20 之间的用户能够互访，同时只允许 VLAN10 的用户 Telnet 交换机进  行设备的管理。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)#no ip routing</span><br><span class="line">Switch(config)#vlan 10,20,255</span><br><span class="line">Switch(config-vlan)#exit</span><br><span class="line">Switch(config)#int e0/1</span><br><span class="line">Switch(config-if)#switchport mode access</span><br><span class="line">Switch(config-if)#switchport access vlan 10</span><br><span class="line">Switch(config-if)#int e0/2</span><br><span class="line">Switch(config-if)#switchport mode access</span><br><span class="line">Switch(config-if)#switchport access vlan 20</span><br><span class="line">Switch(config-if)#exit</span><br><span class="line">Switch(config)#int e0/3</span><br><span class="line">Switch(config-if)#switchport trunk encapsulation dot1q</span><br><span class="line">Switch(config-if)#switchport mode trunk</span><br><span class="line">Switch(config-if)#exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Switch(config)#line vty 0 4</span><br><span class="line">Switch(config-line)#password CISCO</span><br><span class="line">Switch(config-line)#login</span><br><span class="line">Switch(config-line)#exit</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">interface Vlan255</span><br><span class="line"> ip address 192.168.255.1 255.255.255.0</span><br><span class="line">ip default-gateway 192.168.255.254</span><br></pre></td></tr></table></figure>

<p>由于EVE的交换机都是三层，所以这里用no ip routing将三层交换机的路由功能关闭，变为二层交换机，如果不配置该命令，ip default-gateway指定的缺省网关是无效的，此时也可以使用ip route 0.0.0.0 0.0.0.0 的方式来代替ip default-gateway这条命令，但必须注意，ip default-gateway，是给交换机自己用的，不是为了底下接入的PC配置的网关。接下来看路由器的配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> no shutdown</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0.10</span><br><span class="line"> encapsulation dot1Q 10</span><br><span class="line"> ip address 192.168.10.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0.20</span><br><span class="line"> encapsulation dot1Q 20</span><br><span class="line"> ip address 192.168.20.254 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0.255</span><br><span class="line"> encapsulation dot1Q 255</span><br><span class="line"> ip address 192.168.255.254 255.255.255.0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">GW#show ip interface brief</span><br><span class="line">Interface                  IP-Address      OK? Method Status                Protocol</span><br><span class="line">Ethernet0/0                unassigned      YES unset  up                    up</span><br><span class="line">Ethernet0/0.10             192.168.10.254  YES manual up                    up</span><br><span class="line">Ethernet0/0.20             192.168.20.254  YES manual up                    up</span><br><span class="line">Ethernet0/0.255            192.168.255.254 YES manual up                    up</span><br></pre></td></tr></table></figure>

<p>GW的E0/0接口一定要配置no shutdown命令否则子接口也无法打开。E0/0.10是VLAN10的网关，E0/0.20是VLAN20的网关，E0/0.255是VLAN255的网关。在实际部署中，如果直接将交换机暴露在网络中，所有内网PC都能随意登陆是有风险的，我们还可以在交换机上增加如下配置，来限制交换机管理的网段，例如只为让192.168.10.0/24网段的用户登陆管理交换机：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(router)# access-list 1 permit 192.168.10.0 0.0.0.255 </span><br><span class="line">Switch(router)# line vty 0 4 </span><br><span class="line">Switch(router-line)# access-class 1 in </span><br></pre></td></tr></table></figure>

<h3 id="三层交换机的管理"><a href="#三层交换机的管理" class="headerlink" title="三层交换机的管理"></a>三层交换机的管理</h3><p><img src="/2022/01/20/19-Switch/1618555135173-f02c6ec9-4568-4cd2-bc7f-45e82964c782.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618555341872-b690794a-3ad5-419a-b9d9-26825711a474.png" alt="img"></p>
<p>二层交换机配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)# vlan 10，20,255</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line">Switch(config)# interface fast0/1 </span><br><span class="line">Switch(config-if)# switchport access vlan 10 </span><br><span class="line">Switch(config)# interface fast0/2</span><br><span class="line">Switch(config-if)# switchport access vlan 20 </span><br><span class="line">Switch(config)# interface fast0/15</span><br><span class="line">Switch(config-if)# switchport trunk encapsulate dot1Q</span><br><span class="line">Switch(config-if)# switchport mode trunk</span><br><span class="line">Switch(config)# interface vlan 255</span><br><span class="line">Switch(config-if)#ip address 192.168.255.1 255.255.255.0</span><br><span class="line">Switch(config)# ip default-gateway 192.168.255.254</span><br></pre></td></tr></table></figure>

<p>核心交换机配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Switch(config)# vlan 10，20,255</span><br><span class="line">Switch(config-if)# exit</span><br><span class="line">Switch(config)# interface fast0/15</span><br><span class="line">Switch(config-if)# switchport trunk encapsulate dot1Q</span><br><span class="line">Switch(config-if)# switchport mode trunk</span><br><span class="line">Switch(config)# interface vlan 10</span><br><span class="line">Switch(config-if)#ip address 192.168.10.254 255.255.255.0</span><br><span class="line">Switch(config)# interface vlan 20</span><br><span class="line">Switch(config-if)#ip address 192.168.20.254 255.255.255.0</span><br><span class="line">Switch(config)# interface vlan 2550</span><br><span class="line">Switch(config-if)#ip address 192.168.10.254 255.255.255.0</span><br></pre></td></tr></table></figure>

<h2 id="冗余网关技术"><a href="#冗余网关技术" class="headerlink" title="冗余网关技术"></a>冗余网关技术</h2><p>一旦网关或关键节点出现故障，将对业务造成灾难性的故障，因此应运而生了首跳网关冗余技术，常见的有HSRP、VRRP和GLBP，相互之间的区别如下：</p>
<p><img src="/2022/01/20/19-Switch/1618556451542-3e276964-def5-46cf-a0e6-050382f2afbd.png" alt="img"></p>
<h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>由于HSRP和GLBP都是思科私有技术，这里只写VRRP这种公有技术。</p>
<p>利用VRRP（Virtual Router Redundancy Protocol，虚拟路由冗余协议）协议，一组路由器可以协同工作，但只有一个处于激活状态，在一个VRRP组内的多个路由器公用一个虚拟IP地址，该地址被作为局域网内所有主机的缺省网关地址，VRRP协议决定哪个路由器被激活，被激活的路由器负责收发过来的数据包并进行路由。</p>
<p><img src="/2022/01/20/19-Switch/1618556886952-3c05fda8-f129-4779-9a31-d434a40fd947.png" alt="img"></p>
<ul>
<li><p>VRRP路由器：运行VRRP协议的路由器，一台VRRP路由器可以同时参与到多个VRRP组中，在不同的组中，一台VRRP路由器可以充当不同的角色；</p>
</li>
<li><p>VRRP组（VRID）：由多个路由器组成，属于同一个VRRP组的VRRP路由器相互交换信息，每一组由一个VRID标识；</p>
</li>
<li><p>虚拟路由器：对每一个VRRP组，抽象出来的一个逻辑路由，该路由器充当网络用户的网关；</p>
</li>
<li><p>虚拟IP、MAC地址：用于标识虚拟的路由器，该地址实际上是用户的默认网关，两个地址都是虚拟的；</p>
</li>
<li><p>Master路由器：在VRRP组中实际转发数据包的路由器，在每一个VRRP组中，仅有Master响应对虚拟IP地址的ARP请求；</p>
</li>
<li><p>Backup路由器：在VRRP组中处于监听状态的路由器，一旦Master路由器出现故障，Backup路由器就开始接替所有的工作；</p>
</li>
<li><p>初始状态（Initialize）：路由器杠杠启动时进入此状态，通过VRRP报文交互数据后进入其他状态；</p>
</li>
<li><p>活动状态（Master）：VRRP组中的路由器通过VRRP报文交换后确定的当前转发数据包的一种状态；</p>
</li>
<li><p>备份状态（Backup）：VRRP组中的路由器通过VRRP报文交换后确定的处于监听的一种状态；</p>
</li>
</ul>
<h3 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h3><p>VRRP路由器之间使用组播进行消息传输。报文使用的组播地址是224.0.0.18，VRRP报文承载在IP报文之上，使用协议号112。</p>
<p><img src="/2022/01/20/19-Switch/1618557911808-c3096179-e87b-49a9-967c-a74b8a82280a.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618558019697-822e7020-7a62-442d-ad4a-d5063d3d7f41.png" alt="img"></p>
<h3 id="计时器"><a href="#计时器" class="headerlink" title="计时器"></a>计时器</h3><ul>
<li>Advertisement Interval：主路由器按照Advertisement Interval定义的时间间隔来发送VRRP通告报文，默认为1秒，在备份路由器上可以手动配置，但必须与主路由器相同，也可以从主路由器学习到这个时间间隔；</li>
<li>Master Down Timer：Backup路由器认为Master路由器Down掉的时间间隔，默认情况下为3*Hello+Skew time【skew time=（(256-pri)/256）ms】，这个时间确保优先级更好的备份路由器成为新的Master路由器；</li>
</ul>
<h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/2022/01/20/19-Switch/1618558675533-97ac5d28-50e1-4451-b9f9-e190e5a91c78.png" alt="img"></p>
<ul>
<li>Preempt抢占模式，主要用于保证更高优先级的路由器在接入网络时成为活动路由器；如果关闭抢占模式，高优先级的备份路由器不会主动成为活动路由器，即使活动路由器优先级较低，只有当活动路由器实效时，备份路由器才会成为主路由器；默认情况下，VRRP抢占模式都是开启的；</li>
<li>Track：监视某个接口，并根据所监视接口的状态动态的调整本地路由器的优先级。</li>
</ul>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p><img src="/2022/01/20/19-Switch/1618559064972-0e168f67-152e-4a29-915f-1e3180e1dfe7.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#interface F1/0</span><br><span class="line">R1(config-if)#ip address 192.168.1.253 255.255.255.0</span><br><span class="line">R1(config-if)#vrrp 1 ip 192.168.1.254</span><br><span class="line">R1(config-if)#vrrp 1 priority 105</span><br><span class="line">R1(config-if)#vrrp 1 preempt</span><br><span class="line">R1(config-if)#vrrp 1 track e0/0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2(config)#interface F1/0</span><br><span class="line">R2(config-if)#ip address 192.168.1.252 255.255.255.0</span><br><span class="line">R2(config-if)#vrrp 1 ip 192.168.10.254</span><br><span class="line">R2(config-if)#vrrp 1 preempt</span><br><span class="line">R2(config-if)#vrrp 1 track e0/0</span><br></pre></td></tr></table></figure>

<ul>
<li><p>vrrp ip：用于激活VRRP协议，如果配置的VRRP组地址与接口的实际地址相同，那么该路由器将具有最高优先级，成为Master；</p>
</li>
<li><p>vrrp priority：用于设定端口的VRRP优先级，具有最高优先级的成员将成为激活的路由器（假设设置为优先级的方式）；</p>
</li>
<li><p>vrrp timers：用预设定Hello包之间的时间间隔（Hello time）以及路由器在多长的一个时间段内没有从VRRP邻居收到Hello包就判定该邻居已经关闭（Hold time）；</p>
</li>
<li><p>vrrp preempt：表明当本地路由器的备份优先级超过当前激活路由器时，他就将接管控制权，成为激活路由器；</p>
</li>
<li><p>vrrp track：用于设置允许路由器端口根据另一端口的可用性修改自己的VRRP优先级；</p>
</li>
</ul>
<h1 id="EtherChannel"><a href="#EtherChannel" class="headerlink" title="EtherChannel"></a>EtherChannel</h1><h2 id="协议概述-1"><a href="#协议概述-1" class="headerlink" title="协议概述"></a>协议概述</h2><p>为了适应园区网业务的发展，速率的提高，我们可以采用多种方式提高园区网络中的数据传输速度：</p>
<ul>
<li><p>能够提供更多带宽；</p>
</li>
<li><p>将相同的链路逻辑上聚合到一起；</p>
</li>
<li><p>逻辑上聚合到一起的端口看起来像是一个逻辑上的端口；</p>
</li>
<li><p>可以提供冗余和负载均衡；</p>
</li>
<li><p>三层接口和二层接口均可以捆绑；</p>
</li>
<li><p>Port-channel接口一旦建立完毕后，就形成了一个逻辑的接口，后续针对该接口的配置在Port-channel中完成；</p>
</li>
<li><p>Port-channel不能称为SPAN的目的接口；</p>
</li>
<li><p>隶属于同一个Port-channel的物理接口要有相同的speed、duplex、接口模式（access、trunk），如果是trunk模式那么Native vlan和allowed vlan需相同，如果是access模式那么所属vlan需相同；</p>
</li>
<li><p>有PAgP和LACP两种协议，其中PAgP是思科私有协议，LACP是公有协议；</p>
</li>
</ul>
<p><img src="/2022/01/20/19-Switch/1618561498229-21564692-be92-4204-9e54-7f4c9c3c0dc9.jpeg" alt="img"></p>
<h2 id="PAgP相关知识"><a href="#PAgP相关知识" class="headerlink" title="PAgP相关知识"></a>PAgP相关知识</h2><p>模式：</p>
<p><img src="/2022/01/20/19-Switch/1618561592678-681b43c6-39b0-4cf1-a92a-6a30551abbb0.png" alt="img"></p>
<p><img src="/2022/01/20/19-Switch/1618561604175-b365237b-7537-4f8a-b70f-547ba8db6778.png" alt="img"></p>
<h2 id="LACP相关知识"><a href="#LACP相关知识" class="headerlink" title="LACP相关知识"></a>LACP相关知识</h2><p><img src="/2022/01/20/19-Switch/1618561630034-fb7d3be4-bb3c-4479-bfd8-634180d58821.png" alt="img"></p>
<h2 id="二层捆绑配置"><a href="#二层捆绑配置" class="headerlink" title="二层捆绑配置"></a>二层捆绑配置</h2><p><img src="/2022/01/20/19-Switch/1618562143625-05e72743-b484-407c-bcdc-aab415879c75.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sw1(config)#interface range F0/1-2</span><br><span class="line">Sw1(config-if-range)#switchport</span><br><span class="line">！将接口配置为二层</span><br><span class="line">Sw1(config-if-range)#switchport trunk encapsulation dot1q</span><br><span class="line">！封装trunk协议为dot1q</span><br><span class="line">Sw1(config-if-range)#switchport mode trunk</span><br><span class="line">!设置接口为trunk</span><br><span class="line">Sw1(config-if-range)#channel-protocol pagp/lacp</span><br><span class="line">Sw1(config-if-range)#channel-group 1 mode desirable</span><br><span class="line">配置etherchannel，ID为1，模式为desirable</span><br><span class="line">！</span><br><span class="line">查看命令为show etherchannel 1 summary</span><br></pre></td></tr></table></figure>

<h2 id="三层捆绑配置"><a href="#三层捆绑配置" class="headerlink" title="三层捆绑配置"></a>三层捆绑配置</h2><p><img src="/2022/01/20/19-Switch/1618562315733-a1acc9c2-1f3f-4aae-8041-bb67fe1dfeb4.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sw1(config)#interface range F0/1-2</span><br><span class="line">Sw1(config-if-range)#no switchport</span><br><span class="line">Sw1(config-if-range)#no ip address</span><br><span class="line">Sw1(config-if-range)#channel-group 1 mode desirable</span><br><span class="line">Sw1(config-if-range)#no shutdown</span><br><span class="line">Sw1(config)#interface port-channel 1</span><br><span class="line">Sw1(config-if)#ip address 172.16.10.1 255.255.255.0</span><br><span class="line">Sw1(config-if)#no sh</span><br><span class="line"></span><br><span class="line">查看命令为show ethernet 1 summary</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡配置"><a href="#负载均衡配置" class="headerlink" title="负载均衡配置"></a>负载均衡配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Sw1(config)#Port-channel load-balance XX</span><br></pre></td></tr></table></figure>

<p>Etherchannel支持在同一个port-channel的链路中执行负载均衡，负载均衡动作可以基于MAC、端口、IP（源IP，目的IP或两者），默认的负载均衡行为是源目ip地址（src-dst-ip）</p>
<h1 id="二层安全"><a href="#二层安全" class="headerlink" title="二层安全"></a>二层安全</h1><h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://blog.51cto.com/9315074/1680082">STP生成树协议的分析总结</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/spanning-tree-protocol-stp/">Spanning Tree Protocol (STP) 生成树协定</a></p>
<p><a href="https://blog.csdn.net/jiao424525707/article/details/89493103">stp中优先级为什么是4096的倍数？</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/rapid-spanning-tree-protocol-rstp/">Rapid Spanning Tree Protocol (RSTP) 快速生成树协定</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/multiple-spanning-tree-protocol-mstp/">Multiple Spanning Tree Protocol (MSTP) 多重生成树协定</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>20-Multicast</title>
    <url>/2022/01/20/20-Multicast/</url>
    <content><![CDATA[<p>我们可以为网络选择三种类型的流量：</p>
<ol>
<li>单播；</li>
<li>广播；</li>
<li>组播；</li>
</ol>
<p>如果需要将数据，从一个源设备发送到一个终端设备时，使用单播；如果需要将数据，从一个源设备发送给所有其他设备时，使用广播。</p>
<p>如果需要将数据，从一个源设备发送给一组但不是所有设备时，应该使用组播。</p>
<h1 id="组播VS广播VS单播"><a href="#组播VS广播VS单播" class="headerlink" title="组播VS广播VS单播"></a>组播VS广播VS单播</h1><p>为什么要使用组播而不是广播或单播呢？让我们来举个例子，假设你要在网络中将一部电影播放给其他人的，看看这时使用单播、广播和组播有什么区别，<strong>先看单播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622272190582-da2dc063-4690-4fed-9d0e-98b8c8149a0a.png" alt="img"></p>
<p>在上图的小型网络中使用单播播放电影的话，一台服务器为四台终端播放，两台终端在同一网段中，另外两台终端在其他网段中，两个路由器之间的带宽为30Mbit。</p>
<p>给单个终端串流视频需要6Mbps的带宽，给4个终端播放视频意味着需要24Mbps的流量，在使用单播的情况下，每增加一个用户就会需要更多的带宽。如果在右侧H3和H4的网段内出现大量的用户，那么两台路由器之间的30Mbit带宽是无法满足太多设备同时串流的需求的。</p>
<p>从上面的例子能够看出，单播的劣势就是它不可扩展，优势在于配置较为简单。</p>
<p><strong>现在来看广播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622449819852-bbc587f9-1c22-4240-a904-ac59544f5498.png" alt="img"></p>
<p>如果我们使用广播来串流视频，那么服务器的负载会小很多，服务器只需要发送一次数据即可。问题在于只有广播域内的用户能够收到，而广播域之外的的其他用户无法收到，比如上图中广播域内的H1和H2可以收到广播的串流，而另一个广播域的H3和H4则无法收到。</p>
<p><strong>最后来看组播：</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622450406809-837fed5c-4578-44b1-beca-4357f751f59a.png" alt="img"></p>
<p>组播在视频串流这种场景下的效果要好得多，不管有多少台设备需要串流，只需要发送一次数据即可。使用组播不仅可以降低服务器的负载，也能降低对网络带宽的消耗。</p>
<p>使用单薄时，用户越多，对服务器和网络的负载要求越高，而使用单薄的话则没有变化：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622450516798-54021796-64da-4165-9231-4d734c88acf9.png" alt="img"></p>
<p>既然单播的效率如此之高，互联网中的视频巨头，比如优酷、YouTube用的就是这种方式来给用户服务的吗？并不是，互联网中的组播并未真正部署过，这视频巨头用的依旧是单播，比如CDN，互联网中唯一能用到组播的地方就是IPTV。</p>
<h1 id="组播定义"><a href="#组播定义" class="headerlink" title="组播定义"></a>组播定义</h1><p>组播，Multicast，用来将数据发送给一组特定的网络设备或终端，这些设备可以在不同的网段中，这些设备称之为一个组播组。组播在传输时，主机只发送一份数据，这份数据的目的地址为组播组的地址。组播组中的所有成员都可以接收到同样的数据拷贝，这个数据拷贝通过路由器进行复制分发，并且只有组播组内的设备可以接收该数据。由于每个分支只发送一份报文，所以网络规模的增大不会额外增加网络的负担。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622462093382-c8ac3547-e875-4287-acad-0a2ec29afc50.png" alt="img"></p>
<p><strong>组播的优势为：</strong></p>
<ul>
<li>降低网络流量；</li>
<li>降低服务器的负载；</li>
</ul>
<p>组播的不足为：</p>
<ul>
<li><p>因为组播只支持UDP，所以所有UDP的缺点它都有，比如因为UDP是尽力投递，不能确保数据一定会发送到所以不可靠，没有拥塞机制，报文可能会错乱等；</p>
</li>
<li><p>组播报文的复制使得路由器的资源消耗增加；</p>
</li>
<li><p>可控性差，用户管理困难，存在安全问题，因为用户可以随意加入某个组播组而无需密码；</p>
</li>
</ul>
<p><strong>组播的使用场景为：</strong></p>
<ul>
<li><p>多媒体会议；</p>
</li>
<li><p>任何的‘单点到多点’应用；</p>
</li>
<li><p>金融应用；</p>
</li>
<li><p>远程教学等；</p>
</li>
</ul>
<h1 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a>组播地址</h1><p>组播使用D类IP地址，以1110开头，组播范围为224.0.0.0——239.255.255.255。</p>
<p>各个地址范围段含义如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622462486090-41ec1dee-4a5f-4892-b38b-cf30c023a9d5.png" alt="img"></p>
<table>
<thead>
<tr>
<th>起始地址</th>
<th>终止地址</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.0</td>
<td>224.0.0.255</td>
<td>永久地址组，除了224.0.0.0做保留不分配以外，其他地址提供给路由协议、拓扑查找和协议维护等使用，也就是预先留给那些‘well know’的协议使用，比如OSPF建立邻居使用224.0.0.5和224.0.0.6。</td>
</tr>
<tr>
<td>224.0.1.0</td>
<td>224.0.1.255</td>
<td>公用组播地址，可以用于互联网使用。</td>
</tr>
<tr>
<td>224.0.2.0</td>
<td>238.255.255.255</td>
<td>用户可用的组播地址，也就是临时地址组，全网范围内有效。</td>
</tr>
<tr>
<td>239.0.0.0</td>
<td>239.255.255.255</td>
<td>本地管理组地址，仅在本地管理域内有效，使用本地管理组地址可以灵活定义组播的范围，以实现不同组播域之间的地址隔离，从而有助于在不同组播域内重复使用相同的组播地址而不会引起冲突。</td>
</tr>
</tbody></table>
<p>几个常用的组播地址如下：</p>
<table>
<thead>
<tr>
<th>地址</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>224.0.0.1</td>
<td>子网上所有主机，包括路由器。</td>
</tr>
<tr>
<td>224.0.0.2</td>
<td>子网上所有路由器。</td>
</tr>
<tr>
<td>224.0.0.5</td>
<td>所有OSPF路由器</td>
</tr>
<tr>
<td>224.0.0.6</td>
<td>OSPF DR路由器</td>
</tr>
<tr>
<td>224.0.0.9</td>
<td>RIP-2路由器</td>
</tr>
<tr>
<td>224.0.0.25</td>
<td>所有的交换机</td>
</tr>
<tr>
<td>224.2.0.0-224.2.255.255</td>
<td>多媒体会议呼叫</td>
</tr>
</tbody></table>
<h1 id="组播MAC地址映射"><a href="#组播MAC地址映射" class="headerlink" title="组播MAC地址映射"></a>组播MAC地址映射</h1><p>封装数据的时候，除了有源目的IP地址以外，还要封装源目的MAC地址，上面已经说了组播IP地址的分类，那么如何封装组播的MAC地址呢？MAC地址为48位：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622517381383-4df18c2e-f726-4a40-ac07-67c644a009a9.png" alt="img"></p>
<p>从上图中可以看出，第一个八位组中，有一位保留，用于标识MAC地址是用于组播还是广播，当数据为单播时，这位置0，当数据为广播或组播时，该位置1。在二层也有保留给组播使用的MAC地址段，就是01-00-5E开头的MAC地址段，也就是说组播的MAC地址一定是以01:00:5e开头的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622517702661-49cc2169-6258-426c-96fb-76435c561b44.png" alt="img"></p>
<p>前三个八位组已经规定好，也就是前24bit已经规定好不能更改了，第25bit规定了必须是0，所以48-24-1=23，也就是说后23bit可以随意使用，前24位成为‘组织唯一标识符’，英文是Organizationally Unique Identifier，简称OUI，会统一为不同的组织\公司分配不同的值，后24bit分配给具体的设备使用。</p>
<p>IP组播长度为32bit，前4bit固定为1110，后面跟着28bit可变的地址，为了将32bit组播IP地址映射成48bit的MAC地址，需要进行以下操作：</p>
<p>将24bit的OUI地址（组织唯一标识符）填充最前面的24bit，也就是说最前面是‘01-00-5E’，第25bit恒定为0，组播MAC地址剩下还有23bit，这个空间由组播IP地址的后23bit填满，32-23=5，也就是下图中组播地址中标红的地方，2的5次方为32，所以也就是说有32个IP地址映射的组播地址是相同的。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622514231143-1877203a-5aae-4250-8a8f-8a24ff2e2d71.png" alt="img"></p>
<p>用上面的方式进行了组播IP地址——组播MAC地址的映射以后，有一些IP地址的映射相同，具体来说就是有32个组播IP地址映射后的组播MAC地址是相同的，听起来是个大问题，但实际中并不是，因为MAC地址只在链路上使用，相同链路上组播IP地址处于一个区间概率很小，所以映射的组播MAC地址相同的几率也会很小，当然也是有可能映射的组播MAC地址相同，因此设备会假定它所收到的组播报文并不是发给它这个组播组的，设备会将这个组播报文交给IP层去查看组播IP地址，如果IP层判断这个报文并不是发给它这个组播组的，那么这个报文将会被丢弃，这种情况很少发生，所以多一道工序使得效率降低一些也可以接受。</p>
<h1 id="组播分发树"><a href="#组播分发树" class="headerlink" title="组播分发树"></a>组播分发树</h1><p>组播分发树用来描述IP组播报文在网络中经过的路径，也就是从源主机到数据接收者的传输路径，组播转发树有两类，有源树和共享树。</p>
<h2 id="有源树"><a href="#有源树" class="headerlink" title="有源树"></a>有源树</h2><p>有源树也叫最短路径树，英文为Source or Shortest Path Tree，由组播源到用户之间的最短路径构成。路由器必须为每个组播源保存路由信息，占用内存较多，但路径最优，接收者到多播源是最佳路径，延迟最小。</p>
<p>有源树的根，是组播数据流的来源，有源树的分支形成了通过网络到达接收站点的分布树：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535325802-6d962656-dc69-4b8f-87b9-16db98445cfe.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535330089-52de9420-be7a-4498-abbf-f7ba3a64ab64.png" alt="img"></p>
<h2 id="共享树"><a href="#共享树" class="headerlink" title="共享树"></a>共享树</h2><p>共享树英文为Shared Tree，以网络上某特定节点为公用根，占用内存较少，路径不一定是最优的，多播流量转发必须先经过RP（Rendezvous Point，汇聚点），引入额外的延迟，对RP的可靠性和处理能力要求很高。</p>
<p>共享树的根不在多播数据流的源头，而位于网络中管理员指定的汇聚点，RP，所有多播源先把多播流发送到RP，再由RP分发到各个接收站点，目标组地址向它的多个源节点共享多播分布树。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535536609-b829e199-6ac5-4c25-9e5d-4d29c1d7f808.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622535620240-7e73fdaa-b962-4286-98d0-6f62c55ad89e.png" alt="img"></p>
<h1 id="组播数据转发"><a href="#组播数据转发" class="headerlink" title="组播数据转发"></a>组播数据转发</h1><p>组播路由转发和单播路由转发是相反的：</p>
<ul>
<li>单播路由转发关心数据报文要到哪里去，关心的是终点；</li>
<li>组播路由转发关心数据报文从哪里来，关心的是起点；</li>
</ul>
<p>组播路由转发使用‘返乡路径转发’机制，避免环路。多播数据流从多播路由器入口路由到出口路由转发出去，入口由RPF决定，出口由IGMP和多播路由协议决定。</p>
<h2 id="RPF"><a href="#RPF" class="headerlink" title="RPF"></a>RPF</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>什么是RPF？英文是Reverse Path Forwarding，也就是反向路径转发，路由器收到组播数据报文后，只有确认这个数据报文是从自己前往源的出接口上收到后，才会进行转发，如果不是则会丢弃报文。上面确认源接口的过程由RPF检查完成，路由器会在单播路由表中查找到组播报文源地址的路由，如果该路由的出接口就是报文的入接口，则RPF成功，否则表示RPF失败。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536163160-5354be9d-3e29-45f1-8c85-918db0f5e3c1.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536193757-69feca91-53a8-4afd-a102-c9df1f4f6d47.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622536206887-e2f03d97-c891-4c04-bd37-9d2f7d81ea54.png" alt="img"></p>
<h3 id="检测顺序"><a href="#检测顺序" class="headerlink" title="检测顺序"></a>检测顺序</h3><h4 id="优先级优先（默认）"><a href="#优先级优先（默认）" class="headerlink" title="优先级优先（默认）"></a>优先级优先（默认）</h4><ol>
<li><p>如果同时存在单播和组播路由（用于RPF检查的组播路由条目），比较优先级，优先级越小越优；</p>
</li>
<li><p>如果优先级相同，则组播静态&gt;MBGP&gt;单播（默认情况下组播静态优先级为1，MBGP优先级为255，单播路由需要视协议而定）；</p>
</li>
<li><p>如果都是单播路由，比较路由的掩码长度，掩码长度越长越优；</p>
</li>
<li><p>如果掩码长度一样，比较下一跳的IP地址，IP地址越大越优；</p>
</li>
</ol>
<h4 id="掩码长度优先"><a href="#掩码长度优先" class="headerlink" title="掩码长度优先"></a>掩码长度优先</h4><ol>
<li><p>如果同时存在单播和组播路由，比较掩码长度，掩码长度越长越优；</p>
</li>
<li><p>如果掩码长度一样，比较路由协议优先级，优先级越小越优；</p>
</li>
<li><p>如果优先级一样，组播静态&gt;MBGP&gt;单播；</p>
</li>
<li><p>如果都是单播路由，比较下一跳的IP地址，IP地址越大越优；</p>
</li>
</ol>
<h1 id="IGMP协议"><a href="#IGMP协议" class="headerlink" title="IGMP协议"></a>IGMP协议</h1><h2 id="协议简介"><a href="#协议简介" class="headerlink" title="协议简介"></a>协议简介</h2><p>IGMP协议全称是Internet Group Management Protocol，互联网组管理协议，该协议是TCP/IP协议簇中负责IP组播成员管理的协议，主要用于在IP主机和其直接相邻的组播路由器之间建立，维护组播组成员的关系，它是一个主机和路由器之间的协议。IGMP通过在接收者和组播路由器之间交互IGMP报文实现组成员管理功能，IGMP报文封装在IP报文中。主机通过IGMP协议向路由器报告自己想加入的组，路由器通过IGMP协议查询网上是否还有特定组的成员。</p>
<p>IP组播通信的特点是报文从一个源发出，被转发到一组特定的接收者，但在组播通信模型中，发送者不关注接收者的位置信息，只是将数据发送到约定的目的组播地址，要使组播报文最终能够到达接收者，需要某种机制，这种机制使得接收者所在的路由器能够知道该网段存在哪些组播接收者，同时保证接收者可以加入相应的组播中。IGMP就是用来在接收者主机和它（接收者主机）所在网段连接的路由器之间，建立、维护组播组成员关系的协议。组播路由器通过IGMP协议了解每个接口连接的网段上是否存在组播接收者，也就是组成员。如果存在组成员，组播路由器会把组播数据包转发到这个网段，如果没有成员则停止转发。</p>
<h2 id="协议版本"><a href="#协议版本" class="headerlink" title="协议版本"></a>协议版本</h2><p>IGMPV1中定义了基本的组成员查询和报告过程，IGMPV2在此基础上添加了查询器选举和成员离开的机制，IGMPV2版本是目前使用的协议，IGMPV3中增加的主要功能是成员可以指定接收或指定不接收某些组播源的报文。三个版本在演进过程中对报文的处理是向前兼容的，也就是说高版本可以兼容低版本的报文。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622537662433-3291ffb8-a5bd-48f1-bc5d-a9ec2546b95f.png" alt="img"></p>
<h2 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h2><p>IGMP采用路由器查询、主机报告两种方式维持组员关系：</p>
<ul>
<li><p>路由器查询：路由器周期性的，每六十秒发送查询（目的为224.0.0.1，TTL=1）试图发现感兴趣的组员，主机每次都会回复路由器的查询；</p>
</li>
<li><p>主机报告：主机主动发送一个IGMP报告（目的为组播组地址，TTL=1）表示要加入某个组播组，这里面包含了要加入的组播组的地址，也可以用来回复路由器的查询。同一网段中，只需要一台主机发送Report报文，避免网络中充斥大量的Report报文。</p>
</li>
<li><p>抑制机制：倒数报告计时器的默认时间为10S；</p>
</li>
</ul>
<h3 id="IGMP-V1"><a href="#IGMP-V1" class="headerlink" title="IGMP V1"></a>IGMP V1</h3><p>IGMP V1协议主要基于查询和响应机制完成组播组管理，当一个网段内有多个组播路由器时，由于它们都可以接收到主机发送的成员报告报文，因此只需要选取其中一组路由器发送查询报文就够了，改组播路由器称为IGMP查询器（Querier）。在IGMP V1中，由组播路由协议PIM选举出唯一的组播信息转发者（Assert Winner或DR）作为IGMP V1的查询器，负责该网段的组成员关系查询。</p>
<p>IGMP V1的工作机制可以分为普遍组查询和响应机制，新成员加入机制和组成员离开机制三个方面。</p>
<h4 id="普遍组查询和响应机制"><a href="#普遍组查询和响应机制" class="headerlink" title="普遍组查询和响应机制"></a>普遍组查询和响应机制</h4><p>通过普遍组查询和响应，IGMP查询器可以了解到该网段内哪些组播组存在成员。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622602965988-0c5616dd-cee3-4ab3-92d0-8f2e66de85ee.png" alt="img"></p>
<p>如上图所示，普遍组查询和响应过程如下：</p>
<ul>
<li>IGMP查询器发送目的地址为224.0.01（表示同一网段内所有主机和路由器）的普遍查询报文；收到该查询报文的组成员启动定时器。查询器所发送的普遍组查询报文是周期性发送的，发送周期可以通过命令配置，默认情况下每隔60秒发送一次。Host A和Host B是组播组G1的成员，则在本地启动定时器Timer-G1。缺省情况下，HostA和B的定时器范围为0-10秒之间的随机值。下图中IGMP版本为V1版本，目的IP地址为224.0.0.1，源IP地址为自己接口的IP地址，在组播地址中，填充为0.0.0.0。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622604418259-22900164-3839-4f18-b845-fae61e7dcc4e.png" alt="img"></p>
<ul>
<li>第一个定时器超时的组成员发送针对该组播组的报告报文。假设Host A上的Timer-G1首先超时，Host A向该网段发送目的地址为G1的报告报文。也想加入G1的Host B收到此报告报文，则停止定时器Timer-G1，不再发送针对G1的报告报文，报告报文被抑制，可以减少网段上的流量。下图中是主机像路由器发送的报告报文，类型值为0X12，源IP地址为自己主机的IP地址，目的IP地址为组播地址。下图中，是主机像路由器发送的报告的抓包，类型值为0x12，源IP地址为自己主机的IP地址，目的IP地址为组播地址。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622604927603-f942692b-5f96-4c08-b756-4398c336c219.png" alt="img"></p>
<h4 id="新成员加入机制"><a href="#新成员加入机制" class="headerlink" title="新成员加入机制"></a>新成员加入机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622606359352-f0988066-6e48-47bd-ae24-b0b21139ceea.png" alt="img"></p>
<p>如上图所示，主机Host C加入组播组G2的过程如下：</p>
<ul>
<li>主机Host C不等待普遍组查询报文的到来，主动发送针对G2的报告报文，声明加入该组播组；</li>
<li>IGMP查询器接收到Host C的报告报文后，了解到本地网段内出现了组播组G2的成员，则生成组播转发项（*，G2），网络中一旦有G2的数据到达路由器，将向该网段转发；</li>
</ul>
<h4 id="组成员离开机制"><a href="#组成员离开机制" class="headerlink" title="组成员离开机制"></a>组成员离开机制</h4><p>IGMP V1没有专门定义离开组的报文，主机离开组播组后，便不会再对普通组查询报文做出回应。</p>
<ul>
<li>假设Host A想要退出组播组G1：Host A收到IGMP 查询器发送的普遍组查询报文时，不再发送针对G1的报告报文，由于网段内还存在G1组成员Host B，Host B会向IGMP查询器发送针对G1的报告报文，因此IGMP查询器感知不到Host A的离开；</li>
<li>假设Host C想要退出组播组G2：Host C收到IGMP查询器发送的普遍组查询报文时，不再发送针对G2的报告报文。由于网段内不存在组G2的其他成员，IGMP查询器不会收到G2组成员的报告报文，则在一定时间内（默认为130秒）后，删除G2所对应的组播转发表项；</li>
</ul>
<h4 id="报文"><a href="#报文" class="headerlink" title="报文"></a>报文</h4><p>V1版本包括两种类型的报文：</p>
<ul>
<li>普遍组查询报文：英文为General Query，是查询器向共享网络上所有主机和路由发送的查询报文，用于了解哪些组播组存在成员；</li>
<li>成员报告报文：英文为Report，是主机向查询器发送的报告报文，用于申请加入某个组播组或者应答查询报文。</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622548966946-e76ee04a-80e5-467e-a8af-09858c6415d4.png" alt="img"></p>
<ul>
<li><p>Version：版本号，在IGMP V1中该值为1；</p>
</li>
<li><p>Type：报文类型，该字段有以下两种取值：0x11，表示普遍组查询报文。0x12，表示成员报告报文；</p>
</li>
<li><p>Unused：在IGMP V1中，该字段在发送时被设置为0，并在接收时被忽略；</p>
</li>
<li><p>Checksum：IGMP报文的校验和，校验和是IGMP报文长度（也就是IP报文的整个有效载荷）的16位检测，表示IGMP信息补码之和的补码。Checksum字段在进行校验计算时设为0.当发送报文时，必须计算校验和并插入到Checksum字段中去，当接收报文时，校验和必须在处理该报文之前进行校验；</p>
</li>
<li><p>Group Address：组播地址，在普遍组查询报文中，该字段为0，在成员报告报文中，该字段为成员加入的组播组地址；</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622549396314-69df852c-9fa3-411f-98c2-100565dc131d.png" alt="img"></p>
<h3 id="IGMP-V2"><a href="#IGMP-V2" class="headerlink" title="IGMP V2"></a>IGMP V2</h3><p>IGMP V2工作机制与IGMP V1基本相同，最大不同之处在于IGMP V2增加了离开组机制，成员主机离开组播组时，会主动发送成员离开报文通知IGMP查询器；IGMP查询器在收到成员离开报文后，会连续发送特定查询报文，询问该组播组是否还存在组成员。如果在一段时间内没有收到成员主机发送的报告报文，IGMP查询器将不再维护该组的组成员关系。IGMP V2可以使IGMP查询器即使了解到网段内哪些组播组已经不存在成员，从而即使更新组成员关系，减少网络中冗余的组播流量。</p>
<p>和IGMP V1相比，V2版本增加了查询器选举和离开组的机制。</p>
<h4 id="查询器选举机制"><a href="#查询器选举机制" class="headerlink" title="查询器选举机制"></a>查询器选举机制</h4><p>IGMPV2使用独立的查询器选举机制，当共享网段上存在多个组播路由器时，<strong>IP地址最小的路由器成为查询器。</strong></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618789348-45b81e15-fd91-400f-adf1-34d6bb33c78b.png" alt="img"></p>
<p>如上图所示，在IGMP V2中，查询器的选举过程如下：</p>
<ul>
<li>最初，所有运行IGMP V2的组播路由器（上图中的Router A和Router B）都会认为自己试查询器，向本网段内所有主机和组播路由器发送普遍查询报文。Router A和B在收到对方发送的普遍查组查询报文后，将报文的源IP地址与自己的接口地址作比较，通过比较，IP地址最小的组播路由器将成为查询器，其他组播路由器成为非查询器（Non-Querier），V2查询报文示例如下：</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618970687-4a5cd027-2193-45b4-bd8c-483042819cfe.png" alt="img"></p>
<p>IGMP V2报告报文如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622618994148-25511dfe-94fa-4430-8deb-c247ead1a2d1.png" alt="img"></p>
<ul>
<li>此后，将由IGMP查询器，也就是上一步选举出来的IP地址最小的Router A，向本网段内所有主机和其他组播路由器发送普遍查询报文，而非查询器（Router B）将不再发送普遍组查询报文。非查询器（Router B）上都会启动一个定时器（即其他查询器存在时间的定时器，Other Querier Present Timer）。在该定时器超时前，如果收到了来自查询器的查询报文，则重置该定时器；否则就认为原查询器失效，并发起新的查询器选举过程。</li>
</ul>
<h4 id="离开组机制"><a href="#离开组机制" class="headerlink" title="离开组机制"></a>离开组机制</h4><p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622619463267-c728555a-f309-4534-91af-8d490286df3e.png" alt="img"></p>
<p>如上图所示在IGMP V2中，主机Host A离开组播组G1的过程如下：</p>
<ul>
<li><p>Host A向本地网段内的所有组播路由器（也就是目标地址为224.0.0.2）发送针对组G1的离开报文；</p>
</li>
<li><p>查询器收到离开报文，会发送针对组G1的特定组查询报文。发送间隔和发送次数可以通过命令配置，缺省情况下，每隔1秒发送一次，一共会发送两次，同时查询器会启动组成员关系定时器（Timer-Membership=发送间隔X发送次数）；</p>
</li>
<li><p>如果该网段内<strong>还存在</strong>组G1的其他成员，这些成员在收到查询器发送的特定查询报文后，会立即发送针对组G1的报告报文。查询器收到针对组G1的报告报文后，将继续维护该组成员关系；</p>
</li>
<li><p>如果该网段内<strong>不存在</strong>组G1的其他成员，查询器将不会收到针对组G1的报告报文。在Timer-Membership超时后，查询器将删除（*，G1）对应的IGMP组表项。当有组G1的组播数据到达查询器时，查询器将不会向下游转发。</p>
</li>
</ul>
<h4 id="报文分析"><a href="#报文分析" class="headerlink" title="报文分析"></a>报文分析</h4><p>和IGMP V1相比，IGMP V2除了普遍组查询报文和成员报告报文之外，IGMP V2新增了两种报文：</p>
<ul>
<li>成员离开报文（Leave）：成员离开组播组时，会主动向查询器发送离开报文，用于宣告自己离开了某个组播组；</li>
<li>特定组查询报文（Group-Specific Query）：查询器向共享网段内指定组播组发送的查询报文，用于查询该组播组是否存在成员；</li>
</ul>
<p>报文方面的另一个变化是，IGMP V2对普遍组查询报文的格式进行了改进，添加了最大响应时间（Max Response Time）字段，该字段取值可以通过命令配置，用于控制成员对于查询报文的响应速度。查询报文的抓包如下：</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1622620680251-e616a989-93aa-4283-a169-63914a5259ce.png" alt="img"></p>
<ul>
<li><p>Type：报文类型，该字段有四种取值：0x11表示查询报文，包括普遍组查询报文和特定组查询报文两类；0x12表示IGMPV1成员报告报文；0x16表示IGMPV2成员报告报文；0x17表示成员离开报文。</p>
</li>
<li><p>Max Response Time：最大响应时间，成员主机在收到IGMP查询器发送的普遍查询报文后，需要在最大相应时间内做出回应，该字段仅在IGMP查询报文中有效。</p>
</li>
<li><p>Group Address：组播组地址。在普遍查询报文中，该字段为0.0.0.0；在特定组查询宝文中，该字段为要查询的组播组地址；在成员报告报文和离开报文中，该字段为组成员要加入或离开的组播组地址。</p>
</li>
</ul>
<h3 id="IGMP-V3"><a href="#IGMP-V3" class="headerlink" title="IGMP V3"></a>IGMP V3</h3><p>IGMP V3主要是为了配合SSM（Source-Specific Multicast）模型发展起来的，提供了在报文中携带组播源信息的能力，也就是说主机可以对组播源进行选择。</p>
<h4 id="特定组的加入"><a href="#特定组的加入" class="headerlink" title="特定组的加入"></a>特定组的加入</h4><p>IGMP V3的成员报告报文的目的地址为224.0.0.22（表示同一网段所有能使用IGMP V3的路由器）。通过在报告报文中携带组记录，主机在加入组播组的同时，能够明确要求接收或不接收特定组播源发出的组播数据。</p>
<p>如果Host和组播路由器之间运行的是IGMP V1或IGMP V2，那么Host加入组播组G时无法对组播源进行选择，无论其是否需要，都会同时接收到来自组播源S1和S2的数据。如果采用IGMP V3，成员主机可以选择仅仅接收S1组播的数据。</p>
<ul>
<li>方法1：Host发送IGMP V3报告（G，Include，（S1）），仅接收源S1向组播组G发送的数据；</li>
<li>方法2：Host发送IGMP V3报告（G，Include，（S2）），不仅接收指定源S2向组播组G发送的数据，从而仅有来自S1的组播数据才能传递到Host。</li>
</ul>
<h4 id="特定组查询"><a href="#特定组查询" class="headerlink" title="特定组查询"></a>特定组查询</h4><p>当接收到组成员发送的改变组播组与愿列表的对应关系的报告时（比如Change_to_include_mode\Change_to _exclude_mode），IGMP查询器会发送特定源的组查询报文，如果组成员希望接收其中任意一个源的组播数据，将反馈报告报文。IGMP查询器根据反馈的组成员报告更新该组对应的源列表。</p>
<h3 id="IGMP-SSM-Mapping"><a href="#IGMP-SSM-Mapping" class="headerlink" title="IGMP SSM Mapping"></a>IGMP SSM Mapping</h3><h4 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h4><p>SSM（Source-Specific Multicast）成为指定源组播，要求路由器能了解成员主机加入组播时所指定的组播源。如果成员主机上运行IGMP V3，可以在IGMP V3报文中直接指定组播源地址，但是在某些情况下，成员主机只能运行IGMP V1或V2，为了使其也能够使用SSM服务，路由器上需要提供IGMP SSM Mapping功能。</p>
<h4 id="工作机制"><a href="#工作机制" class="headerlink" title="工作机制"></a>工作机制</h4><p>通过在路由器上静态配置SSM地址的映射规则，将IGMP V1和V2报告报文中的（*，G）信息转化为对应的（G，Include，（S1，S2….））信息，以提供SSM组播服务。</p>
<ul>
<li><p>SSM模型针对特定源和组的绑定数据流提供服务，接收者主机在加入组播组时，可以指定只接收哪些源的数据或指定拒绝接收来自哪些源的数据。加入组播组以后，主机只会收到指定源发送到该组的数据；</p>
</li>
<li><p>SSM模型对组播地址不再要求全网唯一，只需要每个组播源保持唯一。这里的唯一指的是同一个源上不同的组播应用必须使用不同的SSM地址来区分。不同的源之间可以使用相同的组地址，因为SSM模型中针对每一个（源，组）信息都会生成表项。这样一方面节省了组播组地址，另一方面也不会造成网络拥塞；</p>
</li>
<li><p>如果G在ASM（And-Source Multicast）范围内，只提供ASM服务。</p>
</li>
<li><p>如果G在SSM组地址范围内（默认情况下为232.0.0.0-232.255.255.255），如果路由器上没有G对应的SSM Mapping规则，那么无法提供SSM服务，丢弃该报文；如果路由器上有G对应的SSM Mapping规则，则一句规则将报告报文中所包含的（*，G）信息映射为（G，Include，（S1，S2…..））信息，提供SSM服务。</p>
</li>
</ul>
<h3 id="IGMP-Proxy"><a href="#IGMP-Proxy" class="headerlink" title="IGMP Proxy"></a>IGMP Proxy</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>IGMP Proxy，也称为IGMP代理，通常被部署在接入设备（Router A）和成员主机之间的三层设备上，IGMP Proxy设备可以手机下游成员主机的IGMP报告\离开报文，将报告\离开报文汇聚后，代理下游成员主机同一上报给接入设备；另一方面IGMP Proxy设备也可以代理IGMP查询器向下游成员主机发送查询报文，维护成员关系，基于组成员关系进行组转发。在接入设备Router A看来，Router B就是一台主机，在下游成员主机看来，Router B就是IGMP查询器。</p>
<ul>
<li>上游接口：指IGMP代理设备上配置IGMP Proxy功能的接口，该接口执行IGMP代理设备的主机行为，因此也称为主机接口（Host Interface）；</li>
<li>下游接口：指IGMP代理设备上配置IGMP功能的接口，该接口执行IGMP代理设备的路由器行为，因此也称为路由器接口（Router Interface）；</li>
</ul>
<h4 id="工作机制-1"><a href="#工作机制-1" class="headerlink" title="工作机制"></a>工作机制</h4><p>IGMP代理设备实现的功能主要分为两种：主机行为和路由器行为。</p>
<p>主机行为是指IGMP代理设备的上游接口收到查询报文时，根据当前组播转发表的状态对查询报文做出响应，或者当组播转发表发生变化时，上游接口主动向接入设备发送报告\离开报文。主机行为的工作机制如下：</p>
<ul>
<li><p>IGMP代理设备上游接口收到查询报文时，会根据当前组播转发表的状态对查询报文作出相应；</p>
</li>
<li><p>IGMP代理设备收到某组播组的报告报文后，会在组播转发表中查找该组播组。如果没有找到相应的组播组，IGMP代理设备会向接入设备发送针对该组播组的报告报文，并在组播转发表中添加该组播组。如果找到相应的组播组，IGMP代理设备就不需要向接入设备报告发送报告报文；</p>
</li>
<li><p>IGMP代理设备收到某组播组G的离开报文后，会向接收到该离开保温的接口发送一个特定组查询报文，检查该接口下是否还存在组播组G的其他成员。如果没有其他成员，IGMP代理设备会向接入设备发送针对该组播组的离开报文，并在组播转发表中将对应的接口删除。如果有其他成员，IGMP代理设备会继续向该接口转发组播数据；</p>
</li>
</ul>
<h2 id="IGMP命令"><a href="#IGMP命令" class="headerlink" title="IGMP命令"></a>IGMP命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip multicast</span><br><span class="line">开启组播路由功能</span><br><span class="line"></span><br><span class="line">ip igmp version&#123;1|2|3&#125;</span><br><span class="line">设置igmp版本</span><br><span class="line"></span><br><span class="line">ip igmp query-interval XX</span><br><span class="line">设置查询报文发送间隔，默认为60秒</span><br><span class="line"></span><br><span class="line">ip igmp query-max-response-time XX</span><br><span class="line">设置igmp普遍组查询报文的最大响应时间，默认为10秒</span><br><span class="line"></span><br><span class="line">ip igmp query-timeout XX</span><br><span class="line">设置igmp通告过期时间</span><br><span class="line"></span><br><span class="line">ip igmp join-group X.X.X.X</span><br><span class="line">接口需要侦听某个组播组</span><br><span class="line"></span><br><span class="line">show ip igmp interface E0/0</span><br><span class="line">查看接口上igmp配置</span><br></pre></td></tr></table></figure>

<h1 id="PIM协议"><a href="#PIM协议" class="headerlink" title="PIM协议"></a>PIM协议</h1><p>PIM协议英文全称为，Protocol Independent Multicast，中文是协议无关组播，这里的协议无关指的是与单播路由协议无关，也就是说，PIM不需要维护专门的单播路由协议。作为组播路由解决方案，它直接利用单播路由表的路由信息，对组播报文执行RPF（Reverse Path Forwarding，逆向路径转发）检查，检查通过后创建组播路由表项，从而转发组播报文。，目前设备实际支持的IPM协议包括：PIM-DM（PIM-Dense Mode）、PIM-SM（PIM-Sparse Mode）</p>
<h2 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="组播分发树-1"><a href="#组播分发树-1" class="headerlink" title="组播分发树"></a>组播分发树</h3><p>PIM网络以组播组为单位在路由器上建立单点到多点的组播转发路径。由于组播转发路径呈现树形结构，也称为组播分发树MDT（Multicast Distribution Tree）。主要包括SPT和RPT两种。</p>
<h4 id="SPT"><a href="#SPT" class="headerlink" title="SPT"></a>SPT</h4><ul>
<li><p>SPT全称为Shortest-Path Tree，中文为最短路径树，以组播源为根，是组播组成员为叶子的组播分发树，SPT同时适用于PIM-DM网络和PIM-SM网络；</p>
</li>
<li><p>主要使用（S,G）表项；</p>
</li>
<li><p>源树的分支形成了通过网络到达接收者所在分支的分布树，因为最短路径树使用最短的、从源起始贯穿网络到达组播接收者的路径，所以又叫最短路径树；</p>
</li>
</ul>
<h4 id="RPT"><a href="#RPT" class="headerlink" title="RPT"></a>RPT</h4><ul>
<li><p>以RP（Rendezvous Point）为根，也就是使用RP为汇聚点，组播组成员为叶子的组播分发树称为RPT（RP Tree），RPT适用于PIM-SM网络；</p>
</li>
<li><p>主要使用（*,G）表项；</p>
</li>
<li><p>多个组播组可以共用一个RP，需要接收组播流量的路由器，通过组播协议在自己与RP之间建立一条RPT的分支，组播流量首先需要从源发送到RP，然后再由RP将组播流量转发下来，组播流量顺着RPT最终到达各个接收者所在的终端网络；</p>
</li>
</ul>
<h3 id="PIM路由器"><a href="#PIM路由器" class="headerlink" title="PIM路由器"></a>PIM路由器</h3><p>在接口上使用了PIM协议的路由器即为PIM路由器。在建立组播分发树的过程中，PIM路由器又分为以下几种：</p>
<ul>
<li><p>叶子路由器，与用户主机相连的PIM路由器，但连接的用户主机不一定为组成员；</p>
</li>
<li><p>第一跳路由器：组播转发路径上，与组播源相连且负责转发该组播源发出的组播数据的PIM路由器；</p>
</li>
<li><p>最后一跳路由器：组播转发路径上，与组播组成员相连且负责向改组播组成员转发组播数据的PIM路由器；</p>
</li>
<li><p>中间路由器：组播转发路径上，第一跳路由器与最后一跳路由器之间的PIM路由器；</p>
</li>
</ul>
<h3 id="RPF-1"><a href="#RPF-1" class="headerlink" title="RPF"></a>RPF</h3><p>RPF全称为Reverse Path Forwarding，反向路径转发。在组播网络中，如果组播流量出现转发环路，比起单播报文的转发环路的危害要大得多，路由器在转发组播报文时，除了会关注报文的目的地址，还会特别关心该报文的源地址。组播路由器通过RPF的机制来实现组播数据转发的无环化。</p>
<p>RPF机制确保组播数据从正确的接口被收到，只有通过RPF检查的组播数据包才会被路由器沿着组播树进行转发，如果数据包从错误的接口被收到，路由器将丢弃这些报文。这里所谓的正确接口，其实就是通过了RPF检查的接口，也就是经常说的上游接口，一种常见的情况是，设备借助其单播路由表来实现RPF检查。</p>
<h3 id="PIM路由表项"><a href="#PIM路由表项" class="headerlink" title="PIM路由表项"></a>PIM路由表项</h3><p>PIM路由表项就是那些通过PIM协议建立的组播路由表项。PIM网络中存在两种表项：（S,G）路由表项或（，G）路由表项。S表示组播源，G表示任意的组播组。</p>
<ul>
<li>（S,G）路由表项主要用于在PIM网络中建立SPT（Shortest Path Tree，最短路径树），路由表项知道组播源S的位置，用于PIM-DM网络和PIM-SM网络；</li>
<li>（*,G）路由表项主要用于在PIM网络中建立RPT（Rendezvous Point Tree，共享树），路由表项只知道组播G的存在，用于PIM-SM和PIM-DM网络；</li>
</ul>
<p>路由器上可能同时存在两种路由表项，当收到源地址为S，组地址为G的组播报文，且RPF检测通过的情况下，按照如下的规则转发：</p>
<ul>
<li>如果存在（S,G）路由表项，则由（S,G）路由表项指导报文转发；</li>
<li>如果不存在（S,G）路由表项，只存在（,G）路由表项，则先依照（,G）路由表项创建（S,G）路由表项，再由（S,G）路由表项指导报文转发；</li>
</ul>
<p>PIM路由表项中主要用于指导转发的信息如下：</p>
<ul>
<li><p>组播源地址；</p>
</li>
<li><p>组播组地址；</p>
</li>
<li><p>上游接口：本地路由器上接收到组播数据的接口；</p>
</li>
<li><p>下游接口：将组播数据转发出去的接口；</p>
</li>
</ul>
<h1 id="PIM-DM"><a href="#PIM-DM" class="headerlink" title="PIM-DM"></a>PIM-DM</h1><h2 id="基本原理-1"><a href="#基本原理-1" class="headerlink" title="基本原理"></a>基本原理</h2><p>PIM-DM全称Protocol-Independent Multicast-Dense Mode，可以翻译成协议无关组播的密集模式，使用的‘推（Push）模式’转发组播报文，一般应用于组播组成员规模相对较小，相对密集的网络。在实现过程中，它会假设网络中的组成员分布非常稠密，每个网段都可能存在组成员，当有活跃的组播源出现时，PIM-DM将组播源发来的组播报文扩散到整个网络的PIM路由器上，再裁减掉不存在的组成员的分支。PIM-DM通过周期性的进行‘扩散（Flooding）——修剪（Prune）’，来构建并维护一颗连接组播源和组成员的单向无环SPT（Specific Shortest Path Tree）。如果在下一次‘扩散-修剪’进行前，被裁剪掉的分支由于其叶子路由器上有新的组成员加入而希望提前恢复转发状态，也可通过嫁接（Graft）机制主动恢复其对组播报文的转发。</p>
<p>PIM-DM工作机制包括邻居发现、扩散、裁剪、嫁接、断言和状态刷新。其中扩散、裁剪和嫁接是构建SPT的主要方法。</p>
<ul>
<li><p>使用‘推(push)’模型，也就是说不管你要不要这个组播，先推送给你；</p>
</li>
<li><p>组播数据流整个网络泛洪（Flood）；</p>
</li>
<li><p>下游不需要这个组播的话则会裁剪（Prune）；</p>
</li>
<li><p>泛洪——裁剪——泛洪——裁剪，周而复始，每隔三分钟泛洪一次；</p>
</li>
</ul>
<h2 id="几种动作"><a href="#几种动作" class="headerlink" title="几种动作"></a>几种动作</h2><h3 id="邻居发现"><a href="#邻居发现" class="headerlink" title="邻居发现"></a>邻居发现</h3><p>PIM路由器上每个使用了PIM协议的接口都会对外发送Hello报文，每个30S（Hello Interval）会使用组播的PIM Hello报文选入它的连入，105S内收不到邻居的Hello报文则会认为邻居失效，在组播转发时经过RPF检测后会将组播流量发送给所有PIM邻居路由器，查看邻居的命令为:show ip pim neighbor。</p>
<p>封装Hello报文的组播报文的目的地址是224.0.0.13（表示同一网段中所有PIM路由器）、源地址为接口的IP地址、TTL数值为1。</p>
<p>Hello报文的作用如下：</p>
<ul>
<li><p>发现PIM邻居。同一网段中的PIM路由器都必须接收目的地址为224.0.0.13的组播报文，这样直接相连的PIM路由器之间通过交互Hello报文以后，就可以彼此知道自己的邻居信息，建立邻居关系。只有邻居关系建立成功后，PIM路由器才能接收其他PIM协议报文，从而创建组播路由表项；</p>
</li>
<li><p>维持邻居关系。PIM路由器之间周期性地发送Hello报文，如果Holdtime超时还没有收到该PIM邻居发出的新的Hello报文，PIM路由器就认为该邻居不可达，将其从邻居列表中清除。PIM邻居的变化将导致网络中组播拓扑的变化。如果组播分发树上的某上游邻居或下游邻居不可达，将导致组播路由重新收敛，组播分发树迁移；</p>
</li>
<li><p>协调各项PIM协议报文参数。Hello报文中携带多项PIM协议报文参数，主要用于邻居之间PIM协议报文的控制：</p>
</li>
</ul>
<ol>
<li><p>DR_Priority：表示各路由器接口精选DR的优先级，优先级越高越容易获胜；</p>
</li>
<li><p>Holdtime：表示保持邻居为可达状态的超时时间，如果在超时时间内没有收到PIM邻居发送的Hello报文，路由器则认为邻居不可达；</p>
</li>
<li><p>LAN_Delay：表示共享网段内传输Prune报文的延迟时间；</p>
</li>
<li><p>Neighbor-Tracking：表示邻居跟踪功能；</p>
</li>
<li><p>Override-Interval：表示Hello报文中携带的否决裁剪的时间间隔；</p>
</li>
</ol>
<h3 id="扩散（Flooding）"><a href="#扩散（Flooding）" class="headerlink" title="扩散（Flooding）"></a>扩散（Flooding）</h3><p>当PIM-DM网络中出现活跃的组播源之后，组播源发送的组播报文将在全网内扩散，当PIM路由器接收到组播报文，根据单播路由表进行RPF检查通过后，就会在该路由器上创建（S,G）表项，下游接口列表中包括除上游接口之外与所有PIM邻居相连的接口，后续到达的组播报文将从各个下游接口转发出去。</p>
<p>最后组播报文扩散到达叶子路由器，会出现以下两种情况：</p>
<ul>
<li>若与该叶子路由器相连用户网段上存在组成员，则将与该网段相连的接口加入（S,G）表项的下游接口列表中，后续的组播报文会向组成员转发；</li>
<li>若与该叶子路由器相连用户网段上不存在组成员，则不需要向其下游PIM邻居转发组播报文，则执行裁剪动作；</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483842043-cfe5005b-ba16-4a94-b6db-9671b06b24f9.png" alt="img"></p>
<h3 id="裁剪（Prune）"><a href="#裁剪（Prune）" class="headerlink" title="裁剪（Prune）"></a>裁剪（Prune）</h3><p>当PIM路由器接收到组播报文后，RPF检查通过，但是下游网段没有组播报文需求。此时PIM路由器会向上游发送裁剪报文，通知上游路由器禁止相应下游接口的转发，将其从（S,G）表项的下游接口列表中删除。裁剪操作由叶子路由器发起，逐跳向上，最终组播转发路径上只存在与组成员相连的分支。</p>
<p>路由器为被裁剪的下游接口启动一个裁剪计时器，计时器超时后接口恢复转发。组播报文重新在全网范围内扩散，新加入的组成员可以接收到组播报文。随后，下游不存在组成员的叶子路由器将向上发起裁剪的操作。这种周期性的扩散-裁剪，PIM-DM周期性的刷新SPT（Shortest Path Tree，最短路径树）。</p>
<p>当下游接口被裁剪后：</p>
<ul>
<li>如果下游叶子路由器有组成员加入，并且希望在下次‘扩散-裁剪’前就恢复组播报文转发，则执行嫁接动作；</li>
<li>如果下游叶子路由器一直没有组成员加入，希望该接口保持一直转发状态，则执行状态刷新动作；</li>
</ul>
<p>会发生Prune的情况：</p>
<ul>
<li><p>该接口下没有接收者；</p>
</li>
<li><p>没有下游PIM邻居；</p>
</li>
<li><p>非RPF接口收到多播流，也就是当前路由器向上游路由器发送Prune；</p>
</li>
<li><p>多路访问环境下由于Assert原因，自己不能转发多播流，重复Prune之前会等待3秒钟延迟来等待有无Join；</p>
</li>
</ul>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483947038-5a5b82de-e489-41cf-98f2-764c7867599d.png" alt="img"></p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623483968748-1ca715d6-8b9c-45ae-950f-dba40437fb15.png" alt="img"></p>
<h3 id="嫁接（Graft）"><a href="#嫁接（Graft）" class="headerlink" title="嫁接（Graft）"></a>嫁接（Graft）</h3><p>PIM-DM通过嫁接机制，使有新组成员加入的网段快速得到组播报文。叶子路由器通过IGMP了解到与其相连的用户网段上，组播组G有新的组成员加入。随后叶子路由器会向上游发送Graft报文，请求上游路由器恢复相应出接口转发，将其添加在（S,G）表项下游接口列表中。</p>
<p>嫁接过程从叶子路由器开始，到有组播报文到达的路由器结束。</p>
<h3 id="状态刷新（State-Refresh）"><a href="#状态刷新（State-Refresh）" class="headerlink" title="状态刷新（State Refresh）"></a>状态刷新（State Refresh）</h3><p>在PIM-DM网络中，由于裁剪计时器为3分钟，也就是说3分钟后那些不需要组播，被裁剪了的路由器将会重复一遍‘泛洪——裁剪’的动作，使得网络中充满了组播的泛洪以及裁剪数据，为了避免被裁剪的接口因为‘裁剪定时器’超时而一次次的恢复转发，去消耗网络带宽，离组播源最近的第一跳路由器会周期性的触发State Refresh报文在全网内扩散，收到State Refresh报文的PIM路由器会刷新裁剪定时器的状态，被裁剪接口的下游叶子路由器如果一直没有成员加入，则该接口一直处于被抑制转发的状态。配置命令为到接口下输入: ip pim state-refresh origination-interval XX。</p>
<h3 id="断言（Assert）"><a href="#断言（Assert）" class="headerlink" title="断言（Assert）"></a>断言（Assert）</h3><p>当一个网段内有多个相连的PIM路由器，使用RPF检查通过向该网段转发组播报文时，则需要通过断言机制来保证只有一个PIM路由器向该网段转发组播报文。PIM路由器在接收到邻居路由器发送的相同组播报文后，会以组播的方式向本网段的所有PIM路由器发送Assert报文，其中目的地址为永久组地址224.0.0.13。其他PIM路由器在接收到Assert报文后，将自身参数与对方报文中携带的参数作比较，进行Assert竞选，规则如下：</p>
<ul>
<li><p>单播路由协议优先级较高者获胜；</p>
</li>
<li><p>如果优先级相同，则到组播源的开销较小者获胜；</p>
</li>
<li><p>如果以上都相同，则下游接口IP地址最大者获胜；</p>
</li>
</ul>
<p>根据Assert竞选结果，路由器将执行不同的操作：</p>
<ul>
<li>获胜一方的下游接口称为Assert Winner，将负责后续对该网段组播报文的转发；</li>
<li>落败的乙方的下游接口称为Assert Loser，后续不会对该网段转发组播报文，PIM路由器也会将其从（S,G）表项下游接口列表中删除；</li>
</ul>
<p>Assert竞选结束后，该网段上只存在一个下游接口，只传输一份组播报文。所有Assert Loser可以周期性地恢复组播报文转发，从而引发周期性的Assert竞选。</p>
<h2 id="协议数据包"><a href="#协议数据包" class="headerlink" title="协议数据包"></a>协议数据包</h2><h3 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h3><p>Hello消息的作用是发现和维护邻居关系。默认发送间隔是30秒也就是Hello Interval是30秒，邻居超时时间为Hello的3.5倍，也就是105秒。在PIM-DM网络中，刚启动的组播路由器需要使用Hello消息来发现邻居、维护邻居关系以及选举DR指定路由器。路由器之间周期性的发送Hello消息来构建和维护SPT树（Shortest Path Tree，最短路径树）。在PIM-DM中，只需要Hello报文就能够接收组播的数据而不需要其他的报文。</p>
<p>Hello Interval，在接口下配置发送Hello消息的时间间隔，Hello消息默认周期是30S。Holdtime interval，在接口下配置Hello消息超时的时间，默认情况下超时时间为105S。</p>
<p>Hello消息还有一个重要的功能，就是在多个路由器网段中选举DR指定路由器，DR路由器充当IGMP V1的查询器，查询器的选举由组播协议决定。在PIM-DM中各路由器通过比较Hello消息中携带的优先级和IP地址，为多个路由器网段选举指定路由器DR，充当IGMP V1的查询器。当DR出现故障时，接收Hello消息将会超时，邻居路由器之间会触发新的DR选举过程。</p>
<p><strong>PIM DR的选举过程为：</strong></p>
<ul>
<li>优先级大的为DR，优先级默认为1；</li>
<li>IP地址大的；</li>
</ul>
<p>在PIM-DM模式下，DR只充当IGMP V1版本的查询者，没有其他用途。</p>
<h3 id="Join-Prune"><a href="#Join-Prune" class="headerlink" title="Join\Prune"></a>Join\Prune</h3><p>加入和裁剪组播树。</p>
<p>当有新的组播成员要加入组播组时，它所连入的当前路由器要加入组播树，由于当前路由器以前被</p>
<h3 id="Graft"><a href="#Graft" class="headerlink" title="Graft"></a>Graft</h3><p>嫁接，嫁接报文用于<strong>重新</strong>加入一个组播组，而这个路由器之前使用裁剪动作退出了该组播组。</p>
<p>graft message is specific for re-joining to a group which was pruned by the router earlier</p>
<p>​                                                                  <a href="https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023">出自</a></p>
<h3 id="Graft-ACK"><a href="#Graft-ACK" class="headerlink" title="Graft ACK"></a>Graft ACK</h3><p>嫁接成功后的确认报文。</p>
<h3 id="Assert"><a href="#Assert" class="headerlink" title="Assert"></a>Assert</h3><p>声明。在多路访问环境下，用来协商哪台多播路由器来向该多路访问网络中转发组播数据流。</p>
<p><img src="https://cdn.nlark.com/yuque/0/2021/png/1187856/1623486301187-4337483e-bebe-4aef-8254-abcb3b2aaf75.png" alt="img"></p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ul>
<li>首先保证单播的路由通信正常；</li>
<li>其次在网络设备上配置组播协议：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">全局启用组播：</span><br><span class="line">ip multicast-routing</span><br><span class="line"></span><br><span class="line">三层接口上启用PIM-DM</span><br><span class="line">ip pim dense-mode</span><br></pre></td></tr></table></figure>

<ul>
<li>配置接收节点并‘放号’；</li>
<li>查看与拍错；</li>
</ul>
<p>在接口上配置‘ip pim dense-mode’时，首先必须运行单播路由协议，否则PIM无法做RPF，确定RPF接口；第二是配置了PIM的时候必须每个接口都启用该协议，否则可能会出现RPF故障。</p>
<p>show ip igmp interface XX 来查看接口运行组播情况。</p>
<h2 id="PIM-DM总结"><a href="#PIM-DM总结" class="headerlink" title="PIM DM总结"></a>PIM DM总结</h2><p>PIM-DM对于小型网络来说非常有效。</p>
<p>优点：</p>
<ul>
<li>易于配置，只有两条命令；</li>
<li>实现机制简单，基于泛洪——裁剪；</li>
</ul>
<p>不足：</p>
<ul>
<li><p>泛洪——裁剪的过程不够高效；</p>
</li>
<li><p>复杂的Assert机制；</p>
</li>
<li><p>控制和数据平面混合；</p>
</li>
<li><p>容易导致网络内部所有的路由器上都有（S,G）表项；</p>
</li>
<li><p>可能会导致非确定性的拓扑行为；</p>
</li>
<li><p>不支持共享树；</p>
</li>
</ul>
<h1 id="PIM-SM"><a href="#PIM-SM" class="headerlink" title="PIM-SM"></a>PIM-SM</h1><p>PIM-SM全称是Protocol-Independent Sparse Mode，可以翻译成协议无关组播的稀疏模式。PIM-SM有两种模型，分别是ASM（Any-Source Multicast，任意信源组播)和SSM（Source-Specific Multicast，指定信源组播），ASM模型可以支持PIM-DM和PIM-SM两种模式；SSM模型只有PIM-SM模式，目前PIM-SM用的绝大多数都是SSM模式。</p>
<p>ASM模式出现较早也就是协议更老一些，在组播组中可以存在多个组播源，而SSM在组播组中只能有一个组播源。现网中用的基本都是SSM，而ASM使用较少的原因是安全问题，因为可以指定多个组播源，谁都可以向这个组播发送报文，容易乱套，而SSM都是指定源IP，加上有RPF，安全性相对较好。</p>
<h2 id="基本原理-2"><a href="#基本原理-2" class="headerlink" title="基本原理"></a>基本原理</h2><h3 id="ASM模型"><a href="#ASM模型" class="headerlink" title="ASM模型"></a>ASM模型</h3><p>在ASM（Any-Source Multicast）模型中，PIM-SM使用‘拉(pull)模式’转发组播报文，一般应用于组播成员规模相对较大，相对较稀疏的网络。基于这一种西数的网络模型，它的实现方法是：</p>
<ul>
<li><p>在网络中维护一台重要的PIM路由器，汇聚点RP（Rendezvous Point），可以为随时出现的组播成员或组播源服务。网络中所有PIM路由器都知道RP的位置；</p>
</li>
<li><p>当网络中出现组成员（用户主机通过IGMP加入某组播组G）时，最后一跳路由器向RP发送Join报文，逐跳创建（*,G）表项，生成一颗以RP为根的RPT（Rendezvous Point Tree）；</p>
</li>
<li><p>当网络中出现活跃的组播源（组播源向某组播组G发送第一个组播数据）时，第一跳路由器将组播数据封装在Register报文中单播发送给RP，在RP上创建（S,G）表项，注册源信息；</p>
</li>
</ul>
<p>在ASM模型中，PIM-SM的关键机制包括邻居发现、DR精选、RP发现、RPT构建、组播源注册、SPT切换、断言；同时可以通过配置BSR（Bootstrap Router）管理域来实现单个PIM-SM域的精细化管理。</p>
<p>由于ASM用的比较少</p>
<h3 id="SSM模型"><a href="#SSM模型" class="headerlink" title="SSM模型"></a>SSM模型</h3><p>SSM模型是借助PIM-SM的部分技术和IGMP V3\MLD V2来实现的，无需维护RP、无需构建RPT、无需注册组播源，可以直接在源与组播成员之间建立SPT。</p>
<p>SSM的特点是网络用户能够预先知道组播源的具体位置，因此用户在加入组播组时，可以明确指定从哪些源来接收信息，组成员端DR了解到用户主机的需求后，直接向源端发送Join报文，Join报文逐跳向上传输，在源与组成员之间建立SPT。</p>
<p>在SSM模型中，PIM-SM的关键机制包括邻居发现，DR竞选，构建SPT。</p>
<h2 id="关键机制"><a href="#关键机制" class="headerlink" title="关键机制"></a>关键机制</h2><h3 id="DR选举"><a href="#DR选举" class="headerlink" title="DR选举"></a>DR选举</h3><p>在组播源或组成员所在的网段，通常同时连着多台PIM路由器。这些PIM路由器之间通过交互Hello报文成为PIM邻居，Hello报文中携带DR优先级和该网段接口地址。PIM路由器将自身条件与对方对方报文中携带的信息进行比较，选举出DR来负责源端或组成员端组播报文的收发。选举规则如下：</p>
<ul>
<li>如果网段中所有PIM路由器都支持DR优先级，那么DR优先级较高者获胜；</li>
<li>如果DR优先级相同或该网段存在至少一台PIM路由器不支持在Hello报文中携带DR优先级，则IP地址较大者获胜。</li>
</ul>
<p>如果当前DR出现故障，导致PIM邻居关系超时，其他PIM邻居之间会触发新一轮的DR选举。</p>
<p><a href="https://www.juniper.net/documentation/us/en/software/junos/multicast/topics/concept/multicast-pim-ssm.html">https://www.juniper.net/documentation/us/en/software/junos/multicast/topics/concept/multicast-pim-ssm.html</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/protocol-independent-multicast-pim/">https://www.jannet.hk/zh-Hans/post/protocol-independent-multicast-pim/</a></p>
<p><a href="https://cshihong.github.io/2018/02/13/%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%85%B3%E7%BB%84%E6%92%AD-PIM/">https://cshihong.github.io/2018/02/13/%E5%8D%8F%E8%AE%AE%E6%97%A0%E5%85%B3%E7%BB%84%E6%92%AD-PIM/</a></p>
<h1 id="组播衍生问题"><a href="#组播衍生问题" class="headerlink" title="组播衍生问题"></a>组播衍生问题</h1><p>为什么OSPF这种IGP协议的邻居必须直连，没法像BGP一样，非直连也能建立邻居呢？因为BGP使用TCP来建立邻居，TCP连接可以跨设备不需直连，而OSPF使用组播地址建立邻居，也就是224.0.0.5和224.0.0.6，这个地址段不能被路由，传播范围仅限于本链路，不能传给下一个链路，RFC5771上规定的是：</p>
<ol>
<li>Local Network Control Block (224.0.0/24)<br>Addresses in the Local Network Control Block are used for protocol control traffic that is not forwarded off link. Examples of this type of use include OSPFIGP All Routers (224.0.0.5) [RFC2328].</li>
</ol>
<p>所以使用组播建立邻居的动态路由协议，比如OSPF，邻居必须直连，因为用来建立邻居的组播只能在本链路内传递。</p>
<p><a href="https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023">https://community.juniper.net/communities/community-home/digestviewer/viewthread?MID=65023</a></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://networklessons.com/cisco/ccie-enterprise-infrastructure/introduction-to-multicast">Introduction to Multicast</a></p>
<p><a href="http://wulc.me/2016/12/20/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93--%E7%BB%84%E6%92%AD%E5%9F%BA%E7%A1%80/">计算机网络课程总结–组播基础</a></p>
<p><a href="http://www.tcpipguide.com/free/t_IPMulticastAddressing.htm">IP Multicast Addressing</a></p>
<p><a href="https://network.51cto.com/art/201901/590835.htm">这是全面的IGMP协议总结，没有之一！</a></p>
<p><a href="https://networkengineering.stackexchange.com/questions/51956/why-we-use-224-as-multicast-address-in-many-protocols">Why we use 224 as multicast address in many protocols?</a></p>
<p><a href="http://www.tcpipguide.com/free/t_IPMulticasting.htm">IP Multicasting</a></p>
<p><a href="https://cshihong.github.io/2018/02/12/IGMP%E5%9F%BA%E7%A1%80/">IGMP基础</a></p>
<p><a href="https://community.cisco.com/t5/switching/multicast-source-tree-pim-graft-shared-tree-pim-join-prune/td-p/1683050">Multicast Source-Tree: PIM-Graft - Shared Tree: PIM Join/Prune</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>21-SDWAN</title>
    <url>/2022/01/21/21-SDWAN/</url>
    <content><![CDATA[<p>本文大部分自翻于思科的《Cisco SD-WAN Design Guide》2020年9月版本</p>
<h1 id="SD-WAN概述"><a href="#SD-WAN概述" class="headerlink" title="SD-WAN概述"></a>SD-WAN概述</h1><h2 id="SD-WAN是什么"><a href="#SD-WAN是什么" class="headerlink" title="SD-WAN是什么"></a>SD-WAN是什么</h2><p>SD-WAN（Software Defined Wide Area Network ）的中文是软件定义的广域网。WAN（Wide Area Network）表示广域网，是使得多个局域网（Local Area networks，LANs）相连的连接，一般这些局域网之间的距离为几公里到几千公里；Software-defined中文为软件定义，表示WAN（广域网）采用软件编程的方式配置和管理，因此网络可以根据需求快速的进行改变。SDWAN是一种虚拟化的服务，在很远的地理距离上，连接和扩展企业网络。WAN通常使用MPLS(Multiprotocol Label Switching)、无线、宽带、虚拟专用网络（VPN，Virtual Private Networks）等方式让远程办公的用户不受地域的限制，能够访问企业的应用程序、各种服务和资源。SDWAN能够实时监控、管理WAN广域网连接的质量，使得流量保持高速并优化连接。</p>
<h2 id="SD-WAN和传统WAN的区别"><a href="#SD-WAN和传统WAN的区别" class="headerlink" title="SD-WAN和传统WAN的区别"></a>SD-WAN和传统WAN的区别</h2><p>传统架构的WAN依赖于物理路由器将远程分支站点或远程用户连接到数据中心，使远程用户能够使用部署于数据中心中的各种程序。这些物理路由器有着独立的数据层面，数据层面中存储着信息和控制层面（告诉数据向哪里传输），数据传输的路径通常由网络管理员手工配置的规则或策略决定。这个决定的过程对于每一台路由器来说，都会耗费时间并可能会出错。</p>
<p>SD-WAN将控制和管理这两个流程与底层网络硬件分离（也就是常说的管控分离），使得两者能够被软件所配置和部署。中心化控制面板意味着网络管理员可以将新的策略或规则一次性在全网设备上部署。</p>
<h2 id="为什么需要SD-WAN"><a href="#为什么需要SD-WAN" class="headerlink" title="为什么需要SD-WAN"></a>为什么需要SD-WAN</h2><p><img src="/2022/01/21/21-SDWAN/image-20220123171759480.png" alt="image-20220123171759480"></p>
<p>这是一个当前企业典型的传统网络拓扑图，设计的初衷是既希望保障客户访问云服务的质量，也希望能够保证云的安全性。所有分支机构的流量通过主用的MPLS链路回传到总部的数据中心（Internet线路为备用线路），再由数据中心访问云端的应用。这么设计的好处有两点：</p>
<ol>
<li>MPLS线路作为主用，线路的质量比较好；</li>
<li>由于分支机构往往没有强大的安全设备，由分支机构直接访问云端服务可能存在安全隐患，因此要求分支机构的流量经由MPLS线路到达总部的数据中心，由数据中心做一系列安全的控制、策略后，流量再由数据中心连接云服务。总部的数据中心一般都会有完备的防火墙设备及相关策略配置。</li>
</ol>
<p>但这种网络设计也存在一些不足：</p>
<ol>
<li>分支机构的流量无法直接到达云服务供应商；</li>
<li>加大了MPLS带宽的压力，流量经过绕行数据中心后，会明显的增加MPLS线路的延迟；</li>
<li>MPLS带宽价格比较贵，如果业务流量增加需要加大MPLS带宽，成本会比较高，而且MPLS设计的初衷也不是为了应对SAAS（Software-as-a-service，软件即服务）应用和云服务的流量。比如中国电信2M的MPLS线路每个月价格为11500；</li>
<li>传统技术无法高效实时的在主用、备用链路之间切换，导致无法有效的利用两条链路；</li>
</ol>
<p>和传统的WAN相比，SD-WAN能够处理包括MPLS、宽带、LTE（Long Term Evolution，和数值的GSM，CMDA一样，是一种手机使用的网络制式）在内的多种连接方式，也能支持私有云、公有云、数据中心部署，SAAS（Software-as-a-service，软件即服务）等服务。SD-WAN还能实时的路由这些软件的数据，使它们选择最优的路由路径。在云部署的情况下，SD-WAN能够将互联网和云服务流量直接转发到分支结构，而无需回到总部的数据中心中。</p>
<h2 id="SD-WAN的优势"><a href="#SD-WAN的优势" class="headerlink" title="SD-WAN的优势"></a>SD-WAN的优势</h2><ul>
<li>简洁：因为每个设备都是集中管理的，所以每个设备没有单独的路由表，而是有统一的路由表，使得管理路由更为方便。路由基于应用所采用的策略，网络管理员能够实时的创建、更新安全规则，以应对网络变化；当SD-WAN和ZTP（Zero Touch Provisioning，零配置部署，是指新出厂或空配置设备上电启动时采用的一种自动加载开局文件&lt;包括系统软件、补丁文件、配置文件等&gt;的功能。设备运行ZTP功能，可以自动获取并自动加载开局文件，实现设备的免现场配置和部署，从而降低人力成本，提升部署效率。）相结合以后，企业能够进一步降低新建站点所需的复杂性、资源和运营成本；</li>
<li>增强性能：分支站点的流量可以直接访问云服务，而无需绕行总部数据中心，降低延迟，获得更好的用户体验；</li>
<li>降低成本：网络管理员能够利用宽带去替代或作为MPLS的补充，降低MPLS费用；</li>
<li>多接入：可以使用传统的Internet、4G或MPLS等多种接入方式，因此接入具体采用什么技术，显得无关紧要；</li>
</ul>
<h1 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h1><p><img src="/2022/01/21/21-SDWAN/image-20220124153315775.png" alt="image-20220124153315775"></p>
<h2 id="Secure-Automated-WAN"><a href="#Secure-Automated-WAN" class="headerlink" title="Secure Automated WAN"></a>Secure Automated WAN</h2><p>安全自动的广域网。替代了传统的MPLS为主用、互联网IPSec为备用的方式。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220129122741732.png" alt="image-20220129122741732"></p>
<ul>
<li>Automated Zero-Touch Provisioning：零接触上线。是指新出厂或空配置设备上电启动时采取的一种自动加载开局文件（包括系统软件、补丁文件、配置文件等）的功能。设备运行ZTP功能，可以自动获取并自动加载开局文件，实现设备的免现场配置和部署，从而降低人力成本，提升部署效率。在vEdge上，指的是Edge路由器自动发现它的控制器并进行认证，在和网络其他设备建立IPSec tunnel之前，自动下载预设的配置。ZTP在vEdge上的配置步骤流程图如下：</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/1217531-20210120112932910-1203274606.png" alt="img"></p>
<p><img src="/2022/01/21/21-SDWAN/1217531-20210120111753180-905326148.png" alt="img"></p>
<ul>
<li>Bandwidth Augmentation：带宽汇聚。允许用户使用所有可用的广域网（WAN）的连接方式（包括4G、5G、MPLS、普通Internet等）和路由效能（通过路由，控制流量走哪条WAN链路），来增加广域网带宽，借助增加的带宽以主动\主动方式将数据流量分布到所有可用的广域网路径上。流量可以从MPLS这种高质量、更昂贵的线路，转移到普通宽带线路上，普通宽带线路可以实现和MPLS这种昂贵线路相同的可用性和性能，但价格只有MPLS线路的几分之一。通过性能监控以及主动的路由重计算（使数据绕过故障区域），应用的性能可以得到最大限度的提高。</li>
<li>VPN Segmentation：将流量隔离是任何安全策略的关键。进入路由器的流量被分配给到一个VPN中，这样做不仅将用户的流量分离开，也将路由表分离开。这样确保了一个VPN中的用户无法传输数据给另一个VPN，除非有意这么做并进行了相关配置。当流量在广域网（WAN）中传输时，在ESP报头的后面会插入一个标签，当数据到达远端站点时，这个标签用来确定用户的流量属于哪一个VPN。</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/image-20220203211445410.png" alt="image-20220203211445410"></p>
<ul>
<li>Centralized Management：中心化管理。vManage提供了故障、配置、计费、性能和安全的中心化管理界面，该中心化管理界面可以在day0、1、2天部署设备时使用。vManage有大量可迅速部署的策略及模板，通过这些策略和模板可以提供操作上的简洁以及部署时的便利，以达到减少变更配置及部署的时间。关于day0、day1、day2，简单来说说，day-1就是在设备上架之前，day0就是设备上架并通过ZTP等方式进行简单配置，day1是设备上架后对服务进行具体配置，day2….N是设备运行中的配置，具体的说明如下：</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/116795_pastedImage_2.png" alt="img"></p>
<p><img src="/2022/01/21/21-SDWAN/116794_pastedImage_1.png" alt="img"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220205123059128.png" alt="image-20220205123059128"></p>
<h2 id="Application-Performance-Optimization"><a href="#Application-Performance-Optimization" class="headerlink" title="Application Performance Optimization"></a>Application Performance Optimization</h2><p>应用性能优化。提供了更好的基于应用的实时的优化，对链路实时监控，找到并切换到满足应用需求的链路上。</p>
<p>现网中存在着各式各样的网络问题，比如丢包、广域网链路拥塞、广域网链路的高延迟以及广域网链路选择了次优路径，这些网络问题影响着终端用户的软件体验。优化软件体验对于保持高效生产至关重要。思科SD-WAN解决方案能最小化网络的丢包、延迟和抖动，能够消除广域网延迟以及传输错误所带来的不利影响，优化软件性能。下面几个组件能够达成这个目标：</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220129123854598.png" alt="image-20220129123854598"></p>
<ul>
<li>Application-Aware Routing：可感知应用的路由。应用感知路由允许为流量创建定制的SLA策略，并通过BFD探针（Bidirectional Forwarding Detection probe）检测实时性能。应用的流量被引导到支持该SLA的广域网链路，如果出现性能下降且超过了设定值，流量可以被分配到其他性能更好的路径。上图中，远端站点到达数据中心共有三条路径，SD-WAN能够实时计算链路质量，确定应用的SLA能否被满足，从图中可以看到链路2不满足设定的参数，SD-WAN将不使用链路2传输应用的流量。</li>
<li>QoS：Quality of Service，服务质量包括对WAN路由器接口上的流量进行分类、调度、排序、整形和监督。以上这些使得QOS能够最大限度的减少关键应用数据流的延迟、抖动和丢包。</li>
<li>FEC and Packet Duplication：Forward Error Correction（FEC，转发错误纠正）和数据包复制都是用来降低丢包的。使用FEC，发送端的广域网Edge路由器会在每四个数据包中插入一个奇偶校验数据包，接收端广域网Edge路由器能够根据这个奇偶校验数据包来恢复\重建丢失的数据包；使用数据包复制这个特性，发送端的广域网Edge路由器会将选定的重要应用的所有数据包进行复制，并将复制的数据包同时在两个隧道上进行传输，接收端的广域网Edge路由器重建该重要应用的数据流并丢弃重复的数据包。</li>
<li>TCP optimization and Session Persistence：TCP优化和会话持久性，该特性能够为长距离或高延迟链路解决高延迟和低吞吐量的问题，有了TCP优化，广域网的Edge路由器可以在客户端和服务器之间起到TCP代理的作用；有了会话保持特性，一个TCP连接可以用来发送和接收多个TCP的请求和响应（request and responses），而不用像之前那样，每个TCP请求和会话都需要建立单独的会话来保持。</li>
</ul>
<h2 id="Secure-Direct-Internet-Access"><a href="#Secure-Direct-Internet-Access" class="headerlink" title="Secure Direct Internet Access"></a>Secure Direct Internet Access</h2><p>安全的互联网直接访问。在保证安全的前提下，分支结构直接通过互联网访问云端资源，而无需绕行总部的数据中心。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220206132319847.png" alt="image-20220206132319847"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220130152431301.png" alt="image-20220130152431301"></p>
<p>在传统的广域网构架下，分支机构的互联网流量会先折回到中心站点的数据中心，在数据中心，分支机构的流量能够被数据中心布置的多重安全设备保护，而后流量再回到分支机构。随着时间的推移，越来越多的公司使用了云服务上的应用，并且越来越多的应用都是基于互联网的云服务，导致分支机构的互联网流量越来越大，由于流量要先绕行数据中心，所以对带宽的需求越来越大，传输的延迟也越来越高，影响了应用的性能。</p>
<p>思科的SDWAN构架，在边缘上使用IOS XE上成熟的安全特性来保证分支机构访问互联网流量的安全，而且思科的Umbrella服务能够提供基于云的安全服务。使用Umbrella服务之前，不管是总部还是远端分支机构，都需要分别部署防火墙并且分别配置安全策略来保证数据的安全，但有了Umbrella以后，所有的流量都会先汇聚到SD-WAN上来，在SD-WAN的云端会挂一些防火墙服务，不管是分支还是总部的数据都先通过云端的防火墙后，再发送到互联网的目的地去，SDWAN相当于把总部和各个分支的流量汇聚到云端的安全服务上来过滤，而后再发送给本来流量的目的地。这样做的好处就是，只需要在云端部署一个统一策略的云防火墙即可，各个分支和总部都不需要再单独部署防火墙。</p>
<h2 id="Multicloud-Connectivity"><a href="#Multicloud-Connectivity" class="headerlink" title="Multicloud Connectivity"></a>Multicloud Connectivity</h2><p>多云连接。不仅能连接传统的站点，而且能够连接多个云服务。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220130153630428.png" alt="image-20220130153630428"></p>
<h3 id="laaS-PaaS-Saas"><a href="#laaS-PaaS-Saas" class="headerlink" title="laaS\PaaS\Saas"></a>laaS\PaaS\Saas</h3><h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p>任何一个在互联网上提供其服务的公司都可以叫云计算公司，但云服务也是分层的，分别是Infarstructure（基础设施）-as-a-Service，Platform（平台）-as-a-Service，Software（软件）-as-a-Service。基础设施在最下端，平台在中间，软件在顶端。网上流传着一个吃披萨的例子，很简单明了的阐述了LaaS\PaaS\SaaS三者之间的区别：</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220206182445824.png" alt="image-20220206182445824"></p>
<p>对于LaaS来说，就是你有一个所有材料都搭配好的生披萨，你只需要把这个披萨拿到供应商店里烤出来即可，这个过程中，厨房、烤箱、煤气等是供应商提供的，你需要自备披萨面团、番茄酱、配料、奶酪等原材料。</p>
<p>而PaaS简单多了，除了厨房、烤箱等基础设施，别人把披萨饼都准备好了，你需要做的是把自己的配料撒到披萨饼上，然后在供应商平台上烤出来即可。这个过程中，你需要的是搭配配方（产品）、掌握火候（营销推广），他人提供平台来给你实现。</p>
<p>SaaS则是所有东西都是别人的，交给你的时候已经是一个成品，换到现在的话来说就是，贴上自己的Logo，你需要做的工作就是把产品卖出去即可。</p>
<p><img src="/2022/01/21/21-SDWAN/as-a-service-Models.png" alt="as-a-service-Models"></p>
<h4 id="laaS"><a href="#laaS" class="headerlink" title="laaS"></a>laaS</h4><p>全称为Infrastructure-as-a-Service，也就是基础设施即服务，有时候也叫Hardware-as-a-Service，在实际应用中，简单来说就是laaS公司会提供场外服务器，存储和网络硬件，你可以租用。节省了维护成本和办公场地，公司可以在任何时候利用这些硬件来运行、推出其产品。laaS发展到今天，你甚至可以将硬件外包出去。</p>
<p>Microsoft、VMWare、Rackspace等公司就是典型的laaS公司。</p>
<h4 id="PaaS"><a href="#PaaS" class="headerlink" title="PaaS"></a>PaaS</h4><p>PaaS有时候也叫做中间件，也就是说客户所有的开发都在这一层开展，节省了时间和资源。</p>
<p>最典型的就是，PaaS在网上提供虚拟服务器，操作系统等集研发和分发应用于一体的各种解决方案。节省了客户在硬件开发商的费用、时间，也让分散的办公室之间合作更加便捷。一般来说，PaaS服务大致包括网页应用管理、应用设计、应用虚拟主机、存储、安全以及应用开发协作工具等。</p>
<p>Google APP Engine、Heroku，Engine Yard就是典型的PaaS公司。</p>
<h4 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h4><p>SaaS其实更简单，意味着任何一个远程服务器上的应用都可以通过网络来运行，见得比较多的就是当下各种服务中提供的SDK、API甚至是H5等形式的快捷接口形式。</p>
<p>Citrix的GoToMeeting，Cisco的WebEx等产品都是典型的商务应用型SaaS服务。</p>
<h1 id="技术构架"><a href="#技术构架" class="headerlink" title="技术构架"></a>技术构架</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><img src="/2022/01/21/21-SDWAN/image-20220130120800814.png" alt="image-20220130120800814"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220130154509323.png" alt="image-20220130154509323"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220212173534220.png" alt="image-20220212173534220"></p>
<p>思科SDWAN总体架构分为四个层次，Orchestration（编排），management（管理），control（控制）和data plan（数据层面）。</p>
<ul>
<li>编排层（Orchestration），设备为vBond，帮助SDWAN路由器自动加入Overlay中；</li>
<li>管理层（Management），设备为vManage，负责集中配置以及集中监控；</li>
<li>控制层（Control），设备为vSmart，构筑并且维持网络拓扑，并且决定流量的走向；</li>
<li>数据层面（Data plan），设备为vEdge，基于控制层的路由决策来转发数据包。</li>
</ul>
<h2 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h2><h3 id="vManage"><a href="#vManage" class="headerlink" title="vManage"></a>vManage</h3><blockquote>
<p>This is centralized network management system is software-based and provides a GUI interface to easily monitor, configure, and maintain all Cisco SD-WAN devices and their connected links in the underlay and overlay network. It provides a single pane of glass for Day 0, Day 1, and Day 2 operations. </p>
</blockquote>
<p>vManage是一个中心化的网络管理系统，它基于软件，提供图形化界面来配置和维护所有思科的SDWAN设备以及这些设备所连接的Overlay、Underlay链路。它有统一的管理界面，用来实时Day0、Day1和Day2的操作配置。</p>
<p><img src="/2022/01/21/21-SDWAN/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=.png" alt="img"></p>
<h3 id="vSmart-controller"><a href="#vSmart-controller" class="headerlink" title="vSmart controller"></a>vSmart controller</h3><blockquote>
<p>This software-based component is responsible for the centralized control plane of the SD-WAN network. It maintains a secure connection to each WAN Edge router and distributes routes and policy information via the Overlay Management Protocol (OMP), acting as a route reflector. It also orchestrates the secure data plane connectivity between the WAN Edge routers by reflecting crypto key information originating from WAN Edge routers, allowing for a very scalable, IKE-less architecture.  </p>
</blockquote>
<p>vSmart在控制层（control plane），它基于软件，负责SDWAN网络中的中心控制层。vSmart维护着每个edge路由器之间的连接，并且通过OMP协议（Overlay Management Protocol）分发路由及策略信息，vSmart充当着路由反射器的角色。vSmart通过反射来自edge路由器秘钥信息的方式，来协调\编排edge路由器之间的安全数据平面的连接，从而实现一个可扩展性极佳、无IKE的构架。</p>
<h3 id="vBond-orchestrator"><a href="#vBond-orchestrator" class="headerlink" title="vBond orchestrator"></a>vBond orchestrator</h3><blockquote>
<p>This software-based component performs the initial authentication of WAN Edge devices and orchestrates vSmart, vManage, and WAN Edge connectivity. It also has an important role in enabling the communication between devices that sit behind Network Address Translation (NAT).  </p>
</blockquote>
<p>vBond在编排层（Orchestration plane），它基于软件，负责edge设备初始认证，以及编排\协调vSmart、vManage和edge设备之间的连接。它也在NAT后面那些设备之间的通讯方面，起到重要作用。</p>
<h3 id="WAN-Edge-router"><a href="#WAN-Edge-router" class="headerlink" title="WAN Edge router"></a>WAN Edge router</h3><blockquote>
<p>This device, available as either a hardware appliance or software-based router, sits at a physical site or in the cloud and provides secure data plane connectivity among the sites over one or more WAN transports. It is responsible for traffic forwarding, security, encryption, quality of service (QoS), routing protocols such as Border Gateway Protocol (BGP) and Open Shortest Path First (OSPF), and more.  </p>
</blockquote>
<p>Edge路由器可以是硬件的实体路由器，也可以是基于软件的路由器，它可以部署在实体的物理站点中，也可以部署在云上（亚马逊、微软云），通过一个或多个广域网传输提供站点之间的安全数据平面连接。它负责流量转发、安全、加密、质量服务（QOS）、路由协议（BGP、OSPF等）。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220130155934626.png" alt="image-20220130155934626"></p>
<p>上图中的简单拓扑描述了两个WAN的Edge站点，每个Edge站点都连接了两条链路，私有MPLS链路和公有互联网链路。基于云服务的SDWAN控制器（两个vSmart控制器，vBond和vManage服务器）通过公有互联网直接连接。此外，拓扑也包括了连接到SaaS、laaS的云服务。</p>
<p>Edge路由器与vSmart控制器形成永久的DTLS（Datagram Transport Layer Security）或TLS（Transport Layer Security）控制连接。并通过两种连接方式（MPLS链路、公有互联网链路）与两个vSmart控制器建立了连接。路由器还与vManage服务器形成了永久的DTLS或TLS控制连接，但只通过其中一种连接方式传输。Edge路由器们通过每种连接方式（MPLS链路、公有互联网链路），使用IPSec隧道与其他广域网路由器进行安全通信。BFD（双向转发检测，Didirectional Forwarding Detection）协议默认启动并运行在每一个隧道上，检测丢包、延迟、抖动以及路径故障。</p>
<h3 id="Site-ID"><a href="#Site-ID" class="headerlink" title="Site ID"></a>Site ID</h3><blockquote>
<p>A site ID is a unique identifier of a site in the SD-WAN overlay network with a numeric value 1 through 4294967295 (2^32-1) and it identifies the source location of an advertised prefix. This ID must be configured on every WAN Edge device, including the controllers, and must be the same for all WAN Edge devices that reside at the same site. A site could be a data center, a branch office, a campus, or something similar. By default, IPsec tunnels are not formed between WAN Edge routers within the same site which share the same site-id. </p>
</blockquote>
<p>Site ID是一个独一无二的数字（从1到4294967295之间的），用来标识SDWAN overlay网络上的站点，并且Site ID还用来标识路由前缀的起源站点。这个Site ID必须在所有广域网的Edge设备上进行配置，包括控制器上也要配置Site ID，这些在同一个站点的所有广域网Edge设备上必须配置相同的Site ID。同一个站点可以是一个数据中心，一个分支机构，一个校园网或其他类似的。默认情况下，同一个站点中使用相同Site ID的广域网Edge设备之间不会形成IPSec隧道。</p>
<h3 id="System-IP"><a href="#System-IP" class="headerlink" title="System IP"></a>System IP</h3><blockquote>
<p>A System IP is a persistent, system-level IPv4 address that uniquely identifies the device independently of any interface addresses. It acts much like a router ID, so it doesn’t need to be advertised or known by the underlay. It is assigned to the system interface that resides in VPN 0 and is never advertised. A best practice, however, is to assign this system IP address to a loopback interface and advertise it in any service VPN. It can then be used as a source IP address for SNMP and logging, making it easier to correlate network events with vManage information.  </p>
</blockquote>
<p>System IP是一个固定的，系统级别的IPV4地址，这个地址唯一的标识着设备，使得它区别于其他接口的地址。System IP有点类似于Router ID，因此System IP不需要被宣告或者被underlay知道。system ip被分配给位于VPN0中的系统接口，不会被宣告。然而，最好将System IP分配给一个环回口，并且在所有VPN中宣告这个环回接口，它可以作为SNMP和系统日志的源地址，使得它能更好的将网络中发生的情况和vManage信息关联起来。</p>
<h3 id="Organization-Name"><a href="#Organization-Name" class="headerlink" title="Organization Name"></a>Organization Name</h3><blockquote>
<p>Organization Name is a name that is assigned to the SD-WAN overlay. It is case-sensitive and must match the organization name configured on all the SD-WAN devices in the overlay. It is used to define the Organization Unit (OU) field to match in the Certificate Authentication process when an SD-WAN device is brought into the overlay network.  </p>
</blockquote>
<p>组织名是分配给SDWAN overlay网络的，这个名字大小写敏感（也就是说大写的组织名和小写的组织名，并不是同一个名字），SDWAN的overlay网络中的所有设备的组织名必须一致。组织名用来定义Organization Unit（OU）字段，以便在SDWAN设备接入overlay网络时，在证书认证过程中进行匹配。</p>
<h3 id="Private-IP-Address"><a href="#Private-IP-Address" class="headerlink" title="Private IP Address"></a>Private IP Address</h3><blockquote>
<p>On WAN Edge routers, the private IP address is the IP address assigned to the interface of the SD-WAN device. This is the pre-NAT address, and despite the name, can be a public address (publicly routable) or a private address (RFC 1918). </p>
</blockquote>
<p>在广域网的边缘路由器上，那些分配给SDWAN设备接口的IP地址叫做私有IP地址。这些地址并没有经过NAT，尽管它们被叫做私有地址，但这些所谓的私有地址可以是真-公有地址（能够被路由的公有地址）或私有地址（符合RFC1918-Address Allocation for Private Internets规定的真-私有地址）</p>
<h3 id="Public-IP-Address"><a href="#Public-IP-Address" class="headerlink" title="Public IP Address"></a>Public IP Address</h3><blockquote>
<p>The Post-NAT address detected by the vBond orchestrator. This address can be either a public address (publicly routable) or a private address (RFC 1918). In the absence of NAT, the private and public IP address of the SD-WAN device are the same. </p>
</blockquote>
<p>那些经过NAT之后，被vBond编排器所检测到的地址，叫做公有IP地址。这些公有地址可以是真正意义上的真-公有地址（能够被路由的公有地址），也可以是私有地址（符合RFC1918-Address Allocation for Private Internets规定的真-私有地址）。由于没有经过NAT，SDWAN设备的私有IP地址和公有IP地址是相同的。</p>
<h3 id="TLOC"><a href="#TLOC" class="headerlink" title="TLOC"></a>TLOC</h3><blockquote>
<p>A TLOC, or Transport Location, is the attachment point where a WAN Edge router connects to the WAN transport network. A TLOC is uniquely identified and represented by a three-tuple, consisting of system IP address, link color, and encapsulation (Generic Routing Encapsulation [GRE] or IPsec).  </p>
</blockquote>
<p>TLOC（Transport Location，传输位置），是关于王边缘路由器连接到广域网的连接点。一个TLOC由一个三元组定义并代表，这个三元组由system IP、Link color（链路颜色）和封装方式（GRE或IPSec）构成。</p>
<h3 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h3><blockquote>
<p>The color attribute applies to WAN Edge routers or vManage and vSmart controllers and helps to identify an individual TLOC; different TLOCs are assigned different color labels. The example SD-WAN topology in figure 10 uses a public color called biz-internet for the Internet transport TLOC and a private color called mpls for the other transport TLOC. You cannot use the same color twice on a single WAN Edge router.  </p>
</blockquote>
<p>颜色，color属性用在广域网边缘路由器、vManage控制器或vSmart控制器上，用来帮助识别一个独立的TLOC，不同的color标签会分配给不同的TLOC。上图中的SDWAN拓扑中，使用名叫biz-internet的公有color来标识互联网TLOC链路，使用名叫mpls的私有color来标识其他的TLOC链路。在一个广域网边缘路由器上，不能使用相同的color两次。</p>
<h3 id="OMP"><a href="#OMP" class="headerlink" title="OMP"></a>OMP</h3><blockquote>
<p>Overlay Management Protocol.The OMP routing protocol, which has a structure similar to BGP, manages the SD-WAN overlay network. The protocol runs between vSmart controllers and between vSmart controllers and WAN Edge routers where control plane information, such as route prefixes, next-hop routes, crypto keys, and policy information, is exchanged over a secure DTLS or TLS connection. The vSmart controller acts similar to a BGP route reflector; it receives routes from WAN Edge routers, processes and applies any policy to them, and then advertises the routes to other WAN Edge routers in the overlay network.  </p>
</blockquote>
<p>OMP协议（Overlay 管理协议），用来管理SDWAN的overlay网络，它的构架看上去和BGP有些类似。它运行在vSmart和广域网边缘路由器之间，在vSmart和边缘路由器之间控制层面信息（例如路由前缀、下一跳路由、秘钥和策略信息）通过安全的DTLS或TLS连接进行交互。vSmart控制器的角色有点类似于BGP路由反射器，它从广域网边缘路由器上接收路由，处理且应用二者（vSmart和边缘路由器）之间的所有策略，然后宣告路由到其他的overlay网络中的边缘路由器上。 </p>
<h3 id="VPN"><a href="#VPN" class="headerlink" title="VPN"></a>VPN</h3><p>在SDWAN的overlay网络中，VPNs（Virtual Private Networks）提供了隔离功能，类似于VRFs（Virtual Routing and Forwarding instances）的功能。每个VPN和其他VPN分离开，并且每个VPN有它各自的转发表项，一个接口\子接口只能配置于一个VPN中，标签应用于OMP路由的属性中，以及数据包的封装中，用来标识数据包属于哪个VPN之中。</p>
<p>VPN号是一个范围在0-65535之间的，四字节整数，但有一些VPN号码要保留给内部使用，所以VPN号中，一共能用来给用户配置的数字为65527个。广域网边缘设备上和控制器上，有两个默认存在的VPN，VPN0和VPN512，要注意，VPN0和VPN512是唯一能配置在vManage和vSmart控制器上配置的VPN。对vBond这个编排器来说，虽然能配置更多的VPN，但只有VPN0和VPN512是有效的，而且只能使用这两个VPN。</p>
<ul>
<li>VPN0是传输VPN（Transport VPN）。它包含着所有连接到广域网链路的接口，与控制器的安全DTLS/TLS连接就是由这个VPN发起的。静态路由、默认路由或动态路由协议都需要配置在这个VPN中，以便能得到下一跳的路由信息，从而建立控制层面，使得IPSec隧道流量能够到达远程站点。</li>
<li>VPN512是管理VPN，它承载着进出思科SDWAN设备的带外管理流量。这个VPN被OMP协议所忽略，不在overlay网络上传输。</li>
</ul>
<p>除了已经定义的VPN之外，需要建立一个或多个服务端VPN，这些服务端VPN包含着连接本地端网络的接口，并且承载着用户数据的流量。通常建议选择1-511之间的数字作为VPN的名字，但也支持更高数字号码，只要这些号码和保留\默认VPN的数字不重复就行。可以为OSPF、BGP、VRRP（Virtual Redundancy Protocol）、QOS、流量整形或策略等功能启用服务VPN。通过将OMP路由（从站点的vSmart控制器收到的）重分布到服务端VPN使用的路由协议中的方式，可以将用户流量通过IPSec隧道引导到其他站点。反过来，本地站点的路由也可以通过宣告服务端VPN路由到OMP路由协议中的方式，被宣告到其他站点，OMP路由协议被发送到vSmart控制器并且重分布到网络中的其他广域网边缘路由器上。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220218175246477.png" alt="image-20220218175246477"></p>
<p>当配置从vManage推送到运行了IOS XE系统的SDWAN路由器的时候，配置会自动的转换成IOS XE能识别的格式，其中一些区别包括：</p>
<ul>
<li>VPN关键词会被VRF的术语所代替；</li>
<li>用全局路由表来表示VPN0；</li>
<li>VRF Mgmt-intf（The Gigabit Ethernet Management interface is automatically part of its own VRF. This VRF, which is named “Mgmt-intf,” is automatically configured on the Cisco ASR 1000 Series Router and is dedicated to the Management Ethernet interface; no other interfaces can join this VRF.）在管理接口上默认启用，被用来代表VPN512。</li>
</ul>
<h2 id="控制层面"><a href="#控制层面" class="headerlink" title="控制层面"></a>控制层面</h2><h3 id="控制连接"><a href="#控制连接" class="headerlink" title="控制连接"></a>控制连接</h3><p>思科SDWAN的vManage和vSmart控制器最初会和vBond控制器进行通讯并对其身份进行认证，vManage和vSmart会和vBond形成永久的DTLS连接，随后vManage会和vSmart之间建立并维持永久的DTLS\TLS连接。广域网边缘路由器也采用类似的方式接入网络，但是边缘路由器会断开和vBond的短暂链接，边缘路由器会和vManage和vSmart控制器形成永久的DTLS\TLS连接，下面的图标说明了这一过程：</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220219122516052.png" alt="image-20220219122516052"></p>
<p>到vBond的连接永远是采用DTLS方式的，默认情况下，连接到vManage和vSmart的连接也是DTLS的，但也可以在设备上将连接方式改为TLS，在安全控制协议配置中进行更改。如果一个设备的连接方式改为TLS，另一个设备的连接方式为DTLS，那么这两个设备之间的控制连接方式将使用TLS。更推荐使用TLS的方式进行连接，因为TLS用的是TCP协议，TCP协议有ACK确认包，可靠性更高。TCP是面向连接的，因此防火墙可以保存维持TCP连接的状态，允许返回流量，不用显示配置策略允许返回流量。</p>
<p>如果vManage和vSmart有多个核心（core）的情况下，vManage和vSmart的每个核心（比如说vSmart有2个CPU，也就是vSmart有两个核心。最多支持8个核心，也就是8个CPU）会初始化，然后建立控制连接到vBond（vBond只有一个核心也就是一个CPU），vManage和vSmart之间只有一个连接。如果vSmart有两个CPU，也就是有两个核心（core），那么vSmart和vBond之间会建立并保持两个完全控制连接，每个核心一个连接。如果vManage有4个CPU，也就是4个核心，那么vBond和vManage之间就会保持着4个完全控制连接，一个核心一个连接。vSmart和vSmart之间，vManage和vManage之间都只有一个控制连接，冗余的vBond之间没有控制连接。</p>
<h4 id="WAN-edge控制连接"><a href="#WAN-edge控制连接" class="headerlink" title="WAN edge控制连接"></a>WAN edge控制连接</h4><p>在默认情况下，广域网边缘路由器会尝试在所有可用的连接链路上建立控制连接，在和其他控制器建立连接之前，会先在每个连接链路上，尝试去连接vBond，如果链路上有多个vBond，那么每个链路上只会建立一个vBond控制连接。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220219161612060.png" alt="image-20220219161612060"></p>
<ul>
<li>每个vManage核心（core）和每个vBond核心（core）之间会建立持久的DTLS连接；</li>
<li>vSmart和vManage之间会建立持久的TLS或DTLS连接；</li>
<li>vSmart控制器之间会建立全互联（Full mesh）的TLS\DTLS连接（每对之间一个连接）；</li>
<li>vManage集群的实例之间会建立全互联（Full mesh）的TLS\DTLS连接（每对之间一个连接）；</li>
<li>每个广域网边缘路由器和vManage实例之间会建立TLS\DTLS连接，每个链路（比如4G，MPLS或互联网）上只有一个连接；</li>
<li>默认情况下，每个广域网边缘路由器和两个vSmart控制器之间默认会建立TLS\DTLS连接，每个链路一个；</li>
</ul>
<h2 id="编排层面"><a href="#编排层面" class="headerlink" title="编排层面"></a>编排层面</h2><h3 id="edge路由器上线overlay"><a href="#edge路由器上线overlay" class="headerlink" title="edge路由器上线overlay"></a>edge路由器上线overlay</h3><p><img src="/2022/01/21/21-SDWAN/image-20220124181223612.png" alt="image-20220124181223612"></p>
<blockquote>
<p>\1. Through a minimal bootstrap configuration or through the automated provisioning (ZTP or PnP) process, the WAN Edge router first attempts to authenticate with the vBond orchestrator through an encrypted DTLS connection. Once authenticated, the vBond orchestrator sends the WAN Edge router the IP addresses of the vManage network management system (NMS) and the vSmart controllers. The vBond orchestrator also informs the vSmart controllers and vManage of the new WAN Edge router wanting to join the domain.  </p>
<p>\2. The WAN Edge router begins establishing secure DTLS or TLS sessions with the vManage and the vSmart controllers and tears down the session with the vBond orchestrator. Once the WAN Edge router authenticates with the vManage NMS, the vManage pushes the configuration to the WAN Edge router if available.  </p>
<p>\3. The WAN Edge router attempts to establish DTLS/TLS connections to the vSmart controllers over each transport link. When it authenticates to a vSmart controller, it establishes an OMP session and then learns the routes, including prefixes, TLOCs, and service routes, encryption keys, and policies.  </p>
<p>\4. The WAN Edge router attempts to establish BFD sessions to remote TLOCs over each transport using IPsec. </p>
</blockquote>
<ol>
<li> 通过最小启动配置或者自动配置（ZTP，Zero Touch Provisioning，PnP，Plug and Play）的过程，广域网边缘路由器（edge router）首先开始尝试对vBond进行认证，认证是通过加密的DTLS连接进行的。一旦认证成功，vBond会将vManage网络管理系统（NMS）和vSmart的地址发送给edge路由器，vBond也会将新的edge路由器希望加入域的情况告知vSmart和vManage。</li>
<li>edge路由器开始与vManage、vSmart建立安全的DTLS\TLS会话，并且结束和vBond的会话。一旦edge路由器和vManage NMS（Network Management System）完成了认证，vManage会将配置推送给edge路由器，如果vManage上有这个配置的话。</li>
<li>edge路由器尝试在每条链路上（4G，MPLS，互联网等连接方式）和vSmart建立DTLS\TLS连接，当edge路由器和vSmart认证完毕后，edge路由器和vSmart建立OMP会话并且学习路由（包括路由前缀、TLOCs&lt;Transport Location，传输位置&gt;、服务端路由、秘钥和策略）。</li>
<li>得个路由器在每条链路上，使用IPSec尝试和远端TLOCs建立BFD（Bidirection Forwarding Detection，双向转发检测）会话。</li>
</ol>
<h2 id="数据层面"><a href="#数据层面" class="headerlink" title="数据层面"></a>数据层面</h2><h3 id="vBond作为NAT促进器"><a href="#vBond作为NAT促进器" class="headerlink" title="vBond作为NAT促进器"></a>vBond作为NAT促进器</h3><p>所有的控制器或SDWAN的路由器，都不知道它们位于NAT设备之后，知道从网络外界连接的IP地址和端口，对于在SDWAN网络中成功立管理和数据层的连接十分重要。vBond在这个过程中扮演了重要角色，它的角色是STUN（Session Traversal Utilities，是一种<a href="https://zh.wikipedia.org/wiki/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE">网络协议</a>，它允许位于NAT&lt;或多重NAT&gt;后的客户端找出自己的公网地址，查出自己位于哪种类型的NAT之后以及NAT为某一个本地端口所绑定的Internet端端口。这些信息被用来在两个同时处于NAT路由器之后的主机之间建立UDP通信。该协议由RFC 5389定义。）服务器的角色，使得其他控制器和SDWAN中的路由器能够发现它们映射\转换的IP地址和端口号。SDWAN设备宣告这些信息以及TLOCs信息，使得其他SDWAN中的设备能够知晓这些信息，从而成功建立连接。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220219182433607.png" alt="image-20220219182433607"></p>
<h3 id="数据层面隐私及加密"><a href="#数据层面隐私及加密" class="headerlink" title="数据层面隐私及加密"></a>数据层面隐私及加密</h3><p>edge路由器使用IPSec以及秘钥用来加密和解密数据，这样能确保edge之间交互的数据流量的安全性。在传统的IPSec环境中，IKE（Internet Key Exchange）协议用来在peer路由器之间加速秘钥交换的速度。这样交换秘钥使得创建的秘钥都是成对出现的，也就是一次创建出两个秘钥，如果在全互联（Full mesh）的环境中，假设有N台设备，那么每台设备需要设备管理$N^2$个秘钥交换以及（N-1）个不同的秘钥。在思科SDWAN网络中，为了更便捷的扩展网络的规模，思科SDWAN不使用IKE协议交换秘钥，因为edge路由器之间的认证已经建立完毕（IKE交换秘钥就是为了进行认证），这也就是前面相关概念部分中vSmart概念中提到的‘allowing for a very scalable, IKE-less architecture’，也就是实现一个可扩展性极佳、无IKE的构架。控制层面（已经通过DTLS\TLS实现了认证，加密，防篡改）用来传输经过AES-256加密的对称秘钥。每个edge路由在每一个传输链路上，在每个TLOC上生成一个AES秘钥，将此秘钥信息通过OMP路由数据包传输给vSmart，vSmart再将这个秘钥信息传递到所有其他edge路由器上。</p>
<p>默认情况下，秘钥的持续时间为24小时，每隔12小时会生成新的秘钥，新秘钥被发送到vSmart上，由vSmart传递给其他edge路由器，这意味着任何时候都有两个秘钥。当edge路由器切换到使用新生成秘钥的时候，上一个旧的秘钥依旧会保留12小时，这时候，使用哪个秘钥的流量都可以被接收。如果到vSmart的OMP会话中断了，edge路由器会持续使用之前已知的信息（包括配置、策略、路由以及IPSec秘钥）最多12小时，这个12小时是OMP优雅重启计时器到期的时间。两个秘钥（旧秘钥和新秘钥）使得网络肯定能够支持OMP12小时的优雅重启计时器，因为谁也不知道OMP会话什么时候出现中断。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220124181508318.png" alt="image-20220124181508318"></p>
<p>从vEdge版本19.2、IOS XE版本16.12.1b开始，可以配置成对的秘钥，成对秘钥使用AES256对称加密算法，SDWAN路由器并没有和其他overlay上所有的路由器共享同一个秘钥，而是和传输路径上的路由器共享一个特殊的TLOC秘钥。</p>
<p>为了加密传输数据流，会使用一个经过改良的ESP（Encapsulating Security Payload）版本来保护数据包的payload负载部分。加密的算法使用AES-256 GCM（Galois/Counter Mode）也可以根据需要回退到AES-256 CBC（Cipher Block Chaining，密码分组链接模式）加密算法（在有组播的情况下）。可以配置认证算法（验证了数据完整性和真实性），它包含在TLOC属性中，这个属性会与vSmart进行交互。默认情况下，会同时配置AH-SH1 HMAC和ESP HMAC-SHA1算法，当配置了多个认证方式时，会选择两种方式中最安全的方法（AH-SHA1 HMAC）。</p>
<h3 id="TLOCs"><a href="#TLOCs" class="headerlink" title="TLOCs"></a>TLOCs</h3><p>TLOCs，全称为Transport Locators，中文翻译为传输定位器（？），是edge路由器连接到广域网链路（4G、MPLS、宽带互联网等）的连接点，一个TLOC是唯一的，它被三元组（固定的system IP，color和封装方式<Generic routing encapsulate>）所代表。TLOC路由器通过OMP协议宣告给vSmart，宣告给vSmart时也包括了每个TLOC所包含的属性，包括私有IP地址、公有IP地址、端口号、color和秘钥。这些TLOC路由器以及它们的属性被通告给其他的edge路由器。在edge路由器知道了TLOC属性和秘钥信息后，它们就能用IPSec协议和其他edge路由器建立BFD会话。</Generic></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220124181553099.png" alt="image-20220124181553099"></p>
<p>在默认情况下，edge路由器会尝试在每一条链路上尝试去连接每个TLOC，其中也包括那些属于其他链路上标记为其他color的TLOC，当用户在不同的地点有不同的互联网链路时，这样操作会很有帮助，因为它们之间应该直接相互通信。为了防止这种行为，可以在配置的时候加上‘restrict’关键词，可以和tunnel的color一起设定。加上关键词restrict配置后，可以防止不同color之间去建立BFD会话，通常这种配置会用在私有链路上，用来防止私有链路和公有链路之间建立连接。</p>
<p>下面给出了关键词‘restrict’在BFD会话建立之时的影响。左边是没配置restrict的情况，右边是在MPLScolor上配置了restrict的情况，这时MPLS TLOCs只和其他的MPLS TLOCs建立会话。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220220154849740.png" alt="image-20220220154849740"></p>
<h3 id="Color-1"><a href="#Color-1" class="headerlink" title="Color"></a>Color</h3><p><strong>color属性用来标识在edge设备上终止的单个广域网传输链路的抽象概念。</strong>color是静态定义的关键字而不是动态自由格式的标签。color很重要，因为它们定义了单个传输链路是公有的还是私有的。当color为metro-Ethernet（城域网），MPLS，private1，private2，private3，private4，private5和private6的时候，为私有颜色，私有颜色用在私有网络，或者用在传输链路终端没有NAT的地方；公有color为3g，biz-internet，blue，bronze，custom1，custom2，custom3，default，gold，green，LTE，public-Internet，red和silver。它们被用在公有网络上或者用在传输链路终端经过NAT的地方，无论是本地还是经过NAT。<strong>color决定了在通过控制平面或数据平面进行通信时，使用私有IP地址还是公有IP地址。</strong></p>
<p>在edge路由器上，每一个TLOC都会和《私有IP地址：公有IP地址》这个IP地址对儿相互关联。、</p>
<ul>
<li>私有地址是分配给SDWAN设备接口的，这个地址没经过NAT转换并且即使它的名字是“私有地址”，但也可以是在公网上可路由的公有IP地址；</li>
<li>公有地址是经过NAT转换的，被vBond所知晓的地址，这个公有地址可以是公有可路由地址，也可以是私有地址，没有NAT的话，SDWAN的公有地址和私有地址都是一样的。</li>
</ul>
<h4 id="公有-私有color之间的通信"><a href="#公有-私有color之间的通信" class="headerlink" title="公有\私有color之间的通信"></a>公有\私有color之间的通信</h4><p>当SDWAN设备和vBond设备进行通信和认证时，vBond在交互信息时就知道了和它通信设备的“私有地址/端口”以及“公有地址/端口”这些设置信息。上面提到的私有地址是分配给接口的本地IP地址，如果涉及NAT的话，公有地址是指经过NAT的IP地址。</p>
<p>当两个SDWAN设备想和彼此通信时，它俩都会使用private color的接口来进行通信，两端的设备都会尝试和对方的私有IP地址进行通信。如果有一端或两段都采用public color时，那么两端都会使用公有IP地址和对端进行通信。</p>
<p>需要注意的是，如果两端的Site ID相同，但使用了public color时，会使用私有地址进行通信。这种情况可能发生在edge路由器试图与位于同一站点的内部vManage或vSmart进行通信时，亦或是与位于同一防火墙后面的内部控制器通信时。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220220170026348.png" alt="image-20220220170026348"></p>
<ul>
<li>edge路由器使用IPSec和其他edge路由器通信；</li>
<li>edge路由器和vManage\vSmart\edge路由器之间使用DTLS\TLS连接；</li>
<li>edge路由器和vManage\vSmart之间使用DTLS\TLS进行连接</li>
</ul>
<h3 id="BFD"><a href="#BFD" class="headerlink" title="BFD"></a>BFD</h3><p>BFD全称是，Bidirectional Forwarding Detection，双向转发检测。在思科的edge路由器上，在对等体\邻居之间，BFD默认被开启且无法关闭。它跨越所有传输链路，在IPSec隧道封装的拓扑中的所有edge路由器之间运行。BFD在echo模式下使用，这模式下意味着当BFD数据包被edge路由器发送的时候，接收到这个BFD数据包的edge路由器会不经过任何处理而将它直接发回。这样做的目的是因为，BFD协议是用来检测链路是否处于通畅状态，它也可以用来为应用感知的路由执行链路质量检测，例如丢包、延迟和抖动。BFD可以用来检测长时间断电（Blackout）以及短时间断电（Brownout）</p>
<p>隧道活性</p>
<p>Tunnel Liveliness，隧道活性。BFD默认每1秒（原文是1000 milliseconds/1 second，其实就是1秒，奇葩的写法，凸）在所有Tunnel上发送一次hello包，用来检测IPSec隧道是否UP。默认的BFD最大计时器为7，意味着如果一个一个tunnel连续丢了7个Hello包，就会被认为该Tunnel已经down了。BFD的Hello包的间隔和最大计时器可以在一对color上同时修改。</p>
<h3 id="NAT"><a href="#NAT" class="headerlink" title="NAT"></a>NAT</h3><p>在设计SDWAN网络时，要格外小心分支机构使用的NAT类型，因为NAT类型可以影响站点是否可以建立连接并直接与对方通信。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220223150045359.png" alt="image-20220223150045359"></p>
<p>所有的NAT类型都能建立映射，映射内容是IP数据包中的源IP地址、源端口、目标IP地址、目标端口。在后文通常的例子里，源NAT是为了将数据包中的真私有IP地址（符合RFC1918规则，Address Allocation for Private Internets），也就是源IP地址A，变成一个公有且可路由的IP地址Z，以便让Host A能够和基于互联网的服务器，Host B，通信。当Host B回给Host A的回包经过NAT时，目标IP地址Z会映射回初始的IP地址A，并且数据包会发送给初始的主机，Host A。</p>
<p>四种不同类型的NAT有着不同的行为模式：</p>
<ul>
<li>Full-Cone NAT。直译成中文就是全锥形NAT，这种NAT类型也被称作“一对一NAT”，它是受限最小的NAT类型，它将一个本地IP地址、本地端口，映射到一个公有IP地址和公有端口上，一旦一个NAT转换出现或是一个静态的一对一NAT进行了配置，任何外部主机（比如下图中的HostC和HostB）都可以通过这个NAT映射的IP地址和端口，给这个内部的主机发送数据。</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/image-20220223154134468.png" alt="image-20220223154134468"></p>
<ul>
<li>Restricted-Cone NAT。直译成中文是受限锥形NAT。这种NAT和之前的全锥形NAT十分相似，但受到一些限制。一旦一个内部主机A给一个外部主机B发送数据包，那么NAT为这个内部的IP地址和端口提供了转换，但只有外部的HostB能够通过所有端口给本地的HostA发送数据。</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/image-20220223154830349.png" alt="image-20220223154830349"></p>
<ul>
<li>Port-Restricted-Con NAT。端口受限的锥形NAT。该类型NAT和上面的受限锥形NAT很像，但限制了通信的端口号。当内部主机Host A发送数据包给外部主机Host B的端口X时，并且本地IP地址和端口发生了NAT转换，那么只有外部主机B（仅限于主机B的端口X）可以通过映射的NAT IP地址和端口向本地主机A发送数据。</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/image-20220223160020537.png" alt="image-20220223160020537"></p>
<ul>
<li>Symmetric NAT。对称NAT。该类型是受限最多的NAT类型，和上面的端口限制锥形NAT类似，区别在于只有外部的主机B的源端口X能够给本地主机A，可以通过NAT存储的IP地址和端口来发送数据。对称NAT的不同之处在于，每次主机A要和不同的目的地通信时，都会使用一个独特的源端口。对称NAT会引起STUN服务器的问题，因为STUN服务器学到的IP地址/端口映射是对另一个主机的不同映射。</li>
</ul>
<p><img src="/2022/01/21/21-SDWAN/image-20220223160154584.png" alt="image-20220223160154584"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220223170218180.png" alt="image-20220223170218180"></p>
<h2 id="SDWAN路由"><a href="#SDWAN路由" class="headerlink" title="SDWAN路由"></a>SDWAN路由</h2><h3 id="Underlay-VS-Overlay路由"><a href="#Underlay-VS-Overlay路由" class="headerlink" title="Underlay VS Overlay路由"></a>Underlay VS Overlay路由</h3><p>思科SDWAN网络分为两个不同的部分，underlay和overlay。underlay网络时物理网络基础设施，它将网络设备（比如路由器、交换机）连接在一起，并使用传统的路由机制在设备之间路由流量。在SDWAN网络中，它通常由edge路由器与广域网传输链路的连接，以及广域网传输链路本身，这两者组成。连接到underlay的网络接口属于VPN0，也就是传输VPN。在广域网传输链路上，连接到运营商网关意味着要配置静态默认网关，或者要配置诸如BGP或OSPF之类的动态路由协议。这些位于underlay网络的路由过程只限于VPN0上。主要目的是为了与其他edge路由器的TLOC相连通，以便于建立IPSec隧道，组成overlay网络。</p>
<p><img src="/2022/01/21/21-SDWAN/image-20220218175246477.png" alt="image-20220218175246477"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220124182048736.png" alt="image-20220124182048736"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220125203935057.png" alt="image-20220125203935057"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220126152634318.png" alt="image-20220126152634318"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220126152833236.png" alt="image-20220126152833236"></p>
<p><img src="/2022/01/21/21-SDWAN/image-20220126153325463.png" alt="image-20220126153325463"></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://www.riverbed.com/faq/what-is-sd-wan.html">What is SD-WAN?</a></p>
<p><a href="https://www.paloaltonetworks.com/cyberpedia/what-is-a-sd-wan">What Is SD-WAN?</a></p>
<p><a href="https://community.cisco.com/t5/nso-developer-hub-blogs/day-1-day-0-day-1-day-2-n-configurations/ba-p/3658255">Day(-1),Day-0,Day-1,Day-2..N Configurations</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1033638">一文看懂LaaS、PaaS、SaaS</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>8、子网划分</title>
    <url>/2020/02/19/8-subnet/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此篇笔记是在<a href="https://blog.51cto.com/6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a>以及<a href="https://blog.51cto.com/6930123/2115072">IP地址和子网划分学习笔记之《超网合并详解》</a>两篇笔记的基础上进行了部分改动。</p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><h3 id="子网划分的定义"><a href="#子网划分的定义" class="headerlink" title="子网划分的定义"></a>子网划分的定义</h3><p>可以自由的加减子网掩码长度，也就是不限制于A/B/C类默认的掩码长度，A类地址不必须使用8/位的掩码，也可以用诸如：10/位掩码或者7/位掩码。</p>
<h3 id="子网划分的原因"><a href="#子网划分的原因" class="headerlink" title="子网划分的原因"></a>子网划分的原因</h3><p>子网就是把一个大网划分为几个小网，而如果按照默认的A\B\C类默认使用的话，比如一个B类地址，默认掩码为255.255.0.0，意味着这个地址空间里有2的16次方个IP，并且该网络号只能用于一个广播域，造成了IP地址的极大浪费，如果一个广播域中的PC数量过于庞大，网络可能被广播报文消耗大量资源。把一个大网络划分成几个不同的小网络以后，他们之间的网络号和广播地址各不相同，可以尽可能多的使用IP地址避免浪费，一个网段中的主机数量相对少一些的话，广播报文消耗的资源也会少很多，使得网络更有层次性。</p>
<p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是<strong>VLSM（可变长子网掩码）</strong>和<strong>CIDR（无类别域间路由）</strong>，把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。</p>
 <span id="more"></span>  

<p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率。</p>
<h3 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h3><p>知道划分子网的实质就是把host-id分出若干位数来作net-id，这时外界是怎样和划分好了的子网内的主机联系的呢？</p>
<p>在没有子网掩码的情况下，外界要和子网内的主机联系必须通过先前没划分的总的网络路由器，然后由路由器查找网内的各主机，这样效率就很低下。可不可以让各个子网独自通过自己的路由和外界通信呢？掩码正是为了解决这个问题。</p>
<p>各个子网要和外界独自通信，必须让外界知道你是划分了的子网，你的具体网络ID。但路由表并没有划分子网的具体信息，所以外界也无法通过你的路由器和你联系。掩码就是在你划分了的子网IP地址中，net-id相对应的地方标上1, host-id相对应的地方标上0.再在路由表中添加掩码这一项，这样外界就很容易知道你的具体网络ID了。这就是掩码的作用。</p>
<h3 id="子网划分的方法"><a href="#子网划分的方法" class="headerlink" title="子网划分的方法"></a>子网划分的方法</h3><p>子网划分的总体思路是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网：</p>
<ol>
<li><p>把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p>
</li>
<li><p>把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p>
</li>
<li><p>原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p>
</li>
</ol>
<p>网络ID等同于网络位，主机ID等同于主机位，翻译方式不同。</p>
<p><strong>必须注意的是，子网ID和网络位、主机位概念类似，都是一个范围，根据借位的多少有所区别，因为IP地址都是二进制的，所以接1位会多出2个子网，借两位多出4个子网，借三位多出8个子网，以此类推。后面会结合实际例子进一步说明，这里一定要记住这个概念。</strong></p>
<p><img src="/2020/02/19/8-subnet/afdf9cfdadeda8e3fce05fd4857b1947.png" alt="afdf9cfdadeda8e3fce05fd4857b1947"></p>
<p><strong>全0子网与全1子网</strong></p>
<p>①、“全0子网”代表的是对应子网的“子网ID”部分各位都是0，是第一个子网。</p>
<p>②、“全1子网”代表的是对应子网的“子网ID”部分各位都是1，是最后一个子网。</p>
<p>③、按照RFC950参考规定，划分子网后，只有n-2个可用的子网（n表示总的子网数）。</p>
<p>④、后来<strong>RFC1878</strong>参考规定，划分子网后，可以有n个可用的子网（n表示总的子网数）。</p>
<blockquote>
<p>RFC950参考规定：第一个子网（也就是“全0子网”）和最后一个子网（也就是“全1子网”）不可用，为的就是避免全0子网的网络地址和全1子网的广播地址分别与没有划分子网前的网络地址和广播地址相冲突。 但是在后来RFC1878规定中，该项规定已被废止了，现在的设备基本上都普遍支持RFC1878。</p>
</blockquote>
<p><strong>子网划分的任务：</strong></p>
<p>①、确定子网掩码的长度。</p>
<p>②、确定子网下的主机可用地址范围（第一个可用IP和最后一个可用IP）。</p>
<p>③、确定网络地址（主机位全为0）和广播地址（主机位全为1），不能分配计算机主机用。</p>
<h3 id="等长子网划分"><a href="#等长子网划分" class="headerlink" title="等长子网划分"></a>等长子网划分</h3><p>等长子网划分就是将一个有类网络等分成多个网络，也就是等分成多个子网，所有子网的子网掩码都相同。</p>
<h4 id="C类网络子网划分示例"><a href="#C类网络子网划分示例" class="headerlink" title="C类网络子网划分示例"></a>C类网络子网划分示例</h4><h5 id="等分位两个字网"><a href="#等分位两个字网" class="headerlink" title="等分位两个字网"></a>等分位两个字网</h5><p>将192.168.0.0 255.255.255.0这个网络等分成2个子网，并写出每个子网的地址信息</p>
<p>分析步骤：</p>
<p>该子网掩码位/24位，要划分成2个子网，<strong>网络位向主机位接用1位作为子网位</strong>，因为IP地址都是2进制，1位2进制数字有两种可能，0以及1，0是A子网，1是B子网。</p>
<p>接用主机位1位，所以子网掩码+1位，由原来的255.255.255.0（/24）变为255.255.255.128（/25）</p>
<p><strong>结论：C类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。</strong></p>
<p><img src="/2020/02/19/8-subnet/cc05ee8e14483fc9144d7f74397aa78e.png" alt="cc05ee8e14483fc9144d7f74397aa78e"></p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_14-52-56.jpg" alt="Snipaste_2020-03-10_14-52-56"></p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_14-59-24.jpg" alt="Snipaste_2020-03-10_14-59-24"></p>
<p><strong>最终结果：</strong></p>
<p>A子网的网络地址：192.168.0.0/25，可用地址（192.168.0.1、192.168.0.2….～192.168.0.126），广播地址：192.168.0.127。</p>
<p>B子网的网络地址：192.168.0.128/25，可用地址（192.168.0.129、192.168.130….～192.168.0.254），广播地址：192.168.0.255。</p>
<h5 id="等分为四个子网"><a href="#等分为四个子网" class="headerlink" title="等分为四个子网"></a>等分为四个子网</h5><p>同样将192.168.0.0 255.255.255.0 这个网络等分成4个子网</p>
<p>分析：要想分成4个子网，需要将子网掩码往右移动两位，这样第1位和第2位就变为网络位，就可以分成4个子网，因为二进制数0和1按两位排列组合，只有这4种，分别为：00，01，10，11，如下图所示：</p>
<ul>
<li>00为A子网</li>
<li>01为B子网</li>
<li>10为C子网</li>
<li>11为D子网</li>
</ul>
<p>借用主机2位，所以子网掩码+2位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/26）</p>
<p>结论：C类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p>
<p><img src="/2020/02/19/8-subnet/b238a2ab335a04d7c47484f6d6b63528.png" alt="b238a2ab335a04d7c47484f6d6b63528"></p>
<p><img src="/2020/02/19/8-subnet/e4a37fd71224bf10f85f89b656e395ba.png" alt="e4a37fd71224bf10f85f89b656e395ba"></p>
<p>最终结果：</p>
<p>A子网的网络地址：192.168.0.0/26，可用地址（192.168.0.1～192.168.0.62），广播地址：192.168.0.63/26。</p>
<p>B子网的网络地址：192.168.0.64/26，可用地址（192.168.65～192.168.0.126），广播地址：192.168.0.127。</p>
<p>C子网的网络地址：192.168.0.128/26，可用地址（192.168.129～192.168.0.190），广播地址：192.168.0.191。</p>
<p>D子网的网络地址：192.168.0.192/26，可用地址（192.168.193/26～192.168.0.254），广播地址：192.168.0.255。</p>
<h5 id="等分为八个子网"><a href="#等分为八个子网" class="headerlink" title="等分为八个子网"></a>等分为八个子网</h5><p>同样将192.168.0.0 255.255.255.0 这个网络等分成8个子网</p>
<p>分析：要想分成8个子网，需要将子网掩码往右移动三位</p>
<p>这样第1位、第2位和第3位就变为网络位，就可以分成8个子网</p>
<p>因为二进制数0和1按两位排列组合，只有这8种，分别为：000，001，010，011，100，101,110,111，</p>
<p>借用主机3位，所以子网掩码+3位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/29）</p>
<p>结论：C类网络等分成8个子网，子网掩码往右移动3位，就能等分成8个子网，即2^3。</p>
<p><img src="/2020/02/19/8-subnet/2e44e2a13a05f4de228f0a1eec2f173c.png" alt="2e44e2a13a05f4de228f0a1eec2f173c"></p>
<p>最终结果：</p>
<p>子网掩码：255.255.255.224 （/27）</p>
<p>A子网的网络地址：192.168.0.0/27，可用地址（192.168.0.1～192.168.0.30），广播地址：192.168.0.31。</p>
<p>B子网的网络地址：192.168.0.32/27，可用地址（192.168.33～192.168.0.62），广播地址：192.168.0.63。</p>
<p>C子网的网络地址：192.168.0.64/27，可用地址（192.168.65～192.168.0.94），广播地址：192.168.0.95。</p>
<p>D子网的网络地址：192.168.0.96/27，可用地址（192.168.97～192.168.0.126），广播地址：192.168.0.127。</p>
<p>E子网的网络地址：192.168.0.128/27，可用地址（192.168.129～192.168.0.158），广播地址：192.168.0.159。</p>
<p>F子网的网络地址：192.168.0.160/27，可用地址（192.168.161～192.168.0.190），广播地址：192.168.0.191。</p>
<p>G子网的网络地址：192.168.0.192/27，可用地址（192.168.193～192.168.0.222），广播地址：192.168.0.223。</p>
<p>H子网的网络地址：192.168.0.224/27，可用地址（192.168.225～192.168.0.254），广播地址：192.168.0.255。</p>
<h4 id="B类网络子网划分示例"><a href="#B类网络子网划分示例" class="headerlink" title="B类网络子网划分示例"></a>B类网络子网划分示例</h4><p>将131.107.0.0/16等分成2个子网，写出各个子网的第一个和最后一个可用的IP地址</p>
<p>分析：要划分为2个子网，就要借用主机位1位作为子网位。</p>
<ul>
<li>0是A子网</li>
<li>1是B子网</li>
</ul>
<p>借用主机1位，所以子网掩码+1位，由原来的255.255.0.0 （/16）变为255.255.128.0（/17）</p>
<p>结论：B类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。</p>
<p>最终结果：</p>
<p>A子网<br>网络地址：131.107.0.0/17，<br>可用地址（131.107.0.1 ~ 131.107.127.254）<br>广播地址：131.107.127.255</p>
<p>B子网<br>网络地址：131.107.128.0/17<br>可用地址（131.107.128.1 ~ 131.107.255.254）<br>广播地址：131.107.255.255</p>
<p><img src="/2020/02/19/8-subnet/93b1e2732ce3bf7a221c62cad65482ed.png" alt="93b1e2732ce3bf7a221c62cad65482ed"></p>
<h4 id="A类网络子网划分示例"><a href="#A类网络子网划分示例" class="headerlink" title="A类网络子网划分示例"></a>A类网络子网划分示例</h4><p>将A类网络42.0.0.0/8等分成4个子网，写出各个子网的第一个和最后一个可用的IP地址？</p>
<p>分析：要划分为4个子网，就要借用主机位2位作为子网位</p>
<ul>
<li>00是A子网</li>
<li>01是B子网</li>
<li>10是C子网</li>
<li>11是D子网</li>
</ul>
<p>借用主机2位，所以子网掩码+2位，由原来的255.0.0.0 （/8）变为255.192.0.0（/10）</p>
<p>结论：A类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p>
<p>最终结果：</p>
<p>A子网的网络地址：42.0.0.0/10，可用地址（42.0.0.1 ~ 42.63.255.254），广播地址：42.63.255.255</p>
<p>B子网的网络地址：42.64.0.0/10，可用地址（42.64.0.1 ~ 42.127.255.254），广播地址：42.127.255.255</p>
<p>C子网的网络地址：42.128.0.0/10，可用地址（42.128.0.1 ~ 42.191.255.254），广播地址：42.191.255.255</p>
<p>D子网的网络地址：42.192.0.0/10，可用地址（42.192.0.1 ~ 42.255.255.254），广播地址：42.255.255.255</p>
<p><img src="/2020/02/19/8-subnet/ddcabb080e751306e58335a533daeb20.png" alt="ddcabb080e751306e58335a533daeb20"></p>
<h3 id="变长子网划分"><a href="#变长子网划分" class="headerlink" title="变长子网划分"></a>变长子网划分</h3><p>VLSM规定了如何在一个进行了子网划分的网络中，不同子网使用不同的子网掩码。这对于网络内部不同网段需要不同大小子网的情形来说很有效，这种划分子网的方式叫变长子网划分。</p>
<p>变长子网划分其实就是在等长子网的划分上，分别取不同等分子网中的某个或者多个子网。</p>
<p><img src="/2020/02/19/8-subnet/76c86f103dd758c8dc3cd81d7aa85005.png" alt="76c86f103dd758c8dc3cd81d7aa85005"></p>
<p>如上示例划分分析结果：</p>
<p>A子网<br>网络地址：192.168.10.32，255.255.255.224（/27），可用地址（192.168.10.33 ~ 192.168.10.62），广播地址：192.168.10.63<br>相当于取了等长子网划分为8个子网中的一个子网</p>
<p>B子网<br>网络地址：192.168.10.64，255.255.255.192（/26），可用地址（192.168.10.65 ~ 192.168.10.126），广播地址：192.168.10.127<br>相当于取了等长子网划分为4个子网中的一个子网</p>
<p>C子网<br>网络地址：192.168.10.128，255.255.255.128（/25），可用地址（192.168.10.129 ~ 192.168.10.254），广播地址：192.168.10.255<br>相当于取了等长子网划分为2个子网中的一个子网</p>
<p>D子网<br>网络地址：192.168.10.0，255.255.255.252（/30），可用地址（192.168.10.1 ~ 192.168.10.2），广播地址：192.168.10.3<br>相当于取了等长子网划分为64个子网中的第一个子网</p>
<p>E子网<br>网络地址：192.168.10.4，255.255.255.252（/30），可用地址（192.168.10.5 ~ 192.168.10.6），广播地址：192.168.10.7<br>相当于取了等长子网划分为64个子网中的第二个子网</p>
<p><strong>变长子网划分总结</strong></p>
<p>①、变长子网划分规律</p>
<p>如果一个子网地址块是原来网段的(1/2)^n，子网掩码就在原网段的基础上右移n位，不等长子网，子网掩码也不同。</p>
<p>②、点到点网络的子网掩码</p>
<p>每个子网是原来网络的(1/2)×(1/2)×(1/2)×(1/2)×(1/2)×(1/2)，也就是(1/2)^6，子网掩码往右移动6位。</p>
<p>例如：11111111.11111111.11111111.11111100写成十进制子网掩码也就是255.255.255.252。</p>
<h3 id="子网划分总结和技巧"><a href="#子网划分总结和技巧" class="headerlink" title="子网划分总结和技巧"></a>子网划分总结和技巧</h3><p><img src="/2020/02/19/8-subnet/de085bbf8eb4753018b7e8c8bbbad651.png" alt="de085bbf8eb4753018b7e8c8bbbad651"></p>
<p>1、确定划分子网数</p>
<p>子网数 = 2^n，n代表子网掩码往右移动的位数<br>例如：<br>要划分2个子网，子网掩码需要往右移动1位，2^1=2<br>要划分4个子网，子网掩码需要往右移动2位，2^2=4<br>要划分8个子网，子网掩码需要往右移动3位，2^3=8<br>……<br>子网数只能为2倍的关系划分。</p>
<p>2、确定子网划分后的地址</p>
<p>每个子网地址块大小（IP_block）= 2^(8-n)<br>每个子网可用地址个数（IP_num）= 2^(8-n)-2<br>①、子网的网络地址 = 从0到255，取每段地址块的首个值<br>②、子网的广播地址 = 下一个子网的网络地址-1<br>③、子网的可用地址 = 子网的网络地址到子网的广播地址区间</p>
<p>例如：<br>要划分为4个网段（2^2），子网掩码右移2位<br>每个子网地址块大小（IP_block）= 2^(8-4) = 64<br>每个子网可用地址个数（IP_num）= 2^(8-4)-2 = 62<br>每段取值分别为：0，64，128，192<br>第一个子网<br>①、网络地址 = 0<br>②、广播地址 = 63<br>③、可用地址 = 1到62</p>
<p>第二个子网<br>①、网络地址 = 64<br>②、广播地址 = 127<br>③、可用地址 = 65到126</p>
<p>第三个子网<br>①、网络地址 = 128<br>②、广播地址 = 191<br>③、可用地址 = 129到190</p>
<p>第四个子网<br>①、网络地址 = 192<br>②、广播地址 = 255<br>③、可用地址 = 193到254</p>
<p>3、确定子网掩码</p>
<p>划分后的子网掩码CIDR = 原网络的子网掩码CIDR+n，如要写成十进制：256-2^(8-n)<br>例如：<br>原来子网掩码：255.255.255.0（/24），往右移动3位，则划分为8个子网<br>子网掩码就变为为 /27，256-2^(8-3) = 256-2^5 = 256-32 = 224<br>最后子网掩码结果：255.255.255.224（/27）</p>
<p>如还有不明白的，请参照上面给出的VLSM可变长子网掩码对应CIDR值这个图就一目了然。</p>
<h3 id="子网划分举例"><a href="#子网划分举例" class="headerlink" title="子网划分举例"></a>子网划分举例</h3><p>1、计算一下172.16.1.0/27这个子网的网络号、广播号，及可用IP地址</p>
<p>答案：</p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_17-11-40.jpg" alt="Snipaste_2020-03-10_17-11-40"></p>
<p>2、200.200.200.0是一个C类地址。要求划分一个子网100主机，另外四个子网20主机。</p>
<p>解析过程：</p>
<p>我们可以先把该网络划分成两个子网。一个给100主机的子网，一个给另外20主机的四子网。</p>
<p>C类地址有8bit的主机号，划分子网就是把主机号拿出若干位来作网络ID。</p>
<p>具体要拿出多少位这里有一个公式：子网内主机数=2的x次方-2（x是主机号的位数）</p>
<p>现在主机数是100，我们取2的x次方-2略大于100。即x=7。</p>
<p>也就是说主机号位数是7位，这个子网才能够连100台主机。本来有8位的，剩下的一位拿去当网络号。（也实在是巧，这一位刚好可以标识两个子网（0或者1）下面的红色部分！）</p>
<p>NET ID              200.200.200.00000000</p>
<p>NETMASK        255.255.255.00000000</p>
<p>子网1:</p>
<p>NET ID           200.200.200.00000000               </p>
<p>NETMASK     255.255.255.10000000  （掩码就是用1标识网络ID，看蓝色部分）</p>
<p>子网2:</p>
<p>NET ID          200.200.200.10000000               </p>
<p>NETMASK     255.255.255.10000000</p>
<p>接下来划分四个子网，用上面任何一个子网划分都行。这里用子网2吧。</p>
<p>由上面的公式，子网内主机数=2的x次方-2</p>
<p>取2的x次方-2略大于20，也即x=5.</p>
<p>也就是主机号位数是5位，刚才是7位，剩下2位作网络ID,</p>
<p>子网2.1:</p>
<p>NET ID             200.200.200.10000000               </p>
<p>NETMASK       255.255.255.11100000</p>
<p>子网2.2:</p>
<p>NET ID             200.200.200.10100000               </p>
<p>NETMASK        255.255.255.11100000</p>
<p>子网2.3:</p>
<p>NET ID             200.200.200.11000000               </p>
<p>NETMASK       255.255.255.11100000</p>
<p>子网2.4:</p>
<p>NET ID            200.200.200.11100000               </p>
<p>NETMASK      255.255.255.11100000</p>
<p>这样，子网划分就完成了。</p>
<p>接下来写出五个子网的子网掩码、网络地址、第一个主机地址、最后一个主机地址、广播地址就比较简单了。</p>
<p>记住这一条：</p>
<p><strong>主机号全0是网络地址,网络地址+1是第1个主机地址,主机号全1是广播地址.广播地址-1是最后的主机地址.</strong></p>
<p>子网一主机号全是0的：NET ID  200.200.200.00000000   后面八个0是二进制，换成十进制就是它的网络地址了，然后+1是主机地址；广播地址要注意，那个红色0已是网络ID，主机号是后面七个0，把7个0全置为1就是他的广播地址。</p>
<p>接下来以此类推。</p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-17_15-35-30.jpg" alt="Snipaste_2020-03-17_15-35-30"></p>
<p>这篇<a href="https://blog.csdn.net/gui951753/article/details/79412524">子网划分详解与子网划分实例精析</a>的博客写的非常不错，就不搬运了，贴出链接可以自己做一下后面的子网划分题目。</p>
<h2 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h2><h3 id="超网的概念"><a href="#超网的概念" class="headerlink" title="超网的概念"></a>超网的概念</h3><p>超网(Supernetting)是与子网类似的概念，IP地址根据子网掩码被分为独立的网络地址和主机地址。超网，也称无类别域间路由选择（CIDR），它是集合多个同类互联网地址的一种方法。</p>
<p>与子网划分（把大网络分成若干小网络）相反，它是把一些小网络组合成一个大网络，就是超网。</p>
<h4 id="合并网段"><a href="#合并网段" class="headerlink" title="合并网段"></a>合并网段</h4><p>示例：某企业有一个网段，该网段有200台主机，使用192.168.0.0 255.255.255.0网段。</p>
<p>后来计算机数量增加到400台，为后来增加的200台主机使用192.168.1.0 255.255.255.0网段，如下图：</p>
<p><img src="/2020/02/19/8-subnet/5d24088e7d02bd4ed72abd42b3a7da8e.png" alt="5d24088e7d02bd4ed72abd42b3a7da8e"></p>
<p>在路由器配置了192.168.0.1的IP地址接口，再添加192.168.1.1地址后，这样192.168.0.0和192.168.1.0这两个网段内的主机就通过路由器转发来实现通信了。</p>
<p>那么有没有更好的办法，让这两个C类网段的计算机认为在一个网段？</p>
<p>这就需要将192.168.0.0/24和192.168.1.0/24 两个C类网络合并。</p>
<p><img src="/2020/02/19/8-subnet/f47b84ff5c676c5ab1c7b164777c3255.png" alt="f47b84ff5c676c5ab1c7b164777c3255"></p>
<p>网段合并：子网掩码向前移动1位，使得网络部分保持前部分相同。</p>
<p>注：子网掩码往左移1位，能够合并2个连续的网段，但<strong>不是任何连续的网段都能合并</strong>。</p>
<p>合并网段之后，如下图，这样所有主机相互通信就不再经过路由器转发了。</p>
<p><img src="/2020/02/19/8-subnet/aac305e52a42ee6b66c91467e700ff01.png" alt="aac305e52a42ee6b66c91467e700ff01"></p>
<p>①、合并之后网段为：192.168.0.0/23，IP分配如下图：</p>
<p>②、合并之后IP地址192.168.0.255/23也是可以给计算机使用的，因为主机部分往左增加了一位0（并不是全1），如下图：</p>
<p><img src="/2020/02/19/8-subnet/b7a8122e3f4cb53da6150d1e665ed15e.png" alt="b7a8122e3f4cb53da6150d1e665ed15e"></p>
<h4 id="不是任何连续的网段都能合并"><a href="#不是任何连续的网段都能合并" class="headerlink" title="不是任何连续的网段都能合并"></a>不是任何连续的网段都能合并</h4><p>示例，如下两个连续的网段是不能合并（往前移动1位，网络部分不能保持相同）的。</p>
<p><img src="/2020/02/19/8-subnet/c1a0729463af746735f8bc6e9f363c69-1584431224823.png" alt="c1a0729463af746735f8bc6e9f363c69"></p>
<p>如果非要合并，就要往前移动2位，这时候网络部分保持相同，这样一来，等于合并了4个网段，如下图：</p>
<p><img src="/2020/02/19/8-subnet/3856bdd5d929cc7a387cdde9f897d7ea.png" alt="3856bdd5d929cc7a387cdde9f897d7ea"></p>
<h4 id="哪些连续的网段能够合并"><a href="#哪些连续的网段能够合并" class="headerlink" title="哪些连续的网段能够合并"></a>哪些连续的网段能够合并</h4><p>（1）判断2个网段是否能够合并</p>
<p><img src="/2020/02/19/8-subnet/39d316df0dc23263117006deafc8cc35.png" alt="39d316df0dc23263117006deafc8cc35"></p>
<p>子网掩码往左移动相应位数后，网络部分保持相同才能合并。</p>
<p><strong>结论：判断连续的2个网段是否能够合并，只要第一个网络号能被2整除，就能够通过左移1位子网掩码合并。</strong></p>
<p>（2）判断4个网段是否能够合并</p>
<p><img src="/2020/02/19/8-subnet/9d6bf7bb37c193e6ff334f315c7bbab4.png" alt="9d6bf7bb37c193e6ff334f315c7bbab4"></p>
<p><strong>结论：判断连续的4个网段是否能够合并，只要第一个网络号能被4整除，就能够通过左移2位子网掩码合并。</strong></p>
<p>依次类推，要想判断连续的8个网段是否能够合并，只要第一个网络号能被8整除，这8个连续的网段就能够通过左移3位子网掩码合并。</p>
<h4 id="网段合并的规律"><a href="#网段合并的规律" class="headerlink" title="网段合并的规律"></a>网段合并的规律</h4><p>子网掩码左移1位能够将能够合并两个网段，左移2位，能够合并四个网段，左移3位，能够合并8个网段。</p>
<p><img src="/2020/02/19/8-subnet/8a0dbd60f0d4db1a709e316c7b2628c4.png" alt="8a0dbd60f0d4db1a709e316c7b2628c4"></p>
<h4 id="判断一个网段是超网还是子网"><a href="#判断一个网段是超网还是子网" class="headerlink" title="判断一个网段是超网还是子网"></a>判断一个网段是超网还是子网</h4><ol>
<li><p>通过左移子网掩码合并多个网段，右移子网掩码将一个网段划分成多个子网，使得IP地址打破了传统的A类、B类、C类的界限。</p>
</li>
<li><p>判断一个网段到底是子网还是超网，就要看该网段是A类网络、还是B类网络、还是C类网络，默认A类子网掩码/8，B类子网掩码是/16，C类子网掩码是/24。</p>
</li>
<li><p>如果该网段的子网掩码比默认子网掩码长，就是子网，如果该网段的子网掩码比默认子网掩码短，则是超网。</p>
</li>
</ol>
<p>引用文章：</p>
<p><a href="https://blog.csdn.net/lemontree1945/article/details/79553187">划分子网例题详解</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>9、通信过程分析</title>
    <url>/2020/04/02/9-communication-process/</url>
    <content><![CDATA[<p>这一部分开始把前面那堆枯燥乏味的理论联系到实际数据传输的过程了，阅读这部分建议结合OSI模型以及TCP/IP模型中的“相关概念”部分一起看，实际通信过程结合理论分析，有助于真正掌握通信的过程和概念。</p>
<h2 id="数据总体通讯过程"><a href="#数据总体通讯过程" class="headerlink" title="数据总体通讯过程"></a>数据总体通讯过程</h2> <span id="more"></span>  

<p><img src="/2020/04/02/9-communication-process/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p><img src="/2020/04/02/9-communication-process/TCPIP%20ENCAPSULATION.png" alt="TCPIP ENCAPSULATION"></p>
<p><img src="/2020/04/02/9-communication-process/Data_Flow_of_the_Internet_Protocol_Suite.png" alt="Data_Flow_of_the_Internet_Protocol_Suite"></p>
<h3 id="TCPIP模型回顾"><a href="#TCPIP模型回顾" class="headerlink" title="TCPIP模型回顾"></a>TCPIP模型回顾</h3><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-12-42.jpg" alt="Snipaste_2020-06-11_14-12-42"></p>
<p>TCP/IP模型是当今IP网络的基础（由OSI七层参考模型发展而来，也称为DoD模型）。分层参考模型的设计是非常经典的理念：</p>
<ul>
<li>层次化的模型设计将网络的通信过程划分为更小、更简单的部件，因此有助于各个部件的独立开发、设计和故障排除；</li>
<li>层与层之间相互独立，又互相依赖，每一层都有该层的功能、以及定义的协议标准。层与层之间相互配合，共同完成数据通信的过程；</li>
<li>通过组件的标准化，允许多个供应商进行开发；</li>
<li>通过定义在模型的每一层实现什么功能，鼓励产业的标准化；</li>
<li>允许各种类型的网络硬件和软件相互通信。</li>
</ul>
<p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-14-20.jpg" alt="Snipaste_2020-06-11_14-14-20"></p>
<h3 id="路由器的通信过程"><a href="#路由器的通信过程" class="headerlink" title="路由器的通信过程"></a>路由器的通信过程</h3><p>路由器（Router）是一种负责寻径的网络设备，连接不同网段，负责不同网段之间的数据转发，例如192.168.1.0/24和192.168.2.0/24之间通信，由于他们分别属于192.168.1.0和192.168.2.0这两个不同的网段，所以他们之间的通信需要三层设备也就是路由器来连同，它在互连网络中从多条路径中寻找通讯量最少的一条网络路径提供给用户通信。</p>
<p>Router 的责任是记录相应路由信息应该从哪个接口发出，并形成一张路由表，当收到数据时，根据网络层报头的目的地址去查询路由表中是否有相对应的条目，如果有就从该路由条目的出接口发出数据，如果没有就将数据丢弃。</p>
<h3 id="LAN内交换机的通信原则和过程"><a href="#LAN内交换机的通信原则和过程" class="headerlink" title="LAN内交换机的通信原则和过程"></a>LAN内交换机的通信原则和过程</h3><p>交换机（Switch）对数据的处理过程：</p>
<p><img src="/2020/04/02/9-communication-process/switch.jpg" alt="switch"></p>
<ul>
<li><p>交换机如果刚刚加电启动，它的MAC地址缓存为空，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址而且在同一网段，根据TCP/IP模型我们知道，由于在同一网段所以只需要二层交换机即可通信，封装数据时，下四层每一层需要封装本层的报头，三层网络层封装的时候需要源目的IP地址，二层数据链路层封装的时候需要原目的MAC地址，这里PC1只知道PC3的IP地址和自己的IP地址，所以三层需要封装的参数已经知道了，但在开始通信的时候，二层封装的目的MAC地址还不知道，所以需要获得MAC地址才能完成二层数据链路层的封装，PC1会使用ARP协议去获取目的MAC地址用来完成二层封装，PC1获取PC3 MAC地址的过程，请结合<a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/#ARP%EF%BC%88Address-Resolution-Protocol-%EF%BC%89">ARP</a>的部分学习。</p>
</li>
<li><p>假设PC1已经知道了PC3的MAC地址，而Switch的MAC地址表项为空，PC1将源IP、MAC地址为自身，目标IP、MAC地址为PC3相应地址的数据封装好发送给Switch，Switch从接口G0/1接收到PC1发过来的数据后，首先对数据进行解封装，将物理层0101的比特流还原成数据帧后对二层进行解封装，知道了该数据帧的源、目的MAC地址，将这个数据帧的源MAC地址，既PC1的MAC地址（AAAAAAAAAA）和对应的端口G0/1添加到自己的MAC地址表中方便以后再进行数据传输时使用，然后从自己的MAC地址表中去查找这个数据帧目的地PC3（CCCCCCCCCC）的MAC地址，但是此时由于MAC地址表项为空所以找不到对应的MAC地址，这时Switch将这个数据封装上初始的源、目的MAC地址作为二层帧头，从除了收到这个数据的G0/1以外的其他接口（G0/2、G0/3、G0/0）泛洪出去；</p>
</li>
<li><p>PC2和PC4都接收到了这个数据帧，这两台设备将比特流还原成帧后对数据帧进行解封装，查看该数据帧的目的MAC地址，发现目的MAC地址与自己的网卡MAC地址不相同，PC2和PC4丢弃这个数据帧；</p>
</li>
<li><p>在上一步中PC3也同时收到了这个数据帧，PC3对数据进行解封装后，检查目的MAC地址的时候发现，与本机相同，PC3接收这个数据包，并回发数据包对PC1进行确认，PC3封装一个源地址为自己MAC地址，目的地址是A的MAC地址，源IP为自己IP，目的IP为PC1的IP地址的数据发送给Switch；</p>
</li>
<li><p>Switch接收到这个数据，它首先添加PC3的MAC和对应的接口G0/3到自己的MAC地址表中，然后查询源MA地址表时候发现PC1的MAC地址在MAC地址表项中可以查到，此MAC地址对应端口为G0/1，Switch将这个数据帧发给接口G0/1的PC1；</p>
</li>
<li><p>PC1收到PC3发回的确认，通信成功；</p>
</li>
<li><p>通过这种形式，Switch学习到的MAC地址以及所在接口。如下：</p>
</li>
</ul>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191124185137.jpg" alt="微信截图_20191124185137"></p>
<p>通过不停的通信，最终Switch能够获得所有端口对应的MAC地址，但需注意，MAC地址表项的老化时间为300秒，如果超过老化时间，表项会被删除，Switch需重新泛洪以获取目的MAC地址对应的表项。思科交换机查看MAC地址表的命令为：<strong>show mac-address</strong> </p>
<h2 id="通信示例分析"><a href="#通信示例分析" class="headerlink" title="通信示例分析"></a>通信示例分析</h2><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-28-29.jpg" alt="Snipaste_2020-06-11_14-28-29"></p>
<p>网络上各设备的接口、IP和MAC地址如图所示，PC1要访问WebServer上的网页服务（HTTP、80端口），用这个例子分析数据在TCP/IP每层经历的过程。在阐述过程中，我们重点放在利用TCP/IP参考模型理解通信过程，因此可能会忽略部分技术细节，例如DNS、TCP三次握手等，这些技术细节这里暂不做讨论。事实上，整个过程的宏观层面如下：</p>
<p><img src="/2020/04/02/9-communication-process/53a14dfd2e01a-1591856957079.png" alt="53a14dfd2e01a"></p>
<h3 id="PC封装过程"><a href="#PC封装过程" class="headerlink" title="PC封装过程"></a>PC封装过程</h3><h4 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e23b3ca6.png" alt="53a14e23b3ca6"></p>
<p>PC的用户在WEB浏览器中访问Server的WEB服务（这里我们暂且不去关注底层的HTTP交互、DNS交互等细节。重点看通信过程），PC的这次操作将触发HTTP应用为用户构造一个应用数据。当然这个数据最终要传递到Server并最终“递交”到Server的HTTP应用来处理，但是HTTP不关心数据怎么传、怎么寻址、怎么做差错校验等等，那么这些事情就交由专门的Layer也就是专门的层来完成，所以HTTP应用数据还的经过一番“折腾”才能从PC传出去到达Server，现在开始。<strong>应用层</strong>中的相关程序生成一个应用层的数据，也就是图中的DATA部分，然后交给下一层，传输层。</p>
<h4 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e35e03e1.png" alt="53a14e35e03e1"></p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145310-1585388711315.jpg" alt="微信图片编辑_20200113145310"></p>
<p>上层的DATA到达传输层后，首先查看数据类型，由于这是一个要发送给web服务器的HTTP数据，而HTTP是一种尽力而为的协议，本身没有纠错功能，所以选择能保证数据传输完整性的TCP协议去封装，而TCP报头中需要的两个重要参数就是源、目的端口地址。HTTP固定的端口是80，所以目的端口号为80，客户端使用的源端口号一般为系统中未使用的且大于1023的数字，在这我们假设设备使用1025作为源端口号。封装完TCP报头，形成了数据段（segment）后，交给下一层，网络层。</p>
<h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e4be283e.png" alt="53a14e4be283e"></p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200328175537.jpg" alt="微信图片编辑_20200328175537"></p>
<p>上层数据到达网络层后，要加上网络层的IPV4报头，等以后如果IPV6普及了会加IPV6报头，以便该数据能够在IP网络中被网络设备转发（路由）。IPV4报头封装所需的三个重要的参数就是源IP地址、目的IP地址和协议号。由于上层用的是TCP协议，TCP协议对应的协议号为6，所以在Protocol部分为6；源IP地址为自身的IP地址192.168.1.1，目的IP地址为WebServer的IP地址192.168.2.1。封装好三层报头将数据段封装为数据包后，交给下一层，数据链路层。</p>
<h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e5955e8b.png" alt="53a14e5955e8b"></p>
<p><img src="/2020/04/02/9-communication-process/1920px-Ethernet_Type_II_Frame_format.svg.png" alt="1920px-Ethernet_Type_II_Frame_format.svg"></p>
<p>上层数据到数据链路层后，需要封装以太网2的报头，使得之前的IP数据包能够在链路上被传输，因为TCP/IP在二层采用的是这种封装格式，以太网2报头中三个需要获知的重要参数为源MAC地址、目的MAC地址和以类型，源MAC地址为PC自身的MAC地址，目的MAC地址呢？PC知道，数据的目的地是192.168.2.1这个IP，而本机IP是192.168.1.1/24，显然，目的地与自己并不在同一个网段，因此需要借助自己的网关，让网关来帮助自己将数据包转发出去。那么首先我得把数据转发到网关吧？因此目的MAC地址填写的就是网关192.168.1.254对应的MAC地址。但是初始情况下，PC可能并没有192.168.1.254的MAC，所以，它会发送一个ARP广播去请求192.168.1.254的MAC，R1的GE0/0/0口会收到这个ARP请求并且回送ARP响应。如此一来PC就知道了网关的MAC，它将网关MAC 0018-0011-0001填写在以太网数据帧头部的目的MAC中。另外，以太网数据帧头的类型字段写上0x0800这个值，表示我这个数据帧头后面封装的是一个IP包。由于三层采用的封装为IPV4，所以EtherType中类型字段的值为0x0800，表示我这个数据帧头后面封装的是一个IP包。数据链路层封装好本层报头以后，将数据传给下一层，物理层。</p>
<h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e6820ab9.png" alt="53a14e6820ab9"></p>
<p>物理层收到上层的数据帧后，将数据帧转换为物理层能识别的电磁信号，也就是bit流，从物理上来说，最终数据帧在物理层变成了一堆的0101，然后通过物理介质传输给网关，路由器R1。</p>
<h3 id="R1处理过程"><a href="#R1处理过程" class="headerlink" title="R1处理过程"></a>R1处理过程</h3><h4 id="物理层第一次："><a href="#物理层第一次：" class="headerlink" title="物理层第一次："></a>物理层第一次：</h4><p>R1收到物理介质传输的数据后，在物理层将电磁信号还原成数据帧，然后交给数据链路层。</p>
<h4 id="数据链路层第一次："><a href="#数据链路层第一次：" class="headerlink" title="数据链路层第一次："></a>数据链路层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e73c02b5.png" alt="53a14e73c02b5"></p>
<p>R1收到物理层发来的数据帧，先查看数据帧的CRC Checksum部分，看数据帧在传输过程中是否有损坏：</p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704.jpg" alt="微信图片编辑_20200611145704"></p>
<p>确定数据帧无损坏以后，开始对二层进行解封装，看看数据帧中目的MAC地址和收到这个数据帧的GE0/0/0口的MAC是否相同，如果相同说明这个数据是发给自己的，然后讲数据交给上层继处理。在这个例子中，两者相同，于是查看数据帧头部的Ether Type字段，发现类型为0X0800，表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<h4 id="网络层：-1"><a href="#网络层：-1" class="headerlink" title="网络层："></a>网络层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e7e58f26.png" alt="53a14e7e58f26"></p>
<p>网络层收到数据后，继续对IP报头进行解封装，校验一下在传输过程中IP报头部分是否损坏：</p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749.jpg" alt="微信图片编辑_20200611150749"></p>
<p>如果没有损坏就继续看目标IP地址部分，发现目的IP地址不是本机，网关R1根据目的IP地址，按照最长匹配原则查询是否有对应路由条目，查询后发现应将该数据从GE0/0/1端口发出。于是它不在继续拆IP报头看里面的其他字段也不会剥离IP头部了，而是把原封不动包含IP报头的IP数据包交给下层以太网协议去处理。</p>
<h4 id="数据链路层第二次："><a href="#数据链路层第二次：" class="headerlink" title="数据链路层第二次："></a>数据链路层第二次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e8bef0b7.png" alt="53a14e8bef0b7"></p>
<p>数据链路层收到上层发来的数据后，因为该数据是要从GE0/0/1口发送给R2的GE0/0/0口，所以以太网2封装的源MAC地址是R1的GE0/0/1口的MAC地址，目的MAC地址是R2的GE0/0/0接口的MAC地址，如果ARP缓存中没有R2的GE0/0/0接口MAC地址（在初始情况下是这样），则需要用ARP协议进行获取，如果有该ARP缓存则直接使用；由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给物理层转换成电磁信号发送给R2。</p>
<h3 id="R2处理过程："><a href="#R2处理过程：" class="headerlink" title="R2处理过程："></a>R2处理过程：</h3><h4 id="数据链路层第一次：-1"><a href="#数据链路层第一次：-1" class="headerlink" title="数据链路层第一次："></a>数据链路层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e978d982.png" alt="53a14e978d982"></p>
<p>R2的物理层将收到的电磁信号恢复成数据帧后交给数据链路层，数据链路层对二层报头进行解封装，发现目的MAC地址和自己的F0/0接口的MAC地址相同，所以这个数据是发给自己的，于是将该数据交给上层的网络层继续处理。</p>
<h4 id="网络层第一次："><a href="#网络层第一次：" class="headerlink" title="网络层第一次："></a>网络层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14ea4e02bc.png" alt="53a14ea4e02bc"></p>
<p>网络层收到下层的数据后继续解封装，发现目的IP地址不是自己的，然后根据目的IP地址，按照最长匹配原则查询是否有对应路由条目，查询后发现应将该数据从GE0/0/1端口发出。在网络层将三层按原报头重新打包好然后发给数据链路层。</p>
<h4 id="数据链路层第二次：-1"><a href="#数据链路层第二次：-1" class="headerlink" title="数据链路层第二次："></a>数据链路层第二次：</h4><p><img src="/2020/04/02/9-communication-process/53a14eb0487d8.png" alt="53a14eb0487d8"></p>
<p>数据链路层收到上层发来的数据后，因为该数据是要从GE0/0/1口发送给WebServer，所以以太网2封装的源MAC地址是R2的GE0/0/1口的MAC地址，目的MAC地址是WebServer的MAC地址（ARP方式获得MAC地址），由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给数据链路层转换成电磁信号发送给WebServer。物理层将数据帧转换为物理层能识别的电磁信号然后通过物理介质传输给最终目的设备，WebServer，数据传输结束。</p>
<p><a href="https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996">https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996</a></p>
<h3 id="Server处理过程"><a href="#Server处理过程" class="headerlink" title="Server处理过程"></a>Server处理过程</h3><p>Server首先是将101010这些比特流还原成帧，然后做校验看看帧头是否损坏，如果没有，则查看数据帧的目的MAC，结果发现就是自己的MAC，于是查看类型字段，发现是0x0800，于是知道这里头装的是一个IP包，于是将帧头剥去，将内层的IP数据包交给上层协议IP去处理。IP收到这个数据包之后，首先依然是查看IP包头是否损坏，如果没有，则查看目的IP地址，发现目的IP地址是192.168.2.1正是自己的网卡IP，于是它知道，这个IP包是发给自己的，因此继续查看IP包头中的协议字段，发现协议字段填写的是6这个值，原来这个IP包头后面封装的是一个TCP的数据，因此将IP包头剥去，将里头的TCP数据交给上层的TCP协议去处理。而TCP在处理这个数据的时候，查看TCP头部的目的端口号，发现目的端口号是80，而本地的TCP80端口是开放的，开放给HTTP应用了，接着它将TCP头部剥去，交给HTTP应用，好了终于从PC发送出来的HTTP应用数据，到达了目的地 –Server的HTTP应用的手中。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-05-13_10-49-06.jpg" alt="Snipaste_2020-05-13_10-49-06"></p>
<p>两台路由器，R1的G0/0接口IP地址为192.168.12.1，R2的G0/1接口IP地址为192.12.2，R1和R2之间能够相互ping通，当R1ping一个不存在的IP地址时，比如192.168.12.3，请问链路上是否有ping包？</p>
<p>答案：没有，因为要封装ping包也就是ICMP，需要源目的IP以及源目地MAC地址，在ping12.3这个不存在的地址时，源目地IP地址已经有了，源MAC地址为自身的MAC地址所以也是有的，但目的MAC地址是靠ARP获得的，但当R1发出ARP请求以后，是获取不到MAC地址的，因为这个IP地址没有设备，也就没法告诉R1它的MAC地址，所以ping包无法封装，所以网络上没有ping包。</p>
<h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><p><a href="https://forum.huawei.com/enterprise/zh/thread-272107.html">利用TCP/IP模型理解数据通信过程</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>6、tcp/ip参考模型</title>
    <url>/2019/11/23/6-tcp-ip/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><img src="/2019/11/23/6-tcp-ip/TCP-IP%E6%A8%A1%E5%9E%8B%20(2)%20(1).jpg" alt="TCP-IP模型 (2) (1)" style="zoom: 67%;">

 <span id="more"></span>  

<p><img src="/2019/11/23/6-tcp-ip/tcpipprotocols.png" alt="tcpipprotocols"></p>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack）。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网&lt;高级研究计划局网络（英语：Advanced Research Projects Agency Network），通称阿帕网（英语：ARPANET）是美国国防高级研究计划局开发的世界上第一个运营的数据包交换网络，是全球互联网的鼻祖。&gt;项目，因此也被称作DoD模型（DoD Model）。这个协议族由互联网工程任务组负责维护。</p>
<p>TCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p>
<h2 id="TCP-IP和OSI模型对比"><a href="#TCP-IP和OSI模型对比" class="headerlink" title="TCP/IP和OSI模型对比"></a>TCP/IP和OSI模型对比</h2><p><img src="/2019/11/23/6-tcp-ip/999804-20170926194048637-1078586652.png" alt="999804-20170926194048637-1078586652"></p>
<ol>
<li><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p>
</li>
<li><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p>
</li>
<li><p>OSI是一种理论下的模型，而TCP/IP已被广泛使用，比如现在我们每天都在用的互联网就是用的TCP/IP协议。</p>
</li>
<li><p>OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</p>
</li>
</ol>
<p><strong>简单来说，OSI参考模型和TCP/IP参考模型，其实都是每一层加上本层的报头然后发给其他层这么一个工作模式，不过分层方式有所不同，现在的互联网用的都是TCP/IP，因为OSI分层太多，有些层没必要，比如表示层、会话层，在TCP/IP模型中应用层都搞定了。</strong></p>
<h2 id="TCP-IP相关概念"><a href="#TCP-IP相关概念" class="headerlink" title="TCP\IP相关概念"></a>TCP\IP相关概念</h2><h3 id="TCP-IP-的具体含义"><a href="#TCP-IP-的具体含义" class="headerlink" title="TCP/IP 的具体含义"></a>TCP/IP 的具体含义</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p>
<p><img src="/2019/11/23/6-tcp-ip/tcpip.jpg" alt="tcpip"></p>
<h3 id="数据的格式"><a href="#数据的格式" class="headerlink" title="数据的格式"></a>数据的格式</h3><p>一般而言，数据包含报文头部（报头、header）、数据（Data、载荷、Payload）、报文尾部（Footer、Trailer）。</p>
<p><strong>报文头部</strong>：在实际数据部分之前的信息，一般包含少量的控制信息，这些控制信息用于传达有关报文所包含的数据以及如何使用这些数据的信息。例如四层的数据段（Segment）的TCP报头中包含了源目地端口号（用来定位数据交给上层的哪个程序处理）等信息；三层的数据包（Packet）的IP报头中包含了源目地IP地址（用来在互联网上找到通信双方的位置）等信息。</p>
<p><strong>数据</strong>：真正需要传递的数据，一般也叫做载荷。有些消息承载了各种各样的数据，有些消息并没有承载任何数据，这种没有承载任何数据的消息是用作控制在和沟通目的的，比如TCP的三次握手和四次分手的过程中的消息是没有承载任何数据的。</p>
<p><strong>报文尾部</strong>：哪些在数据后面的信息，报文头部的信息和报文尾部的信息没有真正的区别，他们都包含了特定的控制信息。只在某些情况下使用报文尾部，特别是在字段中的数据是基于要传输的数据的值来计算的情况下。</p>
<p>看完上面你可能会有疑问，为什么要区别出来报文头部和报文尾部呢？两者看上去功能完全相同，为什么不合二为一，非要分个头尾不同的部分？是因为有些类型的控制信息（例如FCS，详见<a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/#%E4%BB%A5%E5%A4%AA%E7%BD%912%E5%B8%A7%E5%A4%B4%E5%88%86%E6%9E%90">二层部分</a>）是利用数据本身的值来计算的。在某些情况下，在发送数据有效载荷的同时进行这种计算，然后在有效载荷后以页脚的形式传输结果，这样做更有效率。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-01_16-54-42.jpg" alt="Snipaste_2020-05-01_16-54-42"></p>
<h3 id="数据段、数据包、数据帧、比特、PDU"><a href="#数据段、数据包、数据帧、比特、PDU" class="headerlink" title="数据段、数据包、数据帧、比特、PDU"></a>数据段、数据包、数据帧、比特、PDU</h3><p><img src="/2019/11/23/6-tcp-ip/featured-4.jpg" alt="featured-4"></p>
<p><img src="/2019/11/23/6-tcp-ip/tcp_pdus.png" alt="tcp_pdus"></p>
<p>协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。</p>
<ul>
<li>数据链路层的PDU叫做Frame（帧）</li>
<li>网络层的PDU叫做Packet（数据包）</li>
<li>传输层TCP的PDU叫做Segment（数据段），UDP的PDU叫做Datagram。（数据报）</li>
<li>物理层传输的PDU叫Bit(比特)</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-13_14-10-29.jpg" alt="Snipaste_2019-12-13_14-10-29"></p>
<p>为什么每层的PDU要有不同的命名呢？</p>
<blockquote>
<p>In some cases, the different terms can be very useful, because the name used to refer to a particular message can tell you something about what the message contains, as you will see shortly. In particular, different message names are usually associated with protocols and technologies operating at specific layers of the OSI Reference Model. Thus, the use of these different names can help clarify discussions that involve multiple protocols operating at different layers. </p>
</blockquote>
<p>因为在某些情况下，不同的术语可能非常有用，因为用来指代一个特定报文的名称可以告诉你一些关于该报文包含的内容，特别是，不同的报文名称通常与在OSI参考模型的特定层中运行的协议和技术有关。因此，使用这些不同的名称可以帮助澄清涉及在不同层操作的多个协议的讨论。举个例子就是，如果严谨的使用这些术语，一说数据帧，我们就能知道这是封装到二层，数据链路层，的数据，报头中封装的是数据链路层的报头，源、目的MAC地址。但如果不严格使用这些属于就可能传达混淆的信息，当然有些人混用以上这几个术语，有些人则逻辑严谨的使用，必须在与他人交流或学习网络知识的时候注意这些。</p>
<h3 id="什么是TCP的连接"><a href="#什么是TCP的连接" class="headerlink" title="什么是TCP的连接"></a>什么是TCP的连接</h3><blockquote>
<p>The reliability and flow control mechanisms described above requirethat TCPs initialize and maintain certain status information foreach data stream.  The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p>上面提到的TCP的可靠和流量控制机制，需要TCP为每个信息流数据初始化并维持特定的状态信息。包括sockets、序列号和窗口大小在内的这些信息的集合，叫做连接。</p>
<h3 id="面向连接协议与无连接协议"><a href="#面向连接协议与无连接协议" class="headerlink" title="面向连接协议与无连接协议"></a>面向连接协议与无连接协议</h3><p>面向连接（Connection-Oriented）：是指发送数据之前必须在两端建立逻辑连接（logical connection）。通常建立连接的方式是通过遵循一系列规则来完成的，这些规则指定了应如何发起，协商，管理以及最终终止连接的方式。 通常，一台设备首先发送打开连接的请求，而另一台则响应。 设备传递控制信息，以确定是否以及如何建立连接。 如果成功，则在设备之间发送数据。 完成后，连接断开。TCP建立逻辑连接的方法是“三次握手”，这样能建立可靠的连接。</p>
<p>无连接（Connection-less）：是指发送数据之前不在两端建立连接。即使对端主机关机或不存在，数据包还是会被发送出去。反之，对于一台主机来说，它会何时从哪里收到数据也是不得而知的。通常应该进行网络监控，让主机只接收发给自己的数据包。若没有做好准备很有可能会错过一些该收的包。因此，在面向无连接的方式下可能会有很多冗余的通信。</p>
<h3 id="可靠传输与不可靠传输"><a href="#可靠传输与不可靠传输" class="headerlink" title="可靠传输与不可靠传输"></a>可靠传输与不可靠传输</h3><blockquote>
<p>Thus, to support these applications, something has to be done to <strong>guarantee</strong> that the data sent by one end of the application is delivered <strong>correctly</strong> and <strong>completely</strong> to the other end of the application. If a protocol provides such a guaranteed data delivery service, it is said to provide reliable data transfer.</p>
</blockquote>
<p>分组可能会在网络中丢失、损坏，应用层可能对网络通信有所要求，不允许出现这种差错，<strong>必须保证接收方的应用收到了完整且正确的数据，这种服务就是可靠数据传输服务。</strong>如果一个协议可以确保发送端发送了怎样的数据，那么接收端就必然能接收到怎样的数据，那么就可以说这个协议提供了可靠数据传输服务，这个协议是可靠（Reliable）的，反之则是不可靠（Unreliable）的。</p>
<h3 id="端口号、协议号以及通信如何识别"><a href="#端口号、协议号以及通信如何识别" class="headerlink" title="端口号、协议号以及通信如何识别"></a>端口号、协议号以及通信如何识别</h3><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号，端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址；在网络层的类似概念就是协议号。</p>
<p>类比到相对熟悉的概念就是流水线上，比如造车的时候先有底盘，然后装传动轴，再装轮胎，不同的车型用的轮胎和轴承不同，底盘生产出来以后就得告诉下一步组装传动轴的，这个底盘要装什么类型的传动轴，传动轴工序完毕以后要告诉装轮胎的，我这个传动轴要配什么轮胎，否则下一步不知道如何处理上一步给过来的零件，数据传输中，这个告诉下一步要如何处理的功能就是由端口号、协议号实现的。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145437.jpg" alt="微信图片编辑_20200113145437"></p>
<p>协议号（Protocol）是三层概念，存在于IP头部协议号字段，解封装时，如果上一层是TCP就将IP包首部之后的部分传给TCP处理；如果是UDP则将IP包首部后面的部分传给UDP处理(常见的例如：6=TCP，17=UDP)；</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145310.jpg" alt="微信图片编辑_20200113145310"></p>
<p>端口号是四层概念，存在于TCP或UDP源/目端口号字段，用以识别发送主机跟接收主机上的应用，解封装时会根据端口号的不同，传给由端口号识别的应用程序。常见的例如：TCP80=HTTP, UDP53=DNS，如果目的端口号是80，就交给上层的HTTP协议去处理，如果目的端口号是53就交给DNS协议去处理。</p>
<p>说白了都是“区分上层”用的，就是用来识别同一台计算机中进行通信的不同应用程序。但是所处的层次不一样。一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p>之所以有如此多的端口号是因为通信并不是由端口号一个字段决定的，识别一个通信是由五元组（<strong>源IP地址、目标IP地址、源端口号、目标端口和协议号</strong>）一起决定的。源IP地址决定了通信起源设备，目标IP地址决定了通信目的设备，但仅有源、目的IP地址不能识别一个通信，因为一台设备可以同时运行多个程序，下面举个接收端的例子来说明：</p>
<p>设备收到了一个数据后，先通过把物理层的电磁信号还原成二层的数据帧，然后看二层数据帧帧头的目的MAC地址和自己所接收端口的MAC地址是否相一致，如果一致就继续解封装到三层，查看目的IP地址是否是自己的，如果是自己的IP地址，再看协议号中的字段规定使用的是TCP还是UDP协议，然后将这个数据交给相应的四层（应用层）协议去处理，应用层处理以后，怎么知道把该数据交给上层（应用层）的哪个程序去处理呢？这就要通过端口号了，如果端口号是80，说明这是一个http协议，交给http处理，如果有多个http进程，则可以根据通信的五元组中其他不同的部分加以区分，其他的协议以此类推。</p>
<p><img src="/2019/11/23/6-tcp-ip/1e487b21-906d-41ae-8894-d02f1037cf25-1577770747233.jpg" alt="1e487b21-906d-41ae-8894-d02f1037cf25"></p>
<p><img src="/2019/11/23/6-tcp-ip/c9daa-20190821100721-bd5df.jpeg" alt="c9daa-20190821100721-bd5df"></p>
<p><img src="/2019/11/23/6-tcp-ip/3d251-20190821100721-c0e40.jpeg" alt="3d251-20190821100721-c0e40"></p>
<ul>
<li>① 和② 的通信是在两台计算机上进行的。它们五元组中的源、目的IP（源IP为192.168.4.22，目标地址为192.168.4.20），协议号（TCP6）以及目标端口号（80）均相同。这里可以根据五元组的源端口号加以区分。</li>
<li>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h3 id="MTU、Default-media-MTU、Default-IP-MTU、Protocol-MTU"><a href="#MTU、Default-media-MTU、Default-IP-MTU、Protocol-MTU" class="headerlink" title="MTU、Default media MTU、Default IP MTU、Protocol MTU"></a>MTU、Default media MTU、Default IP MTU、Protocol MTU</h3><p>MTU是最大传输单元的英文简写（<strong>M</strong>aximum <strong>T</strong>ransmission <strong>U</strong>nit）</p>
<blockquote>
<p>the maximum transmission unit (MTU) is the size of the largest protocol data unit (PDU) that can be communicated in a single network layer transaction</p>
</blockquote>
<p>最大传输单元（MTU）是可以在单个网络层事务中通信的最大协议数据单元（PDU）的大小，简单来说也就是 <strong>TCP 数据段能够携带的数据上限</strong>。MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，<strong>两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定</strong>。</p>
<p>Default media MTU是Juniper的叫法，个人觉得Juniper的命名方式比较清楚，所以以下均采用Juniper的方式。Default IP MTU和Default media MTU（MTU）不是同一个概念。Juniper有个计算公式：</p>
<p>Default media MTU = Default IP MTU + encapsulation overhead</p>
<p>encapsulation overhead 在现网中就是 Ethernet header，因为二层的协议用的都是以太网2封装技术，以太网头部（14字节）但<strong>不包括尾部的FCS校验部分</strong>（4字节），所以：</p>
<p>Default media MTU = 1500 （Default IP MTU） + 14（encapsulation overhead，6字节的目的MAC＋6字节的源MAC＋2字节的帧类型） =1514字节。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200129143940.jpg" alt="微信图片编辑_20200129143940"></p>
<p>Default IP MTU=TCP header + IP header + TCP segment length（也就是图中的Data部分） </p>
<p>Default IP MTU（1500字节）= TCP header（20字节） + IP header（20字节） + TCP segment length（1460字节）</p>
<p>注1：TCP MSS 、Payload、 DATA 以及 TCP segment length其实是同一个东西</p>
<p>注2：抓包软件抓到的是去掉前导同步码、帧开始分界符、CRC校验之外的数据，其最大值是6＋6＋2＋1500＝1514，这个在Juniper这就是Default media MTU</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200129144404.jpg" alt="微信图片编辑_20200129144404"></p>
<p>如果IP层有&lt;=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。但如果分片的话，会导致网络传输效率降低，所以要尽量避免分片。</p>
<blockquote>
<p>Why we ‘ve both of Interface MTU and IP MTU?</p>
<p>IP MTU will only affect IP packets while MTU will affect all ethernet frames. It gives you a bit more granularity to only set the MTU for IP packets.</p>
</blockquote>
<p>为什么同时需要Default IP MTU和Default media MTU这两个概念呢？</p>
<p>因为IP MTU仅仅影响IP包，Default media MTU将影响所有以太网帧，这样区分概念可以为网络提供更高的颗粒度，比如可以仅仅设置IP MTU而不影响以太网帧。</p>
<p>当然，上面这个解答是在二层用以太网封装的情况下，如果用PPP或其他方式的话，上文中的Default media MTU影响的就不是所有以太网了。</p>
<h3 id="最大分段大小（MSS）"><a href="#最大分段大小（MSS）" class="headerlink" title="最大分段大小（MSS）"></a>最大分段大小（MSS）</h3><p>“最大分段大小”（英语：<strong>M</strong>aximum <strong>S</strong>egment <strong>S</strong>ize）。TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，注意，<strong>UDP是没有MSS这个概念的</strong>。MSS是TCP用来限制application层最大的发送字节数，是tcp能发送的分组的最大长度。MSS是系统默认的，就是系统TCP/IP栈所能允许的最大包。<strong>在建立连接的三次握手时，这个MSS值经过双方协商后已经被确定了</strong>，这个值并不是客观的值，而是由tcp/ip的实现确定的，<strong>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。</strong>下图中，左右两边的MSS都是1460。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_13-48-20.jpg" alt="Snipaste_2020-01-26_13-48-20" style="zoom:150%;">

<p>如果两边的MSS值不同，则MSS会使用较小值。通信双方最终的MSS一般情况下 = 双方较小IP MTU - 40。这个40是由20字节的IP Header和20字节的TCP Header构成的，但如果IP Header和TCP Header的大小有变化，比如下图中的MSS就是1448位：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-02_15-17-34.jpg" alt="Snipaste_2020-04-02_15-17-34"></p>
<p>如果Default IP MTU  = 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。</p>
<p><img src="/2019/11/23/6-tcp-ip/tcp_pdus-1580019861990.png" alt="tcp_pdus"></p>
<p><img src="/2019/11/23/6-tcp-ip/MTU-image-1.png" alt="MTU-image-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/2843224-029d06502bd58f0e.webp" alt="2843224-029d06502bd58f0e"></p>
<h3 id="TCP-segment-length"><a href="#TCP-segment-length" class="headerlink" title="TCP segment length"></a>TCP segment length</h3><p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_17-04-26.jpg" alt="Snipaste_2020-01-26_17-04-26"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_17-06-18.jpg" alt="Snipaste_2020-01-26_17-06-18"></p>
<p>这个TCP segment length就是上图的DATA部分，TCP MSS 、Payload、 DATA 以及 TCP segment length其实是同一个东西，也就是应用层交给传输层的数据。</p>
<h3 id="TCP分段与IP分片"><a href="#TCP分段与IP分片" class="headerlink" title="TCP分段与IP分片"></a>TCP分段与IP分片</h3><p>有<a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">一篇文章</a>把这两个概念讲的非常好，如果想深入了解请自行访问链接进行查看。</p>
<p>TCP分段的原因是因为TCP报文段的大小受到MSS的限制，当TCP报文段的长度大于MSS时，就要在TCP层面进行分段，MSS 是操作系统内核层面的限制，为的是保证传输的性能；IP分片的原因是IP数据包的大小受到MTU的限制，当所需转发的IP数据报的大于MTU时，就需要在IP层面进行分片，IP层面分片是因为物理设备的限制。这两个分片有点类似于，一辆车上只能装4个人，如果有6个人想坐车就只能坐两辆车分开走，但这个比喻只是方便理解但非常的不准确。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-08_12-07-28.jpg" alt="Snipaste_2020-04-08_12-07-28"></p>
<p>但由于一直有MSS&lt;=MTU，很明显，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。</p>
<p>再来看UDP数据报，由于UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p><strong>总结：UDP不会分段，就由IP来分。TCP会分段，当然就不用IP来分了！</strong></p>
<h4 id="TCP分段分析"><a href="#TCP分段分析" class="headerlink" title="TCP分段分析"></a>TCP分段分析</h4><p>TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是向其他网络协议，在下一站就要进行重组。</p>
<p>当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_15-59-26.jpg" alt="Snipaste_2020-03-12_15-59-26"></p>
<h4 id="IP数据分片分析"><a href="#IP数据分片分析" class="headerlink" title="IP数据分片分析"></a>IP数据分片分析</h4><p>前面说过，IP分片的原因是IP数据包的大小受到MTU的限制，当所需转发的IP数据报的大于MTU时，就需要在IP层面进行分片。</p>
<p>在分析IP数据分片时，有三个IP报头中的字段需要格外注意：</p>
<blockquote>
<ul>
<li>Identification - this value identifies a group of fragments. It’s what tells the reassembling device which fragments make up the original packet.</li>
<li>Fragment offset - once all the fragments have been received, they need to be put back in the correct order. This field tells the reassembling device where in the original packet to place the data from each fragment (after stripping the L2&amp;L3 headers).<br>the value for the first fragment will be 0</li>
<li>Flags - MF bit - More Fragments means that there are additional packets coming in after this one.<br>it is set (1) in all but the last fragment (0)</li>
</ul>
</blockquote>
<p>Identification（标识符），这个字段标识该数据为同一组分片的数据，用来告诉重组数据的设备哪些数据分片可以用来重组称为原始数据。</p>
<p>Fragment offset（分段序号），当所有分段数据都被接收后，需要将这些数据根据正确的顺序重组起来，这个字段告诉重组的设备这些分段数据正确的重组顺序。第一个分段数据的Fragment offset值为0。</p>
<p>Flags（标记）-MF位（more fragments），当该位为1时表示后面还有更多的分片数据，当最后一个分片数据的MF位为0，表示没有更多的分片数据了。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404205116.png" alt="微信截图_20200404205116"></p>
<p>先总体来看看这个抓包，这个抓包工有14个数据，前7个是ping包，也就是红框中的这些，后7个是replay这个ping包的，是蓝色框中的部分。</p>
<blockquote>
<p>The most important information is in the last entry (<code>#7</code> for the request and <code>#14</code> for the reply). It shows a combination of the contents (and size) of the last fragment to arrive (<code>134</code> bytes), but it also shows the reassembled packet in all its glory (<code>8980</code> bytes).</p>
<p>They key to that is noticing the tab that appears at the bottom which says <code>Reassembled IPv4 (8980 bytes)</code>.</p>
</blockquote>
<p>最重要的信息是在最后的两行中，对于ping包就是第七个数据，对于回复包就是第十四个数据，这两行显示的是最后一个整合了前面所有分片数据信息和大小，也是前面所有分片的整合。</p>
<p>关键是要看到标签按键上的“组合起来是8980位”这个，表示7个数据的ipv4部分加起来是8980位。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-05_16-51-01.jpg" alt="Snipaste_2020-04-05_16-51-01"></p>
<blockquote>
<p>To make matters worse, the IP header shown inside the reassembled packet is the one from the last fragment (notice Fragment offset is <code>8880</code> and MF is <code>0</code>). On the flip side, it does tell you that the packet has been reassembled from 7 fragments and it gives you the sizes and links to the fragments themselves. Convenient.</p>
</blockquote>
<p>让事情变得更糟糕的是，只有分片最后的那片数据带有UDP或ICMP首部，在这个例子中，只有第七和第十四片带有ICMP头部，因为Flag位上的MF位（More Fragments）为0，也就是说没有更多分片了，这两个是他们分片中的最后一个分片了，所以可以把所有分片整合起来了。在7和14上可以看到所有的分片大小以及这些分片的链接。</p>
<p>有些书上写的是只有第一个分片包含UDP或ICMP首部，但通过抓包以及询问原厂工程师，我觉得应该是最后一个分片带有UDP和ICMP首部，因为只有在7和14这两个上才有其他分片的信息以及Flag位中的MF位为0（表示没有更多分片）。在自己的结果和书上查到的资料有差异时，不要简单的就怀疑自己的结果有问题，要多方查证，通过做实验和抓包去证实真正的结果如何。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404194723.png" alt="微信截图_20200404194723"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404194744.png" alt="微信截图_20200404194744"></p>
<p>最后一点，对IP分片的数据报来说，即使只丢失一片数据也要重新传整个数据报（既然有重传，说明运输层使用的是具有重传功能的协议，如TCP协议）。这是因为IP层本身没有超时重传机制——由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<h3 id="FCS和CRC"><a href="#FCS和CRC" class="headerlink" title="FCS和CRC"></a>FCS和CRC</h3><p>定义：</p>
<blockquote>
<p>FCS - Frame Check Sequence is the process of using an algorithm or many algorithms to check frames</p>
<p>CRC - Cyclical Redunancy Check is a checksum type. It uses a specific algorithm (found below) for checking computation or transmission integrity.</p>
</blockquote>
<p>用简单的话来说，FCS是用算法校验数据的过程，而CRC是FCS这个校验过程可以采用的一种校验的方式，以太网用的就是CRC这种校验方式，所以在以太网里可以暂且把两者看成是同一个东西，但从概念上来讲，要知道二者是不同的。</p>
<h2 id="各层功能"><a href="#各层功能" class="headerlink" title="各层功能"></a>各层功能</h2><h3 id="应用层（Network-Access-Layer）"><a href="#应用层（Network-Access-Layer）" class="headerlink" title="应用层（Network Access Layer）"></a>应用层（Network Access Layer）</h3><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200118145723.png" alt="微信图片_20200118145723"></p>
<p>图中的DATA部分可以理解为由应用层产生的，应用层向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录，常见用的软件所使用的很多协议都在这一层。应用层包含了所有的高层协议：</p>
<ul>
<li>HTTP 80                  超文本传输协议，提供浏览网页服务 </li>
<li>Telnet 23                  远程登陆协议，提供远程管理服务</li>
<li>FTP 20、21             文件传输协议，提供互联网文件资源共享服务</li>
<li>SMTP 25                  简单邮件传输协议，提供互联网电子邮件服务</li>
<li>POP3 110                邮局协议，提供互联网电子邮件服务</li>
<li>TFTP 69 (UDP)        简单文件传输协议，提供简单的文件传输服务 </li>
<li>DNS  53（UDP）    域名解析协议，提供网址和IP地址相互映射服务</li>
</ul>
<p>关于DNS举个现实中的例子，我们在设备上ping百度网址的时候，其实ping的并不是百度 <a href="http://www.baidu.com/">www.baidu.com</a> 的网址而是ping的61.135.169.125这个IP地址，因为在网络上只有IP地址才是设备的唯一标识，必须通过IP地址数据才能通信，但相比一长串的IP地址，还是网址这个贴近人类记忆习惯的东西比较好记，但机器无法识别这些人类熟悉的网址，所以有了DNS这个映射协议，将网址和IP地址对应起来，当用户输入主机名（域名）时，DNS会自动检索那个注册了主机名和IP地址的数据库，并迅速定位对应的IP地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-09_13-54-41-1583733928827.jpg" alt="Snipaste_2020-03-09_13-54-41"></p>
<h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118145922.jpg" alt="微信图片编辑_20200118145922"></p>
<p>传输层位于应用层和网络接口层之间，负责在主机之间提供逻辑连接，通常提供如下功能：</p>
<p>流量控制：通过窗口技术</p>
<p>可靠连接：通过序列号和确认号</p>
<p>会话多路复用：通过端口号和IP地址</p>
<p>分段：通过使用数据段的协议数据单元（PDU）</p>
<p>在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。图中的TCP协议（也可能是UDP协议）+端口号（Port Number）+应用层的DATA可以理解为整个传输层封装后产生的，在数据由应用层传递给传输层后，TCP提供将应用层发来的数据顺利发送至对端的可靠传输。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118151853.jpg" alt="微信图片编辑_20200118151853"></p>
<p>为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号（用以识别发送主机跟接收主机上的应用）、序号（用以发送的包中哪部分是数据）以及校验和（Check Sum，用来检验数据的读取是否正常进行的方法。） （用以判断数据是否被损坏）。随后将附加了TCP首部的包再发送给IP。</p>
<p><img src="/2019/11/23/6-tcp-ip/TCPUDP.jpg" alt="TCPUDP"></p>
<p>TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）为两台主机提供高可靠性的数据通信，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h5 id="TCP的特点："><a href="#TCP的特点：" class="headerlink" title="TCP的特点："></a>TCP的特点：</h5><p>1、面向连接：是指发送数据之前必须在两端建立连接。TCP建立连接的方法是“三次握手”，这样能建立可靠的连接，所以说TCP是面向连接的协议。建立连接，是为数据的可靠传输打下了基础。</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。TCP建立连接的方法是“三次握手”，这样能建立可靠的连接，所以说TCP是面向连接的协议。</p>
<p>2、可靠传输：TCP协议可以确保发送端发送了怎样的数据，那么接收端就必然能接收到怎样的数据，因为TCP协议中规定了：①如何处理丢失或重复等差错情况。②如何初始化一个数据流传输 ③如何协商结束数据流传输 ④流量控制和拥塞控制机制。</p>
<ul>
<li><p>①如何处理丢失或重复等差错情况：靠的是TCP的序列号（Sequence Number）以及确认应答号（Acknowledgement Number、ACK）。TCP在发送数据的时候，为每个字节编号（也就是序列号），接收端收到数据之后，经过校验无误，发回确认应答号，确认应答号为接收端等待接受的写一个字节的序号。并且它会缓存到达的乱序数据，统一排序之后传递给上层。这样就解决了丢包，重复和乱序的问题。</p>
</li>
<li><p>②如何初始化一个数据流传输：TCP的三次握手进行了规定。</p>
</li>
<li><p>③如何协商结束数据流传输：TCP的四次分手进行了规定。</p>
</li>
<li><p>④流量控制和拥塞控制机制：TCP的窗口字段、序列号、确认应答号、Tail drop（尾帧丢弃）和RED（Random early detection）等提供了这些功能。</p>
</li>
</ul>
<p>3、支持流控</p>
<p>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。具体见下文的窗口大小部分。</p>
<p>4、窗口机制</p>
<p>见下方的窗口机制部分。</p>
<h5 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h5><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-31_13-24-32.jpg" alt="Snipaste_2019-12-31_13-24-32"></p>
<p>一个 TCP Header 一般有 20 个字节，如果启用了options，header的长度可以达到 60 个字节。图中每一行是 4 个 bytes，32 个 bits。</p>
<img src="/2019/11/23/6-tcp-ip/01e54adf-35dc-4628-8de3-044c64437a37.jpg" alt="01e54adf-35dc-4628-8de3-044c64437a37" style="zoom:67%;">

<p><img src="/2019/11/23/6-tcp-ip/3-slide3.jpg" alt="3-slide3"></p>
<h6 id="源端口号（Source-Port）"><a href="#源端口号（Source-Port）" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h6><p><strong>表示发送端端口号</strong>，字段长16位。</p>
<h6 id="目标端口号（Destination-Port）"><a href="#目标端口号（Destination-Port）" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h6><p><strong>表示接收端端口号</strong>，字段长度16位。</p>
<p>源和目标端口号长度均为16位，即允许一个主机有2的16次方，也就是65535个不同端口，其中：</p>
<p>0——1023为分配给系统的端口号，属于知名端口，不可以乱用，常见的有HTTP的80端口，FTP的21端口以及TELNET的23端口。</p>
<p>1024——49151为登记端口号，第三方可以使用。</p>
<p><strong>应用客户端使用的源端口号一般为系统中未使用的且大于1023的数字。</strong></p>
<h6 id="序列号（Sequence-Number）"><a href="#序列号（Sequence-Number）" class="headerlink" title="序列号（Sequence Number）"></a>序列号（Sequence Number）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160155.jpg" alt="微信图片编辑_20200118160155"></p>
<p>字段长32位。<strong>序列号（有时也叫序号）是指发送数据的位置</strong>。每发送一次数据，就累加一次该数据字节数的大小。接收方可以通过检查收到的数据分组的序号发现哪些分组没有收到、哪些分组冗余了。发送ACK/NAK反馈时也可以指定Seq表示需要重传哪些分组或者继续往下发送哪些分组。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_15-20-26.jpg" alt="Snipaste_2020-03-12_15-20-26"></p>
<p>一个TCP流是有无数个0和1构成，这些0和1以8个bit为单位，可以分割成一个个的byte，TCP是可靠传输协议，每一个byte都是有标号的，因为我们需要追踪每个byte是否被成功传输了，每个byte的标号就是我们这里的sequence number。有了数据包对应的序列号，我们就可以：</p>
<ul>
<li><strong>接收方可以通过序列号对重复的数据包进行去重；</strong></li>
<li><strong>发送方会在对应数据包未被 ACK 时进行重复发送；</strong></li>
<li><strong>接收方可以根据数据包的序列号对它们进行重新排序；</strong></li>
</ul>
<p><strong>序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</strong></p>
<blockquote>
<p> A TCP header which only consists of the ACK will not increment the SEQ/ACK</p>
</blockquote>
<p><strong><span style="color:red">一个只包含ACK的TCP报头不会增加序列号和ACK号的数字，也就是说，一个纯ACK确认数据是不会增加序列号和ACK号的数字</span></strong> </p>
<h6 id="确认应答号（Acknowledgement-Number、ACK）"><a href="#确认应答号（Acknowledgement-Number、ACK）" class="headerlink" title="确认应答号（Acknowledgement Number、ACK）"></a>确认应答号（Acknowledgement Number、ACK）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160230.jpg" alt="微信图片编辑_20200118160230"></p>
<p>确认应答号字段长度32位。是指表示<strong>期望收到对方下一个报文段的序号值</strong>。实际上，它是指已收到确认应答号减1为止的数据。当发送端收到确认应答号后，用来确认这个位置以前所有数据都被正常接收，否则将会从新连接发送，这也<strong>是TCP是可靠传输的原因，因为有“序列号—确认应答号”这么一个确认机制，可以知道数据是否发送完整。</strong>例如下图中，主机A向主机B发送了长度为725的数据，主机B在回复的数据中将应答号设置为726，表示前725个数据都正常接收，下次请发送序列号从726开始的数据。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-15_17-04-48.jpg" alt="Snipaste_2019-12-15_17-04-48" style="zoom:150%;">

<p>必须要注意的是，<strong>TCP的ACK表达的意思一方面是期望收到对方下一个报文段的序列号，另一方面也是确认当前数据段前面的全部数据段已经被接收和处理</strong>，如果说对方发送了5个数据段，数据段1-5，如果后四段成功接收，但第一段未接收的话，接收者是不会发送ACK序列号为6的，因为如果发送了ACK=6就是说明1-5全部接收成功，但事实上数据段1并没有接收到所以是不会发送ACK为6的数据的，由于发送方没有收到 ACK，<strong>所有数据段</strong>对应的计时器就会超时并重新传输数据。在丢包较为严重的网络下，这种重传机制会造成大量的带宽浪费。</p>
<p>如何解决上面说的这种其中某一个数据段没收到就要重传所有数据段的问题呢？要用到快速重传（Fast Retransmit/Fast Recovery），大概意思是当接收方收到乱序的数据段时，不会等待重传计时器到时再重传，而是会立刻发送两个连续的 ACK 触发发送方的重传，这里就不展开了，详见RFC2581中的<a href="https://tools.ietf.org/html/rfc2581#page-6">3.2 Fast Retransmit/Fast Recovery</a>。</p>
<blockquote>
<p>The sequence number is always valid. The acknowledgement number is only valid when the ACK flag is one. The only time the ACK flag is not set, that is, the only time there is not a valid acknowledgement number in the TCP header, is during the first packet of connection set-up.</p>
</blockquote>
<p><strong>序列号始终存在。确认编号仅在ACK标志为1时存在。</strong> 唯一未设置ACK标志的时间，即TCP头中没有有效确认号的唯一时间是在连接建立的第一个数据包期间。</p>
<blockquote>
<p>if ACK flag is 1 , Acknowledgment number is considered by application; if ACK flag is 0, Acknowledgment Number is not considered</p>
</blockquote>
<p>如果控制位中的ACK置位为1，则应用程序考虑确认号；如果ACK为0，则不考虑确认编号。关于控制位中的ACK置位问题，请参照后面的控制位部分。</p>
<blockquote>
<p>The ACK flag is used to acknowledge past data, but the acknowledgement number is used to say what is expected in the future. Those are two completely different functions.</p>
<p>when a host sees the ACK flag, it knows that all data up to the acknowledgement number has been acknowledged, but the acknowledgement number, itself, is telling the host what the destination is expecting next.</p>
</blockquote>
<p>注意ACK置位和ACK 序号的区别，ACK位是在TCP报头控制位里的其中一位，而ACK序号是前面的ACK确认应答号，两者功能是完全不同的，ACK置位为1的时候，表示这个数据是确认之前发送的数据，对端会明白这个数据是用来确认的，确认的是ACK确认应答号之前的那些数字，比如ACK确认应答号是1000，而ACK确认应答号是用来告诉对端下一次发送数据的序列号是多少，所以下次发送数据从1000开始。这两个字段是搭配起来用的。</p>
<h6 id="——关于序列号和确认应答号的相关说明——"><a href="#——关于序列号和确认应答号的相关说明——" class="headerlink" title="——关于序列号和确认应答号的相关说明——"></a><strong>——关于序列号和确认应答号的相关说明——</strong></h6><p>序列号和确认号组合起来使用，<strong>可以提高可靠性。</strong></p>
<blockquote>
<p>When a host initiates a TCP session, its initial sequence number is effectively random; it may be any value between 0 and 4,294,967,295, inclusive. However, protocol analyzers like Wireshark will typically display <em>relative</em> sequence and acknowledgement numbers in place of the actual values. These numbers are relative to the initial sequence number of that stream. This is handy, as it is much easier to keep track of relatively small, predictable numbers rather than the actual numbers sent on the wire.</p>
</blockquote>
<p>主机启动TCP会话时，<strong>其初始序列号实际上是随机的； 它可以是0到4,294,967,295（含）之间的任何值。</strong>因为序列号的大小是32位，2的32次方是4294967296。但是，像Wireshark这样的<strong>抓包分析软件通常会显示相对序列和确认号来代替实际值</strong>。 这些数字是相对于该流的初始序列号。这很方便，因为跟踪相对较小的可预测数字比在线上发送的实际数字要容易得多。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-15_16-52-20.jpg" alt="Snipaste_2019-12-15_16-52-20" style="zoom: 150%;">

<p>当TCP连接已经建立时，主机A向主机B发送了9个字节的数据后，主机B在回包中用确认号（Acknowledgemt Number）10来回复，这个10就是期望收到对方下一个报文段的序号值，所以对方在下一次发送中发送的12个字节，编号是从10开始的，也就是编号为10-21的数据。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-31_16-08-44.jpg" alt="Snipaste_2019-12-31_16-08-44" style="zoom:150%;">

<p>从抓包中能更直观的看出来“期望收到对方下一个报文段的序号值”这个概念：主机2（174.143.213.184）发送了长度为1448的数据给主机1（192.168.1.2），主机1在回复的数据中所带的ACK值是1449，所以下一次主机2发送的数据的序列号从1449开始，长度为1448的数据。</p>
<p><strong>通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></p>
<h6 id="数据偏移（Data-Offset）"><a href="#数据偏移（Data-Offset）" class="headerlink" title="数据偏移（Data Offset）"></a>数据偏移（Data Offset）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160306.jpg" alt="微信图片编辑_20200118160306"></p>
<p>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作<strong>TCP首部的长度</strong>（Specifies the size of the TCP header in 32-bit words.）。该字段长4位，单位为4字节（即4X8=32位）。不包括选项字段的话，TCP的首部为20字节长，因此数据偏移字段可以设置为5。反之，如果该字段的值为5，那说明从TCP包的最一开始到20字节为止都是TCP首部，余下的部分为TCP数据。</p>
<h6 id="保留（Reserved）"><a href="#保留（Reserved）" class="headerlink" title="保留（Reserved）"></a>保留（Reserved）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160356.jpg" alt="微信图片编辑_20200118160356"></p>
<p>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃（保留字段的第4位（如图中的第7位）用于实验目的，相当于NS（Nonce Sum）标志位。） 。</p>
<h6 id="控制位（Control-Flag）"><a href="#控制位（Control-Flag）" class="headerlink" title="控制位（Control Flag）"></a>控制位（Control Flag）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160431.jpg" alt="微信图片编辑_20200118160431"></p>
<p>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如下：</p>
<p><img src="/2019/11/23/6-tcp-ip/6976ea88-152b-4bc4-b602-dde1d632cd14.jpg" alt="6976ea88-152b-4bc4-b602-dde1d632cd14"></p>
<p>CWR（Congestion Window Reduced）<br>CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<p>ECE（ECN-Echo）<br>ECE标志表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p>
<p>URG（Urgent Flag）<br>该位为1时，表示包中有需要紧急处理的数据。在目前的协议中很少用到，这个字段的功能需要配合后面的“紧急指针（<em>Urgent Pointer</em>）”一起使用，</p>
<p>ACK（Acknowledgement Flag）<br>该位为1时，确认应答的字段变为有效，ACK字段用于确认成功接收数据包。</p>
<p>PSH（Push Flag）<br>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p>
<p>RST（Reset Flag）<br>该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因导致主机重启的情况下，由于所有的连接信息将全部被初始化，所以原有的TCP通信也将不能继续进行。这种情况下，如果通信对方发送一个设置为1的RST包，就会使通信强制断开连接。</p>
<p>SYN（Synchronize Flag）<br>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。</p>
<p>FIN（Fin Flag）<br>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p>
<h6 id="窗口大小（Window-Size）"><a href="#窗口大小（Window-Size）" class="headerlink" title="窗口大小（Window Size）"></a>窗口大小（Window Size）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160548.jpg" alt="微信图片编辑_20200118160548"></p>
<p>该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所示大小的数据，换句话说就是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p>
<h6 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160621.jpg" alt="微信图片编辑_20200118160621"></p>
<p>该字段长为16位。由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，<strong>会校验包括IP头部、TCP头部和TCP数据在内的整个序列，确保IP地址、端口号和其他相关信息正确</strong>，如果损坏接收方会丢弃该TCP片段。<strong>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</strong></p>
<h6 id="紧急指针（Urgent-Pointer）"><a href="#紧急指针（Urgent-Pointer）" class="headerlink" title="紧急指针（Urgent Pointer）"></a>紧急指针（Urgent Pointer）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160652-1579334838087.jpg" alt="微信图片编辑_20200118160652"></p>
<p>该字段长为16位。仅在 URG = 1 时才有意义，<strong>它指出本报文段中的紧急数据的字节数</strong>。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h5 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h5><h6 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h6><p>因为想确保彼此告诉对方的东西都被准确无误的听到了，类比到现实生活中就是打电话，你给别人打电话，不可能电话一接通你就啪啦啪啦地说一大通，万一对方接通电话后因为有事还没来得及倾听呢？这不太符合正常人类的交流习惯。一般是电话接通后，双方一般会有个交互的过程，一般是你说一声“你好”，然后对方也回复一声“你好”，双方通过各自一句“你好”明确对方的注意力都放在了电话沟通上，然后你们双方就可以开始交流了，这才是正常的人类交流方式，这个过程体现在计算机网络里就是网络协议！我们通过TCP协议在两台电脑建立网络连接之前要先发数据包进行沟通，沟通后再建立连接，然后才是信息的传输，这个机器沟通的过程和人打电话沟通的过程类似，但因为机器始终是机器，没有人那么智能，必须用一系列机制来确保“双方的注意力都放在了电话沟通上”，在TCP建立连接的过程中，这个机制就是三次握手，这三次握手中的Seq、ACK以及控制字段彼此呼应，完成了建立沟通的过程。</p>
<p>当然，上面这部分完全是为了方便理解所做的比喻，但真实情况和上面的例子还是有一些差别的，如果有兴趣请自行查阅<a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">这篇文章</a>，后面我也会结合文章和自己的体会整理一篇单独的笔记，在这里摘要其中一些部分进行说明。</p>
<p>在<a href="https://tools.ietf.org/html/rfc793">RFC793 - Transmission Control Protocol</a> 的文档中，清楚的定义了TCP使用三次握手的重要原因——为了阻止历史的重复链接初始化造成的混乱问题，防止使用TCP协议通信的双方建立了错误的连接。</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
<p>当然，也有另一个原因就是让通信的双方确定初始序列号。</p>
<p>三次握手建立TCP连接的成本相当高，不仅需要额外增加1.5RTT的网络延迟，还要增加222字节的额外开销，以太网数据帧头是3*14=42字节，IP数据帧头占据3 * 20 = 60字节，TCP数据占据3 * 40 =120字节，加起来一共是222字节。所以在弱网环境下，通过三次握手建立TCP连接会加剧TCP的性能问题。</p>
<p><img src="/2019/11/23/6-tcp-ip/2020-01-02-15779393353427-tcp-three-way-handshake-overhead.png" alt="2020-01-02-15779393353427-tcp-three-way-handshake-overhead"></p>
<p><img src="/2019/11/23/6-tcp-ip/2020-01-02-15779393353419-basic-3-way-handshake.png" alt="2020-01-02-15779393353419-basic-3-way-handshake"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200217174753.jpg" alt="微信图片编辑_20200217174753"></p>
<img src="/2019/11/23/6-tcp-ip/TCP-handshake.jpg" alt="TCP-handshake" style="zoom:150%;">

<h6 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118162239.jpg" alt="微信图片编辑_20200118162239"></p>
<p>客户端将标志位SYN置为1，表示我要和对方建立TCP连接，现在开始三次握手，并随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-51-08.jpg" alt="Snipaste_2020-01-08_17-51-08" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-04_17-56-06.jpg" alt="Snipaste_2020-01-04_17-56-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134334.jpg" alt="微信图片编辑_20200113134334"></p>
<p>开始三次握手的设备1（IP地址为192.168.1.2）会将TCP控制位（Control Flag）中的SYN位置为1，表示希望建立TCP连接；序列号（Sequence Number）置为J，在这J为0，因为这是设备1发送的第一个TCP数据（这个0是相对序列号，解释见上边序列号部分或下段说明），并将该数据包发送给对端的设备2（IP地址为174.143.213.184），客户端进入SYN_SENT状态，等待对端确认。会话的每一端都以（相对）序列号零开始。同样，确认数也为零，因为还没有对话的互补面需要确认。</p>
<p>必须注意的是，主机启动TCP会话时，<strong>其初始序列号实际上是随机的； 它可以是0到4,294,967,295（含）之间的任何值。</strong> 但是，像Wireshark这样的<strong>抓包分析软件通常会显示相对序列和确认号来代替实际值</strong>。 这些数字是相对于该流的初始序列号。 这很方便，因为跟踪相对较小的可预测数字比在线上发送的实际数字要容易得多。</p>
<h6 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200130170823.jpg" alt="微信图片编辑_20200130170823"></p>
<p>服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，SYN置位为1表示我也要建立连接，ACK置位为1表示这个是确认收到了对方之前的回复；ack=J+1，表示这个带ack的值是回应之前Seq值为J的数据的，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-52-06.jpg" alt="Snipaste_2020-01-08_17-52-06" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-04_18-03-45.jpg" alt="Snipaste_2020-01-04_18-03-45"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134532.jpg" alt="微信图片编辑_20200113134532"></p>
<p>设备2（IP地址为174.143.213.184）收到数据包后解封装发现TCP的控制位中SYN置1，说明设备1（IP地址为192.168.1.2）请求建立连接，于是将自己TCP的控制位中的SYN和ACK都置为1，SYN置位为1表示我也要建立连接，ACK置位为1表示这个是确认收到了对方之前的回复；ACK为设备1的序列号J+1，第一次握手的J=0，所以这里的ACK为1，表示我确认的是之前序列号为0的那个数据；随机产生一个序列号K，这个K在这也是0（相对序列号），因为这是设备2第一次和设备1通信，然后将该数据包发送给设备1并进入SYN_RCVD状态。</p>
<h6 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200130171052.jpg" alt="微信图片编辑_20200130171052"></p>
<p>客户端收到确认后，检查ack是否为J+1（回应之前Seq值为J的数据），ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-52-53.jpg" alt="Snipaste_2020-01-08_17-52-53" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_18-58-43.jpg" alt="Snipaste_2020-01-05_18-58-43"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134609.jpg" alt="微信图片编辑_20200113134609"></p>
<p>设备1（IP地址为192.168.1.2）收到确认后，检查ack是否为J+1，之前J=0，所以检查ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，前面的K=0，并将该数据包发送给设备2（IP地址为174.143.213.184），设备2检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，两个设备均进入了ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<h5 id="TCP三次握手的漏洞："><a href="#TCP三次握手的漏洞：" class="headerlink" title="TCP三次握手的漏洞："></a>TCP三次握手的漏洞：</h5><p><strong>漏洞：SYN洪泛攻击</strong></p>
<p><strong>定义：</strong></p>
<p>通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-04_12-47-46.jpg" alt="Snipaste_2020-05-04_12-47-46"></p>
<p><strong>原理：</strong></p>
<p>当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的SYN报文，一旦接收到Client发来的SYN报文，就需要为该请求分配一个TCB（Transmission Control Block），通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYNACK报文，立即转为SYN-RECEIVED即半开连接状态，而某些操作系统在SOCKT的实现上最多可开启512个半开连接（如Linux2.4.20 内核）。</p>
<p>如果恶意的向某个服务器端口发送大量的SYN包(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。</p>
<p><strong>解决方案：</strong></p>
<p>无效连接监控释放：</p>
<p>不停的<strong>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</strong>这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉。</p>
<p>延缓TCB分配方法：</p>
<p>1、SYN Cache技术</p>
<p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p>
<p>2、SYN Cookie技术：</p>
<p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p>
<p>防火墙：</p>
<p>很多<strong>防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行。</strong></p>
<h5 id="TCP的四次分手"><a href="#TCP的四次分手" class="headerlink" title="TCP的四次分手"></a>TCP的四次分手</h5><p><img src="/2019/11/23/6-tcp-ip/2020-03-10-15838517142219-tcp-closing-connection.png" alt="2020-03-10-15838517142219-tcp-closing-connection"></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP-88-1.jpg" alt="TCP-88-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200218152246.jpg" alt="微信图片编辑_20200218152246"></p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_17-07-53.jpg" alt="Snipaste_2020-01-05_17-07-53" style="zoom:150%;">

<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_15-49-17.jpg" alt="Snipaste_2020-02-18_15-49-17" style="zoom:150%;">

<p>建立起TCP连接的设备两端均可以发起中断连接。</p>
<h6 id="第一次分手："><a href="#第一次分手：" class="headerlink" title="第一次分手："></a>第一次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/Users/32759/Downloads/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121145129.jpg" alt="微信图片编辑_20200121145129"></p>
<p>理论步骤：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_17-14-40.jpg" alt="Snipaste_2020-01-05_17-14-40"></p>
<p>实际例子分析：设备1（IP地址为10.0.2.15）发送一个序列号（sequence number，此处为相对序列号）为106，确认应答号（Acknowledgement number）为321，这个321是用来确认之前对端发给该设备的，相对FIN与ACK均置为1的数据给设备2（IP地址为176.32.99.41），表示我这段要结束数据传送并进入FIN_WAIT_1状态。意思是说”我没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
<p>上一个数据包的Next sequence number是321，所以这个回送数据中的ACK为321，表示成功接收了320个数据，可以从序列号321开始发送，上一个数据包的抓包如下：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_14-53-26.jpg" alt="Snipaste_2020-01-21_14-53-26"></p>
<h6 id="第二次分手："><a href="#第二次分手：" class="headerlink" title="第二次分手："></a>第二次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121145617.jpg" alt="微信图片编辑_20200121145617"></p>
<p>理论步骤：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_14-57-58.jpg" alt="Snipaste_2020-01-21_14-57-58"></p>
<p>实际例子分析：设备2（IP地址为176.32.99.41）收到FIN后，先发送ack=M+1，这里的M为106，所以本数据包中的ACK为107，此序列号确认了设备1（IP地址为10.0.2.15）发送的序列号（sequence number，此处为相对序列号）为106的数据，告诉了设备1你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</p>
<p><span style="color:red">必须注意的是，这个ACK是个纯ACK，因为只有ACK置位为1了，TCP Segment Len：0，也就是没有DATA部分，没有其他的东西在里头，说明这个数据是个<strong>纯ACK</strong>，而一个只包含ACK的TCP报头不会增加序列号和ACK号的数字，所以后面第三次分手时数据的seq和ACK数字和第二次是一样的。</span></p>
<h6 id="第三次分手："><a href="#第三次分手：" class="headerlink" title="第三次分手："></a>第三次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121150048.jpg" alt="微信图片编辑_20200121150048"></p>
<p>理论步骤：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。<strong>这里其实ACK位也是置位为1的，然后ACK值也是M+1，表示确认的是之前FIN=M那个第一次分手</strong>。服务器端进入LAST_ACK状态。</p>
<p>实际例子分析：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_15-30-30.jpg" alt="Snipaste_2020-01-21_15-30-30"></p>
<p>设备2（IP地址为176.32.99.41）向设备1发送FIN位置为1的报文，告诉设备1（IP地址为10.0.2.15），我这边的数据已经发送完毕，准备好关闭连接了。服务器端进入LAST_ACK状态。<strong>这里的ACK值也是上一次分手时发送给设备1的ACK值，为107，因为第二次回复的ACK是一个纯ACK，里面没有数据，TCP Segment Len=0，也就是这个里面的DATA部分为0，是一个纯ACK数据，所以这里ACK位也置为1。</strong></p>
<p><strong>关于TCP Segment Len</strong></p>
<blockquote>
<p>The TCP payload size is calculated by taking the “Total Length” from the IP header (ip.len) and then substract the “IP header length” (ip.hdr_len) and the “TCP header length” (tcp.hdr_len).</p>
</blockquote>
<p>通过从IP报头（ip.len）中获取“总长度”，然后减去“ IP报头长度”（ip.hdr_len）和“ TCP报头长度”（tcp.hdr_len），可以计算出TCP有效负载大小。tcp payload是0 说明要么是三次握手，四次关闭，要么是纯ack。</p>
<h6 id="第四次分手："><a href="#第四次分手：" class="headerlink" title="第四次分手："></a>第四次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121154015.jpg" alt="微信图片编辑_20200121154015"></p>
<p>理论步骤：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL（Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. ）后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次分手。</p>
<p>实际例子分析：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_15-41-40.jpg" alt="Snipaste_2020-01-21_15-41-40"></p>
<p>实际例子分析：</p>
<p>设备1（IP地址为10.0.2.15）向设备2（IP地址为176.32.99.41）发送了一个相对序列号为107，相对确认号为322，ACK置位为1的数据，表示用来确认之前对方所发送序列号为321的数据，进入TIME_WAIT状态，如果等待了2MSL（Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. ）后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次分手。</p>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。</p>
<blockquote>
<p>It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN &amp; ACK (merely combines 2 steps into one) and host A replies with an ACK</p>
<p><a href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Tanenbaum, Andrew S.</a> (2003-03-17). <a href="https://archive.org/details/computernetworks00tane_2"><em>Computer Networks</em></a> (Fourth ed.). Prentice Hall. <a href="https://en.wikipedia.org/wiki/International_Standard_Book_Number">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-066102-9">978-0-13-066102-9</a>.</p>
</blockquote>
<p>TCP连接的关闭也可以通过3次分手实现，当主机A发送FIN置位为1的数据时，主机B回复一个FIN和ACK位均置位为1的数据，相当于把中间的两步整合为一步，最后主机A回复一个ACK结束TCP连接，比如下图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_17-07-05.jpg" alt="Snipaste_2020-02-18_17-07-05"></p>
<h5 id="为什么TCP实放需要四次分手"><a href="#为什么TCP实放需要四次分手" class="headerlink" title="为什么TCP实放需要四次分手"></a>为什么TCP实放需要四次分手</h5><p>为了保证双方都能通知对方“需要释放连接”，即在释放连接后都无法接收或发送消息给对方</p>
<ul>
<li>需要明确的是：TCP是全双工模式，这意味着是双向都可以发送、接收的</li>
<li>释放连接的定义是：双方都无法接收或发送消息给对方，是双向的</li>
<li>当主机1发出“释放连接请求”（FIN报文段）时，只是表示主机1已经没有数据要发送 / 数据已经全部发送完毕；但是，这个时候主机1还是可以接受来自主机2的数据。</li>
<li>当主机2返回“确认释放连接”信息（ACK报文段）时，表示它已经知道主机1没有数据发送了 但此时主机2还是可以发送数据给主机1</li>
<li>当主机2也发送了FIN报文段时，即告诉主机1我也没有数据要发送了 此时，主机1和2已经无法进行通信：主机1无法发送数据给主机2，主机2也无法发送数据给主机1，此时，TCP的连接才算释放。</li>
</ul>
<h5 id="为什么-TCP-协议有-TIME-WAIT-状态"><a href="#为什么-TCP-协议有-TIME-WAIT-状态" class="headerlink" title="为什么 TCP 协议有 TIME_WAIT 状态"></a><a href="https://draveness.me/whys-the-design-tcp-time-wait/">为什么 TCP 协议有 TIME_WAIT 状态</a></h5><p>？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<h5 id="TCP的流量控制——窗口滑动机制"><a href="#TCP的流量控制——窗口滑动机制" class="headerlink" title="TCP的流量控制——窗口滑动机制"></a>TCP的流量控制——窗口滑动机制</h5><h6 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h6><p>TCP 用“序列号（Sequence Number）”和“确认应答号（Acknowledge Number）”确保数据可靠传输，但如果每发送一个数据都要等对端发送ACK确认后才能发送下一个数据的话，显然效率是很低的，而且包的往返时间越长通信性能就越低，为解决这个问题，TCP引入了窗口这个概念。不再是一个数据段确认一次，而是以更大的单位进行确认，这么做的好处是转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个数据段以后不必要一直等待确认应答，而是继续发送其他的数据段。接收方的硬件性能有限，不可能在同一时间处理完这些数据，所以接收方利用接收缓存（Buffer）去暂时存储那些还没来得及处理的数据。但接收这些未经确认的数据是有大小限制的，这个限制的大小称作窗口大小，也就是TCP报头中的16位字段“Window Size”，这个字段用来告诉发送端，接收端还有多少缓存可以用，发送端会根据缓存的大小来调整发送的数据量。<strong>换句话说，窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。</strong>但是这个数值并不是对方一次发送数据的值，因为发送数据的值收到带宽等多方面因素的影响。</p>
<p>窗口的作用：</p>
<p><strong>1.确保数据不丢失</strong>：如果发送的数据丢失了可以重新发。</p>
<p><strong>2.控制发送速度</strong>：控制发送速度，以免接收方的缓存不够大导致溢出，同时控制流量也可以避免网络拥塞。</p>
<img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160548-1580447316189.jpg" alt="微信图片编辑_20200118160548" style="zoom:80%;">

<blockquote>
<p>Suppose we have two hosts, A and B, that form a TCP connection. At the start of the connection, both hosts allocate 32 KB of buffer space for incoming data, so the initial window size for each is 32,768.</p>
</blockquote>
<p>假设有两台主机用TCP协议连接，在TCP建立连接之初，两端都为接收数据设置了32K的缓存空间，所以这个初始的TCP 窗口大小是32678K（32X1024）。<strong>主机的buffer缓存，是由操作系统决定的。路由器交换机的buffer就是硬件内存</strong>。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_13-20-31.jpg" alt="Snipaste_2020-01-31_13-20-31"></p>
<blockquote>
<p>Host A needs to send data to host B. It can tell from host B’s advertised window size that it can transmit up to 32,768 bytes of data (in intervals of the maximum segment size, or MSS) before it must pause and wait for an acknowledgment. Assuming an MSS of 1460 bytes, host A can transmit 22 segments before exhausting host B’s receive window.</p>
</blockquote>
<p>假设两边的MSS协商为1460位，主机A在主机B的接收缓存满之前，可发送22个数据段，1460X22=32120，小于窗口最大值32768。</p>
<blockquote>
<p>When acknowledging receipt of the data sent by host A, host B can adjust its window size. For example, if the upper-layer application has only processed half of the buffer, host B would lower its window size to 16 KB. If the buffer was still entirely full, host B would set its window size to zero, indicating that it cannot yet accept more data.</p>
</blockquote>
<p>确认收到主机A发送的数据后，主机B可以调整其窗口大小。 例如，如果上层应用程序仅处理了一半的缓冲区，则主机B会将其窗口大小减小到16 KB。 如果缓冲区仍然完全满，主机B会将其窗口大小设置为零，表明它还不能接收更多数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_13-50-39.jpg" alt="Snipaste_2020-01-31_13-50-39"></p>
<blockquote>
<p>On a LAN with high bandwidth and extremely low delay, windows are rarely stressed as there are typically very few segments in transit between two endpoints at any given time. On a high-bandwidth, high-delay network, however, an interesting phenomenon occurs: it is possible to max out the receive window of the destination host before receiving an acknowledgment.</p>
</blockquote>
<p>在具有高带宽和极低延迟的局域网也就是LAN上，TCP的窗口很少受到压力，因为在一定时间在两个端点之间传输的段通常很少。 但是，在高带宽，高延迟的网络上，会出现一个有趣的现象：主机A发送的数据有可能在主机A接收到确认之前就沾满了主机B的缓存。</p>
<blockquote>
<p>As an example, let’s assume a TCP connection is established between two hosts connected by a dedicated 10 Mbps path with a one-way delay of 80ms. Both hosts advertise the maximum window size of 65,535 bytes (the maximum value of a 16-bit unsigned integer). We can calculate the potential amount of data in transit in one direction at one point in time as <strong>bandwidth * delay</strong>: 10,000,000 bps divided by 8 bits per byte, multiplied by 0.08 seconds equals 100,000 bytes. In other words, if host A begins transmitting to host B continuously, it will have sent 100,000 bytes before host B receives the first byte transmitted. However, because our maximum receive window is only 65,535 bytes, host A must stop transmitting once this number has been reached and wait for an acknowledgment from host B. (For the sake of simplicity, our example calculations do not factor in overhead from TCP and lower-layer headers.) This delay wastes potential throughput, unnecessarily inflating the time it takes to reliably transfer data across the network. TCP window scaling was created to address this problem.</p>
</blockquote>
<p>举例来说，让我们假设两台主机A、B之间用延迟80ms，带宽为10M的专线物理连接，他们之间用TCP建立连接，两边都有最大值为65535的TCP窗口（因为TCP报头中window size是16位，2的16次方就是65535），我们能够通过 “ 带宽 * 延迟 ” 的公式计算出某一时间点在一个方向上传输的潜在数据量：</p>
<p>10Mbps连接的带宽：也就是10,000,000 bps，除以8，将单位由bps换算成Bps，换算成Byte是因为byte（字节）一般做容量，bit（比特、位）一般用作速率（1B=8b、1B/s=8b/s或1Bps=8bps），然后乘以延迟0.08s（1ms = 0.001s，80ms=0.08s），等于100,000bytes。</p>
<p>也就是说在主机B收到第一个数据前，主机A会发送100，000字节的数据。但是因为我们接收的TCP最大窗口值为65535字节，所以主机A发送了65535字节的数据后必须停下来等待主机B发送ACK表示数据成功接收，因为 “window size” 这个字段的含义就是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>，发送端会按照这个值去发送数据，等对端确认接收了再继续发送余下的数据。（为了简单起见，我们这个例子的计算不考虑TCP报头以及其他报头的开销）。这种延迟浪费了潜在的吞吐量，不必要地增加了跨网络可靠传输数据所需的时间，将最大窗口限制在65535对所谓的“大而胖的网络”（那些有大带宽延迟产品）的性能有显著的损害。TCP窗口缩放就是为了解决这个问题而产生的。</p>
<h6 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h6><blockquote>
<p>Window scaling was introduced in RFC 1072 and refined in <a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a>. Essentially, window scaling simply extends the 16-bit window field to 32 bits in length. Of course, the engineers could not simply insert an extra 16 bits into the TCP header, which would have rendered it completely incompatible with existing implementations. The solution was to define a TCP option to specify a count by which the TCP header field should be <a href="http://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift">bitwise shifted</a> to produce a larger value.</p>
</blockquote>
<p>滑动窗口由RFC 1072 引入，并在RFC 1323 中进行了改进。本质上，只是简单的将“window size”这个参数从16位的窗口字段扩展为32位。当然，工程师们不是简单的将新增加的16位插入TCP报头，如果简单的将新增加的16位字段插入报头中，TCP的新报头和之前的报头将不同，导致无法互相兼容。解决办法是在TCP的opinion字段中定义一个数值，TCP报头中的“window size”字段按opinion的该数值移位以产生较大的值。</p>
<blockquote>
<p>A count of one shifts the binary value of the field to left by one bit, doubling it. A count of two shifts the value two places to the left, quadrupling it. A count of seven (as shown in the example above) multiplies the value by 128. In this manner, we can multiply the 16-bit header field along an exponential scale to achieve more than sufficiently high values. Of course, this causes us to lose granularity as we scale (we can only increase or decrease the window size in intervals of 2n where <em>n</em> is our scale), but that isn’t much of a concern when dealing with such large windows.</p>
</blockquote>
<p>当值为1时，会将“window size”字段的二进制值向左移一位，也就是将“window size”的值加倍。 当值为2时，将值向左移动两位，也就是将“window size”的值扩大4倍。 一个7的计数（如下面的示例所示）将该值乘以128。以这种方式，我们可以将16位opinion的字段沿指数范围相乘，以获得更多的足够高的值。 当然，这会导致我们在缩放时失去粒度（我们只能以2的n次方为间隔增加或减小窗口大小，其中_n_是我们的缩放比例），但是在处理如此大的窗口时，这并不是什么大问题。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-02_20-51-06.jpg" alt="Snipaste_2020-02-02_20-51-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-02_20-34-36.jpg" alt="Snipaste_2020-02-02_20-34-36"></p>
<blockquote>
<p>The window scaling option may be sent only once during a connection by each host, in its SYN packet. The window size can be dynamically adjusted by modifying the value of the window field in the TCP header, but the scale multiplier remains static for the duration of the TCP connection. Scaling is only in effect if both ends include the option; if only one end of the connection supports window scaling, it will not be enabled in either direction. The maximum valid scale value is 14 (section 2.3 of <a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a> provides some background on this caveat for those interested).</p>
</blockquote>
<p>在TCP三次握手建立连接期间，窗口缩放选项只在其SYN数据包中发送一次。 可以通过修改TCP标头中的窗口字段的值来动态调整窗口大小，但是比例乘数在TCP连接期间保持不变。 仅当两端都包含该选项时，缩放才有效； 如果仅连接的一端支持窗口缩放，则两端都不会启用该参数。 最大有效比例值是14（有进一步研究兴趣的请查阅RFC 1323的2.3节）。</p>
<blockquote>
<p>Revisiting our earlier example, we can observe how window scaling allows us to make much more efficient use of long fat networks. To calculate our ideal window, we double the end-to-end delay to find the round trip time, and multiple it by the available bandwidth: 2 * 0.08 seconds * 10,000,000 bps / 8 = 200,000 bytes. To support a window of this size, host B could set its window size to 3,125 with a scale value of 6 (3,125 left shifted by 6 equals 200,000). Fortunately, these calculations are all handled automatically by modern TCP/IP stack implementations.</p>
</blockquote>
<p>回头看我们之前举的例子，我们可以看到，滑动窗口是如何让我们能更有效的利用“长且胖”（long fat networks）网络的。为了计算我们所需要的理想窗口大小，我们将“端到端延迟”加倍，就能得到“往返时间”（RTT），将这个往返时间（RTT）乘以现有的带宽：2 X 0.08s X 10,000,000 bps / 8 = 200,000 bytes。为了能支持200,000 bytes大小的理想window size，主机B将它的window size 设置成3125（小于window size最大值的65535），然后将缩放比例值（也就是window scale）设置为6,（3125 X 2的6次方等于200,000），幸运的是，这些计算都自动的被近代的TCP\IP协议栈所处理好了。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-28_15-46-40.jpg" alt="Snipaste_2020-03-28_15-46-40"></p>
<p><strong>关于“长且胖”的网络和RTT</strong></p>
<blockquote>
<p>The term, long fat network (<strong>LFN</strong>), which are “<strong>long</strong>” in terms of distance and network delay and “<strong>fat</strong>” in terms of link bandwidth.</p>
</blockquote>
<p>“长且胖”网络是从英文：<strong>L</strong>ong <strong>F</strong>at <strong>N</strong>etwork翻译过来的，简称LFN，“Long”表示传输距离，“Fat”表示链路带宽。</p>
<p>RTT表示来回通信延迟（Round-trip delay time），在通信（Communication）、电脑网络（Computer network）领域中，意指：在双方通信中，发讯方的信号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传消息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将信号传播到收讯方的时间一样久）</p>
<p><strong>关于 “ 带宽 * 延迟 ” 的公式</strong></p>
<p>在文章中，一共有两个“ 带宽 * 延迟 ” ，一开始是由带宽乘以单向通信延迟，后面是由带宽乘以来回通信延迟（RTT）。</p>
<p>前面的带宽乘以单向通信延迟，是为说明65535作为window size 过小，已经影响了TCP传输效率。这里可以把主机A和主机B的通信想象成两台主机通过一根管子（网络）连接，我们要计算它的体积，通过其“宽度”（它的带宽，这更像它的横截面积，以比特每秒为单位）乘以“长度”（单向延迟，以秒为单位），得出来的值<strong>等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。</strong>因为这个计算出来的值是100,000 bytes，远远大于65,535 bytes这个window size的值，没有最大限度的利用网络带宽，最理想的状态是当A发送第1个字节到达B的时候，A刚好停止发送数据，等待ACK，所以后面要加入window scale这个参数把window size扩大到32位、4294967296，更好的利用网络。</p>
<p>后面由带宽乘以来回通信延迟（RTT）这个公式，就是带宽时延乘积（英语：bandwidth-delay product，简写为BDP；或称带宽延时乘积、带宽延时积等），网络速率越高、延迟越大的情况下，计算出来的BDP越大，在这种情况下，TCP的性能难以发挥。</p>
<p>滑动窗口的工作机制演示：</p>
<p><img src="/2019/11/23/6-tcp-ip/gifhome_448x336_13s.gif" alt="gifhome_448x336_13s"></p>
<h5 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h5><blockquote>
<p>When the TCP transmits a segment containing data, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue. If the acknowledgment is not received before the timer runs out, the segment is retransmitted.</p>
</blockquote>
<p>当TCP传输包含数据的段时，它将该数据段的副本放在重传队列上并启动计时器。如果在计时器计时结束之前，收到该数据的ACK，则将该数据段的副本从重传队列中删除，然后继续移动窗口，发送接下来的TCP片段。 如果在计时器用尽之前未收到确认，则重新发送该段。这个计时等待的时间叫做重新发送超时时间(<strong>RTO</strong>, retransmission timeout)。</p>
<p>注意，如果是发送端的数据到达了接收端，但接收端的ACK包没到发送端的情况下，也还是会重传数据。</p>
<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。此外，数据也不会被无限、反复地重发。<strong>达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></p>
<p>除了上面的RTO，还有一个名词叫RTT，<strong>RTT</strong>，Round-trip delay time，来回通信延迟，就是在双方通信中，发讯方的信号传播到收讯方的时间，加上收讯方回传消息到发讯方的时间，要注意两者的区别。</p>
<p>需要注意的是，网络是一直波动的, RTT 是一直变化的, RTO 的值基于上次 RTT 往返时间动态计算出来的而不是一成不变的。</p>
<p><img src="/2019/11/23/6-tcp-ip/RTT.png" alt="RTT"></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP-RTO-Retransmission-Timeout-Diagram.jpg" alt="TCP-RTO-Retransmission-Timeout-Diagram"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-10_15-38-54.jpg" alt="Snipaste_2020-02-10_15-38-54"></p>
<p>例如上图中，client没收到server发送的segment2 ，所以会一直发送ACK2用来请求seq为2的数据，请注意，这里client收到了其他的比如segment 5，但client是不会发送ACK6的，因为它没收到seq2的数据，并且TCP ACK 的语义是<strong>当前数据段前的全部数据段都已经被接收和处理</strong>，所以接收方无法发送 ACK 消息，由于发送方没有收到 ACK，<strong>所有数据段</strong>对应的计时器就会超时并重新传输数据。</p>
<p>server一直收到ACK=2的数据，说明client只确认收到了seq=1的数据，所以在计时完成（RTO），认为client没收到数据以后，server从seq=2的数据重新开始发送。</p>
<h5 id="TCP的慢启动"><a href="#TCP的慢启动" class="headerlink" title="TCP的慢启动"></a>TCP的慢启动</h5><p>定义和作用：</p>
<blockquote>
<p>TCP slow start is an algorithm which balances the speed of a network connection. Slow start gradually increases the amount of data transmitted until it finds the network’s maximum carrying capacity.</p>
</blockquote>
<p>TCP慢启动是一种用来平衡网络连接速度的算法，慢启动渐渐增加传输的数量直到发现网络最大负载能力为止。</p>
<blockquote>
<p>Slow start prevents a network from becoming congested by regulating the amount of data that’s sent over it. It negotiates the connection between a sender and receiver by defining the amount of data that can be transmitted with each packet, and slowly increases the amount of data until the network’s capacity is reached. This ensures that as much data is transmitted as possible without clogging the network.</p>
</blockquote>
<p>慢速启动可以通过调节网络上发送的数据量来防止网络拥塞。 它通过定义每个数据包可以传输的数据量来协商发送方和接收方之间的连接，并缓慢增加数据量，直到达到网络容量为止。 这样可以确保在不阻塞网络的情况下传输尽可能多的数据。</p>
<p>工作机制：</p>
<p><strong>慢启动</strong>（Slow-start）是用于结合其他阶段算法，来避免发送过多数据到网络中而导致网络拥塞，算法在<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc5681">5681</a>中定义。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>慢启动初始启动时设置拥塞窗口值（cwnd）为1、2、4或10个MSS。拥塞窗口在每接收到一个ACK时增加，每个RTT（<strong>RTT</strong>，Round-trip delay time，来回通信延迟，就是在双方通信中，发讯方的信号传播到收讯方的时间，加上收讯方回传消息到发讯方的时间）内成倍增加，当然实际上并不完全是指数增长，因为接收方会延迟发送确认，通常是每接收两个分段则发送一次确认包。发送速率随着慢启动的进行而增加，直到遇到出现丢失、达到慢启动阈值（ssthresh）、或者接收方的接收窗口进行限制。如果数据发生丢失（发送端发现有个ACK一直没来，一直重传然后超过重传次数的threshold，就认为丢包了），则TCP推断网络出现了拥塞，会试图采取措施来降低网络负载。这些是靠具体使用的TCP拥塞算法来进行测量判断。当达到慢启动阈值（ssthresh）时，慢启动算法就会转换为线性增长的阶段，算法控制每个RTT内拥塞窗口只增加1个分段量。虽然称为“慢启动”，但实际上比拥塞控制阶段的窗口增加更为激进。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_16-01-52.jpg" alt="Snipaste_2020-01-31_16-01-52"></p>
<p>关于CWND、slow start与congestion avoidance 之间的切换</p>
<p><a href="https://packetlife.net/blog/2011/jul/5/tcp-slow-start/">TCP Slow Start</a></p>
<p><a href="https://packetbomb.com/understanding-throughput-and-tcp-windows/">Understanding Throughput and TCP Windows</a></p>
<p><a href="https://indigoo.com/petersblog/?p=215">SCTP Congestion Control</a></p>
<p><img src="/2019/11/23/6-tcp-ip/ss-ca.png" alt="ss-ca"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-24_17-01-25.jpg" alt="Snipaste_2020-02-24_17-01-25"></p>
<p><img src="/2019/11/23/6-tcp-ip/cwnd-rwnd.png" alt="cwnd-rwnd"></p>
<h5 id="TCP拥塞的出现"><a href="#TCP拥塞的出现" class="headerlink" title="TCP拥塞的出现"></a>TCP拥塞的出现</h5><p>当接口必须传输超出其处理能力的更多数据时，就会发生拥塞。传统的体现是当它的队列将达到限制，尾部的帧会被丢掉，也就是把缓存之外收到的数据丢弃掉，表示我的缓存已经满了，没法处理再多的数据了。当然这么做肯定有很多弊端，所以出现了拥塞避免机制，具体的见下文。</p>
<h5 id="TCP拥塞避免"><a href="#TCP拥塞避免" class="headerlink" title="TCP拥塞避免"></a>TCP拥塞避免</h5><p>传统的做法是，如果接收方的缓存满了，就把尾部的帧丢弃，也就是丢弃了缓存外的数据，用来表示我的缓存已经满了，没法处理再多的数据了。发送方通过接收方的ACK发现，发送给对方1000个数据，可能只确认了200个，而且window size字段数字很小，说明接收方缓存已经满了，我得少发数据，因为发送了也处理不过来，等不拥塞了再多发数据。因为网络上用TCP的肯定不止一个程序，众多用TCP的程序发现拥塞以后是这么一个“传输——拥塞——丢尾部帧——等待不拥塞——传输”，大家同时这么干，这个过程就是TCP的全局同步（<a href="https://en.wikipedia.org/wiki/TCP_global_synchronization">TCP global synchronization</a>），这样对网络利用效率就很低，因为大家一股脑的在同一时间传输，再一起等待不拥塞，如果这时候再有UDP这种不管是否拥塞都传输的，就会造成TCP饥饿（tcp starvation），所以有了RED ( <strong>Random early detection</strong> ) 这个技术，大概就是说不丢尾部帧了，而是随机丢一些队列里的帧（这个随机是基于队列中的数据包数量和数据包的TOS标记），<strong>因为丢的不是同一时刻的数据包，所以不会造成TCP上面那些同步的情况，</strong>因为造成TCP全局同步需要在同一时间传输，同一时间等待，而因为RED的丢包是随机丢的，并不是同一时刻的包，所以不会造成TCP全局同步。但问题是还是需要丢包，会某些应用造成性能损伤，因为TCP的重传和慢启动机制，这时候ECN就横空出世，大概过程是一开始通过ECN字段为ECT（0），也就是这两位置10，来协商ECN这个字段，两边都支持协商好以后，当队列快要满的时候，网络设备给数据包mark CE bit（ECN=11），然后接收端看到数据包ECN=11 就知道路上有拥塞了，然后下一个TCP返回的报文就TCP  flag ECE（ecn echo）=1，告诉发送端：我这检测到拥塞了，你慢点发，然后发送端收到这个TCP包之后，看到ECE=1，就调小发送速率，并且CWR=1，相当于ECE的确认。<strong>具体实现过程请参照后面IP报头部分的“服务类型”章节。</strong>为了改善RED的这个问题，衍生出来了其他的RED，比如最常用的WRED，是给数据设置优先级，每个优先级丢包的概率不同，优先级低的数据被丢的概率高，优先级高的数据被丢的概率低；除了最常用的WRED还有ARED，RRED等其他方式，就不展开说了，因为使用率不高我也没看，不会说什么，囧~</p>
<p>TCP全局同步的示意图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-29_15-59-48.jpg" alt="Snipaste_2020-02-29_15-59-48"></p>
<p>加入RED之后的TCP拥塞避免示意图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-29_17-20-26.jpg" alt="Snipaste_2020-02-29_17-20-26"></p>
<h5 id="TCP快速重传（Fast-Retransmit-Fast-Recovery）"><a href="#TCP快速重传（Fast-Retransmit-Fast-Recovery）" class="headerlink" title="TCP快速重传（Fast Retransmit/Fast Recovery）"></a>TCP快速重传（Fast Retransmit/Fast Recovery）</h5><blockquote>
<p>The TCP sender SHOULD use the “fast retransmit” algorithm to detect and repair loss, based on incoming duplicate ACKs.  The fastretransmit algorithm uses the arrival of 3 duplicate ACKs (4 identical ACKs without the arrival of any other intervening packets) as an indication that a segment has been lost.  After receiving 3duplicate ACKs, TCP performs a retransmission of what appears to be the missing segment, without waiting for the retransmission timer toexpire.</p>
</blockquote>
<p>TCP的发送方应该基于收到的重复ACK数据，利用快速重传算法检测并修复丢失的数据。快速重传算法使用3个重复ACK数据的到来（也就是4个相同且中间没有其他数据ACK干预的ACK，为什么这里是4个相同的ACK，而前面是3个重复的ACK呢，是因为第一个ACK不是重复的，后面3个一样的才是重复的）作为丢包的标志。收到3个重复的ACK包后，TCP不用等待重传计时器超时，立刻对丢失的数据段进行重传。</p>
<blockquote>
<p>After the fast retransmit algorithm sends what appears to be the missing segment, the “fast recovery” algorithm governs the transmission of new data until a non-duplicate ACK arrives.  The reason for not performing slow start is that the receipt of the duplicate ACKs not only indicates that a segment has been lost, but also that segments are most likely leaving the network (although a massive segment duplication by the network can invalidate this conclusion).  In other words, since the receiver can only generate a duplicate ACK when a segment has arrived, that segment has left the network and is in the receiver’s buffer, so we know it is no longer consuming network resources.  Furthermore, since the ACK “clock” is preserved, the TCP sender can continue to transmit new segments (although transmission must continue using a reduced cwnd)</p>
</blockquote>
<p>当快速重传算法发送了看似丢失的数据段后，“快速恢复”算法控制着新数据的传输，直到收到不重复的ACK为止。之所以不用慢启动是因为在这种情况下，重复的ACK不仅代表着数据段丢失，而且同时代表着这些数据段很可能离开了网络（尽管网络进行的大量段复制可能会使此结论无效），换句话说，因为接收方只能在数据段到达时产生重复的ACK，那个数据段已经不在网络上传输而是在接收方的缓存中了，所以并不消耗网络资源。此外，由于ACK的“时钟”被保留，所以TCP的发送方可以持续发送新的数据段（尽管网络必须使用缩小的CWND来传输）。</p>
<p>RFC中还有一个快速重传的步骤，因为快速重传已经被SACK（Selective Acknowledgments）所取代（The algorithm outlined in this document, heavily based on the algorithm detailed in [FF96], is aconservative replacement of the fast recovery algorithm –rfc3517），所以在这就不摘录翻译剩下的部分了。</p>
<h5 id="TCP-SACK"><a href="#TCP-SACK" class="headerlink" title="TCP SACK"></a><a href="https://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/">TCP SACK</a></h5><p>在TCP传输过程中，没有快速重传的情况下，如果一个传输数据被分成5个数据段发送，当其中一个数据段丢失时，假设数据段2丢失了其他数据段都收到了，接收者会发送一个ACK=2的数据告诉发送端，我只收到了数据段1，但无法告诉发送端我收到了数据段3-5，并且接收端也不能发送一个ACK=6或者其他不是2的数据，因为如果发送了ACK=6表示希望发送端下发送Sequence=6的数据，ACK表示的是希望下一个收到的报文段的序列号，接收端并没有收到数据段2所以不能发送除了ACK=2的其他的ACK信息，但此时接收端只需要数据段2就行了，其他的数据段重新传输完全是浪费网络资源并降低传输效率，所以SACK（Selective Acknowledgment）出现了，SACK可以告诉发送端哪些数据段我收到了，哪些我没有收到。SACK的能力也需要两端在TCP建立连接时进行协商，在两边都支持的情况下才能使用。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-22_16-21-38.jpg" alt="Snipaste_2020-04-22_16-21-38"></p>
<p><strong>理论步骤分析：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP_SACK.png" alt="TCP_SACK"></p>
<blockquote>
<p>Step 1</p>
<p>Response segment #2 is lost.</p>
<p>Step 2</p>
<p>The client realizes it is missing a segment between segments #1 and #3. It sends a duplicate acknowledgment for segment #1, and attaches a SACK option indicating that it has received segment #3.</p>
<p>Step 3</p>
<p>The client receives segment #4 and sends another duplicate acknowledgment for segment #1, but this time expands the SACK option to show that it has received segments #3 through #4.</p>
<p>Step 4</p>
<p>The server receives the client’s duplicate ACK for segment #1 and SACK for segment #3 (both in the same TCP packet). From this, the server deduces that the client is missing segment #2, so segment #2 is retransmitted. The next SACK received by the server indicates that the client has also received segment #4 successfully, so no more segments need to be transmitted.</p>
<p>Step 5</p>
<p>The client receives segment #2 and sends an acknowledgment to indicate that it has received all data up to an including segment #4.</p>
</blockquote>
<p>步骤1：服务器发往接收端的Segment 2丢失。</p>
<p>步骤2：服务器继续发送数据段3被接收端成功接收。接收端通过查看序列号发现，数据段1和3之间丢失了数据段2，接收端发送重复ACK去确认Sequence=1的数据段成功收到并且在opinion中附加了SACK字段表示它收到了数据段3。</p>
<p>步骤3：接收端收到了服务器发送来的数据段4，并且接收端又发送了一个ACK确认数据段1成功接收，但这次扩展的opinion选项字段中的信息表示接收端收到了数据段3和4。</p>
<p>步骤4：服务器端收到了接收端发送的确认数据段1收到重复ACK，这个数据中的SACK字段还表明接收端除了收到数据段1以外还收到了数据段3。至此，服务器端已经可以推测出来接收端并未受到数据段2，因此重新发送数据段2。接收到后一个SACK后发现接收端也收到了数据段4，因此没有其他需要重新传送的数据段了。</p>
<p>步骤5：接收端收到了重新发送的数据段2并且发送了确认收到数据段1-4的ACK信息。</p>
<p><strong>抓包分析：</strong></p>
<p><a href="/download/TCP_SACK.cap"> 点击下载抓包文件 </a></p>
<p>TCP在三次握手的前两个数据交互的时候就已经决定了这个TCP连接是否支持SACK属性，SACK在opinion字段中。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-22_16-21-38-1587612395091.jpg" alt="Snipaste_2020-04-22_16-21-38"></p>
<p>从第28个抓包中我们可以看到，这个ACK期待的下一个收到的序列号是17737：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-48-43.jpg" alt="Snipaste_2020-04-23_11-48-43"></p>
<p>从第三十个抓包中我们可以看到，这个数据包是乱序的，因为前面收到的ACK表明下一个期待的数据序列号应为17377，而第三十个抓包中的序列号是18825，和之前ACK期待的不一样，所以是个乱序包。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-53-18.jpg" alt="Snipaste_2020-04-23_11-53-18"></p>
<p>当收到乱序包以后，接收端用抓包31发送了重复的ACK，这个包中的opinion字段中有SACK部分，用来告诉发送端数据包30我收到了。当然这个SACK字段不可能简单的标明哪个数据段我收到了，而是标识出那些在数据包的确认号之外的数据的左右两边。从ACK17377到left edge18825之间的是没收到的，只传序列号17377-18825之间的数据段即可，而left edge18825到right edge20273这部分也是收到的，不用重新进行传递。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-57-12.jpg" alt="Snipaste_2020-04-23_11-57-12"></p>
<p>除了抓包31这个ACK以外，在抓包33、35、37也发送了同样的重复ACK，duplicate ACK，告诉发送端序列号17377-18825我没收到，于是发送端在抓包38的时候重新发送了序列号17377-18825的这些数据：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_14-23-29.jpg" alt="Snipaste_2020-04-23_14-23-29"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_14-22-27.jpg" alt="Snipaste_2020-04-23_14-22-27"></p>
<p>如果在TCP传输过程中，丢了好几个包，比如收到了序列号为0-500，900-1100和1300-2000的数据段，这时候SACK能否告诉发送端中间丢了好几段数据呢？当然可以，中间可以分几段来表示丢失的不同部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  +--------+--------+</span><br><span class="line">                  | Kind=5 | Length |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Left Edge of 1st Block       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Right Edge of 1st Block      |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                                   |</span><br><span class="line">/            . . .                  /</span><br><span class="line">|                                   |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Left Edge of nth Block       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Right Edge of nth Block      |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP ACK - 501 (in TCP header, not in SACK Option)</span><br><span class="line">TCP SACK - 1st block Left Edge  - 900</span><br><span class="line">TCP SACK - 1st block Right Edge - 1100</span><br><span class="line">TCP SACK - 2nd block Left Edge  - 1300</span><br><span class="line">TCP SACK - 2nd block Right Edge - 2000</span><br></pre></td></tr></table></figure>

<h5 id="TCP协议存在的问题及解决"><a href="#TCP协议存在的问题及解决" class="headerlink" title="TCP协议存在的问题及解决"></a>TCP协议存在的问题及解决</h5><p><strong>TCP性能上存在的问题：</strong></p>
<p>TCP 选择了充分利用带宽，为流量而设计，期望在尽可能短的时间内传输更多的数据，但这种设计会存在一些负面因素，例如TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖；例如TCP丢包时会全部重传从丢的那个包开始以后的数据；例如TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程；弱网环境是丢包率较高的特殊场景，TCP 在类似场景中的表现很差，当 RTT 为 30ms 时，一旦丢包率达到了 2%，TCP 的吞吐量就会下降 89.9%7，从下面的表中我们可以看出丢包对 TCP 的吞吐量极其显著的影响：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-20_16-13-53.jpg" alt="Snipaste_2020-04-20_16-13-53"></p>
<p>影响TCP性能的三个原因：</p>
<ul>
<li>TCP 的拥塞控制算法会在丢包时主动降低吞吐量；</li>
<li>TCP 的三次握手增加了数据传输的延迟和额外开销；</li>
<li>TCP 的累计应答机制导致了数据段的传输；</li>
</ul>
<p>上边的这三个原因中，<strong>拥塞控制算法是导致 TCP 在弱网环境下有着较差表现的首要原因</strong>，三次握手和累计应答两者的影响依次递减，但是也加剧了 TCP 的性能问题。</p>
<p><strong>目前解决的方法：</strong></p>
<ol>
<li>使用 UDP 构建性能更加优异、更灵活的传输协议，例如：QUIC 等；</li>
<li>通过不同的手段优化 TCP 协议的性能，例如：选择性 ACK（Selective ACK, SACK），TCP 快开启（TCP Fast Open, TFO）</li>
</ol>
<p>既然TCP的拥塞算法是导致网络表现较差的首要原因，我们就需要改进这个算法，其中一种算法就是基于不丢包的拥塞算法，CDG（CAIA-Delay Gradient），该算法以 <strong>延迟</strong> 作为判断依据，延迟增大说明拥塞, 数据开始在路由器的缓冲中积累. 降低发送 <strong>窗口</strong>。然而 CDG 算法与基于丢包的算法不兼容, 只有全球的设备都换上 CDG，但这是不可能的，目前市面上的设备不可能一下子都切换到 CDG，因此 Google 就不开心了，Google 的科学家们开发了一种过渡算法来解决这个问题，这个算法的名字就是 <code>BBR（Bottleneck Bandwidth and RTT）</code>，它是一种全新的 <strong>拥塞控制算法</strong>，BBR 同 CDG 一致的思想是不以丢包作为拥塞控制信号，但是和 CDG 不同的是，BBR 能和 cubic 和 reno 共存。</p>
<p>BBR 由 Google 开发，供 Linux 内核的 TCP 协议栈使用，有了 BBR 算法，Linux 服务器可以显著提高吞吐量并减少连接延迟，简单来说 BBR 能加速网络传输速度。此外，部署 BBR 也很容易，因为该算法只需要发送方，而不需要网络或接收方的支持。</p>
<p><img src="/2019/11/23/6-tcp-ip/165a3f47af98be83.gif" alt="165a3f47af98be83"></p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><img src="/2019/11/23/6-tcp-ip/unnamed.png" alt="unnamed"></p>
<p><img src="/2019/11/23/6-tcp-ip/wireshark5-1.png" alt="wireshark5-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/con_026a.gif" alt="con_026a"></p>
<h5 id="UDP的特点："><a href="#UDP的特点：" class="headerlink" title="UDP的特点："></a>UDP的特点：</h5><p>UDP是一种无连接的、不可靠的、面向报文、没有拥塞控制的协议。</p>
<p><strong>无连接的</strong>：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。</p>
<p><strong>不可靠的</strong>：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，即使到达不了也不会像TCP那样重传，因为UDP报头很精简，不像TCP报头中有序列号、确认号以及重传机制，能知道哪些数据发送到哪些没法送到，也不会重传那些没发送到的数据，所以很可能会出现丢包现象，使传输的数据出错。</p>
<p><strong>面向报文</strong>：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。</p>
<p><strong>没有拥塞控制</strong>：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。</p>
<h5 id="UDP的应用场景："><a href="#UDP的应用场景：" class="headerlink" title="UDP的应用场景："></a>UDP的应用场景：</h5><p>UDP通常用于对时间敏感的通信，在这种情况下，偶尔丢弃数据包比等待数据流更好。 语音和视频流量使用此协议发送，因为它们既对时间敏感，又被设计成可处理一定程度的丢失。 例如，许多基于Internet的电话服务使用的VOIP（基于IP的语音）通过UDP运行，在线游戏也通常使用UDP。 同样，由于DNS和NTP服务器都需要快速高效，因此它们通过UDP运行。</p>
<h5 id="UDP报头"><a href="#UDP报头" class="headerlink" title="UDP报头"></a>UDP报头</h5><p><img src="/2019/11/23/6-tcp-ip/th.jpg" alt="th"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_20-44-36.jpg" alt="Snipaste_2020-02-18_20-44-36"></p>
<p>（1）源端口：源端口长度为16位，用于标识源端口号，在需要对方回信时选用，不需要时可全用0。</p>
<p>（2）目的端口：目的端口号长度为16位，用于标识目的地数据包的端口。</p>
<p>（3）长度：UDP用户数据报的长度，其最小值是8（仅有首部）。</p>
<p>（4）校验和：校验UDP用户数据报在传输中是否有错，有错就丢弃。</p>
<h5 id="UDP常见协议："><a href="#UDP常见协议：" class="headerlink" title="UDP常见协议："></a>UDP常见协议：</h5><p>Multimedia applications, DNS, BOOTP, DHCP, TFTP, SNMP, RIP</p>
<h4 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h4><p>TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。例如浏览网页的HTTP服务</p>
<p>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。我们举一个通过IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-25_17-17-29.jpg" alt="Snipaste_2020-02-25_17-17-29"></p>
<h3 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h3><h4 id="网络层总览"><a href="#网络层总览" class="headerlink" title="网络层总览"></a>网络层总览</h4><p>TCP/IP的心脏是互联网层。这一层主要由IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等协议组成。IP协议是一个面向无连接的协议，也就是在发送数据包之前不需要与目标地址之间建立连接，上层如果到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</p>
<h5 id="为什么IP是无连接协议"><a href="#为什么IP是无连接协议" class="headerlink" title="为什么IP是无连接协议"></a>为什么IP是无连接协议</h5><p>主要有两点原因：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层（比如TCP）提供此项服务。因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>
<h5 id="如何提高可靠性"><a href="#如何提高可靠性" class="headerlink" title="如何提高可靠性"></a>如何提高可靠性</h5><p>IP提供尽力服务（Best Effort），意指“为了把数据包发送到最终目标地址，尽最大努力。”然而，它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。如果发送端的数据未能真正发送到对端目标主机会造成严重的问题。例如，发送一封电子邮件，如果邮件内容中很重要的一部分丢失，会让收件方无法及时获取信息。</p>
<p>因此提高通信的可靠性很重要。<strong>TCP就提供这种功能。</strong>如果说IP只负责将数据发给目标主机，那么TCP则负责保证对端主机确实接收到数据。</p>
<p>那么，有人可能会提出疑问：为什么不让IP具有可靠传输的功能，从而把这两种协议合并到一起呢？</p>
<p>这其中的缘由就在于，<strong>如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。</strong>相比之下，按照网络分层，<strong>明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。</strong></p>
<p>网络通信中如果能进行有效分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。互联网能够发展到今天，与网络通信的分层密不可分。</p>
<h4 id="IPv4议报头"><a href="#IPv4议报头" class="headerlink" title="IPv4议报头"></a>IPv4议报头</h4><img src="/2019/11/23/6-tcp-ip/ip-v4-datagram-header.png" alt="ip-v4-datagram-header" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-05-12.jpg" alt="Snipaste_2020-01-08_17-05-12"></p>
<p><img src="/2019/11/23/6-tcp-ip/IP%20packet.png" alt="IP packet"></p>
<p><img src="/2019/11/23/6-tcp-ip/2-slide2.jpg" alt="2-slide2"></p>
<h5 id="版本号（Version）："><a href="#版本号（Version）：" class="headerlink" title="版本号（Version）："></a>版本号（Version）：</h5><p>长度4比特。标识目前采用的IP协议的版本号。一般的值为0100（IPv4），IPv6的值（0110），除此之外的版本号现网中已经几乎绝迹了。</p>
<p>如果不知道为什么0100对应IPV4，0110对应IPV6，请看<a href="https://renyuan431.github.io/2019/11/18/basic-knowledge/">4、基础知识</a>中关于2进制转换的部分，这里简单的说一下计算方法。</p>
<p>二进制转换成十进制的方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p><strong>2进制的0100换算成10进制就是4，代表IPV4</strong></p>
<p>1. 第0位 0 x 2^0 = 0；</p>
<p>2. 第1位 0 x 2^1 = 0；</p>
<p>3. 第2位 1 x 2^2 = 4；</p>
<p>4. 第3位 0 x 2^3 = 0；</p>
<p>所以2进制的0100换算成10进制是：0+0+4+0=4</p>
<p><strong>2进制的0110换算成10进制就是6，代表IPV6。</strong></p>
<p>1. 第0位 0 x 2^0 = 0；</p>
<p>2. 第1位 1 x 2^1 = 2；</p>
<p>3. 第2位 1 x 2^2 = 4；</p>
<p>4. 第3位 0 x 2^3 = 0；</p>
<p>所以2进制的0110换算成10进制是：0+2+4+0=6</p>
<h5 id="IP包头长度（Header-Length）："><a href="#IP包头长度（Header-Length）：" class="headerlink" title="IP包头长度（Header Length）："></a>IP包头长度（Header Length）：</h5><p>长度4比特。这个字段的作用是为了描述IP包头的长度，因为在IP包头中有变长的可选部分。IP包头最小长度为20字节，由于变长的可选部分最大长度可能会变成60字节。</p>
<h5 id="服务类型（Type-of-Service、TOS）："><a href="#服务类型（Type-of-Service、TOS）：" class="headerlink" title="服务类型（Type of Service、TOS）："></a>服务类型（Type of Service、TOS）：</h5><p>长度8比特，通知沿途路由器包含在数据报中的数据的重要性，从而设置数据报的优先级，只有当<strong>网络设备能够支持</strong>（能够识别IP首部中的ToS字段）识别ToS字段时，这给字段设置才有意义。否则都是空谈。这个字段虽然在TCP\IP协议栈中被定义了，但一直以来基本没怎么使用过，在近些年被重新定义为<strong>Differentiated Services</strong>，这个字段又被划分为两部分，DSCP（differentiated services codepoint）和ECN（Explicit Congestion Notification）。</p>
<p><img src="/2019/11/23/6-tcp-ip/differentiated%20services-1578811260461.jpg" alt="differentiated services"></p>
<blockquote>
<p>Differentiated services or DiffServ is a computer networking architecture that specifies a simple and scalable mechanism for classifying and managing network traffic and providing quality of service (QoS) on modern IP networks. DiffServ can, for example, be used to provide low-latency to critical network traffic such as voice or streaming media while providing simple best-effort service to non-critical services such as web traffic or file transfers.</p>
<p>DiffServ uses a 6-bit differentiated services code point (DSCP) in the 8-bit differentiated services field (DS field) in the IP header for packet classification purposes. The DS field replaces the outdated IPv4 TOS field.</p>
<p>Explicit Congestion Notification (ECN), is used by some routers to signal support for Explicit Congestion Notification and, when it is supported, the bits can be used to signal congestion (ECN = 11)</p>
</blockquote>
<p>区分服务或DiffServ是一种计算机网络体系结构，它指定了一种简单且可扩展的机制，用于对网络流量进行分类和管理，并在现代IP网络上提供服务质量（QoS）。 例如，DiffServ可用于为关键网络流量（例如语音或流媒体）提供低延迟，同时为非关键服务（例如Web流量或文件传输）提供简单的尽力而为服务。</p>
<blockquote>
<p>The definition of ToS was changed entirely in RFC 2474, and it is now called Differentiated Service (DS). On the eight fields, the upper six bit contain value called Differentiated Services Code Point (DSCP). The last two bits are used for Explicit Congestion Notification and it is defined in RFC 3168.</p>
</blockquote>
<p>ToS的定义在RFC 2474中完全更改，现在称为差异化服务（DS）。 在8个字段上，高6位包含称为差分服务代码点（DSCP）的值。 后两位用于显式拥塞通知，它在RFC 3168中定义。区分服务代码点（DSCP）是一种分类和管理网络流量并在现代第3层IP网络中提供服务质量（QoS）的方法。</p>
<p>DiffServ使用了IP报头里8位差异服务字段（DS字段）中的6位差异服务代码点（DSCP）进行数据包分类。DS字段替换了过时的IPv4 TOS字段。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-09_13-12-48.jpg" alt="Snipaste_2020-02-09_13-12-48"></p>
<p>一些路由器使用显式拥塞通知（ECN）来表示对显式拥塞通知的支持，这是一个2个比特的字段，置00时，表示设备不支持ECN字段，当两边都置为ECT的时候，表示两端设备均支持ECN字段，可以协商这个能力。ECT（1）和ECT（0）均表示支持这个能力，但一般用ECT（0）。置位为11（CE）的时候，表示网络中出现拥塞。</p>
<p>一开始是没有ECN这个字段的，传统的做法是，如果接收方的缓存满了，就把尾部的帧丢弃，也就是丢弃了缓存外的数据，用来表示我的缓存已经满了，没法处理再多的数据了。发送方通过接收方的ACK发现，发送给对方1000个数据，可能只确认了200个，而且window size字段数字很小，说明接收方缓存已经满了，我得少发数据，因为发送了也处理不过来，等不拥塞了再多发数据。因为网络上用TCP的肯定不止一个程序，众多用TCP的程序发现拥塞以后是这么一个“传输——拥塞——丢尾部帧——等待不拥塞——传输”，大家同时这么干，这个过程就是TCP的全局同步（<a href="https://en.wikipedia.org/wiki/TCP_global_synchronization">TCP global synchronization</a>），这样对网络利用效率就很低，因为大家一股脑的在同一时间传输，再一起等待不拥塞，如果这时候再有UDP这种不管是否拥塞都传输的，就会造成TCP饥饿（tcp starvation），所以有了RED ( <strong>Random early detection</strong> ) 这个技术，大概就是说不丢尾部帧了，而是随机丢一些队列里的帧，<strong>因为丢的不是同一时刻的数据包，所以不会造成TCP上面那些同步的情况，</strong>因为造成TCP全局同步需要在同一时间传输，同一时间等待，而因为RED的丢包是随机丢的，并不是同一时刻的包，所以不会造成TCP全局同步。但问题是还是需要丢包，会某些应用造成性能损伤，因为TCP的重传和慢启动机制，这时候ECN就横空出世，大概过程是一开始通过ECN字段为ECT（0），也就是这两位置10，来协商ECN这个字段，两边都支持协商好以后，当队列快要满的时候，网络设备给数据包mark CE bit（ECN=11），然后接收端看到数据包ECN=11 就知道路上有拥塞了，然后下一个TCP返回的报文就TCP  flag ECE（ecn echo）=1，告诉发送端：我这检测到拥塞了，你慢点发，然后发送端收到这个TCP包之后，看到ECE=1，就调小发送速率，并且CWR=1，相当于ECE的确认。更具体的协商工作机制如下：</p>
<p>TCP initiation and process for ECN：</p>
<ol>
<li>Host A sends a SYNC packet with ECE and CWR set in TCP options field. ECN bit set to 00 in IP header.</li>
<li>Host B responds with a SYNC+ACK packet with ECE set in TCP options field. ECN bit set to 00 in IP header.</li>
<li>After TCP establishes with ECN capable, data start to be transmitted with ECT set(ECN=01/10,same meaning) </li>
<li>The middle device must enable support ECN on respective queue to enable ECN feature.</li>
<li>If a middle device detects that the WRED drop probability is greater than 0 in a ECN enabled queue, which means congestion experiencing in this queue. Device will remark the packet with CE(Congestion Experienced, ECN=II), and downstream device must remain it unchanged.</li>
<li>The receiver gets a packet with CE set, it responds in next ACK with ECE flag set in TCP header</li>
<li>When sender gets the ACK packet with ECE flag set, it reduces the sending rate and reply with CWR flag set in next packet to ack the ECE set packet.</li>
<li>When the receiver receives the CWR flag, the receiver stops setting the ECE bit in replies to the sender.</li>
</ol>
<p>TCP 三次握手时ECN的过程：</p>
<p>1、主机A在TCP三次握手发送第一次SYN时，除了将SYN位置1以外，还将TCP报头里的控制位中的ECE和CWR两个位也置为1；将IP报头中的ECN位设置为00：</p>
<img src="/2019/11/23/6-tcp-ip/%E4%B8%8B%E8%BD%BD.png" alt="下载" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200212184752.jpg" alt="微信图片编辑_20200212184752"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200212185545.jpg" alt="微信图片编辑_20200212185545"></p>
<p>2、主机B发送数据相应主机A的TCP三次握手，将TCP报头中控制位里的SYN和ACK两位置为1，将IP报头中ECN两位也置为00。<br>3、当TCP建立完具有ECN能力的连接后，所传输的数据的IP报头中的ECN位将设置为01或10（表示的含义一样），这两个ECT置为本质上是在IP数据包中的ECN field中放置了一个随机数（<strong>The use of two ECT codepoints essentially gives a one-bit ECN noncein packet headers, and routers necessarily “erase” the nonce whenthey set the CE codepoint</strong>）。<br>4、主机AB之间的中间网络设备，必须在相应的队列上启用支持ECN才能启用ECN功能。<br>5、如果中间设备在启用ECN的队列中检测到WRED丢弃概率大于0，则表示此队列中出现拥塞。 设备将使用CE（表示经历拥塞，ECN = 11）标记该数据包，下游设备必须保持其不变。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200328154414.png" alt="微信图片_20200328154414"></p>
<p>6.接收方获得一个带有CE设置的数据包，它在下一个ACK中响应，并在TCP报头中设置了ECE标志<br>7.当发送方收到设置了ECE标志的ACK数据包时，它将降低发送速率并在下一个数据包中设置CWR标志进行答复，以确认ECE设置数据包。<br>8.当接收方收到CWR标志时，接收方停止设置ECE位，以回复发送方。</p>
<p><strong>关于ECT的说明：</strong></p>
<blockquote>
<p>The use of two ECT codepoints essentially gives a one-bit ECN noncein packet headers, and routers necessarily “erase” the nonce whenthey set the CE codepoint [SCWA99].  For example, routers that erasedthe CE codepoint would face additional difficulty in reconstructingthe original nonce, and thus repeated erasure of the CE codepoint would be more likely to be detected by the end-nodes.  The ECN nonce also can address the problem of misbehaving transport receivers lying to the transport sender about whether or not the CE codepoint was setin a packet.</p>
</blockquote>
<p>这两个ECT置为本质上是在IP数据包中的ECN field中放置了一个随机数，当路由器将ECN field置为位CE（也就是置位11的时候），会将ECT置位抹去（其实也就是将ECT的10换为CE的11用来表示有拥塞了）。举例来说，如果路由器将CE字段抹去会面临难以恢复ECT置位中的那个随机数的情况（因为抹掉CE置位的路由器也不知道ECT置位的随机数是多少，它收到的只是个CE置位，所以就没法复原那个随机数，所以后面的路由器就会知道这个数据有问题因为没有ECT的随机数或者随机数有问题和之前的不同。这里说的这个抹去CE&lt;11&gt;的动作其实是错误的，因为CE表示有拥塞，不能简单的把这个抹去而不进行相应的动作），并且重复的抹去CE置位会让后面的路由器更容易发现这个问题。ECN随机数还可以解决不管是否在分组中设置CE码点的情况下，传输层接收者欺骗传输层发送者的问题。我理解是说是加上了ECT以后，因为多了一个随机数，如果上游设备对TCP层进行了擅自改变，能够检测出来。</p>
<h5 id="IP包总长（Total-Length）："><a href="#IP包总长（Total-Length）：" class="headerlink" title="IP包总长（Total Length）："></a>IP包总长（Total Length）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112151420.jpg" alt="微信图片编辑_20200112151420"></p>
<p>长度16比特。总长度是一个16比特字段，以字节为单位指定包的总长度，包括报头。IP包最大长度65535字节。</p>
<h5 id="标识符（Identifier）"><a href="#标识符（Identifier）" class="headerlink" title="标识符（Identifier）:"></a>标识符（Identifier）:</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112151451.jpg" alt="微信图片编辑_20200112151451"></p>
<p>长度16比特。该字段和Flags和Fragment Offest字段联合使用，对大的上层数据包进行分段（fragment）操作。当数据包的大小超过接口的<strong>最大传输单元</strong>（英语：<strong>M</strong>aximum <strong>T</strong>ransmission <strong>U</strong>nit，缩写<strong>MTU</strong>）时，必须将该数据包分割成较小的数据包，然后，路由器在“标识符（Identifier）”字段中用相同的数字标记每个片段，以便接收设备可以识别这些被分割的数据包，并将它们整合到一起。</p>
<h5 id="标记（Flags）："><a href="#标记（Flags）：" class="headerlink" title="标记（Flags）："></a>标记（Flags）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112152850.jpg" alt="微信图片编辑_20200112152850"></p>
<img src="/2019/11/23/6-tcp-ip/img9.png" alt="img9" style="zoom:150%;">

<p>长度3比特。该字段第一位不使用。第二位是DF位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发（例如数据包大小超过MTU但不允许分片），则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF位，当路由器对一个上层数据包分段，会将最后一个分段之外的所有MF位都设置为1，以便接收设备明白要继续等待分段，直到遇到MF = 0的分段为止。假设一个数据包被分为10段，当其中的分段5的数据在传输中丢失的话，整个所有的分段，也就是10个分段的数据都必须要重新传输。这种情况有可能会增加网络拥塞。</p>
<h5 id="分段序号（Fragment-Offset）："><a href="#分段序号（Fragment-Offset）：" class="headerlink" title="分段序号（Fragment Offset）："></a>分段序号（Fragment Offset）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112152954.jpg" alt="微信图片编辑_20200112152954"></p>
<p>长度13比特。该字段对包含分段的上层数据包的IP包赋予序号。由于IP包在网络上传送的时候不一定能按顺序到达，这个字段保证了目标路由器在接收到IP包之后能够按照发送的顺序准确还原分段的上层数据包。</p>
<h5 id="生存时间（Time-to-Live、TTL）："><a href="#生存时间（Time-to-Live、TTL）：" class="headerlink" title="生存时间（Time to Live、TTL）："></a>生存时间（Time to Live、TTL）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153031.jpg" alt="微信图片编辑_20200112153031"></p>
<p>长度8比特。当IP包进行传送时，先会对该字段赋予某个特定的值。当IP包经过每一个沿途的路由器的时候，每 个沿途的路由器会将IP包的TTL值减少1。如果TTL减少为0，则该IP包会被丢弃。这个字段可以防止由于故障而导致IP包在网络中不停被转发。TTL虽然中文翻译成生存时间，但实际来看其实是一个经过多少路由器的跳数计算，一般情况下建议TTL设置成为64，当然更小的TTL值（例如32或15）也能见到。</p>
<h5 id="协议（Protocol）："><a href="#协议（Protocol）：" class="headerlink" title="协议（Protocol）："></a>协议（Protocol）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153100.jpg" alt="微信图片编辑_20200112153100"></p>
<p>长度8比特。IP头中的协议号用来说明IP报文中承载的是哪种协议（一般是传输层协议，比如6 TCP，17 UDP；但也可能是网络层协议，比如1 ICMP；也可能是应用层协议，比如89 OSPF）。</p>
<p>一些知名协议号：</p>
<p><img src="/2019/11/23/6-tcp-ip/wellKnowProto1.JPG" alt="wellKnowProto1"></p>
<h5 id="头部校验和（Header-Checksum）："><a href="#头部校验和（Header-Checksum）：" class="headerlink" title="头部校验和（Header Checksum）："></a>头部校验和（Header Checksum）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153137.jpg" alt="微信图片编辑_20200112153137"></p>
<p>长度16位，由于IP包头是变长的，所以提供一个头部校验值来保证IP包头中信息的正确性。这个校验和不包括所封装数据，因为UDP、TCP和ICMP这些有自己的校验和去检测信息正确与否。该字段包含一个16位的补码校验和，由数据包的初始发送设备计算得出。</p>
<h5 id="起源和目标地址（Source-and-Destination-Addresses）："><a href="#起源和目标地址（Source-and-Destination-Addresses）：" class="headerlink" title="起源和目标地址（Source and Destination Addresses）："></a>起源和目标地址（Source and Destination Addresses）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153206.jpg" alt="微信图片编辑_20200112153206"></p>
<p>这两个地段都是32比特。标识了这个IP包的起源和目标地址。</p>
<h5 id="可选项（Options）："><a href="#可选项（Options）：" class="headerlink" title="可选项（Options）："></a>可选项（Options）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153233.jpg" alt="微信图片编辑_20200112153233"></p>
<p>这是一个可变长的字段。该字段由起源设备根据需要改写。可选项目包含以下内容：<br>松散源路由（Loose source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，但是允许在相继的两个IP地址之间跳过多个路由器。<br>严格源路由（Strict source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，如果下一跳不在IP地址表中则表示发生错误。<br>路由记录（Record route）：当IP包离开每个路由器的时候记录路由器的出站接口的IP地址。<br>时间戳（Timestamps）：当IP包离开每个路由器的时候记录时间。</p>
<p>这几个参数由于有安全方面的问题，所以几乎不再使用。比如互联网上有人截获报文，就可以知道拓扑，截获大量报文，甚至可以推算全网的拓扑、IP以及接口，比较危险。</p>
<p>比如关于Loose Source and Record Route (LSRR)，<a href="https://tools.ietf.org/html/rfc6274#section-3.13.2">RCF6274</a>上3.13.2.3.的描述是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The LSRR option has well-known security implications.  Among other</span><br><span class="line">   things, the option can be used to:</span><br><span class="line"></span><br><span class="line">   o  Bypass firewall rules</span><br><span class="line"></span><br><span class="line">   o  Reach otherwise unreachable Internet systems</span><br><span class="line"></span><br><span class="line">   o  Establish TCP connections in a stealthy way</span><br><span class="line"></span><br><span class="line">   o  Learn about the topology of a network</span><br><span class="line"></span><br><span class="line">   o  Perform bandwidth-exhaustion attacks</span><br></pre></td></tr></table></figure>

<h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><h5 id="定义及格式"><a href="#定义及格式" class="headerlink" title="定义及格式"></a>定义及格式</h5><p>IPv4地址（以下简称IP地址）是为了确切地标识Internet中的主机和路由器，TCP/IP建立了一套编址方案，为每台主机和路由器分配一个全网唯一的地址。这个地址的名字就叫IP地址。（相当于国家为了知道谁是谁为每个人都分配了一个身份证号码一样），IP地址是一个<strong>逻辑地址</strong>，可以规划改变的。和现实中家里或公司的地址类似，现实中的地址绝大多数是唯一的，是为了让使用一个地址的人收到快递，现实中，一个身份证号（一个地址）对应一个人，网络中，一个IP地址对应一个设备或接口；互联网中的IP地址除极个别情况外也是唯一的，是为了让使用一个虚拟IP地址的人收到数据。IP地址的长度为32位，也就是IP报头中的源和目的IP地址所占的空间，也就是2的32位，32个1和0，例如00001011110000100011111101100100，但这个方式只有机器可以明白，因为机器只能识别0101这种二进制的数字，人类很难理解，于是把32位的IP地址分成4组，这样每个IP地址段中数字不太大方便人类记忆，每个八位组都可以用0到255之间的十进制数表示，然后将2进制换算成10进制，也就是点分十进制，比如上面的地址可以写成：00001011.11000010.00111111.01100100，换算成10进制是：11.194.63.100。这个换算的方式只说一下第一段如何换算，其他的以此类推：</p>
<p>00001011：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_11-18-30.jpg" alt="Snipaste_2020-02-26_11-18-30"></p>
<p>8+2+1=11，所以第一段00001011这个二进制数字换算成10进制数字为11。</p>
<p>以此类推，如果要将11000000换算成10进制：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_14-22-10.jpg" alt="Snipaste_2020-02-26_14-22-10"></p>
<p><img src="/2019/11/23/6-tcp-ip/fea3fac8ba890854dbfdde34926e04ac.png" alt="fea3fac8ba890854dbfdde34926e04ac"></p>
<p>我们需要记住上图的2的幂的结果，不需要死记硬背，这个是有技巧的，从上图来看，很容易发现，由于是2的幂，所有相邻的幂的前后都是相差2倍，所以只要知道其中一个幂值，就知道相邻的幂的值。</p>
<p><strong>但要注意，点分十进制这个写法只是为了方便人类理解记忆IP地址，而网络设备只能看懂32位的0101组合的数字。IP地址由网络位和主机位构成。</strong>网络位的概念基本可以等同于代表一个网段的网络号，网络位用于确定某一特定的网络，主机位用于确定该网络中某一特定的主机，它在这个特定的网络中的编号是多少。<strong>同一网段内的计算机网络部分相同，主机部分不同同时重复出现。</strong>初看这段可能一开始接触会觉得不知所云，这个命名规则用收件地址来类比会比较易懂一些：</p>
<p>比如要从广州寄个快递给北京市海淀区复兴路26号复兴小区7号楼1单元109的李磊收，快递员拿到这个快递以后，只需要看最开头的“北京市海淀区”就够了，他不需要管后面那一长串详细的小区名门牌号之类的因为那些信息等快递到了北京才要去管，快递不到北京知道那些东西毫无意义，他只需要知道地址最开头的大地址“北京市海淀区”，然后把这个快递交给发往北京的线路，发送到北京海淀的集散中心，由北京海淀的集散中心再去关心后边的具体的门牌地址之类的具体信息进行分拣投送。网络位起到的作用和收货地址里“北京市海淀区”这个大范围的作用类似，网络位（网络号/网段）定义了一个大的IP地址范围，网络位对应使用同一个网络号的主机范围，一个网络号（网段）可能包含N个IP地址（具体有几个地址要结合子网掩码计算得出），只要是发往这个网络号包含主机的数据，都可以直接发往通往这个网络号的设备，网络号和网络位的概念基本一致，就是网络位+主机位为0；主机位则是在这个特定的网络中的某一台特定的设备或接口，和地址后面具体的门牌号和收件人功能类似，属于在特定的网络号的范围内，精确定位用的。比如一个四合院里面可能住了很多人，但四合院的门牌号可能都是北京市西城区西直门大街西直门胡同1号院，但如果地址只写这个1号院，谁知道这封信是给院子里哪个人的呢，所以必须在这个1号院的地址后边加上收件人，这个“北京市西城区西直门大街西直门胡同1号院”代表了所有住这个院子里的人的一个大范围的地址，相当于网络号（网络位）的作用，确定一个大的地址范围（IP地址所属的大的范围也就是IP地址所属的网段），所有属于这个网段的每一个IP地址都是这个网络号的一部分，而收件人：张三、李四、王二麻子，相当于主机位。也可以用身份证号码的命名模式类比来理解网络位和主机位：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-10_17-43-57.jpg" alt="Snipaste_2020-03-10_17-43-57"></p>
<p>至于一个网段里有多少主机位，要看具体情况，比如192.168.1.0/24这个网段所能容纳的主机IP地址数，是从192.168.1.0 — 192.168.1.255这么多，但由于192.168.1.0是本网段的网络号所以不能使用，而192.168.1.255是本网段的广播地址，也不能作为普通IP地址使用，最后IP地址的数字是从192.168.1.1 — 192.168.1.254，一共是253个IP地址，把最后的主机位写成二进制，会明白这个意思：</p>
<p>192.168.1.0换算成二进制：</p>
<p>​           192       .           168        .            1           .           0</p>
<p>1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0</p>
<p>由于最后一个8位组都是主机位，所以第一个IP地址是00000001，将00000001换算成2进制，补全网络位以后，这个IP地址就是192.168.1.1；在这个基础上加1，主机位为00000002，由于这个是二进制，也就是逢二进一，所以加1以后主机位应为，00000010，第二个IP地址就是192.168.1.2；在前面的基础上加1 , 主机位为00000011，换算成2进制并补全网络位以后，IP地址为192.168.1.3。以此类推可以得出该网段包含的所有IP地址，因为1个8位组最大的数值就是8个1，也就是：11111111，所以一个8位组换算成10进制最大不会超过255。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-07_16-49-22.jpg" alt="Snipaste_2020-03-07_16-49-22"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_14-21-06.jpg" alt="Snipaste_2020-02-26_14-21-06"></p>
<h5 id="IP地址的类别："><a href="#IP地址的类别：" class="headerlink" title="IP地址的类别："></a>IP地址的类别：</h5><p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-27_20-35-06.jpg" alt="Snipaste_2020-02-27_20-35-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/d8edafebca5bbbf1d5bb35cef4156026.png" alt="d8edafebca5bbbf1d5bb35cef4156026"></p>
<p>网络位部分决定了设备位于网络的哪个网段中，主机位部分标识了一个网段中的特定设备。</p>
<p>IP地址共分5个类别：A、B、C、D、E</p>
<p>A：左起第1位必须是0，其他随意变换（1~126）。第一个八位组为网络位，它第一位必须是0其他位数没有要求，其他三个八位组为主机位。A类网络默认子网掩码为255.0.0.0，也可写作/8。</p>
<p>第1位必须是0，说明第1个八位组中的第一个数字是固定的，其他7个数字可以任意变化，也就是从00000000，00000001,00000010,00000011….. ~ 01111111，将前面的二进制换算成十进制，就是从1 ~ 127，但由于全0地址被保留，因为0.0.0.0表示所有IP地址，常用于定义默认路由，而127.*的这个整个网段常被用作loopback网络接口的默认地址，用于测试本机的TCP\IP协议是否正常（能ping通这个地址说明本机的TCP\IP协议工作正常），按惯例通常设置为 127.0.0.1。这个地址在其他计算机上不能访问，就算你想访问，访问的也是自己，因为每台带有TCP/IP协议栈的设备基本上都有 localhost/127.0.0.1。所以A类地址的网络位只是从1~126，因为0和127都有特殊的用途和意义，所以可用的A类网络有126个（1.0.0.0；2.0.0.0…126.0.0.0），A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址），也就是从1.0.0.0 ~ 126.255.255.255。</p>
<p>B：左起第1、2位必须是10（128 ~ 191）第一和第二个八位组为网络位，第一个八位组的第一位和第二位必须是0、1，其他位数没有要求，其他两个八位组为主机位。B类网络默认子网掩码为255.255.0.0，也可写作/16。</p>
<p>第1、2位必须是10，说明第1个八位组中的第1、2位数字是固定的，其他6个数字可以任意变化，也就是从10000000 ~ 10111111，将前面的二进制换算成十进制，就是从128 ~ 191，所以IP地址的范围是从128.0.0.0 ~ 191.255.255.255。可用的B类网络有16382个，每个网络最大主机数量256×256-2=65534。</p>
<p>C：左起第1、2、3位必须是110（192 ~ 223），前三个八位组为网络位，最后一个八位组为主机位。C类网络默认子网掩码为255.255.255.0，也可写作/24。</p>
<p>第1、2、3位必须是110，说明第1个八位组中的第1、2、3位数字是固定的，其他5个数字可以任意变化，也就是从11000000 ~ 11011111，将前面的二进制换算成十进制，就是从192 ~ 223，所以IP地址的范围是从192.0.0.0 ~ 223.255.255.255。C类网络最大主机数量256-2=254。</p>
<p>D：左起第1、2、3、4位必须是1110（224 ~ 239），不分网络地址和主机地址。</p>
<p>第1、2、3、4位必须是1110，说明第1个八位组中的第1、2、3、4位数字是固定的，其他5个数字可以任意变化，也就是从11100000 ~ 11101111，将前面的二进制换算成十进制，就是从224 ~ 239，所以IP地址的范围是从224.0.0.0 ~ 239.255.255.255。D 类地址没有主机标识，常用于组播（多播）。</p>
<p>E：左起第1、2、3、4、5位必须是11110（240 ~ 255）E类地址用于实验和将来使用。不分网络地址和主机地址。</p>
<p><strong>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/6187e6bd1d31364a8bda03f376b30351.png" alt="6187e6bd1d31364a8bda03f376b30351"></p>
<p><img src="/2019/11/23/6-tcp-ip/e664d181be8697229b52f2af236afae7.png" alt="e664d181be8697229b52f2af236afae7"></p>
<h5 id="关于IP地址的基本概念"><a href="#关于IP地址的基本概念" class="headerlink" title="关于IP地址的基本概念"></a>关于IP地址的基本概念</h5><h6 id="•单播（Unicast）："><a href="#•单播（Unicast）：" class="headerlink" title="•单播（Unicast）："></a>•<strong>单播（Unicast）：</strong></h6><p>主机之间一对一的通讯模式，网络中的交换机和路由器对数据只进行转发不进行复制，单播过程类似于我们现实生活中一对一的打电话。如果10个客户机需要相同的数据，则服务器需要逐一传送，重复10次相同的工作。但由于其能够针对每个客户的及时响应，所以现在的网页浏览全部都是采用单播模式，具体的说就是IP单播协议。网络中的路由器和交换机根据其目标地址选择传输路径，将IP单播数据传送到其指定的目的地。</p>
<h6 id="•广播（Broadcast）："><a href="#•广播（Broadcast）：" class="headerlink" title="•广播（Broadcast）："></a>•<strong>广播（Broadcast）：</strong></h6><p>主机之间一对所有的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。类似我们的校园广播，校园广播一开启播放，校园里的所有人都能听到，但是不是所有人都对广播内容感兴趣，有些人选择倾听，有些人选择忽略。但不管你是倾听还是忽略，广播的声音都会传到你的耳边。例如，校园广播一条失物招领通知，你根本没丢东西，所以这个广播内容与你无关，但是广播的声音还是会传到你的耳边。对比广场舞音乐，对于跳广场舞的大妈大婶来说，这就是音乐，对于想睡觉的您来说，这就是噪音。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。</p>
<h6 id="•组播（Multicast）："><a href="#•组播（Multicast）：" class="headerlink" title="•组播（Multicast）："></a>•<strong>组播（Multicast）：</strong></h6><p>主机之间一对多（一组ip地址）的通讯模式，加入了同一个组的主机可以接受到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯，有点类似于我们常用的微信群，只有加入了特定的微信群才能收到特定群发送的消息，也可以随时退出微信群，这样就无法收到相关微信群的消息了。IP地址中的D类就是组播用的地址，大概意思就是想接收特定组播地址的设备去监听该组播地址，就能收到相应的组播消息。</p>
<h6 id="•网络地址、网络号、网络位："><a href="#•网络地址、网络号、网络位：" class="headerlink" title="•网络地址、网络号、网络位："></a>•<strong>网络地址、网络号、网络位：</strong></h6><p>指代网络的地址，又叫网络号。标识网络上的一个物理网络地址，位于相同的物理网络上的所有主机（包括网关）共享一个相同的网络号，其主机地址的网络部分相同。这样的地址模式便于对大量地址进行分级管理，可以极大的减少路由表的规模，使得网络容纳大量主机成为可能。比如说，如果没有网络号，去往192.168.10.2、192.168.10.3、192.168.10.4将数据从E0口发送出去这个路由，在路由表中就要生成三个条目，而如果用网络号记录则只需要记录一条192.168.10.0的条目即可，能大大节约网络设备的条目数量。</p>
<p><strong>当一个IP地址的主机位全为0的时候得出的地址就是网络号。</strong>如果两个IP地址的网络号相同说明这两个IP地址在逻辑上处于同一个网络，在同一网段，通信的时候只需要二层设备就可以通信了；如果他们的三层地址不在同一个网段，所以必须要三层设备才能互相通信。</p>
<h6 id="•广播地址："><a href="#•广播地址：" class="headerlink" title="•广播地址："></a>•<strong>广播地址：</strong></h6><p>用于向网络中的所有主机发送数据的特殊地址。广播地址使用该网络范围内的最大地址。即主机部分的各比特位全部为1的地址。如下图中，192.168.1.255是192.168.1.0这个网络号代表的网段的广播地址，如果向192.168.1.255这个广播地址发送数据，整个192.168.1.0网段包括的IP地址都能收到这个消息。</p>
<p><strong>当一个IP地址的主机位全为1的时候得出的地址就是该网段的广播地址。</strong></p>
<h6 id="•主机地址："><a href="#•主机地址：" class="headerlink" title="•主机地址："></a>•<strong>主机地址：</strong></h6><p>分配给网络中终端设备的地址，例如：192.168.1.5。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-01_21-35-35.jpg" alt="Snipaste_2020-03-01_21-35-35"></p>
<h6 id="公网IP地址"><a href="#公网IP地址" class="headerlink" title="公网IP地址"></a>公网IP地址</h6><p>公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。有公网IP地址的话可以直接用这个地址访问互联网上的其他资源。</p>
<h6 id="私网IP地址"><a href="#私网IP地址" class="headerlink" title="私网IP地址"></a>私网IP地址</h6><p>创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。</p>
<p>私有地址类似于“10号楼1单元808”，这个在本小区的内部可以正常使用，但出了本小区以外，很多小区都有10号楼1单元808这个地址，就没法正确的定位设备也就没法使用了。私有地址的使用仅限于局域网内部使用，无法在公网上获得路由，一般内部网络都是用私有地址，因为IPV4地址资源有限，如果使用私有地址的设备想访问互联网则使用NAT\PAT技术将私有地址转换成公有地址即可。</p>
<ul>
<li>A类：10.0.0.0 255.0.0.0，保留了1个A类网络。</li>
<li>B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。</li>
<li>C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。</li>
</ul>
<p>PS：私网地址访问Internet需要做NAT或PAT网络地址转换，目前我们常用的家用路由器，都是给家里分配一个私有地址网段，所有设备使用这个网段在内网进行通信，如果要访问互联网上的资源，需要将私有地址进行转换，转换成公有地址才可以。</p>
<p><img src="/2019/11/23/6-tcp-ip/b00638fef79863c0e1958bb912a52d7d.png" alt="b00638fef79863c0e1958bb912a52d7d"></p>
<h6 id="子网掩码："><a href="#子网掩码：" class="headerlink" title="子网掩码："></a>子网掩码：</h6><p>因为越来越多的用户接入互联网，原有的IP地址不够分的，比如一个A类地址中包含的IP地址过多，一般大公司用不了那么多，但按原有的IP地址规定又不好分开，<strong>所以加入了子网掩码，和IP地址结合使用，用于描述一个IP地址中的网络部分及主机部分，用来确定目标IP是否在“逻辑上”与本计算机在同一个网络内。</strong>为什么要确定两个IP地址在逻辑上是否在同一个网络呢？是因为如果两个IP在同一个网络内，也就是在同一个网段内，也就是他们的三层地址在同一个大的范围内，所以通信的时候只需要二层设备就可以通信了；如果他们的三层地址不在同一个大的范围内，必须要三层设备才能互相通信。</p>
<p><img src="/2019/11/23/6-tcp-ip/b740e271ede6cd9fa7d6be4f2bec061b.png" alt="b740e271ede6cd9fa7d6be4f2bec061b"></p>
<p>A、B、C类网络都有默认的子网掩码(default subnet mask).A 类IP 地址的默认子网掩码为255.0.0.0;B 类的为255.255.0.0;C 类的为255.255.255.0 ，但子网掩码也可以改变，也就是让网络位和主机位之间相互借位，已达到更好划分网络利用IP地址的目的，例如VLSM和超网，这两个概念在后面章节有详细的介绍。</p>
<p>如果子网掩码是24/的时候，就是说子网掩码为24位，前24位为网络位，后8位为主机位，也就是24个二进制的1：11111111.11111111.11111111.00000000，换算成10进制就是255.255.255.255.0</p>
<p><strong>如何如何计算出两个IP地址是否逻辑上在同一个网络（在同一网段）呢？</strong>也就是用32位的IP地址和32位的子网掩码，一位对一位的进行与运算，得出的就是所在网段。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-01_22-17-44.jpg" alt="Snipaste_2020-03-01_22-17-44"></p>
<h5 id="IP地址与子网掩码的与运算："><a href="#IP地址与子网掩码的与运算：" class="headerlink" title="IP地址与子网掩码的与运算："></a>IP地址与子网掩码的与运算：</h5><p>与运算的整体规则为：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1。即：两位同时为“1”，结果才为“1”，否则为0，举个例子：4&amp;6</p>
<p>4的二进制：0 1 0 0</p>
<p>6的二进制：0 1 1 0</p>
<p>得出结论：  0 1 0 0</p>
<p>所以得出结论，4&amp;6=4</p>
<p><img src="/2019/11/23/6-tcp-ip/v2-c6bc0d2fb99795fb273e1c976dff903c_r.jpg" alt="v2-c6bc0d2fb99795fb273e1c976dff903c_r"></p>
<p>IP地址与子网掩码的运算步骤为：</p>
<p>1、把IP地址和子网掩码变成二进制</p>
<p>2、将二进制的IP地址与子网掩码进行每一位对应的与运算</p>
<p>3、将运算后的结果换算为十进制得到网络地址也就是网络号</p>
<p>4、网络号不变，主机位全为0得出的即为该网段的网络号，主机位全为1得出的即为该网段的广播地址。</p>
<p>比如IP地址为192.168.1.129和192.168.1.5这两个C类网络地址，在子网掩码为255.255.255.0和255.255.255.128的时候是不同的。</p>
<p>当子网掩码为255.255.255.0的时候，掩码为/24位，因为一个8位组全为1的时候，1111111，换算成十进制以后是255，三个255，也就是3X8=24，掩码为24位，换算成二进制就是11111111.11111111.11111111.11111111。</p>
<p>192.168.1.5/24的网络号计算：</p>
<p>IP地址：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 1 0 1</p>
<p>子网掩码：         1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 0 0 0 0 0 0 0 0</p>
<p>网络号：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p>所以192.168.1.5这个IP当它的掩码为/24的时候，网络号为192.168.1.0，广播地址为192.168.1.255。</p>
<p>192.168.1.129/24的网络号计算以此类推：</p>
<p>IP地址：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 1</p>
<p>子网掩码：         1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 0 0 0 0 0 0 0 0</p>
<p>网络号：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p>所以192.168.1.129这个IP当它的掩码为/24的时候，网络号为192.168.1.0，和192.168.1.5的网络号相同，在同一个网段，当然二者的广播地址也是相同的，因为在同一网段。</p>
<p>下面来看看当这两个IP地址的子网掩码为255.255.255.128（也就是掩码为/25，前三个8位组均为255的时候一共是24位，所以第四个8位组的第一位也为1的时候&lt;10000000=128&gt;，正好是25个1，也就是/25位，）他们的网络号分别为多少。</p>
<p>192.168.1.5/25的网络号计算：</p>
<p>IP地址：                                  1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 1 0 1</p>
<p>子网掩码：                              1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 0 0 0 0 0 0 0</p>
<p>网络号：                                  1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：                               1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 1 1 1 1 1 1 1 = 192.168.1.127</p>
<p>所以192.168.1.5这个IP当它的掩码为/25的时候，网络号为192.168.1.0，<strong>广播地址为192.168.1.127，广播地址这里要注意一下，因为子网掩码是25/位的，也就是说网络位有25位，IP地址一共32位，32-25=7，所以主机位是后7位，所以该网段的广播地址为192.168.1.127，并不是192.168.1.255。</strong></p>
<p>192.168.1.129/25的网络号计算：</p>
<p>IP地址：                          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 1</p>
<p>子网掩码：                      1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 0 0 0 0 0 0 0</p>
<p>网络号：                          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 0  =192.168.1.128</p>
<p>广播地址：                      1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p><strong>所以192.168.1.129这个IP当它的掩码为/24的时候，网络号为192.168.1.128，和192.168.1.5的网络号不同，说明他们属于不同的网段，相互通信的时候需要三层设备。</strong></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><h6 id="子网划分的定义"><a href="#子网划分的定义" class="headerlink" title="子网划分的定义"></a>子网划分的定义</h6><p>可以自由的加减子网掩码长度，也就是不限制于A/B/C类默认的掩码长度，A类地址不必须使用8/位的掩码，也可以用诸如：10/位掩码或者7/位掩码。</p>
<h6 id="子网划分的原因"><a href="#子网划分的原因" class="headerlink" title="子网划分的原因"></a>子网划分的原因</h6><p>子网就是把一个大网划分为几个小网，而如果按照默认的A\B\C类默认使用的话，比如一个B类地址，默认掩码为255.255.0.0，意味着这个地址空间里有2的16次方个IP，并且该网络号只能用于一个广播域，造成了IP地址的极大浪费，如果一个广播域中的PC数量过于庞大，网络可能被广播报文消耗大量资源。把一个大网络划分成几个不同的小网络以后，他们之间的网络号和广播地址各不相同，可以尽可能多的使用IP地址避免浪费，一个网段中的主机数量相对少一些的话，广播报文消耗的资源也会少很多，使得网络更有层次性。</p>
<p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是<strong>VLSM（可变长子网掩码）</strong>和<strong>CIDR（无类别域间路由）</strong>，把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。</p>
<p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率。</p>
<h6 id="子网划分的方法"><a href="#子网划分的方法" class="headerlink" title="子网划分的方法"></a>子网划分的方法</h6><p>子网划分的总体思路是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网：</p>
<p>①、把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p>
<p>②、把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p>
<p>③、原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p>
<p>网络ID等同于网络位，主机ID等同于主机位，翻译方式不同。</p>
<p><img src="/2019/11/23/6-tcp-ip/afdf9cfdadeda8e3fce05fd4857b1947.png" alt="afdf9cfdadeda8e3fce05fd4857b1947"></p>
<p>具体的划分步骤参见：<a href="https://renyuan431.github.io/2020/02/19/8-subnet/">子网划分</a></p>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><h6 id="网关的定义"><a href="#网关的定义" class="headerlink" title="网关的定义"></a>网关的定义</h6><p>网关实质上是一个网络通向其他网络（其他网段）的IP地址，比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1  ~  192.168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1  ~  192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目标主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程也是如此 所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<p>举一个生活中的例子方便理解网关的概念和用途，大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也就是不同的网段不同的网络号之间相互发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。没有这个“关口”，不同网段之间的通信就无法进行，就相当于去别的国家没法过人家海关，就没法入境。</p>
<h6 id="网关的作用及工作流程的通俗解释"><a href="#网关的作用及工作流程的通俗解释" class="headerlink" title="网关的作用及工作流程的通俗解释"></a>网关的作用及工作流程的通俗解释</h6><p>假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。</p>
<p>但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：</p>
<p>小不点：李大爷，我想找班主任查一下小明的电话号码行吗？</p>
<p>李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚了小明的电话）问到了，他家的号码是211.99.99.99</p>
<p>小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。</p>
<p>李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大爷把电话给转到小明家）</p>
<p>就这样你和小明取得了联系。</p>
<p>在网络中，同网段之间的设备要进行通信（和同一个大院里的其他小朋友联系）是不需要经过网关（看门的X大爷）的，不同网段之间的设备要进行通信，就必须经过网关（你家大院看大门的X大爷），帮你把你要发送的信息传送给目的IP所在网段的网关（对方大院看门的X大爷），因为只有对方的网关才能在收到发往该网段的数据时，完成之后的通信步骤，具体的通信步骤以及网关所扮演的角色，请参后文“用TCP/IP模型分析数据传输过程”部分。</p>
<h5 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h5><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。</p>
<p>？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<h5 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h5><h6 id="ICMP（ping、Traceroute）"><a href="#ICMP（ping、Traceroute）" class="headerlink" title="ICMP（ping、Traceroute）"></a>ICMP（ping、Traceroute）</h6><p><strong>用途</strong>：</p>
<p>ICMP由设备（如路由器）用于与数据包的源进行通信，以解决传输问题，例如，如果数据未发送到目的设备，则ICMP可能将此信息报告给主机，并提供详细信息，以帮助识别传输错误。比较常用的是两种工具，Ping和Traceroute。</p>
<p><img src="/2019/11/23/6-tcp-ip/icmp-header-how.jpg" alt="icmp-header-how"></p>
<p><img src="/2019/11/23/6-tcp-ip/icmp-header-fields.jpg" alt="icmp-header-fields"></p>
<p>ICMP报头跟在IPV4报头后面，ICMP在IPV4报头中的协议号为1，所有的ICMP包都有8字节的报头部分和可变长度的数据部分，8字节的报头中，前4字节为固定格式，后4字节取决于ICMP数据包的类型/代码。</p>
<p>Type和Code两个字段，结合使用，在不同的字段下表示不同的含义，Type字段常用的为：</p>
<ul>
<li>Echo Reply (0)：表示对于ping包的回复，和Type8结合使用</li>
<li>Echo Request (8)：表示ping包的请求，和Type0结合使用</li>
<li>Destination Unreachable (3)：表示目标设备不可达</li>
<li>Time Exceeded (11)：表示ICMP等待超时</li>
</ul>
<p>下面来看看常见的ICMP的抓包：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-44-45.jpg" alt="Snipaste_2020-03-22_15-44-45"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-45-21.jpg" alt="Snipaste_2020-03-22_15-45-21"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-46-19.jpg" alt="Snipaste_2020-03-22_15-46-19"></p>
<p>更多的关于Type和Code表示的含义有兴趣可以查看下表</p>
<p><img src="/2019/11/23/6-tcp-ip/Users/32759/Downloads/%E4%B8%8B%E8%BD%BD%20(1).png" alt="下载 (6-tcp-ip/%E4%B8%8B%E8%BD%BD%20(1).png)"></p>
<p><strong>Ping</strong>（ Echo Request and Reply—Types 8 and 0）</p>
<p>Ping是一种非常实用的程序，它使用ICMP消息来报告有关网络连接和主机与目标计算机之间的数据中继速度的信息。大概工作原理就是模拟双向通信过程来检测链路是否畅通，常用命令就是Ping x.x.x.x，一般会返回以下几种信息：</p>
<ul>
<li><p>! ! ! ! !            每一个感叹号代表收到一次回复，表示链路畅通</p>
</li>
<li><p>. . . . .            每一个省略号表示网络在等待答复时超时，表示链路不通</p>
</li>
<li><p>U U U U U    每一个U表示收到目标不可达的错误</p>
</li>
<li><p>Q Q Q Q Q   收到Q表示目的设备太忙无法回复</p>
</li>
</ul>
<p>ping包出去时，在Type中的字段是8，ping包的回复，在Type中字段是0。</p>
<p><strong>Traceroute</strong></p>
<p>traceroute命令可用于识别数据包到达其目标所使用的路径。 它标识从源主机到目标主机的路径中的所有路由器，在排除网络故障时很有用。 这个命令可以帮助网络管理员确定数据传输到哪台设备时发生了丢失，以便对该设备进行进一步的检查以确定问题原因。该命令利用IP头部的TTL字段，TTL字段在每经过一个设备时减少1，当TTL为0时（实际上，TTL来没有被减小到0，因为将其减小到0的路由器在TTL变成0之前会产生错误）数据包会被丢弃然后返回一个ICMP信息告诉源设备该情况，Traceroute命令就是利用TTL超时报错的特性来探测网络路径中的每一个设备节点。</p>
<p>Traceroute工作过程：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_16-09-58.jpg" alt="Snipaste_2020-03-22_16-09-58"></p>
<p>当设备A发送Traceroute到设备D时，A发出的数据的TTL从1开始并且持续增加，第一次发出的数据TTL=1，第二次发出的TTL=2，以此类推。当TTL=1的第一个数据到达设备B时，B发现TTL=1，再将这个TTL-1的话就为0了，会出现错误，从而丢弃该数据并返回一个ICMP超时的信息给设备A；设备A发送第二个数据，将TTL设置为2，经过设备B到达设备C后，设备C发现设备B发过来的数据TTL=1，再将这个TTL-1的话就为0了，会出现错误，从而丢弃该数据返回一个ICMP超时的信息，后面以此类推直到到达最终的设备D，从而将设备A——设备D之间的设备都搞清了。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-07-16.jpg" alt="Snipaste_2020-03-19_19-07-16"></p>
<p>上图是一个Traceroute成功的例子，Traceroute会把从源到目的设备的每一跳设备的信息显示出来。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-09-59.jpg" alt="Snipaste_2020-03-19_19-09-59"></p>
<p>上图是一个Traceroute失败的例子，表示数据包到10.0.0.1以后就无法再传输下去，表示极有可能是在该设备上出了问题。</p>
<p>Traceroute一般会返回如下的信息：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-18-15.jpg" alt="Snipaste_2020-03-19_19-18-15"></p>
<p><strong>ping包抓包：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200319203904.jpg" alt="微信图片编辑_20200319203904"></p>
<h3 id="数据链路层（DataLink-Layer）"><a href="#数据链路层（DataLink-Layer）" class="headerlink" title="数据链路层（DataLink Layer）"></a>数据链路层（DataLink Layer）</h3><h4 id="二层封装格式简析"><a href="#二层封装格式简析" class="headerlink" title="二层封装格式简析"></a>二层封装格式简析</h4><p>二层封装格式，能见到的有四种，分别是TCP/IP协议使用、目前基本大一统的Ethernet II，IEEE的IEEE 802.3、802.2 LLC、802.2 SNAP，常见的封装结构为IEEE 802.3和Ethernet II帧（以太网2），之所以有两种帧封装格式，是因为有OSI七层以及TCP/IP两种模型定义了两种不同的分装格式，他们的差别主要是在帧头封装部分，具体的区别有兴趣的自行搜索。之前商定的结果是控制层面的用802.3格式封装，转发层面的用以太网2封装，但目前基本上是以太网一统天下，所以在这就不介绍802.3的相关东西了。至于什么是控制层面、转发层面，后面会有专门的章节进行阐述。除了以上的知识，还有一些扩展的信息在思科论坛的<a href="https://community.cisco.com/t5/switching/ether-frames-802-3-naming-conventions/td-p/2076323">这个帖子</a>以及<a href="https://community.cisco.com/t5/switching/ethernet-802-3-vs-ethernet-ii-frame/td-p/2718996">这个帖子</a>里，如果有兴趣可以看看，这里贴一段我觉得总结的比较好的话：</p>
<blockquote>
<p>if you are going to look at an IPv4 or IPv6 communication, it will be practically always encapsulated into Ethernet II frames because those are the most efficient in terms of overhead. 802.3 + LLC frames are used nowadays mostly for older protocols authored by IEEE itself, such as STP/RSTP/MSTP. SNAP frames are often used for vendor-proprietary Layer2 protocols - Cisco uses it for CDP, DTP, VTP and PAgP, to name a few.</p>
</blockquote>
<p>如果你观察IPV6或者IPV4的通信，它们实际上都是用以太网2进行封装的，因为从开销方面来说这是最有效率的封装方式。如今，802.3+LLC子层的帧格式绝大部分时候是出现在IEEE编写的较老的协议上，比如STP/RSTP/MSTP等协议。SNAP帧格式经常出现在厂家私有的二层协议中，比如思科用在CDP, DTP, VTP 和 PAgP等协议上。</p>
<h4 id="为什么Ethernet-2-使用的更加广泛"><a href="#为什么Ethernet-2-使用的更加广泛" class="headerlink" title="为什么Ethernet 2 使用的更加广泛"></a>为什么Ethernet 2 使用的更加广泛</h4><blockquote>
<p>To run TCP/IP over IEEE 802.3, the SNAP format has to be used. That requires 8 bytes of the data field to identify the kind of data the frame is carrying: three bytes for the Logical Link Control, three bytes for the SNAP header, and two bytes for the Protocol Type field. That means the data field shrinks from the standard range of 46 to 1500 bytes down to a range of 38 to 1492. This is the reason most network managers stay with Ethernet II.</p>
</blockquote>
<p>在TCP/IP协议上运行IEEE802.3的封装时，必须使用SNAP格式，它需要8字节的数据字段用来标识帧所携带的数据的类型。这8个字节由，3个字节的逻辑子层控制、3字节的SNAP报头、2个字节的协议类型字段组成。这意味着能携带的数据部分将从46到1500字节，缩小到38到1492字节。<strong>数据部分缩小是绝大多数网络使用以太网2封装的原因。</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/u7vjq.jpg" alt="u7vjq"></p>
<h4 id="以太网2帧头分析"><a href="#以太网2帧头分析" class="headerlink" title="以太网2帧头分析"></a>以太网2帧头分析</h4><p><img src="/2019/11/23/6-tcp-ip/1920px-Ethernet_Type_II_Frame_format.svg.png" alt="1920px-Ethernet_Type_II_Frame_format.svg"></p>
<p><img src="/2019/11/23/6-tcp-ip/1-slide11.jpg" alt="1-slide11"></p>
<p>源目的MAC地址两个字段并不复杂就不多说了。</p>
<p>EtherType：这个字段标识由帧数据封装的上层协议，以便接收端能根据不同的上层协议用不同的协议进行处理，提高数据处理的效率。 例如，EtherType值0x0800表示该帧包含IPv4数据包。同样，以太类型0x0806表示ARP帧，0x86DD表示IPv6帧，0x8100表示存在IEEE 802.1Q标签，具体可以参考下表：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-23_15-06-24.jpg" alt="Snipaste_2020-03-23_15-06-24"></p>
<p>最后的CRC checksum，4字节，是表示Cyclical Redundancy Check (CRC)，最后这个部分是让接收端在收到数据的时候检查收到的帧是否正确无误。如果帧校验和错，就丢弃此帧。如果校验和正确，再去判断帧的目的硬件地址是否符合自己的接收条件，<strong>看帧校验和是二层解封装后的第一步</strong>。多说两句，这个部分从严格意义上来说应该叫“FCS - Frame Check Sequence”，FCS是用算法校验数据的过程，而CRC是FCS这个校验过程可以采用的一种校验的方式，以太网用的就是CRC这种校验方式，所以在以太网里可以暂且把两者看成是同一个东西，但从概念上来讲，要知道二者是不同的。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>所有的计算机和终端设备都需要通过网络适配器连接到局域网中，每一个适配器都有唯一的链路层地址，也被叫做 LAN 地址或者 MAC 地址，MAC 地址被设计成了扁平结构，它们不会随着所处网络的不同而发生改变。</p>
<p>MAC地址是烧录在Network Interface Card(网卡,NIC)里的MAC地址，所以也叫硬件地址，可以用两种不同的格式表示，分别是48位的 EUI-48 和 64 位的 EUI-64，IPV4网络中的MAC地址是EUI-48，EUI-64 主要用于 IPv6 协议。EUI-48长度为48比特，由16进制的数字组成。MAC地址是物理地址，一般情况下出厂时候就烧录到网卡中，也有一些特定的方式可以对其进行更改，但一般不推荐这么做。</p>
<p><img src="/2019/11/23/6-tcp-ip/How-To-Find-Or-View-MAC-Address-In-Windows-10-1.png" alt="How-To-Find-Or-View-MAC-Address-In-Windows-10-1"></p>
<p>其中，0 — 24位由厂家自己分配；25 — 47位是组织唯一标志符(organizationally unique identifier,OUI)。OUI是由IEEE分配给每个组织，再由组织按高到低的顺序分配1个唯一的全局地址给每个网卡以保证不会有重复的编号。第47位是individual/Group(I/G)位，当I/G位为0的时候，我们可以设想这个地址是MAC地址的实际地址可以出现在MAC头部信息；当I/G位为1的时候,我们可以设想它为广播或多播。第46位是G/L位，也叫U/L位。当这个位为0的时候代表它是由IEEE分配的全局地址；当这个位为1的时候,代表本地管理地址 (例如在DECnet当中) 。<strong>当MAC地址为全F的时候，代表该数据是个广播。</strong>和IP地址全球统一的点分十进制记录方式不同，MAC地址有一些厂家采取自己规定的方式进行记录：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-12_16-26-52.jpg" alt="Snipaste_2020-05-12_16-26-52"></p>
<p>MAC地址由IEEE负责分配，厂家在生产网卡时也需要向IEEE购买MAC地址，这种由机构分发 MAC 地址段并由设备商保证地址唯一的方式就是为了保证全世界所有硬件的网络地址唯一，但是在实际操作中，全球唯一是无法保证的而且我们也并不需要地址的全球唯一，这主要因为以下两个原因：</p>
<ul>
<li>在不同操作系统上，我们都可以通过软件直接修改网卡的 MAC 地址；</li>
<li>只需要保证一个局域网内的 MAC 地址不重复，网络就可以正常工作；</li>
</ul>
<h4 id="MAC地址和IP地址"><a href="#MAC地址和IP地址" class="headerlink" title="MAC地址和IP地址"></a>MAC地址和IP地址</h4><p>MAC地址和IP地址除了处于层级不同（IP地址在三层，MAC地址在二层），地址的位数不同（MAC地址12位，IP地址32位），MAC地址通常无法改变IP地址可以更改，IP地址是逻辑地址MAC地址是物理地址，这几个比较显著比较好理解的区别以外，还有一个最为关键且显著的差别，也就是他们使用功能以及范围上的区别：IP地址是用于在全球互联网上通信时标识一台设备的，而MAC地址是用于在特定本地网络中标识一台设备的，通信的过程也是先根据IP地址将数据发送到IP地址所在的特定本地网络中，然后根据MAC地址在本地网络中再把数据发送给该设备。关于两者的区别，这里举两个例子，一个是身份证号码和姓名，另一个是寄快递的地址。</p>
<p>姓名和MAC地址类似，在一个小区或者一个村里，不管你是叫张三李四王二麻子，一说名字大家都知道这个是你，因为一个村或一个小区人不多，大家也都相互认识，重名的不多，用名字来标识一个人基本是够用的也是很精确的；但当出去旅游或办事时，范围已经扩大到了全国，这时候叫同名同姓的可能性极高，再只用名字作为标识显然是不够的，这时候就需要一个全国唯一的东西，身份证号码，来标识一个人，IP地址类似于身份证号码。</p>
<p>下面再说说寄快递，比如一个地址“北京市西城区玉桃园小区3号楼2门808”这个地址，前面的“北京市西城区玉桃园小区”是在全国这个大范围里定位快递应送到哪个小区，功能类似于IP地址，在全球互联网内定位数据应发送到哪个网段（小区）中，而后面的“3号楼2门808”是在特定的小区内精准定位，功能类似于MAC地址，在数据发送到特定网段（玉桃园小区）后，在该网段（该小区）内的定位由MAC地址完成，因为全国有很多小区，很多小区都有“3号楼2门808”，光靠后面的无法将货物送达，货物必须到了特定小区后，后面的楼号以及门牌号才能发挥作用。</p>
<p>当然上面这两个比喻只是为了方便理解他们作用范围的区别，而不是对两者完全精确的比喻，请批判的阅读这个比喻后，重新看关于MAC地址和IP地址的准确定义，才能真正明白二者的作用。</p>
<h4 id="数据链路层协议："><a href="#数据链路层协议：" class="headerlink" title="数据链路层协议："></a>数据链路层协议：</h4><h6 id="ARP（Address-Resolution-Protocol-）"><a href="#ARP（Address-Resolution-Protocol-）" class="headerlink" title="ARP（Address Resolution Protocol ）"></a>ARP（Address Resolution Protocol ）</h6><p><strong>作用：</strong></p>
<p>– 将IPv4 地址解析为MAC 地址</p>
<p>– 维护IP与MAC映射关系的缓存</p>
<p>ARP是为了促进IP和以太网之间的动态地址解析而开发的，现在也可以在其他第二层技术上使用。 它通过允许IP设备在本地网络上发送广播来工作，并且它请求来自同一本地网络上另一设备的带有硬件地址的响应。</p>
<p><strong>ARP协议解决现网中的什么问题？</strong></p>
<p>在前面的笔记中也提到过，识别、传输一个数据通信是靠：源IP地址、目的IP地址、协议、源端口地址、目的端口地址，这5个元素，其中源、目的IP地址以及协议是封装在三层的ipv4报头中的，源、目的端口是封装在二层的以太网2报头中的，必须有这几个东西，数据才能封装成帧然后转换成0101的电信号通过网线传给另一端的设备，但一般情况下，网工测试线路是否通畅采用的是ping这个工具，比如你的地址是192.168.1.2，想看看到192.168.1.3是否通畅，你都是直接输入“ping 192.168.1.3”，然后系统就会告诉你连通性，但这时候通信必须的五元组里，你只有源、目的IP地址，协议（ping是ICMP协议中的一部分）以及源MAC地址这四个元组，目的MAC地址是不知道的，如何获取目的MAC地址完成二层帧封装呢？这就需要用到ARP协议，英文翻译成中文就是地址解析协议，地址解析是将网络层地址（IP地址）解析为数据链路层地址（MAC地址）的过程。</p>
<p><strong>必须注意的是，这里的ARP地址解析协议只用于解析Internet协议（IPv4）版本4中的单播地址</strong>，而IPv4下的组播地址使用直接映射方法，而IPv6使用新的邻居发现（ND）协议代替ARP，IPV4组播和IPV6中的部分会在后面的笔记中涉及到。</p>
<p>有两种关联IP和以太网地址的基本方法：直接映射或动态解析。但是，以太网地址长48位，而IP地址只有32位，这立即排除了直接映射的可能。</p>
<p>顺便提一句，ARP协议是出现时间比较早而且还在大范围使用的协议之一，RFC编号是826，发布于1982年。</p>
<p><strong>ARP协议分类</strong></p>
<p>1、静态映射。用命令添加静态的IP地址和MAC地址之间的映射条目，功能类似于大厦1层的索引牌。用静态映射的相对少一些。</p>
<p><img src="/2019/11/23/6-tcp-ip/sign.jpg" alt="sign"></p>
<p>2、动态解析。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。动态映射的应用场景比较多。功能类似于你去小红家找妹纸玩，但只知道她在哪个楼住，但不知道具体楼层门牌号，然后在楼下大喊“小红你在哪~”，她听到你喊她以后出来告诉你她具体的楼层和门牌号，比如“我在地下十八层住，大爷来玩啊”这种。</p>
<p><strong>ARP表缓存查询命令</strong></p>
<p>windows：arp - a</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200512173718.jpg" alt="微信图片编辑_20200512173718"></p>
<p>Cisco IOS：show arp</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-26_16-54-39.jpg" alt="Snipaste_2020-05-26_16-54-39"></p>
<p>表中的**Age(min)**表示自从该ARP条目进入ARP表中以来的时间，当设备第一次收到该ARP时在ARP表项中输入该条目并启动该计时器，ARP的过期时间Nexus和普通交换机过期时间不同：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-06-15_10-12-53.jpg" alt="Snipaste_2020-06-15_10-12-53"></p>
<p>表中的<strong>ARPA</strong>是一种以太网默认的封装格式：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-26_17-08-59.jpg" alt="Snipaste_2020-05-26_17-08-59"></p>
<p><strong>ARP封装格式</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/ARP+Packet+Format+Same+format+for+request+and+reply..jpg" alt="ARP+Packet+Format+Same+format+for+request+and+reply."></p>
<p><img src="/2019/11/23/6-tcp-ip/2015-10-18_00-33-22.png" alt="2015-10-18_00-33-22"></p>
<p><strong>Hardware type</strong> ：该字段表示网络链接协议类型。例如常用的TCP/IP中以太网表示为1，换算成16进制就是0X0001。</p>
<p><strong>Protocol type</strong>：该字段表示ARP请求所针对的互联网络协议。对于IPv4，其值为0x0800。</p>
<p><strong>Hardware address length</strong>：硬件地址（MAC地址）的长度（八位字节）。以太网地址长度为6。</p>
<p><strong>Protocol address length</strong>：互联网络地址（IP地址）的长度（八位字节）。互联协议在PTYPE中指定。示例：IPv4地址长度为4。</p>
<p><strong>Operation code</strong>：ARP request，也就是ARP请求时该字段为1，当为ARP reply，也就是ARP回复时该字段为2。</p>
<p>**Sender protocol address (SPA)**：Internetwork address of the sender，也就是发送设备的IP地址</p>
<p>**Target protocol address (TPA)**：Internetwork address of the intended receiver，也就是目标设备的IP地址。</p>
<p>在图中有<strong>两组MAC地址</strong>，要明白他们各自代表的是什么含义并且区分开，可以简单理解为一组是以太网2协议中的通信用MAC地址，另一组是arp协议中的请求用MAC地址：</p>
<ol>
<li>从左边起算的，在ARP前边的destination address 和 source address， source address表示的是这整个的数据帧的发送者的源MAC地址，destination address表示的是整个数据帧接收者的MAC地址，这个是以太网报头中的通信用的MAC地址，这组MAC地址的目的是把ARP请求信息送到接收端。</li>
<li>而ARP段中的source hardware address根据该数据是ARP请求还是ARP回复所表示的含义不同，在ARP请求中，此字段用于指示发送请求的主机的地址。在ARP答复中，此字段用于指示请求正在寻找的主机的地址。Target hardware address含义也是有区别的，在ARP请求中，此字段为空，因为并不知道目标MAC地址才要使用ARP协议。在ARP答复中，此字段用于指示发起ARP请求的主机的地址。ARP中的这组MAC地址是为了完成请求目的MAC地址的功能的。</li>
</ol>
<p><strong>工作过程：</strong></p>
<blockquote>
<p>ARP is a relatively simple request-and-reply protocol. The source device broadcasts an ARP Request that’s looking for a particular device based on the device’s IP address. That device responds with its hardware address in an ARP Reply message.</p>
</blockquote>
<p>ARP是一个相对来说比较简单的“请求——回应”的协议，源设备广播它的ARP请求，这个ARP请求基于目标设备的IP地址，那个有ARP请求中同样IP地址的设备将用ARP回复来告知源设备它的MAC地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_13-58-43.jpg" alt="Snipaste_2020-03-12_13-58-43"></p>
<blockquote>
<ol>
<li>Source Device Checks Cache The source device will first check its cache to determine if it already has a resolution of the destination device. If so, it can skip to step 9. </li>
<li>Source Device Generates ARP Request Message The source device generates an ARP Request message. It puts its own data link layer address as the Sender Hardware Address and its own IP address as the Sender Protocol Address. It fills in the IP address of the destination as the Target Protocol Address. (It must leave the Target Hardware Address blank, since that it is what it is trying to determine!) </li>
<li>Source Device Broadcasts ARP Request Message The source broadcasts the ARP Request message on the local network.</li>
<li>Local Devices Process ARP Request Message The message is received by each device on the local network. It is processed, with each device looking for a match on the Target Protocol Address. Those that do not match will drop the message and take no further action. </li>
<li>Destination Device Generates ARP Reply Message The one device whose IP address matches the contents of the Target Protocol Address of the message will generate an ARP Reply message. It takes the Sender Hardware Address and Sender Protocol Address fields from the ARP Request message and uses these as the values for the Target Hardware Address and Target Protocol Address of the reply. It then fills in its own layer 2 address as the Sender Hardware Address and its IP address as the Sender Protocol Address. Other fields are filled in, as explained in the description of the ARP message format in the following sec-tion. </li>
<li>Destination Device Updates ARP Cache If the source needs to send an IP dat-agram to the destination now, it makes sense that the destination will probably need to send a response to the source at some point soon. (After all, most com-munication on a network is bidirectional.) Next, as an optimization, the desti-nation device will add an entry to its own ARP cache that contains the hardware and IP addresses of the source that sent the ARP Request. This saves the desti-nation from needing to do an unnecessary resolution cycle later on.</li>
<li>Destination Device Sends ARP Reply Message The destination device sends the ARP Reply message. This reply is, however, sent unicast to the source device, because there is no need to broadcast it. </li>
<li>Source Device Processes ARP Reply Message The source device processes the reply from the destination. It stores the Sender Hardware Address as the layer 2 address of the destination and uses that address for sending its IP datagram. </li>
<li>Source Device Updates ARP Cache The source device uses the Sender Proto-col Address and Sender Hardware Address to update its ARP cache for use in the future when transmitting to this device.<br>KEY CONCEPT ARP is a relatively simple request-and-reply protocol. The source device broadcasts an ARP Request that’s looking for a particular device based on the device’s IP address. That device responds with its hardware address in an ARP Reply message.</li>
</ol>
</blockquote>
<p>源设备，也就是要发送数据的设备为设备A</p>
<p>目标设备，也就是要接收数据的设备为设备B</p>
<p>1、源设备A进行ARP缓存表查询。发送数据的源设备A在一开始将会对自己的ARP缓存表进行查询，看它是否有目标设备的“IP地址——MAC地址”的ARP解析结果，如果有该结果则直接跳到第九步。</p>
<p>2、源设备A生成ARP请求消息。当源设备A发现自身并没有对应的ARP缓存时，源设备生会成ARP请求信息，将本设备的源IP地址以及源MAC地址作为ARP请求信息的源IP地址以及源MAC地址，将目的设备B的IP地址作为目标IP地址。这个请求消息会将目标MAC地址设置为空因为A正在请求目标MAC地址。对比ARP报头格式我们可以知道，ARP封装的信息已经齐了，可以进行ARP报头的封装了。</p>
<p><img src="/2019/11/23/6-tcp-ip/arp-packet-format-1.jpg" alt="arp-packet-format-1"></p>
<p>“**Sender protocol address (SPA)<strong>”是Internetwork address of the sender，也就是发送设备的IP地址，“</strong>Target protocol address (TPA)**”是Internetwork address of the intended receiver，也就是目标设备的IP地址。</p>
<p>3、源设备A将ARP请求信息在本网段上进行广播。</p>
<p>4、本网段设备对ARP请求信息进行处理。本网段所有设备将收到源设备发送的ARP的请求信息，因为ARP请求信息是个“broadcasts”，也就是广播，它所传播的范围就是在本网段，每个收到该广播的设备都会核对自身的IP地址和ARP请求信息中的“目标”是否一致，如果不一致的话将丢弃该ARP请求信息也不会有下一步的处理了。如果所请求的arp目标在不同网段，则需要用到代理ARP，在这篇笔记中暂时不涉及到。</p>
<p>5、目标设备B生成ARP回复信息。那个IP地址和ARP请求信息中“目标IP地址”相同的设备，将生成一个ARP回复信息，这个回复信息将使用ARP请求信息中的源IP地址和源MAC地址，并将它们作为ARP回复信息中的目的IP地址和目的MAC地址。然后将自身的IP地址作为ARP回复信息中的源IP地址，将自己的MAC地址作为源MAC地址，然后封装好ARP报头。</p>
<p>6、目标设备B更新自身的ARP缓存表项。如果源设备A在得知目标设备B的MAC地址后要向目标设备发送数据，目标设备B之后回复数据的时候，也是需要源设备A的MAC地址的，毕竟大多数的通信都是双向的，所以作为一个优化步骤，目标设备B会将收到的ARP请求中的，源设备A的“IP地址——MAC地址”对应的ARP条目放入缓存中，以便于以后使用，因为缓存中有源设备A的ARP条目后，再通信的时候就不用进行ARP请求而可以直接使用了。</p>
<p>7、目标设备B发送APR回复消息。目标设备B发送ARP回复信息，这个ARP回复信息是基于单播的，因为已经知道源设备A的IP地址和MAC地址，无需用广播回复。</p>
<p>8、源设备A处理ARP回复消息。源设备处理A从目标设备B处收到的ARP回复消息，源设备A使用ARP中的发件人硬件地址（也就是ARP报头中的Target hardware address）作为发送给目标设备B的以太网报头中的目的MAC地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200319135836.jpg" alt="微信图片编辑_20200319135836"></p>
<p>9、源设备A更新ARP缓存。源设备A用目标设备的IP地址及MAC地址更新ARP表项，以便未来使用。</p>
<p><strong>示例分析：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-08-38.jpg" alt="Snipaste_2020-03-15_14-08-38"></p>
<p>当PC想和1.1.1.254通信，通过上面ARP的9步我们知道，它先要查询本地的ARP表中是否有相关条目，这时在PC上是用arp -a这个命令在CMD中查询发现，PC并没有该条目所以要发送ARP请求来获知1.1.1.254的MAC地址。先看二层封装，由于ARP请求是一个广播，所以源MAC地址是自身的MAC地址，目的MAC地址则为全F，表示这是一个广播；然后看ARP报头封装，源MAC地址和源IP地址都是自身的地址不多说，目标MAC地址为全0，因为前面也说了，发送ARP请求就是为了获取ARP缓存，目标IP地址就是1.1.1.254。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-29-05.jpg" alt="Snipaste_2020-03-15_14-29-05"></p>
<p>当ARP请求到达交换机时，交换机会将该广播从除了接收接口以外的其他所有接口发送出去，每个收到该广播的设备都会核对自身的IP地址和ARP请求信息中的“目标”是否一致，如果不一致的话将丢弃该ARP请求信息也不会有下一步的处理。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-35-41.jpg" alt="Snipaste_2020-03-15_14-35-41"></p>
<p>当路由器收到该ARP请求时，将0101的电信号还原成帧，然后解二层封装，发现目标MAC地址为全F，也就是一个广播，因为广播是发送给全网段的，所以也就是发给自己的于是进一步解封装到ARP报头，发现Target IP和自身F0/0接口一致，于是对该请求进行处理。路由器将ARP请求信息中的源IP地址1.1.1.1，与源MAC地址00dd.f800.0001的对应条目放入本地ARP缓存中。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-39-09.jpg" alt="Snipaste_2020-03-15_14-39-09"></p>
<p>路由器生成回复ARP请求的单播数据，二层封装的源MAC地址为路由器F0/0的MAC地址，0000.000C.AAAA，目的MAC地址为PC的MAC地址00dd.f800.0001，PC的MAC地址是从PC的ARP报头中获得的，ARP报头封装的源MAC地址与源IP地址为F0/0口的相应地址，目标IP地址与目标MAC地址为PC的相应地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-15-53.jpg" alt="Snipaste_2020-03-15_15-15-53"></p>
<p>ARP回复信息经交换机发送给PC后，PC对回复的信息还原成帧后查看目标MAC地址发现是发送给自己的，然后进一步对数据进行解封装，发现是arp 回复消息，然后将1.1.1.254与它的对应MAC地址条目放入arp缓存表，以后再向1.1.1.254发送数据的时候，就不用再通过arp请求MAC地址了。</p>
<p>ARP缓存在思科设备上的默认过期时间是1500秒，也就是25分钟，这个数字可以自行设置，设置范围为60 — 28800秒之间。</p>
<p>ARP抓包：</p>
<p>arp请求信息</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-22-21.jpg" alt="Snipaste_2020-03-15_15-22-21"></p>
<p>arp回复信息</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-22-52.jpg" alt="Snipaste_2020-03-15_15-22-52"></p>
<h6 id="代理ARP（Proxy-ARP）"><a href="#代理ARP（Proxy-ARP）" class="headerlink" title="代理ARP（Proxy ARP）"></a>代理ARP（Proxy ARP）</h6><blockquote>
<p>Proxy ARP is a technique by which a proxy device on a given network answers the ARP queries for an IP address that is not on that network. The proxy is aware of the location of the traffic’s destination, and offers its own MAC address as the (ostensibly final) destination.</p>
</blockquote>
<p>代理ARP是一种技术，这种技术使得在特定网段上的代理设备回答不在该网段上的IP地址的ARP查询。代理设备知道如何前往数据的目的地址，并且将代理设备自身的MAC地址提供给ARP的查询者。</p>
<p>简单来说，当ARP请求目标跨网段时，网关设备收到此ARP请求，会用自己的MAC地址返回给请求者，这便是代理ARP（Proxy ARP）。代理ARP本质上来说是一个“善意的欺骗”，是一个“错位”的映射，实际网络中，代理ARP由网络中的网关设备来执行，包括路由器、多层交换机、无线路由器、防火墙等设备。并且，网关即便有代理ARP功能，也未必一定执行，还必须满足两个条件：<strong>①网关已经开启代理ARP功能；②网关有目标的路由信息。</strong>思科设备默认开启代理ARP功能，不用再手动进行开启，如果被关闭的话在接口上输入<strong>ip proxy-arp</strong>将接口的代理ARP打开。</p>
<h4 id="数据链路层在数据传输时的步骤："><a href="#数据链路层在数据传输时的步骤：" class="headerlink" title="数据链路层在数据传输时的步骤："></a>数据链路层在数据传输时的步骤：</h4><p>在发送端，数据链路层收到上层传过来的数据后，打上数据链路层的报头，然后发送给物理层。在接收端，数据链路层收到下层发过来的数据后，对二层报头进行解封装，首先查看二层的FCS部分校验是否正确，如果正确再查看报头中的目的MAC地址和本地的MAC地址是否相符，如果相符就根据二层报头中的EtherType将数据发给上层的相应协议继续处理，如果目的MAC地址和本机MAC地址不相符就将数据丢弃。</p>
<h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><blockquote>
<p>The physical layer contains the protocols relating to the physical medium on which TCP/IP will be communicating. Officially, the protocols of this layer fall within four categories that together describe all aspects of physical media: </p>
<p>Electrical/optical protocols describe signal characteristics such as voltage or photonic levels, bit timing, encoding, and signal shape. </p>
<p>Mechanical protocols are specifications such as the dimensions of a connector or the metallic makeup of a wire. </p>
<p>Functional protocols describe what something does. For example, “Request to Send” is the functional description of pin 4 of an EIA-232-D connector. </p>
<p>Procedural protocols describe how something is done. For example, a binary 1 is represented on an EIA-232-D lead as a voltage more negative than 3 volts.</p>
</blockquote>
<p>物理层包含那些和物理传输介质相关的协议，定义了电压、数据传输率、最大传输距离等参数，官方规定了四类属性来描述物理层的各个方面：</p>
<p>电气/光学协议描述了信号特征，例如电压或光子电平，位时序，编码和信号形状。</p>
<p>机械协议是规范，例如连接器的尺寸或电线的金属外观。</p>
<p>功能协议描述了某些功能。 例如，“请求发送”是EIA-232-D连接器的引脚4的功能描述。</p>
<p>过程协议描述了如何完成某件事。 例如，二进制文件1在EIA-232-D引线上表示为比3伏更负的电压。</p>
<p>简单来说，<strong>物理层在传输中完成的动作就是在发送端将二层数字帧转换成电磁脉冲</strong>，在不同的传输介质中，转换的结果不同，如果是在光纤中传输，也就是将0101的数字信号转换为光信号然后传输，如果是在铜缆中就是转换成高低电平然后传输，在接收端完成的动作就是将电磁信号还原成帧然后交给上层处理。</p>
<p>工作在物理层的设备有：中继器，常规集线器和收发器。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404175346.png" alt="微信截图_20200404175346"></p>
<h1 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h1><p><a href="https://blog.csdn.net/hanzhen7541/article/details/79072036">TCP和UDP协议的特点和区别详解</a></p>
<p><a href="https://www.zhihu.com/question/39324847">怎么有效理解可靠数据传输</a>？</p>
<p><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/">第17章 TCP：传输控制协议</a></p>
<p><a href="https://www.jianshu.com/p/9f3e879a4c9c#comments">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>
<p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/">Understanding TCP Sequence and Acknowledgment Numbers</a></p>
<p><a href="https://www.cnblogs.com/xuekai-to-sharp/p/3506982.html">IP包头</a></p>
<p>Routing TCP/IP, Volume I</p>
<p>数据通信与联网技术</p>
<p>图解TCPIP</p>
<p><a href="https://www.cnblogs.com/cyjaysun/p/4415439.html">协议号与端口号详解</a></p>
<p><a href="https://www.cnblogs.com/straybirds/p/5319604.html">ip地址的组成（网络位+主机位）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32361762">IP地址、子网掩码和网络号的计算</a></p>
<p><a href="https://juejin.im/post/5e187698f265da3e3c4ced87">网络架构系列1–TCP/IP详解</a></p>
<p><a href="https://www.jianshu.com/p/c4fcecc2fd2e">SYN-Flood攻击解决办法？</a></p>
<p><a href="https://blog.csdn.net/nie19940803/article/details/76647834">SYN Flood攻击及防御方法</a></p>
<p><a href="https://v.youku.com/v_show/id_XNDg1NDUyMDUy.html">TCP sliding window</a></p>
<p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口（Sliding Window）</a></p>
<p><a href="https://blog.csdn.net/guizaijianchic/article/details/77524825">MTU，窗口大小和mss的区别</a></p>
<p><a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/interfaces-media-mtu.html">Media MTU Overview</a></p>
<p><a href="https://packetlife.net/blog/2010/aug/4/tcp-windows-and-window-scaling/">TCP Windows and Window Scaling</a></p>
<p><a href="https://learningnetwork.cisco.com/message/553728#553728">TCP - Interface MTU VS. IP MTU</a></p>
<p><a href="https://networklessons.com/cisco/ccie-routing-switching-written/tcp-window-size-scaling">TCP Window Size Scaling</a></p>
<p><a href="https://python.freelycode.com/contribution/detail/948">你不知道什么是网络性能（一）</a></p>
<p><a href="https://medium.com/@retroviseur/long-fat-network-lfn-and-tcp-7df4654b7c21">Long Fat Network (LFN) and TCP</a></p>
<p><a href="https://blog.stackpath.com/tcp-slow-start/">What is TCP Slow Start?</a></p>
<p><a href="https://networkengineering.stackexchange.com/questions/59441/whats-the-use-of-an-acknowledgement-number-without-the-ack-flag-set">What’s the use of an acknowledgement number without the ACK flag set?</a></p>
<p><a href="https://www.zhihu.com/question/23940717">localhost、127.0.0.1 和 本机IP 三者的区别?</a></p>
<p><a href="https://www.jianshu.com/p/164ab8a6e6a9">单播、多播（组播）和广播的区别</a></p>
<p><a href="https://www.jannet.hk/zh-Hant/post/IP-Address-Version-4-IPv4/">IP Address Version 4 (IPv4) 網際網路協定位址</a></p>
<p><a href="https://www.zhihu.com/question/56895036">如何理解子网掩码</a>？</p>
<p><a href="https://www.zhihu.com/question/51074319">TCP/IP 协议到底在讲什么TCP/IP 协议到底在讲什么</a></p>
<p><a href="https://blog.51cto.com/vip2010/202899">网关(Gateway)–帮你深入理解什么是网关</a></p>
<p><a href="https://blog.51cto.com/mmanong/1945144">可变长度子网掩码（VLSM）在子网划分中的应用</a></p>
<p><a href="https://blog.51cto.com/6930123/2112403">IP地址和子网划分学习笔记之《IP地址详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2112748">IP地址和子网划分学习笔记之《子网掩码详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2115072">IP地址和子网划分学习笔记之《超网合并详解》</a></p>
<p><a href="https://www.hackingarticles.in/working-of-traceroute-using-wireshark/">Working of Traceroute using Wireshark</a></p>
<p><a href="https://www.globalknowledge.com/us-en/resources/resource-library/articles/what-is-the-difference-between-ethernet-ii-and-ieee-8023/">What is the Difference Between Ethernet II and IEEE 802.3</a></p>
<p><a href="https://www.jianshu.com/p/8d50e92a852c">计算机网络-笔记</a></p>
<p>TCP分段与IP<a href="https://www.jianshu.com/p/f9a5b07d99a2">分片</a></p>
<p><strong><a href="https://www.trueneutral.eu/2015/wireshark-frags-1.html">IP FRAGMENTATION IN WIRESHARK (1)</a></strong></p>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手 · Why’s THE Design?</a></p>
<p><a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">为什么 TCP/IP 协议会拆分数据</a></p>
<p><a href="https://draveness.me/whys-the-design-non-unique-mac-address/">为什么 Mac 地址不需要全球唯一</a></p>
<p><a href="https://blog.51cto.com/chenxinjie/1961255">图解ARP协议（四）代理ARP原理与实践（“善意的欺骗”）</a></p>
<p><a href="https://cordero.me/cisco-arp-and-mac-address-aging/">Cisco ARP and MAC Address Aging</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>5、OSI七层模型</title>
    <url>/2019/11/18/OSI-7/</url>
    <content><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong>（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。</p>
<h2 id="二、OSI模型解决什么问题"><a href="#二、OSI模型解决什么问题" class="headerlink" title="二、OSI模型解决什么问题"></a>二、OSI模型解决什么问题</h2> <span id="more"></span>  

<p>伴随技术喷发，网络设备和网络软件行业兴起了几家巨头，包括思科、微软、Novell、IBM、惠普、苹果以及其它几家公司。<strong>每家都有自己的线缆和端口类型，允许各自的商业性协议。</strong>此时，如你从一家买路由器、另一家买交换机，又从别家买服务器，就会<strong>出现兼容性问题</strong>。</p>
<p>有一些处理这些问题的通容办法，比如<strong>在网络上部署网关来转换不同的协议</strong>，这会导致<strong>性能上的瓶颈</strong>（比如网络慢速部分）并会令到<strong>故障排除十分困难和费时</strong>。最终，厂商们不得不达成一个在各自产品上都能工作的通用标准，一套叫做 TCP/IP 的免费协议包。最后，那些未能采行 TCP/IP 的厂商失去市场份额，走向破产。</p>
<p><strong>ISO 创建出 OSI 模型，以助力于各厂商就通用标准达成一致，实现厂商之间的兼容。</strong>此模型包括了将总多网络功能分解为一套逻辑分层，或通俗地称为层的东西。各层只需完成其特定的一些功能，比如说你的公司专注于防火墙，那么这些防火墙将自然地与其它厂商的设备一起工作。</p>
<p><strong>此模型的优势在于每件设备设计用来出色完成一个角色，而非不充分地完成多个角色。</strong>客户可以根据其解决方案选出最好的设备，而不用死栓在一家厂商那里。同时<strong>故障排除也变得更为容易</strong>，因为确定的出错可被追踪到具体的某层。</p>
<p>OSI 模型将所有网络功能划分为七个不同的层。该层次化模型从第七层一路去往第一层。那些离用户更近、更为复杂的功能，在顶部，一直到处于底层的网络线缆规格。</p>
<h2 id="三、总览"><a href="#三、总览" class="headerlink" title="三、总览"></a>三、总览</h2><p><strong>OSI模型类似于生产车间中的流水线或单位中的部门</strong>，OSI参考模型中的一层就相当于流水线上的一道工序或单位中的一个部门，他们<strong>既相互关联又彼此独立，下层为上层提供传输服务，不关心上层传输的内容，需要标识上层所使用的协议或应用；而上层也不关心下层传输的手段，只期望能将信息最终发到通信对端的相应层次上。</strong>就好像流水线上负责装轮子的工人只会安心装自己的车轮而不会管生产底盘工人如何工作，上一个人将需要生产的产品（也就是网络中的数据）交给他，他只需要装上轮子（在通信过程中就是完成本层协议规定的动作，例如为数据打上本层的报头）然后将产品交给下一个人进行继续生产。</p>
<p>OSI七层模型的<strong>最大优点是将服务、接口和协议这三个概念明确地区分开来</strong>：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。OSI 参考模型分为7层，<strong>高3层定义了端用户如何进行互相通信；底部4层定义了数据是如何端到端的传输。</strong>最高3层，也称之为上层(upper layer)，它们不关心网络的具体情况，这些工作是又下4层来完成。</p>
<p><img src="/2019/11/18/OSI-7/v2-854e3df8ea850c977c30cb1deb1f64db_hd.jpg" alt="v2-854e3df8ea850c977c30cb1deb1f64db_hd"></p>
<p><img src="/2019/11/18/OSI-7/osi5.png" alt="osi5"></p>
<h2 id="四、OSI模型的不足"><a href="#四、OSI模型的不足" class="headerlink" title="四、OSI模型的不足"></a>四、OSI模型的不足</h2><p>OSI模型所存在的问题是模型与协议自身的缺陷。OSI参考模型将“服务”与“协议”的定义相结合，使得参考模型变得格外复杂，实现起来更加困难，而且整体上对安全方面考虑的不够。会话层在大多数应用中很少用到，表示层几乎是空的。在数据链路层与网络层有很多子层插入，每个子层都有不同的功能。所以实际生活中我们用的绝大多数网络协议都是依照后面的TCP/IP协议制定的，只有少部分协议，比如数据中心中使用的IS-IS（Intermediate System to Intermediate System，中间系统到中间系统）是用OSI七层模型的。</p>
<h2 id="五、相关概念"><a href="#五、相关概念" class="headerlink" title="五、相关概念"></a>五、相关概念</h2><p><strong>本章节的概念比较难以理解一些，刚开始学的话建议对这些概念的定义有所了解就行，结合后边TCP/IP模型那章中的“用TCP/IP模型分析数据传输过程”部分，再回头看这些概念，会更好理解一些，因为联系实际能更方便对概念进行理解和掌握。</strong></p>
<h3 id="（一）协议号，端口号"><a href="#（一）协议号，端口号" class="headerlink" title="（一）协议号，端口号"></a>（一）协议号，端口号</h3><p>协议号是三层概念，存在于IP头部协议号字段(常见的例如：6=TCP，17=UDP)；<br>端口号是四层概念，存在于TCP或UDP源/目端口号字段(常见的例如：TCP80=HTTP, UDP53=DNS)</p>
<p>说白了都是“区分上层”用的，就是用来识别同一台计算机中进行通信的不同应用程序。但是所处的层次不一样。一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/2019/11/18/OSI-7/1e487b21-906d-41ae-8894-d02f1037cf25.jpg" alt="1e487b21-906d-41ae-8894-d02f1037cf25"></p>
<h3 id="（二）协议的定义及作用"><a href="#（二）协议的定义及作用" class="headerlink" title="（二）协议的定义及作用"></a>（二）协议的定义及作用</h3><p>什么是协议（protocol）？ </p>
<p>是指通信双方对数据传送控制的一种约定。约定中包括对数据格式，同步方式，传送速度，传送步骤，检纠错方式以及控制字符定义等问题做出统一规定，通信双方必须共同遵守，它也叫做链路控制规程。</p>
<p><strong>通俗的来讲，协议是一种双方都明白或者必须遵守的事先约定</strong>，比如说长城上放狼烟，是因为人们已经预先设定好狼烟这个物理信号代表了“敌人入侵”这一抽象信号。这样一个“狼烟=敌人入侵”就是一个简单的协议。协议可以更复杂，比如摩尔斯码(Morse Code)，使用短信号和长信号的组合，来代表不同的英文字母。当然，通信的双方必须遵从同样的协议才能够完成通信，比如你这里的协议规定的是“长城上放狼烟代表敌人入侵”，而你通信对端的协议规定是“长城上放狼烟代表打开城门”，那就出大事儿了，这样是没法交流的，所以通信双方必须遵从相同的协议才能通信。</p>
<p>网络协议其实也是按照人的思维方式在工作，但是网络设备不会像人一样思考，所以我们当初给它设计各种协议的时候就要尽可能地为它想到这些协议所要应对的场景。</p>
<blockquote>
<p>a protocol is formally defined as a set of rules governing communication between entities at the same layer. </p>
</blockquote>
<h3 id="（三）X层设备"><a href="#（三）X层设备" class="headerlink" title="（三）X层设备"></a>（三）X层设备</h3><p>经常会听到三层交换机、二层交换机以及路由器是三层设备这种叫法。</p>
<p>工作在三层（网络层）的设备，例如路由器，指的是这台设备同时具备1-3层的功能，也就是可以支持物理层、数据链路层和网络层的所有协议；如果是一台二层（数据链路层）设备，比如二层交换机，指的是这台二层交换机同时具备1-2层的功能，也就是可以支持物理层和数据链路层的所有协议。</p>
<p>二层设备以三层设备的区别是看能不能识别三层的东西，能不能完整的运行三层协议，比如IP地址、路由等三层的东西。能识别能完整支持的就为三层设备。三层设备常用于多网段，隔离广播域。</p>
<p>还有一个概念叫四层交换机，它是一种功能，它决定传输不仅仅依据MAC地址(第二层网桥)或源/目标IP地址(第三层路由),而且依据TCP/UDP(第四层) 应用端口号。第四层交换功能就象是虚IP，指向物理服务器，也就是LVS功能。  LVS 是 Linux Virtual Server 的简写，意即 Linux 虚拟服务器，是一个开源的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>流量调度器。LVS 集群采用 IP 负载均衡技术和基于内容请求分发技术，将用户请求按照一定策略分发到后端的 Server 上，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。 具体可参照<a href="https://www.cnblogs.com/zengkefu/p/5587687.html">LVS图解</a>这篇文章。</p>
<h3 id="（四）上三层，下四层"><a href="#（四）上三层，下四层" class="headerlink" title="（四）上三层，下四层"></a>（四）上三层，下四层</h3><p>下四层：物理层、链路层、网络层、传输层都是运行协议数据等保证网络通畅；接着的上面三层：会话层、表示层、应用层都是用来控制会话等。 </p>
<h3 id="（五）TCP-IP模型和OSI模型"><a href="#（五）TCP-IP模型和OSI模型" class="headerlink" title="（五）TCP\IP模型和OSI模型"></a>（五）TCP\IP模型和OSI模型</h3><p><img src="/2019/11/18/OSI-7/OSI-VS-TCPIP.jpg" alt="OSI-VS-TCPIP"></p>
<p>OSI七层模型是 ISO（国际标准化组织）制定的，为了方便学习把层级分的比较多，这七层涵盖很多分类过细导致协议太复杂实现较困难，厂家自己搞出了另一套通信协议，叫做TCP/IP，只有四层实现起来也较为方便简单，所以目前使用的几乎都是TCP/IP协议栈，现在的互联网也是基于TCP/IP的，所以在学习网络知识的时候，都是参照OSI模型的，但在使用的时候，都是使用TCP/IP模型。</p>
<p>关于两个模型具体的区别、联系，请看 <a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/">https://renyuan431.github.io/2019/11/23/6-tcp-ip/</a> 中相关部分</p>
<h3 id="（六）全双工、半双工"><a href="#（六）全双工、半双工" class="headerlink" title="（六）全双工、半双工"></a>（六）全双工、半双工</h3><p><strong>全双工</strong>（Full Duplex）是通讯传输的一个术语。 通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。 <strong>全双工</strong>指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。 指A→B的同时B→A，是瞬时同步的。 类似于我们现在的打电话，电话两边的人可以同时说话（两端同时可以发送接收数据）。</p>
<p><strong>半双工</strong>(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。 例如，在一个局域网上使用具有<strong>半双工</strong>传输的技术，一个工作站可以在线上发送数据，然后立即在线上接收数据，这些数据来自数据刚刚传输的方向。 类似于我们现在的对讲机，只有一端可以说话，在一段说话时对端只能听不能说。</p>
<h3 id="（七）冲突域、广播域"><a href="#（七）冲突域、广播域" class="headerlink" title="（七）冲突域、广播域"></a>（七）冲突域、广播域</h3><p>冲突域：可以理解称为<strong>物理划分</strong>，冲突域是连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。这个域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。冲突域中所有节点都链接到同一个被交换机和学习型网桥划分的相互连接的中继器集合。冲突域一般来说小于或者包含在广播域中。 一些处在数据链路层的设备能够划分冲突域，但是广播域只能由像路由器或者网络层交换机这样的网络层的设备来进行划分。</p>
<p>广播域：广播域是计算机网络的一个<strong>逻辑划分</strong>。广播域中的任意一个节点可以在数据链路层通过广播的方式到达任意一个节点。广播域可以被部署在同一个局域网或者被桥接到其他的局域网。</p>
<p><strong>冲突域是发送一个单播会影响的范围，广播域是发送一个广播会影响的范围。</strong> 二层设备（例如二层交换机）可以分割冲突域，交换机的每个接口都是一个单独的冲突域；三层设备（例如路由器）可以分割广播域，路由器的每个接口都i是一个单独的广播域，一些靠广播才能工作的协议，例如ARP、DHCP协议，到路由器接口就被隔绝了，需要进行适当的中继配置才能跨广播域起到效果。</p>
<h3 id="（八）网关"><a href="#（八）网关" class="headerlink" title="（八）网关"></a>（八）网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。举个现实生活中的例子方便理解，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络（192.168.10.0/24）向另一个网络（192.168.20.0/24）发送信息，也必须经过一道“关口”，这道关口就是网关，具体来说，如果要跨网段传输数据时，要先把数据发给本网段的网关，由该网关把本网段的信息发给其他网段的网关，然后再由其他网段的网关发给目的设备。</p>
<h3 id="（九）泛洪"><a href="#（九）泛洪" class="headerlink" title="（九）泛洪"></a>（九）泛洪</h3><p>交换机将数据从所有的端口（除了接收到此帧的端口）发送出去，通常称为泛洪。如果配置了VLAN，泛洪也只在属于该VLAN ID的端口上泛洪。</p>
<h2 id="六、各层介绍"><a href="#六、各层介绍" class="headerlink" title="六、各层介绍"></a>六、各层介绍</h2><h3 id="（第七层）应用层（Application）"><a href="#（第七层）应用层（Application）" class="headerlink" title="（第七层）应用层（Application）"></a>（第七层）应用层（Application）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175324-1574502824777.png" alt="微信截图_20191123175324"></p>
<p>应用层是最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。注意，<strong>应用层并非由计算机上运行的实际应用软件组成，而是由向应用程序提供访问网络资源的API（Application Program Interface，应用程序接口）组成</strong>，这类应用软件程序超出了OSI模型的范畴。应用层的功能一般包括标识通信伙伴、定义资源的可用性和同步通信。因为可能丢失通信伙伴，应用层必须为传输数据的应用子程序定义通信伙伴的标识和可用性。定义资源可用性时，应用层为了请求通信而必须判定是否有足够的网络资源。在同步通信中，所有应用程序之间的通信都需要应用层的协同操作。 </p>
<p>就是应用软件使用的协议，如邮箱使用的POP3，SMTP、远程登录使用的Telnet、获取IP地址的DHCP、域名解析的DNS、网页浏览的http协议等；这部分协议主要是规定应用软件如何去进行通信的。</p>
<p>http(80)、https（443）、 dns(53)、ftp(20/21)、smtp(25)、pop3(110)、telnet(23)</p>
<h3 id="（第六层）表示层（Presentation）"><a href="#（第六层）表示层（Presentation）" class="headerlink" title="（第六层）表示层（Presentation）"></a>（第六层）表示层（Presentation）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175412.png" alt="微信截图_20191123175412"></p>
<p>表示层提供多种功能用于应用层数据编码和转化，以确保以一个系统应用层发送的信息可以被另一个系统应用层识别。表示层的编码和转化模式包括公用数据表示格式、性能转化表示格式、公用数据压缩模式和公用数据加密模式。 </p>
<p>决定数据的展现（编码）形式，如同一部电影可以采样、量化、编码为RMVB、AVI，一张图片能够是JPEG、BMP、PNG等。</p>
<h3 id="（第五层）会话层（Session）"><a href="#（第五层）会话层（Session）" class="headerlink" title="（第五层）会话层（Session）"></a>（第五层）会话层（Session）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175603.png" alt="微信截图_20191123175603"></p>
<p>为两端通信实体建立、管理及中断连接（会话），中间有认证鉴权以及检查点记录（供会话意外中断的时候可以继续，类似断点续传）,并提供3种不同的方式来组织它们之间的通信：单工、半双工、全双工 。</p>
<h3 id="（第四层）传输层（Transport）-lt-数据段-gt"><a href="#（第四层）传输层（Transport）-lt-数据段-gt" class="headerlink" title="（第四层）传输层（Transport）&lt;数据段&gt;"></a>（第四层）传输层（Transport）&lt;数据段&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175629.png" alt="微信截图_20191123175629"></p>
<p>将一个数据/文件斩件分成很多小段，标记顺序以被对端接收后可以按顺序重组数据，另外标记该应用程序使用的端口号及提供QOS（不同的应用程序使用不同计算机的端口号，同样的应用程序需要使用一样的端口号才能正常通信） 。传输层的协议有TCP、UDP。</p>
<h3 id="（第三层）网络层-Network-lt-数据包-gt"><a href="#（第三层）网络层-Network-lt-数据包-gt" class="headerlink" title="（第三层）网络层(Network)&lt;数据包&gt;"></a>（第三层）网络层(Network)&lt;数据包&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175655.png" alt="微信截图_20191123175655"></p>
<p>OSI参考模型规定网络层的主要功能有以下三点： </p>
<p>1．路径选择与中继。在点-点连接的通信子网中，信息从源结点出发，要经过若干个中继结点的存储转发后，才能到达目的结点。通信子网中的路径是指从源结点到目的结点之间的一条通路，它可以表示为从源结点到目的结点之间的相邻结点及其链路的有序集合。一般在两个结点之间都会有多条路径选择。路径选择是指在通信子网中，源结点和中间结点为将报文分组传送到目的结点而对其后继结点的选择，这是网络层所要完成的主要功能之一。 </p>
<p>2．流量控制。网络中多个层次都存在流量控制问题，网络层的流量控制则对进入分组交换网的通信量加以一定的控制，以防因通信量过大造成通信子网性能下降。 </p>
<p>3．网络连接建立与管理。在面向连接服务中，网络连接是传输实体之间传送数据的逻辑的、贯穿通信子网的端—端通信通道。</p>
<p>路由选路，选择本次通信使用的协议（http、ftp等），指定路由策略及访问控制策略（ospf、eigrp、BGP等协议），使用协议号标识上层应用 ，<strong>（IP地址在这一层，路由器以及三层交换机属于三层设备）</strong> 网络层的协议有IPV4、IPV6、OSPF等协议。</p>
<h3 id="（第二层）数据链路层-Data-Link-Layer-lt-数据帧-gt"><a href="#（第二层）数据链路层-Data-Link-Layer-lt-数据帧-gt" class="headerlink" title="（第二层）数据链路层(Data Link Layer)&lt;数据帧&gt;"></a>（第二层）数据链路层(Data Link Layer)&lt;数据帧&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175720.png" alt="微信截图_20191123175720"></p>
<p>实际的物理链路是不可靠的，总会出现错误，<strong>数据链路层的作用就是通过一定的手段（将数据分成帧，以数据帧为单位进行传输）将有差错的物理链路转化成对上层来说没有错误的数据链路。</strong>它的特征参数包括：物理地址、网络拓朴结构、错误警告机制、所传数据帧的排序和流控等。其中物理地址是相对网络层地址而言的，它代表了数据链路层的节点标识技术。</p>
<p>根据端口与MAC地址，做分组（VLAN）隔离、端口安全、访问控制。（<strong>MAC地址在这一层，二层交换机属于二层设备</strong>）处理VLAN内的数据帧转发，跨VLAN间的访问，需要上升到网络层。 数据链路层有FCS（帧检验字段）用于检测数据的完整性。数据链路层的协议有ARP、PPPOE等。</p>
<h4 id="两个子层"><a href="#两个子层" class="headerlink" title="两个子层"></a>两个子层</h4><h5 id="LLC子层："><a href="#LLC子层：" class="headerlink" title="LLC子层："></a>LLC子层：</h5><p>负责识别Network layer 协议然后封装(encapsulate)数据.LLC 头部信息告诉Data Link layer 如何处理接受到的帧,LLC 也提供流控制和控制比特的编号 。</p>
<h5 id="MAC子层："><a href="#MAC子层：" class="headerlink" title="MAC子层："></a>MAC子层：</h5><p>这层定义了物理地址和拓扑结构,错误检测,流控制等.共享带宽,CSMA/CD先到先服务原则(FCFS) 。</p>
<p>物理地址通常为MAC地址：</p>
<p>MAC地址是烧录在Network Interface Card(网卡,NIC)里的MAC地址,也叫硬件地址,是由48比特长,16进制的数字组成。 </p>
<p>0 -24位 由厂家自己分配。</p>
<p>25-47位 组织唯一标志符(organizationally unique identifier,OUI).OUI是由IEEE分配给每个组织.组织按高到低的顺序分配1个唯一的全局地址给每个网卡以保证不会有重复的编号。</p>
<p>第47位 individual/Group(I/G)位,当I/G位为0的时候,我们可以设想这个地址是MAC地址的实际地址可以出现在MAC头部信息;当I/G位为1的时候,我们可以设想它为广播或多播。</p>
<p>第46位 G/L位,也叫U/L位.当这个位为0的时候代表它是由IEEE分配的全局地址;当这个位为1的时候,代表本地管理地址（例如在DECnet当中）。</p>
<p>CSMA/CD载波监听多路访问/冲突检测(carrier scnse multiple access collision detect)：设备准备发送数据以前先检查载波信首的介质访问机制。当一个节点想在网络中发送数据时，它首先检查线路上是否有其他主机的信号在传送：如果有，说明其他主机在发送数据，自己则利用退避算法等一会再试图发送；如果线路上没有其他主机的信号，自己就将数据发送出去，同时，不停的监听线路，以确信其他主机没有发送数据，如果检测到有其他信号，自己就发送一个JAM阻塞信号，通知网段上的其他节点停止发送数据，这时，其他节点也必须采用退避算法等一会再试图发送。</p>
<h3 id="（第一层）物理层-Physical-Layer-lt-比特-gt"><a href="#（第一层）物理层-Physical-Layer-lt-比特-gt" class="headerlink" title="（第一层）物理层(Physical Layer)&lt;比特&gt;"></a>（第一层）物理层(Physical Layer)&lt;比特&gt;</h3><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164057.png" alt="微信截图_20191123164057" style="zoom:50%;">

<img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164152.png" alt="微信截图_20191123164152" style="zoom: 50%;">

<img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164159.png" alt="微信截图_20191123164159" style="zoom:50%;">



<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>物理层定义了通讯网络之间物理链路的电气或机械特性，以及激活、维护和关闭这条链路的各项操作。物理层特征参数包括：电压、数据传输率、最大传输距离、物理连接媒体等。</p>
<p>物理层将数据最终编码为用0、1标识的比特流，然后传输。（例如将QQ头像的图片，变为一串01100111100这样的数字来表示）。 <strong>物理层的作用就是通过物理手段把电脑连接起来，它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。物理层的协议有蓝牙（802.15）等。</strong></p>
<h4 id="2、介质"><a href="#2、介质" class="headerlink" title="2、介质"></a>2、介质</h4><p>同轴电缆、双绞线（非屏蔽双绞线、屏蔽双绞线），更多具体说明请看 <a href="https://renyuan431.github.io/2019/11/16/lan-and-fiber/">https://renyuan431.github.io/2019/11/16/lan-and-fiber/</a> </p>
<h4 id="3、设备"><a href="#3、设备" class="headerlink" title="3、设备"></a>3、设备</h4><p>物理层典型的设备有集线器（hub）、中继器（reperter）.中继器可以放大信号，延长网线传输距离。一般网线理论传输距离为100米，实际工作中不建议在超过70米的地方使用，丢包会很严重，传输质量无法保障；集线器相当于一个多端口的中继器，也能起到信号放大的作用，但集线器在半双工模式下工作，同一时间只能有一个方向的数据可以传输，发送的时候不能接收，接收的时候不能发送，所以集线器的所有接口都属于同一个冲突域。集线器的工作过程是接收到一个端口发来的数据后，将数据直接转发到除接收到这个数据的端口以外的所有端口上，工作效率比较低下，集线器已经被淘汰。</p>
<h2 id="七、封装、解封装"><a href="#七、封装、解封装" class="headerlink" title="七、封装、解封装"></a>七、封装、解封装</h2><h3 id="（一）封装"><a href="#（一）封装" class="headerlink" title="（一）封装"></a>（一）封装</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>将数据变为比特流的过程中，在参考模型的每一层需要添加上特定的协议报头动作。</p>
<h4 id="2、动作"><a href="#2、动作" class="headerlink" title="2、动作"></a>2、动作</h4><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175033.png" alt="微信截图_20191123175033"></p>
<p>从高层往低层依次封装，在每一层使用特定的协议，对数据进行处理，在数据前添加特定的协议报头。L代表layer，表示第几层，H表示header，表示报头，第七层的报头在DATA（数据）的前面，表示数据在第七层（应用层）的时候前边加上了该层的报头。再到下一层（第六层，表示层）时前面又加上了第六层的报头，以此类推，到了第一层物理层的时候，打上了各层报头的数据被转换成0101的电信号发送给其他设备。</p>
<p>大概流程可以理解为：在传输层将数据分段，并加入TCP头，在网络层加入IP地址，在数据链路层分别加入LLC头和MAC头，最后转换成电信号在物理层传输。 </p>
<h4 id="3、封装原则"><a href="#3、封装原则" class="headerlink" title="3、封装原则"></a>3、封装原则</h4><p>（1）每一层在上一层数据前添加协议报头</p>
<p>注：进行封装的时候是添加的“协议报头”，目前三层封装协议主要是IP协议，二层协议主要是以太网2协议，不代表只有这两个协议才能对二、三层进行封装。四层主要有TCP\UDP两个协议组成，所以在进行四层封装的时候添加的主要是这两个协议的报头。</p>
<p>（2）添加完协议报头的整体，就是该层的PDU</p>
<p>（3）每一层的PDU对于下一层来说就是上层数据（每一层的上层数据就是上层的PDU）。</p>
<h4 id="4、封装的必要参数"><a href="#4、封装的必要参数" class="headerlink" title="4、封装的必要参数"></a>4、封装的必要参数</h4><p>传输层：源端口号     目标端口号</p>
<p>网络层：源IP地址     目标IP地址</p>
<p>数据链路层：源MAC地址   目标MAC地址</p>
<h3 id="（二）解封装"><a href="#（二）解封装" class="headerlink" title="（二）解封装"></a>（二）解封装</h3><h4 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h4><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175058.png" alt="微信截图_20191123175058"></p>
<p>封装的逆过程，数据从比特流还原为数据的过程</p>
<h4 id="2、动作-1"><a href="#2、动作-1" class="headerlink" title="2、动作"></a>2、动作</h4><p>从底层往高层依次解封装，每解封装一层，会将该层的协议报头去掉</p>
<h4 id="3、解封装原则"><a href="#3、解封装原则" class="headerlink" title="3、解封装原则"></a>3、解封装原则</h4><p>（1）必须从底层往高层解封装</p>
<p>（2）解封装时，<strong>只有协议报头合理，才可以解封装</strong>，打个比方，你收到一个包裹，上面有你的名字还有你的家庭住址和电话才是你的，你才能拆开叫做合理。举例说明，<strong>如果拆二层封装，必须目的MAC地址为自己接收这个帧的MAC地址才可以进行二层解封装，如果拆三层封装，必须目的IP地址为自己接收这个数据包的IP地址才可以进行三层解封装。</strong></p>
<p>（3）解封装一旦停止，数据就会被丢弃</p>
<p>（4）解封装由接收者触发，数据必须经过解封装才可以被接收</p>
<h3 id="（三）PDU"><a href="#（三）PDU" class="headerlink" title="（三）PDU"></a>（三）PDU</h3><p><strong>PUD</strong>即协议数据单元（英语：Protocol Data Unit，缩写为_PDU_）。PDU包含来自上层的信息，以及当前层的实体附加的信息。 协议数据单元(Protocol Data Unit )物理层的 PDU是数据位（bit），数据链路层的 PDU是数据帧（frame），网络层的PDU是数据包（packet），传输层的 PDU是数据段（segment），其他更高层次的PDU是报文（message）。</p>
<h2 id="八、通信流程说明"><a href="#八、通信流程说明" class="headerlink" title="八、通信流程说明"></a>八、通信流程说明</h2><p>![o_0D_2V8B_`V86P43E6OKYDVV](OSI-7/o_0D_2V8B_%60V86P43E6OKYDVV.gif)</p>
<p><img src="/2019/11/18/OSI-7/osiencap.png" alt="osiencap"></p>
<p><img src="/2019/11/18/OSI-7/Y6OBY.gif" alt="Y6OBY"></p>
<p>从高层往低层依次封装，在每一层使用特定的协议，对数据进行处理，在数据前添加特定的协议报头。L代表layer，表示第几层，H表示header，表示报头，第七层的报头在DATA（数据）的前面，表示数据在第七层（应用层）的时候前边加上了该层的报头。再到下一层（第六层，表示层）时前面又加上了第六层的报头，以此类推，到了第一层物理层的时候，打上了各层报头的数据被转换成0101的电信号发送给其他设备。其他设备接到电信号后，由物理层将电信号转换成数据，然后发送到上层的数据链路层，拆二层报头识别后交给上一层，网络层继续拆封装并识别，以此类推直到应用层拆除所有层的报头后识别数据。</p>
<h3 id="（一）A——B通信说明（按OSI七层模型）"><a href="#（一）A——B通信说明（按OSI七层模型）" class="headerlink" title="（一）A——B通信说明（按OSI七层模型）"></a>（一）A——B通信说明（按OSI七层模型）</h3><p>两主机通信的过程，从发送者（以下简称A）到接收者（以下简称B），属于从7层（应用层）-&gt;1层（物理层）封装，然后传输到远端，再从1层（物理层）-&gt;7层（应用层）解封装的过程。</p>
<p>2个主机之间的通信，对于2台主机来说，肯定是都需要跨越7层的，而平常说的只需要去到2层或者3层，其实是对于中间系统而言的，就是说中间的交换机、路由器而言。</p>
<p>1、 当A打开了QQ这个软件，相当就到达<strong>应用层</strong>了；因为软件会根据你的操作调动机器底层的硬件工作了。  </p>
<p>2、 当A往QQ这个软件的聊天窗口里面输入信息，发出后，QQ会将这个信息保存在本地聊天记录文件MSGEX.db（一般就保存在QQ目录下以你的QQ号码为文件夹里）。以某种格式编码/保存某种信息，这可以理解为<strong>表示层</strong>了。  </p>
<p>3、 当A打开与B的聊天窗口，输入信息，按下“输入”按钮，用户的操作就完结了，剩下都是机器自己的操作了。实际传输之前QQ会先建立A与B的会话连接，才真正开始传输信息/数据（你可以理解借传输文件理解：你发送文件给对方，要等待对方按下接收，才算建立了会话，然后才开始传输。）这算<strong>会话层</strong>了。  </p>
<p>4、 会话建立后，会将A发的信息斩件，如A发送“你吃了饭没有”？<strong>传输层</strong>将这句话斩成“你”“吃”“了”“饭”“没”“有”6个数据段，标记号使用的端口号，然后准备发出去。  </p>
<p>5、 接上一层，信息还未发出去，这时候在<strong>网络层</strong>做路由选路，可以理解为，从A家出去，可以分别经“联通”“电信”“移动”3个网络中的一个再到B家。</p>
<p>网络层根据路由协议负责选路（根据链路质量、带宽、开销等方法论）。假设最后选了2条，可能就A-&gt;联通-&gt;B发送“你”“吃”“了”3个数据段，A-&gt;电信-&gt;B发送“饭”“没”“有”3个数据段。</p>
<p>选路后，<strong>这一层要标记IP包头，包头主要内容是源IP地址，目的IP地址，使用什么协议</strong>。其中源、目的IP相当于你寄信的时候的收发的地址与邮政编码，标记出发送者与接收者。而协议相当于这封信到底用什么语言书写。（只有保证2端使用同种语言，才能确保通信起来，否则你用英文写信给大妈，大妈怎么看得懂呢？）  </p>
<p>6、 然后再到<strong>数据链路层</strong>，数据链路层主要是负责同一个子网内的通信的。例如A、B连接在同一台二层交换机，就属于同一个子网，那么数据帧的通信室是不需要通过网络层的（即三层交换机或者路由器），直接在这台二层交换机就过去了。<strong>这一层打的是MAC地址的帧头，对于上述通信过程来说，就是为数据帧打上A的机器的MAC与A的网关的MAC</strong>。这一层的工作就完成了。  </p>
<p>7、 到<strong>物理层</strong>了，经过上述斩件、打完各层标签后的6个数据帧，物理层将他们翻译为N段0、1表示的比特流，然后通过光纤、铜缆进行传输。  </p>
<p>8、 当比特流传输到了远端，接着B的机器按照上述的1~7的步骤反方向运行一次即可（即由物理层到应用层）。就是一层层读取标签，传输给标签标记着的相应对象，然后摘除标签，再读取上一层标签，直到最后B的应用程序能够读到A往应用程序输入的数据为止。</p>
<h3 id="（二）A——B通信说明（按实际）"><a href="#（二）A——B通信说明（按实际）" class="headerlink" title="（二）A——B通信说明（按实际）"></a>（二）A——B通信说明（按实际）</h3><h4 id="1、总体原则"><a href="#1、总体原则" class="headerlink" title="1、总体原则"></a>1、总体原则</h4><p><img src="/2019/11/18/OSI-7/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<h4 id="2、局域网（LAN）通信步骤"><a href="#2、局域网（LAN）通信步骤" class="headerlink" title="2、局域网（LAN）通信步骤"></a>2、局域网（LAN）通信步骤</h4><p><img src="/2019/11/18/OSI-7/switch.jpg" alt="switch"></p>
<ul>
<li><p>交换机如果刚刚加电启动，它的MAC地址缓存为空，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址，根据OSI七层模型，我们知道，下四层每一层需要封装本层的报头，三层网络层封装的时候需要源目的IP地址，二层数据链路层封装的时候需要原目的MAC地址，这里PC1只知道PC3的IP地址和自己的IP地址，所以三层需要封装的参数已经知道了，但在开始通信的时候，二层封装的目的MAC地址还不知道，所以需要获得MAC地址才能完成二层数据链路层的封装，PC1会使用ARP（Address Resolution Protocol，缩写：<strong>ARP</strong>）这个协议去获取目的MAC地址用来完成二层封装。</p>
</li>
<li><p>假设PC1已经知道C的MAC地址（ARP获得目的MAC地址的过程在后边讨论）而Switch的MAC地址表项为空，PC1将数据封装好发送给Switch，Switch从接口1接收到PC1发过来的数据后，首先对数据进行解封装，将0101的比特流还原成数据，然后对二层进行解封装，知道了该数据帧的源、目的MAC地址，然后添加这个数据帧的源MAC地址，既PC1的MAC地址（AAAAAAAAAA）和对应的端口G0/1添加到自己的MAC地址表中方便以后再进行数据传输时使用，然后从自己的MAC地址表中去查找这个数据帧目的地PC3（CCCCCCCCCC）的MAC地址，但是此时由于MAC地址表项为空所以找不到对应的MAC地址，这时Switch将这个数据封装上二层帧头，从除了收到这个数据的G0/1以外的其他接口（G0/2、G0/3、G0/0）泛洪出去；</p>
</li>
<li><p>PC2和PC4都接收到了这个数据帧，这两台设备对数据帧进行解封装后查看该数据帧的目的MAC地址，发现目的MAC地址与自己的网卡MAC地址不相同，PC2和PC4丢弃这个数据帧；</p>
</li>
<li><p>在上一步中PC3也同时收到了这个数据帧，PC3对数据进行解封装后，检查目的MAC地址的时候发现，与本机相同，PC3接收这个数据包，并回发数据包对PC1进行确认，PC3封装一个源地址为自己MAC地址，目的地址是A的MAC地址，源IP为自己IP，目的IP为PC1的IP地址的数据发送给Switch；</p>
</li>
<li><p>Switch接收到这个数据，它首先添加PC3的MAC和对应的接口G0/3到自己的MAC地址表中，然后查询源MA地址表时候发现PC1的MAC地址在MAC地址表项中可以查到，此MAC地址对应端口为G0/1，Switch将这个数据帧发给接口G0/1的PC1；</p>
</li>
<li><p>PC1收到PC3发回的确认，通信成功；</p>
</li>
<li><p>通过这种形式，Switch学习到的MAC地址以及所在接口。如下：</p>
</li>
</ul>
<p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191124185137.jpg" alt="微信截图_20191124185137"></p>
<p>通过不停的通信，最终Switch能够获得所有端口对应的MAC地址，但需注意，MAC地址表项的老化时间为300秒，如果超过老化时间，表项会被删除，Switch需重新泛洪以获取目的MAC地址对应的表项。思科交换机查看MAC地址表的命令为：<strong>show mac-address</strong> </p>
<h4 id="3、广域网（WAN）通信步骤"><a href="#3、广域网（WAN）通信步骤" class="headerlink" title="3、广域网（WAN）通信步骤"></a>3、广域网（WAN）通信步骤</h4><p><img src="/2019/11/18/OSI-7/newL3-PC1-PC2.png" alt="newL3-PC1-PC2"></p>
<p>假设交换机如果刚刚加电启动，它的MAC地址缓存为空，两台PC的网关分别为路由器的G0/0和G0/1，此时路由器Router有去往PC1（192.168.10.1）和PC2（192.168.20.1）的路由，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址，PC1首先判断通信对象PC2的IP是否为同一网段地址，此时PC2为不同网段，所以数据要先发给自身的网关（192.168.10.254），所以数据的源MAC地址为PC1的MAC地址，目的MAC地址为网关（192.168.10.254）对应的MAC地址，源IP地址为自身IP地址（192.168.10.1），目的IP地址为PC2的IP地址（192.168.20.1），抓包的结果如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1.jpg" alt="PC1"></p>
<p>PC1的G0/0接口的MAC地址如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1-1.jpg" alt="PC1-1"></p>
<p>网关，Router的G0/0接口MAC地址如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1-2.jpg" alt="PC1-2"></p>
<p>路由器接到数据以后，首先对数据进行解封装，将0101的比特流还原成数据，然后对二层进行解封装，查看二层的目的MAC地址和接收端口G0/0的MAC地址是否一致，确定两者一致后继续对三层解封装查看目的IP地址，网关根据目的IP按照最长匹配原则查询是否有对应路由条目，在这里路由器是有10.0网段和20.0网段的路由的：</p>
<p><img src="/2019/11/18/OSI-7/route.jpg" alt="route"></p>
<p>查询路由表发现192.168.20.0网段直连G0/1接口，需要讲数据从G0/1发出，此时三层的源、目的IP地址封装是不变的，二层封装的MAC地址发生变化，源MAC地址为发出接口的G0/1的MAC地址，目的地址为PC2的G0/0接口MAC地址：</p>
<p><img src="/2019/11/18/OSI-7/PC2-2.jpg" alt="PC2-2"></p>
<p><img src="/2019/11/18/OSI-7/PC2-3.jpg" alt="PC2-3"></p>
<p><img src="/2019/11/18/OSI-7/PC2-4.jpg" alt="PC2-4"></p>
<p><img src="/2019/11/18/OSI-7/PC2.jpg" alt="PC2"></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>4、基础知识</title>
    <url>/2019/11/18/basic-knowledge/</url>
    <content><![CDATA[<h2 id="一、位（bit）与字节（byte）"><a href="#一、位（bit）与字节（byte）" class="headerlink" title="一、位（bit）与字节（byte）"></a>一、位（bit）与字节（byte）</h2><h3 id="（一）位（bit）"><a href="#（一）位（bit）" class="headerlink" title="（一）位（bit）"></a>（一）位（bit）</h3><p>来自英文bit，音译为“比特”，表示一个二进制位（0或者1）。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态（21）；两个二进制位可以表示00、01、10、11四种（22）状态。</p>
<h3 id="（二）字节（byte）"><a href="#（二）字节（byte）" class="headerlink" title="（二）字节（byte）"></a>（二）字节（byte）</h3><p>字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节（Byte）由连续八个二进制位（bit）构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。</p>
 <span id="more"></span>  

<h3 id="（三）位与字节关系举例"><a href="#（三）位与字节关系举例" class="headerlink" title="（三）位与字节关系举例"></a>（三）位与字节关系举例</h3><p>生活中办理的宽带的带宽，比如100M宽带其实是100Mbit/s，换算成Byte/s约等于11MByte/s左右。</p>
<p>计算方法：100Mbit/s*1000&lt;换算成K&gt;*1000&lt;换算成bit&gt;除以8除以1024&lt;换算成K&gt;除以1024&lt;换算成M&gt;  ≈  11MByte/s</p>
<p>1Kbit=1000bit ； 1Mbit=1000Kbit  ;  1Gbit=1000Mbit 1Kbyte=1024Byte  ;  1Mbyte=1024Kbyte  ;  1Gbyte=1024Mbyte</p>
<p><img src="/2019/11/18/basic-knowledge/p.jpg" alt="p"></p>
<p><img src="/2019/11/18/basic-knowledge/QQ%E6%88%AA%E5%9B%BE20191118190909.jpg" alt="QQ截图20191118190909"></p>
<h2 id="二、进制换算"><a href="#二、进制换算" class="headerlink" title="二、进制换算"></a><a href="https://www.cnblogs.com/gaizai/p/4233780.html">二、进制换算</a></h2><h3 id="各进制之间转换总体图"><a href="#各进制之间转换总体图" class="headerlink" title="各进制之间转换总体图"></a>各进制之间转换总体图</h3><p> <img src="/2019/11/18/basic-knowledge/191445561883615.png" alt="wpsC01D.tmp"> </p>
<h3 id="一-（二、八、十六进制）-→-（十进制）"><a href="#一-（二、八、十六进制）-→-（十进制）" class="headerlink" title="(一) （二、八、十六进制） → （十进制）"></a><strong>(一) （二、八、十六进制） → （十进制）</strong></h3><h4 id="1、二进制-→-十进制"><a href="#1、二进制-→-十进制" class="headerlink" title="1、二进制 → 十进制"></a><strong>1、二进制 → 十进制</strong></h4><p>　　方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>例：将二进制的(101011)B转换为十进制的步骤如下：</p>
<p>1. 第0位 1 x 2^0 = 1；</p>
<p>2. 第1位 1 x 2^1 = 2；</p>
<p>3. 第2位 0 x 2^2 = 0；</p>
<p>4. 第3位 1 x 2^3 = 8；</p>
<p>5. 第4位 0 x 2^4 = 0；</p>
<p>6. 第5位 1 x 2^5 = 32；</p>
<p>7. 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。</p>
<h4 id="2、八进制-→-十进制"><a href="#2、八进制-→-十进制" class="headerlink" title="2、八进制 → 十进制"></a><strong>2、八进制 → 十进制</strong></h4><p>　　方法：八进制数从低位到高位（即从右往左）计算，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>　　八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。</p>
<p>　　例：将八进制的(53)O转换为十进制的步骤如下：</p>
<p>1. 第0位 3 x 8^0 = 3；</p>
<p>2. 第1位 5 x 8^1 = 40；</p>
<p>3. 读数，把结果值相加，3+40=43，即(53)O=(43)D。</p>
<h4 id="3、十六进制-→-十进制"><a href="#3、十六进制-→-十进制" class="headerlink" title="3、十六进制 → 十进制"></a><strong>3、十六进制 → 十进制</strong></h4><p>　　方法：十六进制数从低位到高位（即从右往左）计算，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>　　十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。</p>
<p>　　例：将十六进制的(2B)H转换为十进制的步骤如下：</p>
<p>1. 第0位 B x 16^0 = 11；</p>
<p>2. 第1位 2 x 16^1 = 32；</p>
<p>3. 读数，把结果值相加，11+32=43，即(2B)H=(43)D。</p>
<h3 id="二-（十进制）-→-（二、八、十六进制）"><a href="#二-（十进制）-→-（二、八、十六进制）" class="headerlink" title="(二) （十进制） → （二、八、十六进制）"></a><strong>(二) （十进制） → （二、八、十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191445595475175.png"><img src="/2019/11/18/basic-knowledge/191446004698089.png" alt="wpsC01F.tmp"></a></p>
<p>（Figure3：十进制转换为其它进制）</p>
<h4 id="1、十进制-→-二进制"><a href="#1、十进制-→-二进制" class="headerlink" title="1、十进制 → 二进制"></a><strong>1、十进制 → 二进制</strong></h4><p>　　方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 </p>
<p>　　例：将十进制的(43)D转换为二进制的步骤如下：</p>
<p>1. 将商43除以2，商21余数为1；</p>
<p>2. 将商21除以2，商10余数为1；</p>
<p>3. 将商10除以2，商5余数为0；</p>
<p>4. 将商5除以2，商2余数为1；</p>
<p>5. 将商2除以2，商1余数为0； </p>
<p>6. 将商1除以2，商0余数为1； </p>
<p>7. 读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446012199718.png"><img src="/2019/11/18/basic-knowledge/191446019539875.png" alt="wpsC02F.tmp"></a></p>
<p>（Figure4：图解十进制 → 二进制）</p>
<h4 id="2、十进制-→-八进制"><a href="#2、十进制-→-八进制" class="headerlink" title="2、十进制 → 八进制"></a><strong>2、十进制 → 八进制</strong></h4><p>　　方法1：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p>
<p>　　例：将十进制的(796)D转换为八进制的步骤如下：</p>
<p>1. 将商796除以8，商99余数为4；</p>
<p>2. 将商99除以8，商12余数为3；</p>
<p>3. 将商12除以8，商1余数为4；</p>
<p>4. 将商1除以8，商0余数为1；</p>
<p>5. 读数，因为最后一位是经过多次除以8才得到的，因此它是最高位，读数字从最后的余数向前读，1434，即(796)D=(1434)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446027976234.png"><img src="/2019/11/18/basic-knowledge/191446033751877.png" alt="wpsC030.tmp"></a></p>
<p>（Figure5：图解十进制 → 八进制）</p>
<p>　　方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成八进制；</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446044383535.png"><img src="/2019/11/18/basic-knowledge/191446059386793.png" alt="wpsC031.tmp"></a></p>
<p>（Figure6：图解十进制 → 八进制）</p>
<h4 id="3、十进制-→-十六进制"><a href="#3、十进制-→-十六进制" class="headerlink" title="3、十进制 → 十六进制"></a><strong>3、十进制 → 十六进制</strong></h4><p>　　方法1：除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p>
<p>　　例：将十进制的(796)D转换为十六进制的步骤如下：</p>
<p>1. 将商796除以16，商49余数为12，对应十六进制的C；</p>
<p>2. 将商49除以16，商3余数为1；</p>
<p>3. 将商3除以16，商0余数为3；</p>
<p>4. 读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446073607794.png"><img src="/2019/11/18/basic-knowledge/191446083759737.png" alt="wpsC042.tmp"></a></p>
<p>（Figure7：图解十进制 → 十六进制）</p>
<p>　　方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制；</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446096567695.png"><img src="/2019/11/18/basic-knowledge/191446107502896.png" alt="wpsC043.tmp"></a></p>
<p>（Figure8：图解十进制 → 十六进制）</p>
<h3 id="三-（二进制）-↔-（八、十六进制）"><a href="#三-（二进制）-↔-（八、十六进制）" class="headerlink" title="(三) （二进制） ↔ （八、十六进制）"></a><strong>(三) （二进制） ↔ （八、十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191446117669540.png"><img src="/2019/11/18/basic-knowledge/191446126101198.png" alt="wpsC044.tmp"></a></p>
<p>（Figure9：二进制转换为其它进制）</p>
<h4 id="1、二进制-→-八进制"><a href="#1、二进制-→-八进制" class="headerlink" title="1、二进制 → 八进制"></a><strong>1、二进制 → 八进制</strong></h4><p>　　方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。</p>
<p>　　例：将二进制的(11010111.0100111)B转换为八进制的步骤如下：</p>
<p>1. 小数点前111 = 7；</p>
<p>2. 010 = 2；</p>
<p>3. 11补全为011，011 = 3；</p>
<p>4. 小数点后010 = 2；</p>
<p>5. 011 = 3；</p>
<p>6. 1补全为100，100 = 4；</p>
<p>7. 读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446138756684.png"><img src="/2019/11/18/basic-knowledge/191446144855271.png" alt="wpsC054.tmp"></a></p>
<p>（Figure10：图解二进制 → 八进制）</p>
<p>二进制与八进制编码对应表：</p>
<p><img src="/2019/11/18/basic-knowledge/QQ%E6%88%AA%E5%9B%BE20191118191227.jpg" alt="QQ截图20191118191227"></p>
<h4 id="2、八进制-→-二进制"><a href="#2、八进制-→-二进制" class="headerlink" title="2、八进制 → 二进制"></a><strong>2、八进制 → 二进制</strong></h4><p>　　方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。</p>
<p>　　例：将八进制的(327)O转换为二进制的步骤如下：</p>
<p>1. 3 = 011；</p>
<p>2. 2 = 010；</p>
<p>3. 7 = 111；</p>
<p>4. 读数，读数从高位到低位，011010111，即(327)O=(11010111)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446152665143.png"><img src="/2019/11/18/basic-knowledge/191446161888058.png" alt="wpsC055.tmp"></a></p>
<p>（Figure11：图解八进制 → 二进制）</p>
<h4 id="3、二进制-→-十六进制"><a href="#3、二进制-→-十六进制" class="headerlink" title="3、二进制 → 十六进制"></a><strong>3、二进制 → 十六进制</strong></h4><p>　　方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。</p>
<p>　　例：将二进制的(11010111)B转换为十六进制的步骤如下：</p>
<p>1. 0111 = 7；</p>
<p>2. 1101 = D；</p>
<p>3. 读数，读数从高位到低位，即(11010111)B=(D7)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446167506929.png"><img src="/2019/11/18/basic-knowledge/191446173913759.png" alt="wpsC056.tmp"></a></p>
<p>（Figure12：图解二进制 → 十六进制）</p>
<h4 id="4、十六进制-→-二进制"><a href="#4、十六进制-→-二进制" class="headerlink" title="4、十六进制 → 二进制"></a><strong>4、十六进制 → 二进制</strong></h4><p>　　方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。</p>
<p>　　例：将十六进制的(D7)H转换为二进制的步骤如下：</p>
<p>1. D = 1101；</p>
<p>2. 7 = 0111；</p>
<p>3. 读数，读数从高位到低位，即(D7)H=(11010111)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446183444917.png"><img src="/2019/11/18/basic-knowledge/191446194223347.png" alt="wpsC057.tmp"></a></p>
<p>（Figure13：图解十六进制 → 二进制）</p>
<h3 id="四-（八进制）-↔-（十六进制）"><a href="#四-（八进制）-↔-（十六进制）" class="headerlink" title="(四) （八进制） ↔ （十六进制）"></a><strong>(四) （八进制） ↔ （十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191446207353847.png"><img src="/2019/11/18/basic-knowledge/191446216102748.png" alt="wpsC058.tmp"></a></p>
<p>（Figure14：八进制与十六进制之间的转换）</p>
<h4 id="1、八进制-→-十六进制"><a href="#1、八进制-→-十六进制" class="headerlink" title="1、八进制 → 十六进制"></a><strong>1、八进制 → 十六进制</strong></h4><p>　　方法：将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变。</p>
<p>　　例：将八进制的(327)O转换为十六进制的步骤如下：</p>
<p>1. 3 = 011；</p>
<p>2. 2 = 010；</p>
<p>3. 7 = 111；</p>
<p>4. 0111 = 7；</p>
<p>5. 1101 = D；</p>
<p>6. 读数，读数从高位到低位，D7，即(327)O=(D7)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446224386634.png"><img src="/2019/11/18/basic-knowledge/191446233756320.png" alt="wpsC069.tmp"></a></p>
<p>（Figure15：图解八进制 → 十六进制）</p>
<h4 id="2、十六进制-→-八进制"><a href="#2、十六进制-→-八进制" class="headerlink" title="2、十六进制 → 八进制"></a><strong>2、十六进制 → 八进制</strong></h4><p>　　方法：将十六进制转换为二进制，然后再将二进制转换为八进制，小数点位置不变。</p>
<p>　　例：将十六进制的(D7)H转换为八进制的步骤如下：</p>
<p>1. 7 = 0111；</p>
<p>2. D = 1101；</p>
<p>3. 0111 = 7；</p>
<p>4. 010 = 2；</p>
<p>5. 011 = 3；</p>
<p>6. 读数，读数从高位到低位，327，即(D7)H=(327)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446245008763.png"><img src="/2019/11/18/basic-knowledge/191446253919136.png" alt="wpsC06A.tmp"></a></p>
<p>（Figure16：图解十六进制 → 八进制）</p>
<p>此文从 <a href="https://www.cnblogs.com/gaizai/p/4233780.html">https://www.cnblogs.com/gaizai/p/4233780.html</a> 搬运，感谢原作者~</p>
<h2 id="三、带宽、网速、流量"><a href="#三、带宽、网速、流量" class="headerlink" title="三、带宽、网速、流量"></a>三、带宽、网速、流量</h2><p>通常情况下：我们说的带宽10M 20M ；现在网速：200KB/s ； 使用了8M的流量等，那么带宽、网速、流量之间有什么关系，他们分别代表什么呢？</p>
<p>带宽的统计单位是：比特/秒（bps）：10M=10Mbps；</p>
<p>网速是数据传输的速度，单位是：字节/秒（B/s KB/s MB/s）：1MB/s=1024KB/s ；1KB/s=1024B/s</p>
<p>流量是用户上网发送和接收的数据量总和，单位是：字节（Byte）；</p>
<p>网速和带宽是既有区别又有联系的。<br>宽带理论最大速度512k=512kbps=512k bits/s=64k bytes/s，1M=1024kbps=1024k bits/s=128k bytes/s，如此类推。。。。<br>即512Kb=64Kb/s.1M=128Kb/s,2M=256Kb/s(这是理论最大下载速度）</p>
<p>但实际上能达到的“最大”下载速度是1M的100Kb/s、2兆的200kb/s，3M的300。。。。<br>另外还有个标准（电信部门给的）：<br>· 512k用户的到达测速网站的速度大于 40KByte/s,即320Kbps时是属于正常的；<br>· 1M用户的到达测速网站的速度大于 80KByte/s,即640Kbps时是属于正常的；<br>· 2M以上用户的到达测速网站的速度大于 160KByte/s,即1280Kbps时是属于正常的；<br>· 3M以上用户的到达测速网站的速度大于 240KByte/s,即1920Kbps时是属于正常的；</p>
<p>比特是信息的最小单位：1字节=8比特（1B=8bit或者1B=8b）；1字节/秒=8比特/秒（1B/s=8bps）</p>
<p>1 Byte = 8 bits<br>1 Kb = 1024 bits<br>1 KB = 1024 bytes<br>1 Mb = 1024 Kb<br>1 MB = 1024 KB</p>
<p>　在这里要注意的是传输单位的写法上，B 和 b 分别代表 Bytes 和 bits，两者的定义是不同的，千万不要混淆了。否则差距可是8倍阿。</p>
<p>　所以各种宽带的极限下载值也可以轻易的计算出来。</p>
<p>1 M =112 KB/s<br>2 M =225 KB/s<br>8 M =901 KB/s<br>10 M =1126 KB/s</p>
<p>　Mbps实际上是一个带宽单位，而非速度单位，在“Mbps”单位中的“b”是指“Bit（位）”。而真正的速度单位应为MB/s，其中的“B”是指“Byte（字节）”。因为数据是按字节传输的，而并非按位。</p>
<p>　就因这两个大、小写不同的“B”和“b”，使得这两个单位不仅不能等同，而且相差甚远。当然它们之间也存在着较大关联的，那就是1MB/s=8Mbps，可以这么理解，那就是端口带宽是端口的理论最大传输速度，实际中的速度要远小于带宽值（通常为60~80%之间）。</p>
<p>1比特（1b or 1位）是信息技术中的最小存储单位，1位代表一个“1”或者“0”；</p>
<p>1B（1字节）是比较小的存储单位：1个英文字母占1个字节；一个汉字占2个字节；</p>
<p>他们之间的换算：10M带宽=1.25MB/s网速：1M带宽=0.125MB/s=128KB/s</p>
<p>10Mbps=10<em>1024Kbps=10</em>1024<em>1024bps=10</em>1024*1024/8 Byte/s=10/8 MB/s=1.25 MB/s</p>
<h2 id="四、可能会涉及到的术语"><a href="#四、可能会涉及到的术语" class="headerlink" title="四、可能会涉及到的术语"></a>四、可能会涉及到的术语</h2><h2 id="jitter"><a href="#jitter" class="headerlink" title="jitter"></a>jitter</h2><blockquote>
<p>Jitter is used to describe the degree of instability of delay.Jitter may be caused by <a href="https://en.wikipedia.org/wiki/Electromagnetic_interference">electromagnetic interference</a> and <a href="https://en.wikipedia.org/wiki/Crosstalk">crosstalk</a> with carriers of other signals. </p>
<p>抖动是用来形容延迟的不稳定程度的。抖动可能是由电磁干扰和与其他信号载波的串扰引起的。</p>
</blockquote>
<p>举个例子：</p>
<p>A：delay=100ms，测得实际幅度是98ms<del>102ms；B：delay=50ms，测的实际幅度是5ms</del>80ms。这时候，我们说，A的抖动（jitter）比B好，但是B的延迟（delay）比A好。</p>
<h2 id="delay"><a href="#delay" class="headerlink" title="delay"></a>delay</h2><h2 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h2><p><a href="https://zhuanlan.zhihu.com/p/50401281">浅谈带宽、网速和流量之间的关系</a></p>
<p><a href="https://www.cnblogs.com/gaizai/p/4233780.html">二、八、十、十六进制转换（图解篇）</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>1、学习方法</title>
    <url>/2019/11/16/how-to-learn-network-knowledge/</url>
    <content><![CDATA[<h1 id="学习网络知识的四个阶段"><a href="#学习网络知识的四个阶段" class="headerlink" title="学习网络知识的四个阶段"></a>学习网络知识的四个阶段</h1><p>（一）掌握协议的概念。这个协议的概念是什么，是在什么地方应用的，例如什么是路由，什么是交换。</p>
<p>（二）掌握如何使用。例如OSPF、EIGRP在现网中如何配置，如何查看，如何使用。</p>
<p>（三）掌握协议是如何工作的。协议的标准是什么，工作的机制是什么，例如EIGRP的DUAL算法是如何规定且工作的，OSPF的SPF算法是如何规定且工作的。</p>
<p>（四）掌握协议底层的工作机制和报文。例如OSPF协议中，两个路由器之间建立邻居的过程，反应在底层是什么样的，也就是报文是如何传输的，报文的格式是什么，每个报文中重要字段有什么，这些字段的含义是什么。</p>
<p>以上总结出自红茶三杯CCNP课程的路由选择原理。</p>
 <span id="more"></span>  

<p>对于计算机网络初学者来说，知道“为什么这么做”比“知道怎么做”更重要，虽然经历知道“为什么这么做？”的过程很痛苦，但一旦过了这个阶段，“知道怎么做”也就水到渠成了。但是对于初学者来说，真没必要那么深入地学习网络协议的细节，你只需要理解常见协议（例如HTTP、FTP、DHCP、DNS、ARP等常见协议）的工作过程，你理解了这些协议，理解其他的协议就是依葫芦画瓢，虽然计算机网络很讲究知识的积累，但如果你一开始把太多的精力放在了解细节上就会陷进只见树木不进森林的境地。</p>
<p>例如，数据包的结构，浏览一下各字段的作用就可以了，能记住就记住，记不住也没关系，你只需要先重点理解IP头部里的目的地址、源地址和TCP头部里的目的端口号、源端口号，这些比较简单且重要的字段的含义就行了，至于其他用的比较少的字段的含义以及每个位置为1或者0的含义这种相对难一些的概念，建议等对网络有一定的了解以后再进行学习；TCP/IP和OSI两个模型，只要先大概知道为什么要建立参考模型、每一层大概的作用及常见协议即可，我当时在入门的时候希望能把基础砸瓷实一些但事与愿违，在这两个章节纠结了很久，结果既没有弄明白每个细节，又耽误了学习进程，差点“从入门到放弃”。当然我的笔记中试图尽可能多的涵盖一些知识点，会将每一个字段的定义都写上，请参照每一篇笔记的新人学习建议进行选择性学习。</p>
<p><strong>强烈建议听懂一个知识点以后总结一份自己的笔记，因为很多东西听懂的和自己能总结完全不是一个层次，笔记是一个对知识消化并进一步总结归纳的过程，比简单的听懂视频看懂书籍要高了一个档次，虽然耗时更长，但对知识会有更深层次的理解并且记得更牢固。过一段时间回看自己的笔记，会发现自己相对之前有哪些提高。</strong></p>
<h1 id="学习一定要打好基础循序渐进"><a href="#学习一定要打好基础循序渐进" class="headerlink" title="学习一定要打好基础循序渐进"></a>学习一定要打好基础循序渐进</h1><p>这段像是一堆废话，但打好基础的过程是非常痛苦且无聊，因为一开始可能你根本看不懂这段在说什么，比如OSI七层模型每层的功能以及TCP\IP模型的报头格式这种纯理论的东西，在它所在的章节很难联系实际去理解掌握，一开始看起来很云里雾里的感觉，不像后面学了路由或者交换的知识以后马上可以在模拟器上验证，会有成就感，理论知识真的很枯燥乏味，但真心应该把这些东西掌握了再看后面，如果没有完全掌握也没关系，至少对这些理论知识的名词和概念大概有个印象，对一些重点的概念，比如报头中重要的字段，知道定义，哪怕是死记硬背下来不真正明白含义，后面等学到相关的章节或知识的时候，可能就能一通百通了，如果没真正明白也不要气馁，再翻回头对基础知识进行复习，周而复始总会真正掌握的。举个例子就是如果对二进制、十进制的换算不明白的话，会很难真正理解IP地址还有子网划分中的一些东西。</p>
<h1 id="遇到问题如何找寻答案"><a href="#遇到问题如何找寻答案" class="headerlink" title="遇到问题如何找寻答案"></a>遇到问题如何找寻答案</h1><p>如果周围有懂技术的朋友，请教他们是最快捷最直接的解决办法，但还是更建议通过搜索引擎、官方文档或做实验寻找答案，因为人的大脑可能记错答案但官方文档一般来说是不会出问题的，国内技术类网站都是中文，可以解决常见的一些疑问，但如果有比较冷门一些的问题，可能国内的中文网站已经很难找到解答，这时候思科的官方文档和官方社区是最好的求助对象，尤其是思科的官方论坛，经常有思科的技术大佬过去回答问题，是提升自我非常好的学习渠道，老外对技术细节的讨论十分到位，基本可以解决大部分疑惑，善用英文进行搜索能对学习起到很大的帮助。搜索引擎尽量别用百度，搜索的效率相对低一些，容易浪费时间。</p>
<h1 id="抓包有什么用？"><a href="#抓包有什么用？" class="headerlink" title="抓包有什么用？"></a>抓包有什么用？</h1><p>有一些故障的现象并不明显，并不是看配置就能那么轻易的找到问题的答案，需要去抓包分析，分析包的行为能帮助你给出一个排错的大概方向。一般来说 TCP用的比较多，IP头看分片，TOS字段比较多。TCP的话主要看TCP的一些机制和算法。</p>
<h1 id="如何下载学习资料"><a href="#如何下载学习资料" class="headerlink" title="如何下载学习资料"></a>如何下载学习资料</h1><p>推荐两个论坛，<a href="http://bbs.hh010.com/">鸿鹄论坛</a>以及<a href="http://bbs.vlan5.com/">攻城狮论坛</a>。鸿鹄论坛上的考试题库更新比较快，包含版本比较新，也有一些学习资料；攻城狮论坛上的学习资料比较丰富，基本上所有需要的资料在攻城狮论坛都能下载到。</p>
<h1 id="厂商的认证是否有必要考？"><a href="#厂商的认证是否有必要考？" class="headerlink" title="厂商的认证是否有必要考？"></a>厂商的认证是否有必要考？</h1><p>谈一下我浅薄的看法，还是比较建议考取厂商认证，一方面厂商认证的课程是由专业人士设计的，相对于在工作中遇到什么学什么这种学习方式，进行认证课程的学习能够在整体上比较牢固的搭建起你对网络的知识构架体系；另一方面认证也是一个敲门砖，让用人单位能更好的了解你的技术水平，为之后的面试打下基础。但拿到证书并不代表着拿到高薪offer，当上CTO，赢取白富美，走上人生巅峰，光有个认证而没有与之相匹配的技术能力是不行的，因为工作中遇到的问题不像考试有相应的答案，必须靠自己的技术去解决，所以应该将备考的过程视为提高自己技术水平的过程，在这个过程中加深对技术的理解和掌握，而且如果进入面试以后面试官发现你名不副实，花大价钱考下来的证书就显得一点用没有还会让用人单位觉得你名不副实，直接pass你。</p>
<h1 id="关于笔记的一些说明"><a href="#关于笔记的一些说明" class="headerlink" title="关于笔记的一些说明"></a>关于笔记的一些说明</h1><h2 id="关于笔记中的比喻"><a href="#关于笔记中的比喻" class="headerlink" title="关于笔记中的比喻"></a>关于笔记中的比喻</h2><p>这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用。——出自《为什么 TCP 建立连接需要三次握手》</p>
<p>我认为上面这段文字非常精髓的把在技术中使用比喻的优缺点都说到了，用比喻的话能够更快的让不懂这个技术的人较快的大概明白这个东西某一方面的特性或作用，但几乎所有比喻都不是完美的呈现事务本来面貌的，毕竟用生活中的东西和技术上的知识本来就属于两个差别比较大的不同范畴，不可能找到完全一样的事务做出完美的比喻，比喻后几乎一定会产生一定程度上的误导，笔记中既有严禁定义又使用了比喻是希望能更快的使读者对技术某一方面有更快更直观的理解，但希望看过比喻大概了解了一个技术后一定要去看该部分中更为严谨的描述，以便能够真正确切的掌握一个技术而不是仅仅对技术有个模糊且有一定偏差的印象，这不仅是对自己负责，也是今后靠技术吃饭拿到一定薪酬的保证。</p>
<h2 id="关于不同技术的出现"><a href="#关于不同技术的出现" class="headerlink" title="关于不同技术的出现"></a>关于不同技术的出现</h2><p>网络学习中比较让人头疼的一个情况就是，网络技术百花齐放般层出不穷，究其原因，新技术的出现一定是为了解决现网中遇到的实际问题或情况，而旧的技术往往不能解决或不能很好解决这些实际需要，才会开发新技术，比如后面的动态路由协议部分中，现网中有不同的动态路由协议在使用，比如BGP、OSPF等，在一般情况下OSPF协议能满足大多数企业网络的需要，但由于OSPF协议算法的限制，无法承载大批量路由条目，所以在运营商这种路由条目繁多的环境中，会使用IS - IS路由协议，但该协议也无法承载运营商之间超大规模交互路由条目的任务，这时候BGP协议粉墨登场，解决这种情况下的实际需要。所以建议在学技术时不仅要知其然，也要知其所以然，也就是不仅要知道这项技术如何使用，也要明白这项技术是为何而生，使用场景是什么，和其他协议相比有什么不同的特点。</p>
<h2 id="关于笔记中的英文"><a href="#关于笔记中的英文" class="headerlink" title="关于笔记中的英文"></a>关于笔记中的英文</h2><p>笔记中引用了一些英文的文章，在解释一些术语的时候也尽量中英文都写，主要是因为权威的RFC文档通常采用英文撰写，多了解一些专业词汇的英文是个只赚不赔的事，毕竟不可能所有疑问都有人能请教，当没法向别人请教网上又没有相应的中文资料时，查询RFC或用英文搜索是个不错的选择，多一种语言能力也能在找工作时多一个加分项。</p>
<h1 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h1><p><a href="https://www.zhihu.com/question/51074319">TCP/IP 协议到底在讲什么</a></p>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p>
<img src="/2019/11/16/how-to-learn-network-knowledge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201012200720.jpg" alt="微信图片_20201012200720" style="zoom: 25%;">]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>3、网线和光纤</title>
    <url>/2019/11/16/lan-and-fiber/</url>
    <content><![CDATA[<h2 id="一、网线"><a href="#一、网线" class="headerlink" title="一、网线"></a>一、网线</h2><h3 id="（一）网线简介"><a href="#（一）网线简介" class="headerlink" title="（一）网线简介"></a>（一）网线简介</h3><p><strong>双绞线</strong>（twisted pair，TP）是一种综合布线工程中最常用的传输介质，是由两根具有绝缘保护层的铜导线组成的。 把两根绝缘的铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。</p>
<img src="/2019/11/16/lan-and-fiber/UTP_cable.jpg" alt="UTP_cable" style="zoom: 67%;">

 <span id="more"></span>  



<h3 id="（二）网线分类"><a href="#（二）网线分类" class="headerlink" title="（二）网线分类"></a>（二）网线分类</h3><p>双绞线分2类，屏蔽双绞线（STP）与非屏蔽双绞线(UTP)。最大传输距离为100米，但工程中不建议使用超过75米，否则会误码率比较高导致数据传输质量下降。</p>
<h4 id="屏蔽双绞线："><a href="#屏蔽双绞线：" class="headerlink" title="屏蔽双绞线："></a>屏蔽双绞线：</h4><p>由四组两条一对地互相缠绕并包装在绝缘管套中的铜线所组成，四对不同颜色的传输线互相缠绕，每对相同颜色的线传递著来回两方向的电脉冲，这样的设计是<strong>利用了电磁感应相互抵销的原理来屏蔽电磁干扰</strong>。双绞线外的金属网（通常是铜质或铝箔）可以进一步屏蔽传输线，使之较不受外部电磁场干扰。价格相对较高，在高要求场合应用。</p>
<h4 id="非屏蔽双绞线："><a href="#非屏蔽双绞线：" class="headerlink" title="非屏蔽双绞线："></a>非屏蔽双绞线：</h4><p>构造和屏蔽双绞线相同，不过外部没有金属网包裹，价格更低、直径更小、重量更轻、易安装、易弯曲，但抗干扰性相对弱一些，在大多数环境中使用广泛。</p>
<p>一般常见的都是非屏蔽双绞线（UTP），它由四对细铜线组成，每对铜线都绞合一起，每根铜线都外裹带色的塑料绝缘层。然后整体包有一层塑料外套，使用RJ-45接头，网线原则上数字越大，版本越新，带宽也越高，价格也会相应会提高。</p>
<p><img src="/2019/11/16/lan-and-fiber/Cat5e%20cat6%20ca6a%20cat7%20Premium%20Wires-1573891144157.jpg" alt="âcat 5e cat 6âçå¾çæç´¢ç»æ"></p>
<p>CAT-1/2/3/4<br>1/2/3/4类双绞线，目前已淘汰<br>CAT-5<br>5类双绞线，可用于100M以太网传输<br>CAT-5e/6<br>超5类/6类双绞线，可用于1,000M以太网传输<br>CAT-6A<br>超6类双绞线，可用于10,000M以太网传输<br>CAT-7<br>7类双绞线，可用于更高标准（大于等于10,000M）以太网传输，必须为屏蔽线</p>
<h3 id="（三）直通线与交叉线"><a href="#（三）直通线与交叉线" class="headerlink" title="（三）直通线与交叉线"></a>（三）直通线与交叉线</h3><p>直通线：两头都是568B标准， 两端线序相同，用于不同设备之间互连，比如电脑和路由器。</p>
<p>交叉线：一头是568A，而另一头是568B， 两端线序不同，用来同种设备之间互连，比如电脑与电脑。</p>
<p><strong>现网设备接口都支持自适应功能，可以自动翻转线序，不管是直通线还是交叉线可以随意使用，目前使用的基本都是直通线。但在认证考试中要注意。</strong></p>
<h3 id="（三）水晶头的线序排列"><a href="#（三）水晶头的线序排列" class="headerlink" title="（三）水晶头的线序排列"></a>（三）水晶头的线序排列</h3><p><img src="/2019/11/16/lan-and-fiber/568B.jpg" alt="568B"></p>
<p><strong>网线中的1、2、3、6四根线的通断决定了这跟网线是否能正常工作</strong></p>
<h3 id="（四）网线制作步骤"><a href="#（四）网线制作步骤" class="headerlink" title="（四）网线制作步骤"></a>（四）网线制作步骤</h3><p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173154.png" alt="微信截图_20191123173154"></p>
<p>1、用双绞线网线钳把五类双绞线的一端剪齐（最好先剪一段符合布线长度要求的网线），然后把剪齐的一端插入到网线钳用于剥线的缺口中。注意网线不能弯，直插进去，直到顶住网线钳后面的挡位，稍微握紧压线钳慢慢旋转一圈（无需担心会损坏网络里面芯线的包皮，因为剥线的两刀之间留有一定距离，这距离通常就是里面4对芯线的直径），让刀口划开双绞线的保护胶皮，拔下胶皮。</p>
<p>2、剥除外包皮即可见到双绞线的4对8条芯线，并且可以看到每对的颜色都不同。每对缠绕的两根芯线是由一种染有相应颜色的芯线加上一条只染有少许相应颜色的白色相间芯线组成。</p>
<p>先把4对芯线一字并排排列，然后再把每对芯线分开，并按从左到右：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕的顺序排列（这种排列称为568B排序）。然后用网线钳垂直于芯线排列方向剪齐。</p>
<p>3、左手水平握住水晶头，然后把剪齐、并列排列的8条芯线对准水晶头开口并排插入水晶头中，注意一定要使各条芯线都插到水晶头的底部，不能弯曲。确认所有芯线都插到水晶头底部后，即可将插入网线的水晶头直接放入网线钳压线缺口中。水晶头放好后即可压下网线钳手柄，一定要使劲，使水晶头的插针都能插入到网线芯线之中，与之接触良好。</p>
<p>4、用测线仪检测网线连通性，看网线是否制作成功。</p>
<p>至此，这个RJ-45头就压接好了。按照相同的方法、同样的排线顺序制作双绞线的另一端水晶头，要注意的是芯线排列顺序一定要与另一端的顺序完全一样，这样整条网线的制作就算完成了。</p>
<h2 id="二、光纤"><a href="#二、光纤" class="headerlink" title="二、光纤"></a>二、光纤</h2><h3 id="（一）光纤简介"><a href="#（一）光纤简介" class="headerlink" title="（一）光纤简介"></a>（一）光纤简介</h3><p>光导纤维，简称光纤，是一种由玻璃或塑料制成的纤维，利用光在这些纤维中以全内反射原理传输的光传导工具。微细的光纤封装在塑料护套中，使得它能够弯曲而不至于断裂。通常光纤的一端的发射装置使用发光二极管或一束激光将光脉冲传送至光纤中，光纤的另一端的接收装置使用光敏元件检测脉冲。包含光纤的线缆称为光缆。</p>
<p><strong>光纤是一种比较脆弱的传输介质，使用中切忌拉扯、挤压，会造成光纤永久性的损坏。</strong></p>
<p><img src="/2019/11/16/lan-and-fiber/fiber-1573891431396.jpg" alt="fiber"></p>
<h3 id="（二）光纤分类"><a href="#（二）光纤分类" class="headerlink" title="（二）光纤分类"></a>（二）光纤分类</h3><p>支持的多种传播路径或横向模式的光纤被称为多模光纤(MMF)，而支持单一模式的被称为单模光纤（SMF）。单模光纤采用固体激光器做光源，多模光纤则采用发光二极管做光源。</p>
<p><img src="/2019/11/16/lan-and-fiber/f_23ea6035fa6826458ab1312d34a56574.jpg" alt="âå¤æ¨¡åçº¤ åæ¨¡åçº¤âçå¾çæç´¢ç»æ"></p>
<h3 id="（三）单模、多模的区别"><a href="#（三）单模、多模的区别" class="headerlink" title="（三）单模、多模的区别"></a>（三）单模、多模的区别</h3><p>多模光纤的芯线粗、传输距离短、整体传输性差，传输距离相对单模来说较短（最长约2KM），但是成本相对低廉，一般用于建筑物内部或地理位置相邻的环境下，多模光纤跳线大多数橙色的。单模光纤的纤芯相应较细，传输距离远（最长约100KM）、但成本较高，单模光纤条线大多数黄色的。</p>
<p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173535.png" alt="微信截图_20191123173535"></p>
<h3 id="（四）常见光纤使用场景"><a href="#（四）常见光纤使用场景" class="headerlink" title="（四）常见光纤使用场景"></a>（四）常见光纤使用场景</h3><p>机房中常见的光纤使用场景是将接入层交换机与上层的汇聚层连接起来，或汇聚层、核心层设备之间相互连接。</p>
<p><img src="/2019/11/16/lan-and-fiber/SFPGESST.E.jpg" alt="âswitch cisco fiberâçå¾çæç´¢ç»æ"></p>
<p>接入交换机的光纤模块</p>
<img src="/2019/11/16/lan-and-fiber/fiber-optic-cable-connect-to-ethernet-switch-mount-rack-85811589.jpg" alt="âswitch connect with fiberâçå¾çæç´¢ç»æ" style="zoom: 50%;">

<p>用光纤连接网络设备</p>
<h3 id="（五）光纤接头连接器"><a href="#（五）光纤接头连接器" class="headerlink" title="（五）光纤接头连接器"></a>（五）光纤接头连接器</h3><p>“/”前面部分表示尾纤的连接器型号：<br>“SC”接头是标准方型接头，采用工程塑料，具有耐高温，不容易氧化优点。传输设备侧光接口一般用SC接头<br>“LC”接头与SC接头形状相似，较SC接头小一些。<br>“FC”接头是金属接头，一般在ODF侧采用，金属接头的可插拔次数比塑料要多。</p>
<p>“/”后面表明光纤接头截面工艺，即研磨方式：<br>“PC” 微球面研磨抛光，在电信运营商的设备中应用得最为广泛，其接头截面是平的，。<br>“UPC”的衰耗比“PC”要小，一般用于有特殊需求的设备，一些国外厂家ODF架内部跳纤用的就是FC/UPC，主要是为提高ODF设备自身的指标。<br>“APC”呈8度角并做微球面研磨抛光，可改善电视信号的质量。</p>
<p><img src="/2019/11/16/lan-and-fiber/8c89a5e925a216b29e3501.png"></p>
<p><img src="/2019/11/16/lan-and-fiber/fiber-classification.jpg" alt="fiber-classification"></p>
<h4 id="1、ST接口（常用于光纤配线架-）"><a href="#1、ST接口（常用于光纤配线架-）" class="headerlink" title="1、ST接口（常用于光纤配线架 ）"></a>1、ST接口（<em>常用于光纤配线架</em> ）</h4><p>ST(AT&amp;T版权所有)，也许是多模网络(例如大部分建筑物内或园区网络内)中最常见的连接设备。它具有一个卡口固定架，和一个2.5毫米长圆柱体的陶瓷(常见)或者聚合物卡套以容载整条光纤。</p>
<p>ST的英文全称有时记做”Stab &amp; Twist”，很形象的描述，首先插入，然后拧紧！</p>
 <img src="/2019/11/16/lan-and-fiber/0012175_10m-singlemode-simplex-fiber-optic-patch-cable-9125-st-to-st.jpeg" alt="“ST fiber”的图片搜索结果" style="zoom: 33%;"> 

<p><img src="/2019/11/16/lan-and-fiber/16154597.jpg" alt="16154597"></p>
<h4 id="2、SC接口（常用于交换机-）"><a href="#2、SC接口（常用于交换机-）" class="headerlink" title="2、SC接口（常用于交换机 ）"></a>2、SC接口（<em>常用于交换机</em> ）</h4><p>SC同样具有2.5毫米卡套，不同于ST/FC，它是一种插拔式的设备，因为性能优异而被广泛使用。它是TIA-568-A标准化的连接器，但初期由于价格昂贵(ST价格的两倍)而没有被广泛使用。</p>
<p>材质为塑料，推拉式连接，接口可以卡在光模块上，常用于交换机。</p>
<p>SC的英文全称有时记做”Square Connector”, 因为SC的外形总是方状的。</p>
 <img src="/2019/11/16/lan-and-fiber/0012051_2m-singlemode-duplex-fiber-optic-patch-cable-9125-lc-to-sc.jpeg" alt="“SC fiber”的图片搜索结果" style="zoom: 33%;"> 

<h4 id="3、LC接口（用于路由器上连接SFP光模块-）"><a href="#3、LC接口（用于路由器上连接SFP光模块-）" class="headerlink" title="3、LC接口（用于路由器上连接SFP光模块 ）"></a>3、LC接口（用于路由器上连接SFP光模块 ）</h4><p>材质为塑料，用于连接SFP光模块，接口可以卡在光模块上。</p>
<p> <img src="/2019/11/16/lan-and-fiber/lc-fiber-optic-connector-500x500.png" alt="“LC fiber”的图片搜索结果"> </p>
<h4 id="4、光模块"><a href="#4、光模块" class="headerlink" title="4、光模块"></a>4、光模块</h4><p>光模块的作用就是光电转换，发送端把电信号转换成光信号，通过光纤传送后，接收端再把光信号转换成电信号。</p>
<img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173804.png" alt="微信截图_20191123173804" style="zoom:67%;">

<p>短波模块-单模光纤-短波模块：不可行！因为短波模块的发光口大于单模光纤的纤芯直径，部分光信号无法进入光纤 </p>
<p>长波模块-多模光纤-长波模块：一般可行，因为长波模块的发光口小于多模光纤的纤芯直径，所有光信号能够进入光纤。但传输距离受多模光纤限制，只有几百米，甚至连不通的情况！ </p>
<p>长波模块-多模光纤-短波模块：不可行！两端波长必须相同！</p>
<h3 id="（六）光纤打环测试"><a href="#（六）光纤打环测试" class="headerlink" title="（六）光纤打环测试"></a>（六）光纤打环测试</h3><p>可以把光纤弯曲到一定的程度（一般光纤的弯曲度都是有规定的，国家规定光缆的最小弯曲半径是静态10倍缆径，动态20倍缆径）。然后用光功率计（如果已经做上连接头的话）或者OTDR（光时域反射仪）来测试光缆的衰减。正常情况下是光纤的衰减值越小，证明光纤越好。如果是光缆，那就还得看一下光缆的外径和所使用的纺伦，一般是外径越粗越好，纺伦越是细腻光亮越好。<br>单多模光纤都可以使用以上方法测试。</p>
<p>在没有光功率计的时候，用一根光纤将光模块的TX侧和RX侧连接起来，对光模块进行自环测试（长距离光模块必须通过光衰器件互连），如果接口指示灯常亮，接口可以Up，说明本侧的接口和光模块正常；否则说明接口或者光模块可能存在问题，建议更换正常的光模块或者接口测试。</p>
<h3 id="（七）光模块安装与移除"><a href="#（七）光模块安装与移除" class="headerlink" title="（七）光模块安装与移除"></a>（七）光模块安装与移除</h3><h4 id="1、光模块的安装"><a href="#1、光模块的安装" class="headerlink" title="1、光模块的安装"></a>1、光模块的安装</h4><p><img src="/2019/11/16/lan-and-fiber/imgDownload.png" alt="imgDownload"></p>
<p>安装前，要仔细检查光模块的金手指是否明亮齐整，是否干净，拉杆是否完好。</p>
<p>安装时，要仔细辨别光纤口的方向，不要插反。插入光纤跳线时能够听到轻微的听到“啪”的声音或感到轻微震动。 </p>
<p>安装后，要确定光模块的拉杆固定好，光模块的安装到位，不会轻易拔出。</p>
<h4 id="2、光模块的移除"><a href="#2、光模块的移除" class="headerlink" title="2、光模块的移除"></a>2、光模块的移除</h4><p><img src="/2019/11/16/lan-and-fiber/A1117-SFP_remove.jpg" alt="A1117-SFP_remove"></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p><strong><span style="color:red">永远不要让光纤尾部正对你的眼睛，永远不要向光纤里面看，不要直接或使用仪器看光纤尾部。激光是不可见的，但可能会对人眼造成永久伤害</span></strong> </p>
<h3 id="（八）光纤配线架"><a href="#（八）光纤配线架" class="headerlink" title="（八）光纤配线架"></a>（八）光纤配线架</h3><img src="/2019/11/16/lan-and-fiber/timg.jpg" alt="timg" style="zoom:67%;">

<p><img src="/2019/11/16/lan-and-fiber/timg%20(1).jpg" alt="timg (1)"></p>
<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>光纤配线架用于光缆终端光纤熔接、光连接器的调节、多余尾纤的存储及光缆保护等功能 。</p>
<h4 id="2、使用连接示意图"><a href="#2、使用连接示意图" class="headerlink" title="2、使用连接示意图"></a>2、使用连接示意图</h4><p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123174708.png" alt="微信截图_20191123174708"></p>
<h3 id="（八）参考文章"><a href="#（八）参考文章" class="headerlink" title="（八）参考文章"></a>（八）参考文章</h3><h4 id="1、教你如何认识各种光纤接口类型"><a href="#1、教你如何认识各种光纤接口类型" class="headerlink" title="1、教你如何认识各种光纤接口类型"></a><a href="http://blog.51cto.com/68240021/1980520">1、教你如何认识各种光纤接口类型</a></h4>]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>7、为什么要建立TCP/IP通信模型</title>
    <url>/2020/02/19/layer-mind/</url>
    <content><![CDATA[<p>OSI七层和TCP\IP这两个模型，除了了解每层的功能、各字段的意义、封装解封装的过程以及每层的协议以外，还有一个重要但又容易被忽视的概念，就是建立分层的思维，之前的笔记中也提到过，OSI参考模型中的一层就相当于流水线上的一道工序或单位中的一个部门，他们既相互关联又彼此独立，下层为上层提供传输服务，不关心上层传输的内容，需要标识上层所使用的协议或应用；而上层也不关心下层传输的手段，只期望能将信息最终发到通信对端的相应层次上。之前一直觉得这个概念很好理解，也就没再关注这个，但在总结笔记的时候，才发现这个概念还是没有真正理解，可能这个概念要真正掌握并且固话还需要一次次的反复，每次当发现认知有问题的时候，会对此篇笔记进行更新。</p>
 <span id="more"></span>  

<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><h3 id="2月17日事件"><a href="#2月17日事件" class="headerlink" title="2月17日事件"></a>2月17日事件</h3><p>起因是看到TCP的RFC文档的2.6 Reliable Communication里有这么一段话：</p>
<blockquote>
<p>An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.</p>
</blockquote>
<p>一开始觉得这段话的意思是说，对一个数据进行ACK了也不能确保整个数据肯定传到“用户”（user）了，发送ACK的这个设备（也就是其他路由器或网络设备）需要完成接下来的步骤，因为可能收到这个数据并发送ACK的设备给丢弃了，例如它这没有路由表或者说它down了。但因为知道自己很渣，所以到思科论坛发了<a href="https://community.cisco.com/t5/routing/what-s-the-meaning-of-an-acknowledgment-by-tcp-does-not/m-p/4030767#M329627">求助帖</a>，想验证一下自己的想法是否正确，有个哥们回复我说，他认为：</p>
<blockquote>
<p>IMHO, it’s all about hierarchical model. The “user” is the “application process”. TCP is just one of the layers (transport, 4th). TCP is responsible for receiving/transmitted data only. Let’s imagine that TCP receives data. Then the data should travel to the end user (Application, 7th layer). But application may be overloaded and discards the data. In this situation the remote side received TCP-ACK, but on our side the user has not received the message.</p>
</blockquote>
<p>IMHO是in my humble opinion的缩写，翻译成中文就是“以我愚见”，人家真是谦虚啊，帮我解答疑惑还这么客气，真让我无地自容。</p>
<p>他的大概意思就是说，我不懂的那段文字其实说的是分层模型（潜台词就是说，哥们你没明白TCP\IP模型中这个分层的真正含义啊），RFC里的这个user指的并不是一个接收端，而指的是接收端TCP\IP模型（或OSI模型）应用层中的应用程序，因为模型中的每一层都是相互独立的，发给你ACK的是对端的TCP，而TCP在第四层也就是传输层，只能表示数据一直到对面的传输层都是正常的，而且对面的传输层也完整无误的收到了这个数据，也就是数据从发送端的传输层——网络层——数据链路层——物理层——接收端的物理层——传输层——网络层——传输层的这个过程都是没问题的，当然按道理来说，应用层确认收到数据以后，这个数据应该发送给了应用层，但是应用程序可能会过载，并丢弃数据。在这种情况下，会出现发送端已收到TCP-ACK，但在接收端，“user”也就是应用层的程序，尚未收到该消息。</p>
<p><img src="/2020/02/19/layer-mind/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200219144709.jpg" alt="微信图片编辑_20200219144709"></p>
<p>后来经高人指点发现RFC文档上有这么一句话，更印证了上面那哥们的回答：</p>
<blockquote>
<p>This part of the RFC is about passing responsibility over to the operating system or whatever is the next stage of the process. It’s fundamentally concerned with the separation of layers.</p>
</blockquote>
<p>这段话说的是，RFC的这一部分是关于将责任转移到操作系统或过程的下一阶段。 从根本上讲，它与分层有关。所以说这段话还是在强调分层这个概念，当然我这种啃不下去RFC的人，是看不到这段话的。</p>
<p>后来到网上搜了一下，有一个人在另一个论坛提出了和我一样的问题，这个回答相对更严谨复杂一些，有兴趣的可以看一下：</p>
<p><a href="https://networkengineering.stackexchange.com/questions/55581/acknowledgment-by-tcp-does-not-guarantee-that-the-data-has-been-delivered">acknowledgment by TCP does not guarantee that the data has been delivered</a></p>
<h3 id="3月12日事件"><a href="#3月12日事件" class="headerlink" title="3月12日事件"></a>3月12日事件</h3><p>起因是因为感觉对RTO（retransmission timeout）还是理解的有问题，所以去网上看了<a href="https://www.extrahop.com/company/blog/2011/retransmission-timeouts-rtos-application-performance-degradation/">一篇文章</a>，发现文章里有这么一句话：TCP starts a retransmission timer when an outbound segment is handed down to IP。看完这句话，感觉又被教育了一次什么叫分层。</p>
<p>TCP是一个可靠的协议，里面的重传机制也是仅仅工作在本层的，和其他层没关系，之前看到一句话说：When the TCP transmits a segment containing data, it puts a copy on a retransmission queue and starts a timer，结合上面的那句话就是说，当TCP传输包含数据的段时，也就是说当TCP将数据段传送给下层的网络层时，它将该数据段的副本放在重传队列上并启动计时器。而并不是之前我所感觉的数据发出本设备时，计时器开始计时，而是当数据发出本层时计时器就开始计时了，因为TCP是传输层的协议，仅对自己传输层的东西负责和影响。</p>
<h2 id="关于分层概念的浅见"><a href="#关于分层概念的浅见" class="headerlink" title="关于分层概念的浅见"></a>关于分层概念的浅见</h2><p>最后再针对一张很好的图说两句自己对于分层概念以及模型的理解：</p>
<p>1、标准化</p>
<p>2、彼此独立</p>
<p>3、相互联系</p>
<p>4、便于实现</p>
<h3 id="便于网络通信的实现"><a href="#便于网络通信的实现" class="headerlink" title="便于网络通信的实现"></a>便于网络通信的实现</h3><p>为什么要弄出分层这么一个模型，个人感觉是因为整个网络数据的传输过程比较复杂，分层使得网络易于实现和维护，便于调试。类似于汽车上的流水线分工，一开始是一个工人生产一辆汽车，但随着汽车需求原来越大，汽车生产过程的越来越复杂，这种模式已经不适合大规模生产的要求了，首先是一个人很难掌握如此多的工序，其次是即使掌握了也不便于汽车的大规模生产，第三是由于一个人要做很多道工序，很难精通所有的工序，无法加快汽车生产速度也无法提高优化每一步的生产精度，无法提高产品质量。</p>
<p>网络传输也是同样的道理，一开始的时候协议是不分层的，实现所有的功能，但随着通信量的上升，如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现，使得网络易于实现和维护，便于调试。比如汽车生产中有些步骤是生产底盘，有些步骤是安装轮胎，有些步骤是安装外壳，但不同的车型（类似于实现用户需求的程序），需要的轮胎、外壳和底盘都不同（用不同的协议实现），当需要造轿车的时候（比如要实现浏览网页的功能），需要相对应的轿车底盘和轿车轮胎（应用层需要采用HTTP协议，传输层需要采用TCP协议）。</p>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>生产设备的厂家以及每一层的协议，必须符合分层模型统一的标准才能相互兼容，完成通信的全步骤，如果其中一层出了问题或者改变，只需要在其中一层进行改变，不会影响其他层。这么说可能不太直观，依旧用汽车这货来举个贴近生活的例子方便理解，在网络通信中，如果没有统一的规则，自己按照自己的规则开发导致协议、设备相互不兼容，不仅无法通信，也无法形成今天全球互联网全互联的状态，类推到汽车行业就是，生产汽车零件的厂家有很多，比如轮胎有普利司通的，有马牌的也有韩泰的，品牌不同但必须按一个统一的规定去生产，比如轮胎的直径和宽度是多少才能用到轿车上，这样的话，当汽车中的某个零件损坏时，才能使用同规格的零件替换，因为生产的标准、使用的连接方式都相同。同理在分层模型中，网络层的协议也必须遵守一定的规则才能被通信协议使用，才能像汽车一样，如果轮胎坏了（类推到网络中就是其中某些层的某些协议或功能出了问题），只需要更换一个同型号的换轮胎即可上路飞驰，汽车的其他零件不受影响也不用变动（对相应出问题层级进行排错，出问题的特定层级排除错误通信即可恢复）。</p>
<h3 id="彼此独立又相互依靠"><a href="#彼此独立又相互依靠" class="headerlink" title="彼此独立又相互依靠"></a>彼此独立又相互依靠</h3><p>？？？？？？？？？？？？？？？</p>
<h3 id="上层依赖于下层，下层为上层提供服务"><a href="#上层依赖于下层，下层为上层提供服务" class="headerlink" title="上层依赖于下层，下层为上层提供服务"></a>上层依赖于下层，下层为上层提供服务</h3><p>？？？？？？？？？？？？？？</p>
<p>为什么要弄出分层这么一个模型，个人感觉是因为整个网络数据的传输过程比较复杂，分层使得网络易于实现和维护，便于调试。如果其中一层出了问题或者改变，只需要在其中一层进行改变，不会影响其他层。这么说可能不太直观，举个实际中的例子就是造汽车，一个人去造一整辆汽车显然无法适应现代汽车生产的需求，所以出现了汽车生产的流水线，这个流水线也就是将汽车生产的步骤分层成一个一个的步骤，每个步骤实现不同的工序用于实现不同的功能，网络分层也是一样的道理，要适应大规模数据传输必须将复杂的数据传输细分成实现不同功能的层次。比如汽车生产中有些步骤是生产底盘，有些步骤是安装轮胎，有些步骤是安装外壳，但不同的车型（类似于实现用户需求的程序），需要的轮胎、外壳和底盘都不同（用不同的协议实现），当需要造轿车的时候（比如要实现浏览网页的功能），需要相对应的轿车底盘和轿车轮胎（应用层需要采用HTTP协议，传输层需要采用TCP协议）。如果轮胎坏了（其中某些层的功能出了问题），只需要更换轮胎即可，汽车的其他零件不受影响（对相应出问题层级进行排错）。</p>
<p>当然仅仅分层也是不够的，还必须对每一层进行标准化，而生产设备的厂家以及每一层的协议，必须符合分层模型统一的标准才能相互兼容，完成通信的全步骤，否则如果没有统一的规则，自己按照自己的规则开发导致相互不兼容，不仅无法通信，也无法形成今天全球互联网全互联的状态。标准化就类似于生产汽车零件的厂家有很多，但必须按一个统一的规定去生产，比如轮胎的直径和宽度是多少才能用到轿车上，这样的话，当汽车中的某个零件损坏时，才能使用同规格的零件替换，因为生产的标准、使用的连接方式都相同。同理在分层模型中，网络层的协议也必须遵守一定的规则才能被通信协议使用。</p>
<p><img src="/2020/02/19/layer-mind/tcpipprotocols.png" alt="tcpipprotocols"></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>2、模拟器</title>
    <url>/2019/11/16/network-simulator/</url>
    <content><![CDATA[<h2 id="一、用什么模拟器"><a href="#一、用什么模拟器" class="headerlink" title="一、用什么模拟器"></a>一、用什么模拟器</h2><h3 id="（一）cisco-packet-tracer"><a href="#（一）cisco-packet-tracer" class="headerlink" title="（一）cisco packet tracer"></a>（一）cisco packet tracer</h3><p>cisco packet tracer 是思科出品的模拟器，界面、功能和使用都非常简单，对新手十分友好，基本上一学就会。不足是这个模拟器相对简单，一些命令无法运行，不过基本能满足NA阶段的学习。</p>
<h3 id="（二）EVE-NG"><a href="#（二）EVE-NG" class="headerlink" title="（二）EVE-NG"></a>（二）EVE-NG</h3><p>个人推荐使用EVE，因为EVE不仅可以模拟网络设备，也可以运行一切虚拟机，可以算得上是仿真虚拟环境，给用户最接近真实网络设备的体验；它是深度定制的Ubuntu操作系统，可以直接把它安装在x86架构的物理主机上。它也有ova版本，可以导入到VMware等虚拟机软件中运行。EVE-NG在交互模式上更加具有优势，与GNS3截然不同。GNS3更像是用户使用的软件，只有GNS3支持的 OS才能使用；而EVE-NG更像是CS模型，EVE-NG是服务端，用户端可以是支持http/https的任意OS。</p>
 <span id="more"></span>  

<h3 id="（三）GNS3"><a href="#（三）GNS3" class="headerlink" title="（三）GNS3"></a>（三）GNS3</h3><p>GNS3是一个于2008年发布的网络软件模拟器，它允许组合的虚拟和实际设备，用于模拟复杂的网络。 它使用Dynamips模拟软件来模拟Cisco IOS。GNS3在很多大型公司中也有广泛的应用，例如埃克森公司、沃尔玛、AT&amp;T和美国宇航局。功能上比cisco packet tracer 要丰富的多，但相对真机还是有一定差距且使用起来有一些比较麻烦的地方。</p>
<h3 id="（四）NetSim"><a href="#（四）NetSim" class="headerlink" title="（四）NetSim"></a>（四）NetSim</h3><p>该软件相比之前几个软件，对新手更加友好，有很多设计好的实验，针对每一步的配置均有讲解，但该软件是全英文版，而且是付费软件，由于使用人数不多破解版和使用说明并不好找。</p>
<h2 id="二、EVE-NG安装及设置"><a href="#二、EVE-NG安装及设置" class="headerlink" title="二、EVE-NG安装及设置"></a>二、EVE-NG安装及设置</h2><h3 id="（一）所需软件"><a href="#（一）所需软件" class="headerlink" title="（一）所需软件"></a>（一）所需软件</h3><p>EVE-NG的虚拟机文件、VMware-workstation、火狐浏览器、SecureCRT以及EVE-NG-Win-Client-Pack安装包。</p>
<h3 id="（二）安装步骤"><a href="#（二）安装步骤" class="headerlink" title="（二）安装步骤"></a>（二）安装步骤</h3><h4 id="1、下载软件"><a href="#1、下载软件" class="headerlink" title="1、下载软件"></a>1、下载软件</h4><p>推荐用14以上版本，14之前的版本有安全隐患，建议去VMware官网下载最新版进行安装，官网网址为：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a></p>
<img src="/2019/11/16/network-simulator/image-20191117105947209.png" alt="image-20191117105947209" style="zoom: 67%;">

<h4 id="2、安装VMware-workstation"><a href="#2、安装VMware-workstation" class="headerlink" title="2、安装VMware-workstation"></a>2、安装VMware-workstation</h4><p> <img src="/2019/11/16/network-simulator/20181129090415536.png" alt="img"> </p>
<p> <img src="/2019/11/16/network-simulator/image-20191117110739400.png" alt="image-20191117110739400"> </p>
<p>一路next点下去即可，如果不愿意安装在C盘可自行选择空间大的分区，密钥可以自行搜索输入即可激活</p>
<h4 id="3、导入虚拟机文件"><a href="#3、导入虚拟机文件" class="headerlink" title="3、导入虚拟机文件"></a>3、导入虚拟机文件</h4><img src="/2019/11/16/network-simulator/image-20191117110934416.png" alt="image-20191117110934416" style="zoom:150%;">

<p>在bbs.vlan5.com或其他网站均有打包好镜像的整合版，不需要自行导入镜像，更推荐下载这种整合版，装好直接就能用。双击下载好的镜像.ova文件，将文件用Vmware Workstation打开并点击导入。</p>
<img src="/2019/11/16/network-simulator/image-20191117111918615.png" alt="image-20191117111918615" style="zoom:80%;">

<img src="/2019/11/16/network-simulator/image-20191117112009691.png" alt="image-20191117112009691" style="zoom:80%;">

<h4 id="4、安装安装EVE-NG-Win-Client-Pack"><a href="#4、安装安装EVE-NG-Win-Client-Pack" class="headerlink" title="4、安装安装EVE-NG-Win-Client-Pack"></a>4、安装安装EVE-NG-Win-Client-Pack</h4><p>一直下一步即可。</p>
<h4 id="5、设置虚拟机参数"><a href="#5、设置虚拟机参数" class="headerlink" title="5、设置虚拟机参数"></a>5、设置虚拟机参数</h4><p><img src="/2019/11/16/network-simulator/image-20191117112226743.png" alt="image-20191117112226743"></p>
<h5 id="EVE内存设置："><a href="#EVE内存设置：" class="headerlink" title="EVE内存设置："></a>EVE内存设置：</h5><p><img src="/2019/11/16/network-simulator/image-20191117112404527.png" alt="image-20191117112404527"></p>
<p>一般只用设置内存和处理器两个参数即可，运行EVE模拟器建议本机至少12G内存，然后分8G给EVE，16G内存则可以分10G内存给EVE。</p>
<h5 id="CPU设置："><a href="#CPU设置：" class="headerlink" title="CPU设置："></a>CPU设置：</h5><p><img src="/2019/11/16/network-simulator/image-20191117112640714.png" alt="image-20191117112640714"></p>
<p>除服务器工作站外的其他个人主机的处理器数量均为1，每个处理器的内核数量和型号有关，建议根据CPU型号自行搜索选择，虚拟化引擎中的第一项“虚拟化Intel VT-X”必须勾选否则无法运行模拟器。</p>
<h5 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h5><p>此方法适用于虚拟机启动后能够获取IP地址但在浏览器中输入IP地址无法访问，以及无法获取到IP地址</p>
<p><img src="/2019/11/16/network-simulator/lab-net.png" alt="lab-net"></p>
<h4 id="5、在BIOS中开启VT功能"><a href="#5、在BIOS中开启VT功能" class="headerlink" title="5、在BIOS中开启VT功能"></a>5、在BIOS中开启VT功能</h4><h5 id="进入计算机BIOS："><a href="#进入计算机BIOS：" class="headerlink" title="进入计算机BIOS："></a>进入计算机BIOS：</h5><p>参考以下按键，开机时按住对应的键进入BIOS：</p>
<p>组装机以主板分，华硕按F8、Intel按F12,其他品牌按ESC、F11或F12；</p>
<p>笔记本以品牌分，联想ThinkPad系列按F1,其他品牌按F2；</p>
<p>品牌台式机按品牌分， Dell按ESC，其他按F12；</p>
<p>如果仍然不能进入BIOS，找找电脑（主板）说明书或者参考BIOS设置怎么进入图解教程。</p>
<h5 id="开启VT功能"><a href="#开启VT功能" class="headerlink" title="开启VT功能"></a>开启VT功能</h5><p>部分较新主板已经采取了图形化界面，需点击“退出/高级模式”进入高级模式才能看到VT开启选项，华硕等主板的VT选项在“ Advanced高级——CPU Configuration处理器设置 ”中开启，技嘉等主板的VT选项在“ BIOS Features —— Intel Virtualization Technology英特尔虚拟化技术 ”中开启，通用Phoenix BIOS机型在“ Configuration—— Intel Virtual Technology”中开启。</p>
<h2 id="三、EVE-NG使用简略说明"><a href="#三、EVE-NG使用简略说明" class="headerlink" title="三、EVE-NG使用简略说明"></a>三、EVE-NG使用简略说明</h2><h3 id="（一）登陆"><a href="#（一）登陆" class="headerlink" title="（一）登陆"></a>（一）登陆</h3><p><img src="/2019/11/16/network-simulator/image-20191117114900537.png" alt="image-20191117114900537"></p>
<p>点击开启此虚拟机将EVE开启</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115458381.png" alt="image-20191117115458381"></p>
<p>开启后第一行的root、eve分别是虚拟机中登录的用户名密码，一般情况下用不到，第二行的IP地址为登录EVE模拟器的地址，将该地址输入火狐浏览器后进行登录。</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115652940.png" alt="image-20191117115652940"></p>
<p>默认登录用户名密码为：admin、eve</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115844969.png" alt="image-20191117115844969"></p>
<p>登录后点击红框中的按键为新建模拟器</p>
<p><img src="/2019/11/16/network-simulator/image-20191117160634525.png" alt="image-20191117160634525"></p>
<p>更多的设置请查看 <a href="C:\Users\32759\Downloads\EVE-COOKBOOK-1.25-Chinese-20200122-v1.0.pdf">EVE-COOKBOOK-1.25-Chinese-20200122-v1.0.pdf</a> </p>
<h3 id="（二）新建实验拓扑及基本操作"><a href="#（二）新建实验拓扑及基本操作" class="headerlink" title="（二）新建实验拓扑及基本操作"></a>（二）新建实验拓扑及基本操作</h3><h4 id="1、添加设备及选择IOS"><a href="#1、添加设备及选择IOS" class="headerlink" title="1、添加设备及选择IOS"></a>1、添加设备及选择IOS</h4><p><img src="/2019/11/16/network-simulator/image-20191117161041649.png" alt="image-20191117161041649"></p>
<p>在空白处点击右键，出现常用菜单</p>
<p><img src="/2019/11/16/network-simulator/image-20191117162643074.png" alt="image-20191117162643074"></p>
<p>第一个是思科3725路由器的IOS，第二个是IOL，第三四个是VIOS，两者的区别，我找到一个老外的解释：</p>
<p> IOSv is a complete VM. IOU is IOS as a native linux process. IOSv will be more up to date with features but IOU is less resource hungry.  </p>
<p>大概意思是“VIOS是完整的Vmware文件。而IOU是作为本地Linux进程的IOS。VIOS有更多最新功能，但IOU的资源消耗较少。”</p>
<p>如果做实验的过程中确定配置方面没问题，则可能是用的IOS有问题，换个IOS也许就正常了，这种情况在做交换实验的时候遇到的多一些，有一次做三层交换机实验的时候无论如何也不同，换了个IOS但配置没做任何改变就通了。</p>
<p><img src="/2019/11/16/network-simulator/image-20191117165907022.png" alt="image-20191117165907022"></p>
<p>这里用IOL举例，选择IOL以后，有两个IOS可选，L2代表三层、二层交换机的IOS，L3代表路由器的IOS。</p>
<h4 id="2、连接设备"><a href="#2、连接设备" class="headerlink" title="2、连接设备"></a>2、连接设备</h4><p><img src="/2019/11/16/network-simulator/EVE-_-Topology.gif" alt="EVE-_-Topology"></p>
<p>连接设备的方式如GIF图所示，可以选择不同的接口连接，由于录屏软件的问题，下拉菜单并没有录制上。</p>
<h4 id="3、开启设备"><a href="#3、开启设备" class="headerlink" title="3、开启设备"></a>3、开启设备</h4><p>开启设备的方式有两种，选中设备后右键开机以及在左侧菜单中开启全部设备。具体步骤见gif动图。</p>
<p><img src="/2019/11/16/network-simulator/turn-on-and-off.gif" alt="turn-on-and-off"></p>
<h4 id="4、保存设置"><a href="#4、保存设置" class="headerlink" title="4、保存设置"></a>4、保存设置</h4><p>在设备上输入wr既可在关闭模拟器后保存已输入的配置，</p>
<h4 id="5、设置预配"><a href="#5、设置预配" class="headerlink" title="5、设置预配"></a>5、设置预配</h4><p>很多时候我们想把EVE所有的配置都清空，但是又想在清空时保存最基本的预配，比如IP地址，Hostname等等，以下为设置预配详细步骤： </p>
<p>（1）在设备中配置好想保存的基本预配命令后使用wr命令保存。</p>
<p>（2）选择菜单选项栏 More actions—Export all CFGs 注意右边消息窗口弹出config exported并且无错误，此导出步骤请重复2-3遍。此步骤为导出所有设备的配置。</p>
<p>（3）选择 More actions——Set nodes startup-cfg to exported 注意右边消息提示中无错误，并且完成，此操作请重复2-3遍。  此步骤为把步骤2中的导致的配置文件加载到设置的starup-cfg中.</p>
<p>（4） 当完成实验使用右键菜单中的“Wipe Selected”清除配置后，在启动设备时之前的预配信息将不会被清除。</p>
<p>（5）如关闭了虚拟机后想在下次启动EVE模拟器时直接用基本预配启动，则选择More actions——Set nodes startup-cfg to exported，而后选择Wipe all nodes，然后再开启设备。</p>
<h3 id="（三）命令行杂记"><a href="#（三）命令行杂记" class="headerlink" title="（三）命令行杂记"></a>（三）命令行杂记</h3><p>show run | section XXX</p>
<p>show run 是查看所有运行在内存里的配置，在show run 后接管道符“|”（在英文输入状态下，按shift + 回车上面的键，即可输入管道符）section后面接所需要看的命令抬头，比如可以接 ip route ，表示只查看静态路由的相关配置。</p>
<p>int range f0/0 - 2</p>
<p>range 命令可以同时进入多个接口，进行普遍性的操作配置</p>
<h3 id="（四）secure-CRT"><a href="#（四）secure-CRT" class="headerlink" title="（四）secure CRT"></a>（四）secure CRT</h3><p>Secure CRT比putty界面更友好一些，日常使用非常方便，不过CCIE考试的时候因为版权问题，一直使用免费的putty，如果想更贴近考场情况，还是建议使用putty。</p>
<h4 id="1、默认使用secure-CRT打开设备"><a href="#1、默认使用secure-CRT打开设备" class="headerlink" title="1、默认使用secure CRT打开设备"></a>1、默认使用secure CRT打开设备</h4><p>Firefox（火狐）：设置–应用，找到Telnet，右侧选“使用 SecureCRT Application 处理（默认）”，实现单个窗口多标签打开对话。</p>
<p>Chrome： 第一次点开设备的时候选择CRT时将“始终在关联的应用中打开这些类型的链接”点上以后打开就默认用CRT了，如果勾选错了想取消，找到文件“<strong>C:\Users\Whidy(你的用户名)\AppData\Local\Google\Chrome\User Data\Default\Preferences</strong>”搜索protocol_handler修改excluded_schemes内的相关应用为false就可以重新选择打开方式了。</p>
<h4 id="2、如何用SecureCRT标签打开不同设备"><a href="#2、如何用SecureCRT标签打开不同设备" class="headerlink" title="2、如何用SecureCRT标签打开不同设备"></a>2、如何用SecureCRT标签打开不同设备</h4><p>方法1：</p>
<p><img src="/2019/11/16/network-simulator/CRT%E6%89%93%E5%BC%80EVE%E7%9A%84%E8%AE%BE%E5%A4%87%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%AA%97%E5%8F%A3-1573998925521.gif" alt="CRT打开EVE的设备是独立窗口"></p>
<p>方法2：</p>
<p>右键单击CRT左侧面板中的“Session”，选择New Session，单击下一步 </p>
<p> <img src="/2019/11/16/network-simulator/wKiom1hJUcLBOTWIAABRFpokUzM697.png-wh_500x0-wm_3-wmp_4-s_2022892654.png" alt="wKiom1hJUcLBOTWIAABRFpokUzM697.png-wh_50"> </p>
<img src="/2019/11/16/network-simulator/image-20191118183846505.png" alt="image-20191118183846505" style="zoom:150%;">

<p>IP地址为模拟器登录的IP地址，不同的设备所使用的端口不同，鼠标移到设备上会在浏览器左下角显示该设备的IP地址和端口，从端口32796开始将每个设备的参数配置到CRT中，以后使用的时候在左侧面板中点击连接该设备，配置好后以后可方便在相同窗口的不同标签中打开不同设备。</p>
<p>窗口切换快捷键：Ctrl+Tab</p>
<p>参考文章：</p>
<p><a href="https://www.sjzyj.vip/?p=96">EVE-NG 开机无法获取IP地址</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
</search>
