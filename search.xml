<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>10、设备管理及cisco IOS基础配置</title>
    <url>/2020/04/14/10-cisco-ios/</url>
    <content><![CDATA[<h2 id="CISCO路由器及启动过程"><a href="#CISCO路由器及启动过程" class="headerlink" title="CISCO路由器及启动过程"></a>CISCO路由器及启动过程</h2><h3 id="路由器组件"><a href="#路由器组件" class="headerlink" title="路由器组件"></a>路由器组件</h3><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-14_16-22-14.jpg" alt="Snipaste_2020-04-14_16-22-14"></p>
<p>CPU：中央处理器，CPU执行操作系统的指令，例如启动，路由功能和交换功能。</p>
 <span id="more"></span>  

<p>RAM（random access memory）：随机访问存储器，RAM是一种易失性内存，需要持续供电才能保留其内容，如果重启或电源断电的话，该存储器上的内容会全部丢失。RAM上存储那些需要被运行的数据，比如路由器的操作系统、目前正在运行的配置文件（Running Configuration File）、路由表（IP Routing Table）、ARP缓存表（ARP Cache）、缓存数据（Packet Buffer）等。思科设备上运行的操作系统叫做“Cisco IOS”，IOS是Internetwork Operating System的简写，和苹果运行的IOS系统简写一样，话说貌似苹果给了思科授权费才能也用这个简写；Running Configuration File，它是存储了路由器IOS系统目前运行的配置命令，路由器上几乎所有配置命令都存储在running configuration file中，一般叫做running configuration；ARP缓存表（ARP Cache），缓存表中包含了IPV4地址和MAC地址对应的表项，当路由器上有以太网接口时才会有ARP缓存表；缓存数据（Packet Buffer），当接口收到或发出数据前会暂时存储在缓存中，这些暂时存储的数据叫做数据缓存。</p>
<p>ROM（read-only memory），ROM是一种永久性存储，即使断电重启，其中的数据也不会丢失。思科设备中的ROM存储的是，POST，bootstrap，ROMMON，mini-IOS。</p>
<ul>
<li>POST：Power on self test，开机自检程序，用来确定所有必备开机的组建都能正常运行；</li>
<li>bootstrap：开机指令，负责启动路由器并找到IOS系统的位置将其加载到RAM中；</li>
<li>ROMMON：ROMMON是一个精简版IOS程序，在ROMMON上可以进行各种系统检测和进行密码恢复，如果bootstrap成功找到IOS系统则不会进入ROMMON模式，如果bootstrap找不到系统则会进入ROMMON模式；</li>
<li>mini-IOS：Mini-IOS是一个备用工具，它包含了一个剥离版的IOS。它适用于找不到IOS映像的关键情况。Mini-IOS只包含IP代码，允许你从其他资源（如TFTP Server）加载IOS。</li>
</ul>
<p>Flash Memory，Flash Memory是一种非易失性存储，可以通过电子方式进行存储和擦除数据，主要用来存放IOS操作系统。</p>
<p>NVRAM，NVRAM是Nonvolatile RAM的简写，中文是非易失性RAM存储，这种存储在断电或重启时也不会丢失其中的数据，主要用来存放startup configuration，也就是设备的启动配置。</p>
<h3 id="路由器启动过程"><a href="#路由器启动过程" class="headerlink" title="路由器启动过程"></a>路由器启动过程</h3><h4 id="理论步骤"><a href="#理论步骤" class="headerlink" title="理论步骤"></a>理论步骤</h4><p><img src="/2020/04/14/10-cisco-ios/router-booting-process.jpg" alt="router-booting-process"></p>
<p><img src="/2020/04/14/10-cisco-ios/071613_2203_CCNAPrepInt4.png" alt="071613_2203_CCNAPrepInt4"></p>
<p>路由器开机后，先运行ROM中的POST，也就是进行硬件自检，看必备的开机部件（CPU, RAM和NVRAM）是否都工作正常，如果正常的话，将ROM中的Bootstrap程序拷贝到RAM中运行，当拷贝完毕且在RAM运行后，CPU执行bootstrap程序搜寻IOS操作系统的位置，搜索的过程依次为Flash — TFTP Server — ROM，如果都没有的话则进入ROMMON模式，如果找到操作系统则操作系统会加载到RAM中运行，并加载存储在NVRAM中的开机启动配置，当所有程序都在RAM中成功加载后，开机过程运行完毕。</p>
<h4 id="实际分析"><a href="#实际分析" class="headerlink" title="实际分析"></a>实际分析</h4><p><strong>POST</strong> (Power On Self Test) - 首先 Router 会自我检查一下</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-41-19.jpg" alt="Snipaste_2020-05-04_10-41-19"></p>
<p><strong>载入Bootstrap</strong> - 然后会加载Bootstrap这个应用程序，功能是后面加载IOS操作系统。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-43-54.jpg" alt="Snipaste_2020-05-04_10-43-54"></p>
<p><strong>读取Configuration Register</strong> </p>
<p>接下来会读取配置寄存器的数值，预设为0X2102，换算成二进制就是0010 0001 0000 0010 ， 每位都有不同的作用，一般情况下不会改变这个数值，但如果要冲重新设置密码，需要看第六位，也就是从右往左数第七个数字，之所以是第七个数字，是因为右起第一个数字是第零位，右起第二个数字是第一位，以此类推第六位也就是尤其第七个数字：</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-54-08.jpg" alt="Snipaste_2020-05-04_10-54-08"></p>
<p>这个 Bit 可控制 Router 要不要跳过读取 Startup Configuration，预设 0 是不跳过 (即读取)，设成 1 则是跳过 (即不读取)。但开机时是看不到 Configuration Register 的值，只有在开机後用 Show Version 才可看到。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-56-05.jpg" alt="Snipaste_2020-05-04_10-56-05"></p>
<p><strong>载入 IOS</strong> - 依 Flash丶TFTP 和 ROM 的次序载入 IOS，即是我们常常看见很多 # 号那个时刻</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-57-34.jpg" alt="Snipaste_2020-05-04_10-57-34"></p>
<p><strong>载入 Startup Configuration</strong></p>
<p>跟据 Configuration Register 的值决定是否载入 Startup Configuration。如果没有载入或 Startup Configuration 不存在，就会询问是否进行 Initial Configuration，就像打开一台新机一样。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_10-58-34.jpg" alt="Snipaste_2020-05-04_10-58-34"></p>
<p>无论是 Console 密码丶Enable 密码都是储存在 Startup Configuration 之中，然後被载入至 Running Configuration。然而修改 Configuration 需要 Enable 密码，重设密码的哲学在於「如何在不用密码的情况下进入 Enable Mode (或称 Privilege Mode)</p>
<h3 id="忘记登陆密码如何进入系统"><a href="#忘记登陆密码如何进入系统" class="headerlink" title="忘记登陆密码如何进入系统"></a>忘记登陆密码如何进入系统</h3><h4 id="配置寄存器"><a href="#配置寄存器" class="headerlink" title="配置寄存器"></a>配置寄存器</h4><p>配置寄存器（Configuration Register）是一个16位的虚拟寄存器，用于指定路由器启动的次序、中断参数和设置控制台波特率等，不同的配置寄存器数值决定了路由器的启动顺序（比如是从ROM中寻找IOS系统还是直接进入ROMMON模式）以及启动时的一些选项。该寄存器的值通常是以十六进制来表示的。Cisco路由器默认的配置设置是0x2102，这意味着第13位、第8位和第1位是开启的(值为1)。在特权模式下用命令“show version”查看当前配置寄存器的数值为多少。<strong>通过修改该数值可以决定路由器如何启动和运行。</strong></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-30-08.jpg" alt="Snipaste_2020-04-27_10-30-08"></p>
<p>上图中的二进制的0010000100000010，是由0X2102这个16进制的数字换算而来的，换算过程是，分别将2，1，0，2四个16进制换算成2进制然后组合而成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-33-04.jpg" alt="Snipaste_2020-04-27_10-33-04"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-27_10-31-47.jpg" alt="Snipaste_2020-04-27_10-31-47"></p>
<p>配置寄存器的默认设置是0x2102。这表明路由器应该尝试从闪存装载Cisco IOS软件镜像和用9600波特的控制台速率装载启动配置。注意，show version命令显示当前配置寄存器的值，也显示路由器重载后配置寄存器新的值。对配置寄存器进行的任何修改在重载之前不会起作用。</p>
<h4 id="口令恢复"><a href="#口令恢复" class="headerlink" title="口令恢复"></a>口令恢复</h4><p>总体思路是，在开机时需跳过载入 Startup Configuration，在没有任何密码的情况下进入 Enable Mode，然後手动载入 Configuration 并修改密码。正如前面介绍过的，配置寄存器的第6位用于告诉路由器是否使用NVRAM中的内容来加载路由器的配置。默认的配置寄存器值是0x2102，即第6位是关闭的(值为0)。默认情况下，路由器会查找并加载存储在NVRAM(startup-config文件)中的路由器配置。若要恢复口令，需要开启第6位，告诉路由器忽略NVRAM的内容，二进制的话就是0010000101000010，换算成16进制就是0X2142，开启了第6位的配置寄存器值是0x2142，所以在口令回复的时候要将寄存器值从默认的0X2102改成0X2142，葫芦i额NVRAM的内容才能进行密码恢复。</p>
<p><strong>1.启动路由器</strong></p>
<p>在IOS系统被载入时按键盘的Ctrl 和 Break键， (如 Mac 可按 Ctrl-Delete) 中断载入，并进入 rommon 模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200504110154.jpg" alt="微信图片编辑_20200504110154"></p>
<p>如果用笔记本的话没有小键盘的Break键，可以试试如下方法：</p>
<p><img src="/2020/04/14/10-cisco-ios/721cbdd9882df4399175d0c93f7577218c8d74c28dcb01a7cecf1411683e66d5.jpg" alt="721cbdd9882df4399175d0c93f7577218c8d74c28dcb01a7cecf1411683e66d5"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-04-56.jpg" alt="Snipaste_2020-05-04_11-04-56"></p>
<p><strong>2.修改配置寄存器，开启第6位，值为0x2142</strong></p>
<p>按 ? 再按 <ENTER> 可以看到可用的指令。而我们想要做的是修改 Configuration Register，由 0x2102 改成 0x2142，指令是 <strong>confreg 2142</strong>，然後用指令 <strong>reset</strong> 重新开机。</ENTER></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-05-46.jpg" alt="Snipaste_2020-05-04_11-05-46"></p>
<p><strong>3.重载路由器</strong></p>
<p> rommon 2 &gt;reset    //Cisco 2600系列路由器</p>
<p> &gt;I    //初始化，Cisco 2500系列路由器</p>
<p><strong>4.进入特权模式将开机启动配置加载到内存</strong></p>
<p>这次开机让它载入 IOS，最後因为没有载入 Startup Configuration 而出现 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-08-36.jpg" alt="Snipaste_2020-05-04_11-08-36"></p>
<p><strong>4.查看明文口令、重设口令</strong></p>
<p> 由於刚才跳过了载入 Startup Configuration，现在手动把 Startup Configuration 抄写至 Running Configuration，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-10-40-1588561857223.jpg" alt="Snipaste_2020-05-04_11-10-40"></p>
<p><strong>5.设置配置寄存器值为默认值</strong></p>
<p>重新开机，再次按键盘 Ctrl-Break (如 Mac 可按 Ctrl-Delete) 进入 rommon 模式，把 Configuration Register 回复至 0x2102 并重新开机，重设密码的步骤便完成了。</p>
<p> <img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_11-11-43.jpg" alt="Snipaste_2020-05-04_11-11-43"></p>
<h2 id="Cisco-交换机"><a href="#Cisco-交换机" class="headerlink" title="Cisco 交换机"></a>Cisco 交换机</h2><h3 id="交换机启动过程"><a href="#交换机启动过程" class="headerlink" title="交换机启动过程"></a>交换机启动过程</h3><p><strong>POST</strong> (Power On Self Test) - 进行开机硬件自检</p>
<p><strong>flash_init</strong> - 载入 flash_init 的小程式，用作读取 flash 里的档案。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-16-25.jpg" alt="Snipaste_2020-05-04_12-16-25"></p>
<p><strong>载入 IOS</strong> - 依 Flash丶TFTP 和 ROM 的顺序搜索并载入 IOS。</p>
<p><strong>载入 Startup Configuration</strong> - 如 Flash 中有 config.text 这个档案则载入，否则进入 System Configuration Dialog 模式。思科2900及3500系列的交换机并没有Configuration Register，要跳过载入 Startup Configuration 只需在 flash 把 config.text 档名改掉便可。</p>
<h3 id="Switch密码重置步骤"><a href="#Switch密码重置步骤" class="headerlink" title="Switch密码重置步骤"></a>Switch密码重置步骤</h3><h4 id="2950-2960-3550-3560系列"><a href="#2950-2960-3550-3560系列" class="headerlink" title="2950/2960/3550/3560系列"></a>2950/2960/3550/3560系列</h4><p><strong>进入Password-recovery 模式</strong></p>
<p>Switch 没有开关按钮，一插电制便开机了，在插电制的同时按着面版上的 Mode 按钮，直至 Switch 进入 Password-recovery 模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200504122312.jpg" alt="微信图片编辑_20200504122312"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-23-50.jpg" alt="Snipaste_2020-05-04_12-23-50"></p>
<p><strong>更改启动配置文件名称</strong></p>
<p>输入 <strong>flash_init</strong> 挂载 flash 档案系统，然後输入 <strong>dir flash:</strong> 应可看到 flash 里面的档案列表，这里我们的启动配置文件的名称是：config.text，将该文件改名为 config.bak，rename flash:config.text flash:config.bak，然後用指令 <strong>boot</strong> 开始载入 IOS。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-24-44.jpg" alt="Snipaste_2020-05-04_12-24-44"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-29-24.jpg" alt="Snipaste_2020-05-04_12-29-24"></p>
<p>由於系统找不到 config.text，因而没法载入 Startup Configuration 而出现 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-30-18.jpg" alt="Snipaste_2020-05-04_12-30-18"></p>
<p>把 flash:config.bak 改回 flash:config.text，然後把 startup-config 抄至 running-config，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration。重设密码步骤完成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-31-18.jpg" alt="Snipaste_2020-05-04_12-31-18"></p>
<h4 id="3650-3850"><a href="#3650-3850" class="headerlink" title="3650/3850"></a><strong>3650/3850</strong></h4><p>从 3650 开始，Switch 的 IOS 改用 Linux Base，重设密码方法又有点不同，步骤如下：</p>
<p>1、在插电制时先按着面版上的 Mode 去中断正常开机程序。</p>
<p>2、输入指令 SWITCH_IGNORE_STARTUP_CFG=1 (全大写)，这样就会跳过载入 Startup Configuration。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-33-48.jpg" alt="Snipaste_2020-05-04_12-33-48"></p>
<p>3、输入指令 <strong>flash_init</strong> 和 <strong>boot</strong> 把 IOS 载入。</p>
<p>4、系统进入 Initial Configuration Dialog 模式，输入 no 跳过，这时不用密码也可进入 Enable Mode 了。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-35-10.jpg" alt="Snipaste_2020-05-04_12-35-10"></p>
<p>5、由於刚才跳过了载入 Startup Configuration，所以手动把 Startup Configuration 抄写至 Running Configuration，现在可以修改密码了，最後别忘记 <strong>write memory</strong> 把 Configuration 储存至 Startup Configuration</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-35-45.jpg" alt="Snipaste_2020-05-04_12-35-45"></p>
<p>6、重新开机，再次按住 mode 按钮去中断正常开机程序，把 SWITCH_IGNORE_STARTUP_CFG 的值改回 0，然後输入指令 <strong>flash_init</strong> 和 <strong>boot</strong> 继续开机程序。重设密码步骤完成。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_12-36-13.jpg" alt="Snipaste_2020-05-04_12-36-13"></p>
<h2 id="设备管理及CISCO-IOS介绍"><a href="#设备管理及CISCO-IOS介绍" class="headerlink" title="设备管理及CISCO IOS介绍"></a>设备管理及CISCO IOS介绍</h2><h3 id="CISCO-IOS概述"><a href="#CISCO-IOS概述" class="headerlink" title="CISCO IOS概述"></a>CISCO IOS概述</h3><p>Cisco互联网络操作系统，Cisco私有的网络设备操作系统。它是Cisco 的一项核心技术，该操作系统应用于Cisco路由器、局域网交换机、小型无线接入点等设备。</p>
<p>cisco IOS 可为设备提供下列网络服务：</p>
<ul>
<li>基本的路由和交换功能 </li>
<li>安全可靠地访问网络资源 </li>
<li>网络可伸缩性</li>
</ul>
<h3 id="设备管理方法"><a href="#设备管理方法" class="headerlink" title="设备管理方法"></a>设备管理方法</h3><p>可以通过多种方法访问CLI（Command Line Interface，命令行界面） 环境，CLI是一种基于字符（文本）的界面，要与CLI交互，只需要输入命令，就像在文本编辑器中输入文章那样，在CLI中也可以使用复制黏贴等功能，。最常用的方法有：</p>
<ul>
<li>通过Console接口管理设备 </li>
<li>通过Telnet或SSH远程管理设备 </li>
<li>辅助端口 </li>
</ul>
<h4 id="通过Console接口管理网络设备"><a href="#通过Console接口管理网络设备" class="headerlink" title="通过Console接口管理网络设备"></a>通过Console接口管理网络设备</h4><p><img src="/2020/04/14/10-cisco-ios/Cisco+console+port.jpg" alt="Cisco+console+port"></p>
<p><img src="/2020/04/14/10-cisco-ios/console.jpg" alt="console"></p>
<p>Console，翻译成中文就是控制台，Console口就是专门用来配置设备的接口，用Console线和电脑连接，常见的Console线有以下几种：</p>
<p>一种是RJ-45（连接设备的Console口） —— DB-9（连接计算机）线，但由于现在很多电脑已经没有了DB-9接口，所以大多情况下需要额外的转接口才能和电脑连接：</p>
<p><img src="/2020/04/14/10-cisco-ios/usb-to-serial-adapter-with-console-cable.jpg" alt="usb-to-serial-adapter-with-console-cable"></p>
<p>另一种是RJ-45（连接设备的Console口） —— USB（连接计算机）线，所有电脑上都有USB接口，所以不用额外的设备即可连接计算机，比较方便，更推荐使用这种线连接设备：</p>
<p><img src="/2020/04/14/10-cisco-ios/AJV5_131962502847611197bIdYqdnY8K.jpg" alt="AJV5_131962502847611197bIdYqdnY8K"></p>
<p>还有一种蓝牙Console线，不受线长约束，非常方便：</p>
<p><img src="/2020/04/14/10-cisco-ios/O1CN011d84wI1b0cM5C4Gqs_!!52403403.jpg" alt="O1CN011d84wI1b0cM5C4Gqs_!!52403403"></p>
<p>用Console先连接好设备与计算机后，可以用超级终端或Secure CRT连接设备</p>
<h5 id="超级终端（HyperTerminal）"><a href="#超级终端（HyperTerminal）" class="headerlink" title="超级终端（HyperTerminal）"></a>超级终端（HyperTerminal）</h5><p>连接上Console线并装好驱动后，设备管理器中的端口选项中会多出一个设备，记住连接的是哪个COM口</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_13-52-21.jpg" alt="Snipaste_2020-04-16_13-52-21"></p>
<p>Win XP系统自带超级终端，可以再附件中找到该工具，其他系统的话需要自行下载。打开超级终端后，有个对话框提示要填写位置电话号码，点击取消关闭该对话框，然后进入连接配置界面，名称随便输入即可。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_13-55-22.jpg" alt="Snipaste_2020-04-16_13-55-22"></p>
<p>确定使用端口为上面设备管理器中的设备后，点击确定。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-40-15.jpg" alt="Snipaste_2020-04-16_14-40-15"></p>
<p>参数建议直接选择还原默认值，注意核对“位/秒”一项的值为9600即可点击确定，成功通过Console口登入设备。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-42-16.jpg" alt="Snipaste_2020-04-16_14-42-16"></p>
<h5 id="Secure-CRT"><a href="#Secure-CRT" class="headerlink" title="Secure CRT"></a>Secure CRT</h5><p>Secure CRT是网工常用的登录并对设备进行配置的强大工具，它支持SSH、Telnet和rlogin等协议，也可运行VBScript 和 JScript 脚本。该软件是一款商业软件，可以免费试用30天。安装好软件后，点击“New Session”新建连接。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-48-36.jpg" alt="Snipaste_2020-04-16_14-48-36"></p>
<p>协议（Protocol）使用Serial，端口（Port）使用设备管理器中显示的COM口号码，波特率（Baud rate）选择9600，其他用默认选项即可，连接名称可以自定义，此处用 “Cisco serial Console”，设置完毕后即可用Secure CRT通过Console口连接到设备。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-48-59.jpg" alt="Snipaste_2020-04-16_14-48-59"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-51-54.jpg" alt="Snipaste_2020-04-16_14-51-54"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-53-48.jpg" alt="Snipaste_2020-04-16_14-53-48"></p>
<p>下次使用时，该连接在Connect标签中会有保存，可直接点击Connect使用进行连接，不用重新配置参数。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-54-08.jpg" alt="Snipaste_2020-04-16_14-54-08"></p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_14-55-10.jpg" alt="Snipaste_2020-04-16_14-55-10"></p>
<h3 id="IOS系统的备份与升级"><a href="#IOS系统的备份与升级" class="headerlink" title="IOS系统的备份与升级"></a>IOS系统的备份与升级</h3><h4 id="IOS系统备份"><a href="#IOS系统备份" class="headerlink" title="IOS系统备份"></a>IOS系统备份</h4><p>1、设置TFTP服务器，记住该服务器的IP地址。</p>
<p>2、连接需要备份系统的设备，并登陆到特权模式，然后用show Flash命令查看Flash中有哪些文件：</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-04_14-01-01.jpg" alt="Snipaste_2020-05-04_14-01-01"></p>
<p>上面这个.bin后缀的文件就是我们要备份的IOS，根据你选择的路由器的不同，这个文件名称也会有所不同，复制这个名称，等会要用到。</p>
<p>3、使用<code>copy</code>命令将flash中的文件备份到tftp服务器。copy<code> </code>flash tftp，然后输入之前记住的TFTP服务器的IP地址，确保服务器与本设备可以正常通信，备份文件名可以进行更改也可以直接回车用IOS的原名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Address or name of remote host []? 192.168.1.100</span><br><span class="line">Destination filename [c2800nm-advipservicesk9-mz.124-15.T1.bin]?</span><br><span class="line">Writing c2800nm-advipservicesk9-mz.124-15.T1.bin...</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">[OK - 50938004 bytes]</span><br><span class="line">50938004 bytes copied in 30.561 secs (1666000 bytes/sec)</span><br></pre></td></tr></table></figure>

<h4 id="IOS系统升级"><a href="#IOS系统升级" class="headerlink" title="IOS系统升级"></a>IOS系统升级</h4><p>当路由器的IOS有了新的版本，可以通过下面的命令来升级，升级前可以使用show flash来查看一下flash空间大小，看看是否可容纳新的IOS文件。</p>
<p>1、从TFTP服务器上拷贝需要升级的IOS文件到Flash上</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#copy tftp flash</span><br><span class="line">Address or name of remote host []? 192.168.1.100</span><br><span class="line">Source filename []? c2800nm-advipservicesk9-mz.124-15.T1.bin             /输入TFTP上的新IOS文件名    </span><br><span class="line">Destination filename [c2800nm-advipservicesk9-mz.124-15.T1.bin]?         /输入存放到Flash中的名称</span><br></pre></td></tr></table></figure>

<p>2、路由器询问是否在拷贝新的IOS前删除旧的IOS系统，如果按回车则会删除旧的IOS系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Erase flash: before copying? [confirm]</span><br><span class="line">Erasing the flash filesystem will remove all files! Continue? [confirm]</span><br><span class="line">Erasing device... eee ...erased                                                /删除旧IOS系统中</span><br><span class="line">Erase of flash: complete                                                       /旧IOS系统删除成功</span><br></pre></td></tr></table></figure>

<p>3、删除旧IOS系统后开始拷贝新IOS系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Accessing tftp://192.168.1.100/c2800nm-advipservicesk9-mz.124-15.T1.bin...</span><br><span class="line">Loading c2800nm-advipservicesk9-mz.124-15.T1.bin from 192.168.1.100:</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line">[OK - 50938004 bytes]</span><br></pre></td></tr></table></figure>

<p>4、如果Flash中有多个IOS系统，可以使用下面的命令让这个新的IOS作为默认系统使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#boot system flash flash:c2800nm-advipservicesk9-mz.124-15.T1.bin</span><br></pre></td></tr></table></figure>

<h4 id="IOS系统恢复"><a href="#IOS系统恢复" class="headerlink" title="IOS系统恢复"></a>IOS系统恢复</h4><p>如果IOS文件被不小心删除，或者在升级IOS的过程中突然断电，则可能造成路由器IOS文件的丢失，路由不能正常启动，假设服务器上备份好了路由器的IOS文件，这里手动删除路由器的IOS来模拟IOS丢失的情况，因为IOS文件被删除，重启以后路由器进入了ROM monitor模式，在这个模式下配置下面的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rommon 1 &gt;</span><br><span class="line">rommon 1 &gt; IP_ADDRESS=192.168.1.1               /设置路由器的临时IP，只要和TFTP服务器在同一网段就可以了</span><br><span class="line">rommon 2 &gt; IP_SUBNET_MASK=255.255.255.0         /设置路由器的子网掩码</span><br><span class="line">rommon 3 &gt; DEFAULT_GATEWAY=192.168.1.1          /设置网关，由此可见IOS文件的恢复支持跨网段进行</span><br><span class="line">rommon 4 &gt; TFTP_SERVER=192.168.1.100            /设置TFTP服务器的IP地址</span><br><span class="line">rommon 5 &gt; TFTP_FILE=c2800nm-advipservicesk9-mz.124-15.T1.bin               /设置服务器上IOS的文件名</span><br><span class="line">rommon 6 &gt; tftpdnld                             /开始下载TFTP服务器上指定的IOS文件</span><br><span class="line">Do you wish to continue? y/n [n]: y</span><br><span class="line">!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!</span><br><span class="line"></span><br><span class="line">rommon 7 &gt; reset                                /传输完成后使用reset重启路由</span><br></pre></td></tr></table></figure>

<p><span style="color:red">注意：使用这种方法时，必须连接路由器接口号最小的那个以太网接口</span></p>
<h3 id="CISCO-IOS配置模式"><a href="#CISCO-IOS配置模式" class="headerlink" title="CISCO IOS配置模式"></a>CISCO IOS配置模式</h3><p><strong>用户模式</strong>（User Mode），显示为：cisco&gt; </p>
<p>– 正常登陆设备CLI后的第一个配置模式，只具备最基本的查看权限，输入“？”查询能使用的命令后发现可用命令十分有限。 </p>
<p><img src="/2020/04/14/10-cisco-ios/cisco_cli.png" alt="cisco_cli"></p>
<p>输入命令：enable后即可进入特权模式。</p>
<p><strong>特权模式</strong>（Privilege execute mode），显示为：cisco#</p>
<p>– 从用户模式通过认证（如果设置了密码）后即可进入特权模式，从截图中可以看到，输入“？”查询能使用的命令后发现可用命令相比用户模式多了很多。 </p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-04-54.jpg" alt="Snipaste_2020-04-16_15-04-54"></p>
<p><strong>全局配置模式</strong>（Global Configuration mode），在特权模式中输入config terminal 命令后即可进入全局模式，这个模式主要是针对网络整体参数进行的设置，例如DNS地址或接口IP地址等。从截图中可以看到，输入“？”查询能使用的命令后发现，命令相比前两个模式并不相同。</p>
<p>– 可配置设备全局参数，开启或关闭设备全局特性或功能； </p>
<p>– 从全局配置模式可进入多种不同的其他子配置模式。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-09-46.jpg" alt="Snipaste_2020-04-16_15-09-46"></p>
<h3 id="CISCO-IOS命令"><a href="#CISCO-IOS命令" class="headerlink" title="CISCO IOS命令"></a>CISCO IOS命令</h3><h4 id="IOS命令结构"><a href="#IOS命令结构" class="headerlink" title="IOS命令结构"></a>IOS命令结构</h4><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-31-37.jpg" alt="Snipaste_2020-04-16_15-31-37"></p>
<ul>
<li>每个IOS 命令都具有特定的格式或语法，并在相应的提示符下执行。 </li>
<li>常规命令语法为命令后接相应的关键字和参数。 </li>
<li>某些命令包含一个关键字和参数子集，此子集可提供额外功能。 </li>
</ul>
<h4 id="CLI的帮助"><a href="#CLI的帮助" class="headerlink" title="CLI的帮助"></a>CLI的帮助</h4><h5 id="命令提示及补全"><a href="#命令提示及补全" class="headerlink" title="命令提示及补全"></a>命令提示及补全</h5><p><strong>命令提示</strong>：输入一半或未输入命令时，在命令行中输入“？”后系统会提示接下来可能存在的补全命令，例如输入rout 然后输入？ 后，系统会告诉用户所有以“ rout ”开头的命令，在本例中有两个，一个是route-map，一个是router，如果没有任何以这个开头的命令则系统会提示用户知道。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-32-57.jpg" alt="Snipaste_2020-04-16_15-32-57"></p>
<p>如果在命令行中不输入任何命令直接输入“？”，则系统会将所有可能运行的命令告知用户。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-04-54-1587022600316.jpg" alt="Snipaste_2020-04-16_15-04-54"></p>
<p><strong>命令补全：</strong>在输入部分命令后，直接按键盘上的TAB键，如果此时用户输入的命令只存在一种可能，则按完TAB键后该命令会自动补全。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-38-17.jpg" alt="Snipaste_2020-04-16_15-38-17"></p>
<h5 id="命令语法检查"><a href="#命令语法检查" class="headerlink" title="命令语法检查"></a>命令语法检查</h5><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-39-40.jpg" alt="Snipaste_2020-04-16_15-39-40"></p>
<h5 id="热键和快捷方式"><a href="#热键和快捷方式" class="headerlink" title="热键和快捷方式"></a>热键和快捷方式</h5><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-16_15-40-11.jpg" alt="Snipaste_2020-04-16_15-40-11"></p>
<h4 id="cisco-IOS-基础配置"><a href="#cisco-IOS-基础配置" class="headerlink" title="cisco IOS 基础配置"></a>cisco IOS 基础配置</h4><h5 id="修改设备名称"><a href="#修改设备名称" class="headerlink" title="修改设备名称"></a><strong>修改设备名称</strong></h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# hostname AS_SSL_1F_S3640 </span><br><span class="line"></span><br><span class="line">AS_SSL_1F_S3640(config)#</span><br></pre></td></tr></table></figure>

<h5 id="配置用户登录密码："><a href="#配置用户登录密码：" class="headerlink" title="配置用户登录密码："></a><strong>配置用户登录密码</strong>：</h5><p>Console Password</p>
<p>用于限制人员通过控制台（Console）连接访问设备 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#line console 0                                在全局配置模式下进入console口</span><br><span class="line"></span><br><span class="line">R1(config-line)#password  cisco                          将console口登录密码设置成&quot;cisco&quot;</span><br><span class="line"></span><br><span class="line">R1(config-line)#login                                    确认启用该密码</span><br></pre></td></tr></table></figure>

<h5 id="特权模式密码"><a href="#特权模式密码" class="headerlink" title="特权模式密码"></a><strong>特权模式密码</strong></h5><p>限制人员使用特权模式配置设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#enable password cisco          设置非加密的特权模式密码，在查看命令时会显示密码，不安全</span><br><span class="line"></span><br><span class="line">Router(config)#enable secret cisco            设置经过加密的特权模式密码，在查看命令时不会显示密码</span><br></pre></td></tr></table></figure>

<h5 id="VTY-口令"><a href="#VTY-口令" class="headerlink" title="VTY 口令"></a><strong>VTY 口令</strong></h5><p>用于限制人员通过Telnet 远程访问设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#line vty0 4                                   进入编号为0-4的这5条VTY线路中</span><br><span class="line"></span><br><span class="line">Router(config-line)#password cisco                           将VTY远程Telnet登录的密码设置为cisco                    </span><br><span class="line">Router(config-line)#login                                    确认启用该密码</span><br></pre></td></tr></table></figure>

<h5 id="管理配置文件"><a href="#管理配置文件" class="headerlink" title="管理配置文件"></a>管理配置文件</h5><p>将当前配置写入启动配置文件，这样当前运行的配置（running-config）会保存在NVRAM中变成开机配置（startup-config），即使重启或断电后开机后依然会是该配置，下面两条命令均可实现此功能。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# write                                                    也可简写做wr</span><br><span class="line"></span><br><span class="line">R1# copy running-config startup-config                       将运行配置保存为开机配置</span><br></pre></td></tr></table></figure>

<p>删除启动配置文件，删除开机启动的所有配置，务必谨慎使用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# erase startup-config                                     删除</span><br><span class="line"></span><br><span class="line">R1# delete flash:config.text </span><br></pre></td></tr></table></figure>

<h5 id="备份配置文件"><a href="#备份配置文件" class="headerlink" title="备份配置文件"></a>备份配置文件</h5><p><strong>TFTP备份</strong></p>
<p>1、通过TFTP软件工具备份公司Cisco2960交换机的配置，用软件建立TFTP服务器，Server interfaces填入启动软件的电脑IP：172.18.1.88，备份文件存放地址E:\Cisco_bak</p>
<p><img src="/2020/04/14/10-cisco-ios/wKioL1i49degZT-jAAA7S9-CkBA600.png-wh_500x0-wm_3-wmp_4-s_13402697.png" alt="wKioL1i49degZT-jAAA7S9-CkBA600.png-wh_500x0-wm_3-wmp_4-s_13402697"></p>
<p>2、用Secure CRT 通过telnet登录2960交换机，使用命令，copy running-config tftp ，然后输入TFTP的IP地址，172.18.1.88，输入备份的文件名为：djjs-as-c2960x-2-config</p>
<p><img src="/2020/04/14/10-cisco-ios/wKiom1i49dex1enpAAAk-J4bNxI721.png-wh_500x0-wm_3-wmp_4-s_1645361981.png" alt="wKiom1i49dex1enpAAAk-J4bNxI721.png-wh_500x0-wm_3-wmp_4-s_1645361981"></p>
<p>3、在E:\Cisco_bak下查看备份的配置文件，确认备份成功。</p>
<p><strong>复制黏贴备份</strong></p>
<p>在全局配置模式下，输入show run，然后将输出的命令行复制黏贴到文本文档中保存起来。</p>
<h5 id="接口相关配置"><a href="#接口相关配置" class="headerlink" title="接口相关配置"></a>接口相关配置</h5><h6 id="进入接口"><a href="#进入接口" class="headerlink" title="进入接口"></a>进入接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)# interface ethernet 0/0             进入Ethernet 0/0接口</span><br><span class="line"></span><br><span class="line">R1(config-if)# </span><br></pre></td></tr></table></figure>

<p>Ethernet是一种接口类型，全称是Fast Ethernet，速率为100M，除此之外还有Gigabit Ethernet，千兆接口。</p>
<p>Ethernet 后面这个0/0，一般命名规则是：模块号/接口序号，0/0就是第0个模块板的第0个编号的接口</p>
<h6 id="设备接口规则："><a href="#设备接口规则：" class="headerlink" title="设备接口规则："></a>设备接口规则：</h6><ul>
<li>固定配置或者低端路由器。其接口编号使用单个数字，如1600路由器的接口编号可以是e0（以太网接口），s0(串行接口0)</li>
<li>中低端模块化路由器，其接口编号使用两个数字，中间用“1”格开，斜杠前面的是模块号，后面是模块接口编号，如2600路由器上的fa0/1表示第1个槽位的第2个接口，该接口是快速以太网接口。</li>
<li>高端模块化路由器，其接口编号有时是三个数字，中间用“/”格开，第一个数字是模块号，第二个数字是该模块上的子卡号，第三个数字是该子卡上的接口模块号。如2800路由器上的G0/0/0表示0槽位第1个子模块上的第一个接口，该接口是 千兆位以太网口。</li>
</ul>
<h6 id="为接口配置IP地址"><a href="#为接口配置IP地址" class="headerlink" title="为接口配置IP地址"></a>为接口配置IP地址</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)# ip address 192.168.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<h6 id="激活接口"><a href="#激活接口" class="headerlink" title="激活接口"></a>激活接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)# no shutdown                   CISCO设备接口默认shutdown状态，必须将接口开启才能使用</span><br></pre></td></tr></table></figure>

<h6 id="配置serial接口"><a href="#配置serial接口" class="headerlink" title="配置serial接口"></a>配置serial接口</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)# interface serial 0/0                            进入serial 0/0接口</span><br><span class="line">R1(config-if)# ipaddress 192.168.1.1 255.255.255.0          为接口配置IP地址和子网掩码</span><br><span class="line">R1(config-if)# no shutdown                                  将默认为关闭的接口开启</span><br><span class="line">R1(config-if)# clock rate 64000                             在DCE端配置serial接口的时钟信号 </span><br></pre></td></tr></table></figure>

<h5 id="show命令"><a href="#show命令" class="headerlink" title="show命令"></a>show命令</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ? </span><br><span class="line">show version                                                 查看当前操作系统版本 </span><br><span class="line">show running-config                                          查看运行配置 </span><br><span class="line">show startup-config                                          查看启动配置 </span><br><span class="line">show flash                                                   查看FLASH </span><br><span class="line">show cpu                                                     查看CPU利用率 </span><br><span class="line">show memory                                                  查看内存使用情况 </span><br><span class="line">show interface                                               查看端口</span><br><span class="line">show ip interface brief                                      查看所有端口简要情况</span><br></pre></td></tr></table></figure>

<h5 id="设置命令输入同步模式"><a href="#设置命令输入同步模式" class="headerlink" title="设置命令输入同步模式"></a>设置命令输入同步模式</h5><p>输入命令的时候，经常会有路由返回的各种消息打断了你的输入，虽然可以使用”Ctrl+R”来将当前输入转移到新行继续输入，但是这样非常不方便，可以通过下面的命令来让路由返回的消息不影响你的输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#line console 0              /进入console线路，</span><br><span class="line">R1(config-line)#logging synchronous   /设置console线路同步模式，返回的消息就不会打断输出了</span><br><span class="line">R1(config-line)#exec-timeout 0 0     /设置console线路命令输入永不超时，一段时间没有输入以后也不断开连接</span><br></pre></td></tr></table></figure>

<h5 id="返回上级命令"><a href="#返回上级命令" class="headerlink" title="返回上级命令"></a>返回上级命令</h5><p>exit命令是一次退一级的命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-line)#exit</span><br><span class="line">R1(config)#</span><br></pre></td></tr></table></figure>

<p>end命令是一次性退到特权模式最外层</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-line)#end</span><br><span class="line">R1#</span><br></pre></td></tr></table></figure>

<h5 id="命令缩写"><a href="#命令缩写" class="headerlink" title="命令缩写"></a>命令缩写</h5><p>命令可以缩写，缩写从要求是设备必须能够将缩写命令与其他命令区分开，比如在用户模式下要进入特权模式的命令enable可以缩写成en，因为以en开头的命令只有enable，设备不会将缩写的en错认为是其他命令。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-05_16-22-06.jpg" alt="Snipaste_2020-05-05_16-22-06"></p>
<p>但当缩写的命令有两种及两种以上可能时，缩写则不能使用，如下图中，interface 后面以v开头的命令有多个，这时如果直接回车输入的话，设备并不知道用户要输入具体哪个命令，所以返回一个“命令不完整”的信息。</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-05-05_16-23-54.jpg" alt="Snipaste_2020-05-05_16-23-54"></p>
<h4 id="Running-config-VS-Startup-config"><a href="#Running-config-VS-Startup-config" class="headerlink" title="Running-config VS Startup-config"></a>Running-config VS Startup-config</h4><p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-23_16-26-51.jpg" alt="Snipaste_2020-04-23_16-26-51"></p>
<h4 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h4><p>实验1：</p>
<p>结果使R1和R2之间可以连通</p>
<p><img src="/2020/04/14/10-cisco-ios/Snipaste_2020-04-23_16-28-02.jpg" alt="Snipaste_2020-04-23_16-28-02"></p>
<p>拓扑如上图所示，为两台直连路由器配置直连接口参数，使二者能够通信。</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router# configure terminal                                            进入全局配置模式</span><br><span class="line">Router(config)# hostname R1                                           将路由器名字改为R1</span><br><span class="line">R1(config)#enable secret 123456                                       为特权模式设置密码</span><br><span class="line">R1(config)#line console 0                                             进入console线路</span><br><span class="line">R1(config-line)#logg synchronous </span><br><span class="line">                设置console线路同步模式，返回的消息就不会打断输出了               </span><br><span class="line">R1(config-line)#exec-timeout 0 0     </span><br><span class="line">                设置console线路命令输入永不超时不断开连接   </span><br><span class="line">R1(config-line)#password test                                         设置console线路密码</span><br><span class="line">R1(config)# interface fastethernet 0/0                                进入E0/0接口</span><br><span class="line">R1(config-if)# ip address 192.168.12.1 255.255.255.0                  为E0/0接口配置IP地址</span><br><span class="line">R1(config-if)# no shutdown                                            激活E0/0接口</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router# configure terminal </span><br><span class="line">Router(config)# hostname R2 </span><br><span class="line">R2(config)# interface fastethernet 0/0 </span><br><span class="line">R2(config-if)# ip address 192.168.12.2 255.255.255.0 </span><br><span class="line">R2(config-if)# no shutdown </span><br></pre></td></tr></table></figure>

<p>验证配置：</p>
<p>ping 命令，看两者之间通信是否畅通</p>
<p>ping 192.168.12.2</p>
<p>traceroute 命令，追踪两个IP之间的通信路径</p>
<p>traceroute 192.168.12.2</p>
<p>R2telnet 远程连接R1，看设置是否正确</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#telnet 192.168.12.1</span><br><span class="line">Trying 192.168.12.1 ... Open</span><br><span class="line">User Access Verification</span><br><span class="line">Password: /*输入远程访问密码123456*/</span><br><span class="line">R1&gt;en</span><br><span class="line">Password: /*输入R1上的特权密码test*/</span><br><span class="line">R2# /*这样就进入了R2的特权模式了*/</span><br></pre></td></tr></table></figure>

<h2 id="CRT软件使用简介"><a href="#CRT软件使用简介" class="headerlink" title="CRT软件使用简介"></a>CRT软件使用简介</h2><h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><p><a href="http://vmnf.no-ip.org/itblog/how-to-setup-a-serial-console-connection/">How to Setup a serial Console connection</a></p>
<p><a href="http://blog.sina.com.cn/s/blog_635e1a9e0101172t.html">管理配置寄存器和路由器口令恢复</a></p>
<p><a href="https://www.jannet.hk/zh-Hans/post/password-recovery/">Password Recovery 重设密码</a></p>
<p><a href="https://www.qingsword.com/qing/707.html#CCNA-ios-manager-6">[CCNA图文笔记]-27-Cisco设备文件管理与密码恢复</a></p>
<p><a href="https://www.qingsword.com/qing/490.html">[CCNA图文笔记]-8-Cisco路由CLI基础命令</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>12、RIP</title>
    <url>/2020/06/18/12-RIP/</url>
    <content><![CDATA[<h1 id="RIP"><a href="#RIP" class="headerlink" title="RIP"></a>RIP</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>RIP（Routing Information Protocol，路由信息协议），是早期应用比较普遍的内部网关协议，是典型的距离矢量路由协议，适用于小型网络，最大的缺点是无法在具有冗余链路的网络中有效的运用。RIP一共有3个版本的协议，分别是RIP V1，RIP V2以及RIPNG。</p>
<p>RIP定义了请求信息和响应消息两种类型。请求信息：可以请求整张路由表，也可以请求具体的路由信息。</p>
<ul>
<li>请求整张路由表：请求消息含有一个地址族标识字段为0（地址为0.0.0.0），度量值为16的单条路由，收到这个请求的设备将通过单播方式向发出请求的地址回送它的整个路由表。</li>
<li>请求具体路由信息：当需要获知某个或某些具体路由的信息时，请求消息将与特定地址的路由条目一起发送。接受到请求的设备将根据请求消息逐个处理这些条目，并构成一个响应消息。</li>
</ul>
 <span id="more"></span>  

<h3 id="V1和V2的相同点"><a href="#V1和V2的相同点" class="headerlink" title="V1和V2的相同点"></a>V1和V2的相同点</h3><ol>
<li>RIP V1和V2协议的算法均为贝尔曼福特算法。</li>
<li>采用相同的防环机制，这六大机制为水平分割，路由中毒，毒性反转，触发更新，最大跳数，占用时间Hold Time。</li>
<li>端口号、协议号、管理距离和度量值相同。UDP端口号520，协议号17，管理距离（AD）是120，度量值均为跳数。</li>
<li>收敛速度和更新机制相同。更新机制均为周期更新、触发更新或完全更新、增量更新。RIP默认每隔30秒周期性的发送整个路由表给邻路由。</li>
<li>没有邻居机制，但有数据库。</li>
</ol>
<h3 id="V1和V2的不同点"><a href="#V1和V2的不同点" class="headerlink" title="V1和V2的不同点"></a>V1和V2的不同点</h3><ol>
<li><p>RIP V1是有类路由协议，发送路由更新<strong>不携带</strong>子网掩码，默认在有类边界自动汇总，不可关闭；RIP V2使用无类路由，发送路由更新要携带子网掩码，默认在有类边界自动汇总，但可以关闭。</p>
</li>
<li><p>V1不支持认证，V2支持认证。</p>
</li>
<li><p>V1采用广播更新路由，V2采用组播更新路由，组播地址为224.0.0.9。</p>
</li>
</ol>
<h3 id="V1的缺陷"><a href="#V1的缺陷" class="headerlink" title="V1的缺陷"></a>V1的缺陷</h3><p>RIPv1是一个有类路由协议，可以支持带子网的网络地址，但是必须是连续的，中间不被其他主类网络分隔，并且子网掩码长度必须相同。所以后面RIP 又推出了V2版本对此进行了一些改进。</p>
<h3 id="V2的改进"><a href="#V2的改进" class="headerlink" title="V2的改进"></a>V2的改进</h3><ol>
<li>外部路由标记。通过在RIP中使用路由标记，就能在其他协议中，控制相关路由的重发布，当重发布到其他协议时，RIP路由只需要比较赋予他们的标记而不用比较整个路由。</li>
<li>在路由更新中携带有子网掩码的路由选择信息，所以支持了VLSM和CIDR。</li>
<li>组播能力。使用224.0.0.9的组播地址发送路由更新，代替了V1的广播更新。</li>
<li>提供身份验证功能，支持明文和MD5认证。</li>
<li>支持连续子网以及不连续子网。</li>
<li>可以关闭自动汇总，并支持手动汇总。</li>
</ol>
<h3 id="V1和V2兼容性"><a href="#V1和V2兼容性" class="headerlink" title="V1和V2兼容性"></a>V1和V2兼容性</h3><p>默认情况下CISCO路由器上运行的 RIP发送v1，接收v1 v2， 如果显示声明为v1（在RIP进程中使用version 1命令）则只发送和接受v1报文，v2默认只发送和接收v2报文。</p>
<h3 id="RIP的计时器"><a href="#RIP的计时器" class="headerlink" title="RIP的计时器"></a>RIP的计时器</h3><p>Update timer更新计时器：RIP默认路由信息交换的时间为30秒一次。</p>
<p>Invalid timer无效计时器：当一条路由条目被加进路由表后，如果它在路由表中超过180秒未被更新，则路由器认为这条路由无效，在这种情况下，路由器会将该路由的跳数标记为16跳，也就是不可达。</p>
<p>hold down timer抑制计时器：一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。大概过程是如果一个路由器从邻居路由器收到一条更新，提示以前可达的网络现在不可达了，或有一个更大跳数的路由，则路由器标识该路由为不可达并启动一个抑制计时器，如果在定时器到时之前收到该路由又可达的更新，或者新度量值比之前的度量值更好，则路由器标识这个路由可达并删除定时器。路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。RIP的抑制计时器默认为6个更新的周期，也就是6X30，为180秒。</p>
<p>Flush time清除计时器：清除计时器的默认时间为240秒，也就是说如果240秒内一条路由如果始终没有相应，则该路由条目被标记为不可达并从路由表中移除。</p>
<h2 id="RIP-V2"><a href="#RIP-V2" class="headerlink" title="RIP V2"></a>RIP V2</h2><h3 id="报头"><a href="#报头" class="headerlink" title="报头"></a>报头</h3><p><img src="/2020/06/18/12-RIP/RIP_msgformat.PNG" alt="RIP_msgformat"></p>
<p><img src="/2020/06/18/12-RIP/Snipaste_2020-06-21_15-54-09.jpg" alt="Snipaste_2020-06-21_15-54-09"></p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)#router rip</span><br><span class="line">/*使用RIPv2，如果不使用这条命令默认是使用RIPv1*/</span><br><span class="line">Router(config-router)#version 2</span><br><span class="line">/*和RIPv1相同，都是宣告主类网络号*/</span><br><span class="line">R1(config-router)#no auto-summary  </span><br><span class="line">/*关闭自动汇总*/</span><br><span class="line">Router(config-router)#network 主类网络号</span><br><span class="line">Router(config-router)#int s0/0</span><br><span class="line">/*关闭自动汇总后，配置手动汇总的话需要在接口上进行配置，汇总是在路由的外出接口上面做的*/</span><br><span class="line">R1(config-if)#ip summary-address rip 汇总网络号  汇总掩码</span><br><span class="line">/*等待路由收敛后，查看路由表，就只能看到汇总路由的条目了*/</span><br></pre></td></tr></table></figure>

<h3 id="被动接口"><a href="#被动接口" class="headerlink" title="被动接口"></a>被动接口</h3><p>当一个运行RIP协议的接口被配置为被动接口后，这个接口不发出路由的更新信息但接受路由的更新信息。</p>
<p>配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#router rip </span><br><span class="line">R1(config-router)#passive-interface s1/1</span><br><span class="line">/*将S 1/1接口配置为被动接口*/</span><br></pre></td></tr></table></figure>

<h2 id="RIP-综合实验"><a href="#RIP-综合实验" class="headerlink" title="RIP 综合实验"></a>RIP 综合实验</h2><p><img src="/2020/06/18/12-RIP/Snipaste_2020-06-21_17-13-05.jpg" alt="Snipaste_2020-06-21_17-13-05"></p>
<h3 id="实验需求"><a href="#实验需求" class="headerlink" title="实验需求"></a>实验需求</h3><ol>
<li>网络拓扑如上图所示。 PC1 使用模拟器模拟，R3 下联的网段使用 Loopback 接口来模拟，一共开设三个 Loopback 接口，用于模拟 R3 下联的三个网段；</li>
<li>要求 R1、R2、R3 运行 RIPv2，并实现全网可达；</li>
<li>在 R3 上部署 RIP 手工路由汇总，使得 R1、R2 学习到 R3 下联 Loopback 的汇总路由。 </li>
</ol>
<h3 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h3><p>PC1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname PC1</span><br><span class="line">PC1(config)#ip default-gateway 172.16.1.254</span><br><span class="line">/*配置默认网关为172.16.1.254，也就是和本社设备链接的R1的G0/1接口*/</span><br><span class="line">PC1(config)#no ip routing</span><br><span class="line">/*关闭路由功能，当成PC设备使用*/</span><br><span class="line">PC1(config)#int G0/0</span><br><span class="line">PC1(config-if)#no sh</span><br><span class="line">/*路由器接口默认关闭，这里打开该接口*/</span><br><span class="line">PC1(config-if)#ip add 172.16.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R1</span><br><span class="line">R1(config-line)#int g0/1</span><br><span class="line">R1(config-if)#no sh</span><br><span class="line">R1(config-if)#ip add 172.16.1.254 255.255.255.0</span><br><span class="line">R1(config-if)#int g0/0</span><br><span class="line">R1(config-if)#no sh</span><br><span class="line">R1(config-if)#ip add 192.168.12.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R2</span><br><span class="line">R2(config)#int g0/0</span><br><span class="line">R2(config-if)#no sh</span><br><span class="line">R2(config-if)#ip add 192.168.12.2 255.255.255.0</span><br><span class="line">R2(config-if)#int g0/1</span><br><span class="line">R2(config-if)#no sh</span><br><span class="line">R2(config-if)#ip add 192.168.23.2 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router&gt;en</span><br><span class="line">Router#config t</span><br><span class="line">Router(config)#hostname R3</span><br><span class="line">R3(config)#int g0/0</span><br><span class="line">R3(config-if)#no sh</span><br><span class="line">R3(config-if)#ip add 192.168.23.3 255.255.255.0</span><br><span class="line">R3(config)#int loop 1</span><br><span class="line">R3(config-if)#ip add 172.16.32.1 255.255.255.0</span><br><span class="line">R3(config-if)#int loop 2</span><br><span class="line">R3(config-if)#ip add 172.16.33.1 255.255.255.0</span><br><span class="line">R3(config-if)#int loop 3</span><br><span class="line">R3(config-if)#ip add 172.16.34.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<h3 id="配置RIP"><a href="#配置RIP" class="headerlink" title="配置RIP"></a>配置RIP</h3><p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-if)#router rip</span><br><span class="line">R1(config-router)#version 2</span><br><span class="line">R1(config-router)#no auto-summary</span><br><span class="line">R1(config-router)#network 172.16.0.0</span><br><span class="line">R1(config-router)#network 192.168.12.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-if)#router rip</span><br><span class="line">R2(config-router)#version 2</span><br><span class="line">R2(config-router)#no auto-summary</span><br><span class="line">R2(config-router)#network 192.168.12.0</span><br><span class="line">R2(config-router)#network 192.168.23.0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#router rip</span><br><span class="line">R3(config-router)#version 2</span><br><span class="line">R3(config-router)#no auto-summary</span><br><span class="line">R3(config-router)#network 172.16.0.0</span><br><span class="line">/*RIP 在使用 network 命令指定网段时，只支持通告主类网络。R3 有三个 Loopback接口，将这三个接口激活RIP时，只需network 172.16.0.0即可，实际上即使你输 入诸如network 172.16.32.0这样的命令， 系统也会按network 172.16.0.0生效*/</span><br><span class="line">R3(config-router)#network 192.168.23.0</span><br></pre></td></tr></table></figure>

<h3 id="优化路由"><a href="#优化路由" class="headerlink" title="优化路由"></a>优化路由</h3><p>R3</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#int g0/0</span><br><span class="line">R3(config-if)#ip summary-address rip 172.16.32.0 255.255.252.0</span><br><span class="line">/*把三个loopback接口的网段汇总以后是172.16.32.0 255.255.255.252。</span><br><span class="line">RIP 的手工汇总，需要 RIP 版本 2 的支持，另外需要先在 RIP 进程中 no  auto-summary 关闭自动汇总功能，然后再在接口上配置手工汇总命令，注意，该命令配置在汇总 路由欲对外发布的那个接口上。*/</span><br></pre></td></tr></table></figure>

<h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><p><a href="http://ccietea.com/">红茶三杯CCNA实验手册</a></p>
<p><a href="http://ccietea.com/">红茶三杯Ip routing</a></p>
<p><a href="https://www.qingsword.com/qing/570.html#Cisco-CCNA-RIPv1-defect-9">[CCNA图文笔记]-14-RIPv1协议缺陷详解</a></p>
<p><a href="https://www.qingsword.com/qing/576.html">[CCNA图文笔记]-15-RIPv2协议详解</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>11、路由基础及静态路由</title>
    <url>/2020/05/04/11-route-basic/</url>
    <content><![CDATA[<h1 id="路由的基本概念"><a href="#路由的基本概念" class="headerlink" title="路由的基本概念"></a>路由的基本概念</h1><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><blockquote>
<p>Routing is the process of selecting a path for traffic in a network or between or across multiple networks.</p>
<p>In packet switching networks, routing is the higher-level decision making that directs network packets from their source toward their destination through intermediate network nodes by specific packet forwarding mechanisms.</p>
</blockquote>
<p>路由是指在一个网络中或多个网络之间或跨多个网络的流量选择路径的过程。路由是指通过特定的数据包转发机制，将网络数据包从源头通过中间网络节点向目的地方向引导网络数据包的高级决策。路由过程通常根据路由表指导转发。<strong>路由是一个三层（网络层）的概念</strong>。</p>
<p>当路由器（或者其他三层设备）收到一个 IP 数据包，路由器会找出 IP 包三层头中的目的 IP地址，然后拿着目的IP地址到自己的路由表中进行查找，找到“最匹配”的条目后，将数据包根据路由条目所 指示的出接口或下一跳 IP 转发出去，这就是 IP 路由（IP routing） 。而每台路由器都会在本地维护一个路由表 （Routing Table） ，路由表中装载着路由器获知的路由条目（Routes） ，路由条目由路由前缀（路由所关联的目的 地） 、路由信息来源、出接口或下一跳 IP 等元素构成。路由器通过静态的或者动态的方式获取路由条目并维护自 己的路由表。</p>
 <span id="more"></span>  

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_12-17-05.jpg" alt="Snipaste_2020-05-05_12-17-05"></p>
<p>具体到这张图上来说，PC1要和PC2进行通信，路由“指挥”着数据沿着红色箭头的路径一路传到了PC2。但路由器如何知道该如何传递数据呢？是因为路由器在收到数据以后查询了本机的路由表。</p>
<h3 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念"></a>一些基本概念</h3><h4 id="路由收敛"><a href="#路由收敛" class="headerlink" title="路由收敛"></a>路由收敛</h4><p>路由收敛指网络的拓扑结构发生变化后，路由表重新建立到发送再到学习直至稳定，并通告网络中所有相关路由器都得知该变化的过程。也就是网络拓扑变化引起的通过重新计算路由而发现替代路由的行为。路由的收敛时间是指从网络的拓扑结构发生变化到网络中所有路由设备中路由表重新保持一致的状态转换过程。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-27-23.jpg" alt="Snipaste_2020-05-14_17-27-23"></p>
<p>比如之前R4发送到R6数据是通过两者的G0/0直接发送，如果当两者之间G0/0直连的线路出现故障：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-29-41.jpg" alt="Snipaste_2020-05-14_17-29-41"></p>
<p>也就是网络的拓扑结构发生了变化，那么R4之前的路由表要发生变化，并且要重新查找去往R6的路由，最后发现可以通过R4-R5然后到达R6，然后R4重新构筑路由表，把前往R6网段的路径由R4-R6变更为R4-R5-R6，当链路上所有路由器的路由表都包含相同的网络可达信息，路由表不再发生变化进入一个稳定状态后，说明路由器的路由表收敛完毕。</p>
<h4 id="通信是双向的"><a href="#通信是双向的" class="headerlink" title="通信是双向的"></a>通信是双向的</h4><p>绝大部分的通信是双向的，这是由应用层的程序的功能决定的，所以在传输数据时要有来回的路由，比如R1-R2-R3三台路由器，R1需要和R3通信，R1需要有R3的路由这个大多数人都明白，因为没有R3的路由表R1不知道将数据如何发送，但R3也需要有R1的路由这个可能有一些人会忽略或不理解，这是因为常见的绝大多数应用层的应用程序是需要双向交互的，比如常用的检测链路是否通常的ICMP中的PING命令，当R1   ping  R3时，你发送出去了ICMP request（需要R1到R3的路由），对方要回复ICMP reply（需要R3到R1的路由），如果没有这个ICMP reply，R1就不知道ping通与否，所以这个通信是需要来回双向通信的。还有很多软件在传输层用TCP协议，又因为TCP的三次握手是双向的，所以这种情况下同时需要双向的路由，既要能去也要能回。当然也有少数的应用，比如IPTV，纯单向应用，单纯的把节目的流量推送给用户即可，不需要返回什么东西，这种情况下只有单项路由就可以了。</p>
<h4 id="动态路由协议端口号或协议号"><a href="#动态路由协议端口号或协议号" class="headerlink" title="动态路由协议端口号或协议号"></a>动态路由协议端口号或协议号</h4><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-10_11-08-18.jpg" alt="Snipaste_2020-06-10_11-08-18"></p>
<h4 id="有类路由、无类路由"><a href="#有类路由、无类路由" class="headerlink" title="有类路由、无类路由"></a>有类路由、无类路由</h4><p>CISCO 路由器在路由的全局查找上有两种方式：有类（Classful）查找方式及无类（Classless）查找方式。 当路由器执行无类别路由查找时（默认，ip classless），它不会注意目的地址的类别，它会在目的地址和所有 己知的路由之间逐位(bit by bit)执行最长匹配； 而如果是有类路由查找（no ip classless 且关闭ip cef） ，那么收到一个数据包时，路由器先查找目的地址所 属主类，如果路由表中有主类路由，则再去找子网，如果有子网路由，则查询被限定在这些子网中，并进一步查 找，如果最终查找失败（没有任何子网匹配这条路由） ，则丢弃数据包，即使有默认路由存在；如果本地没有该主 类路由，则看是否有默认路由，如果有，则按默认路由转发，如果无，则丢弃数据包。</p>
<p>目前基本所有在用的网络设备都是无类方式，有类如果看一遍不太懂可以暂时不看。</p>
<h4 id="loopback接口"><a href="#loopback接口" class="headerlink" title="loopback接口"></a>loopback接口</h4><ol>
<li>Loopback接口，也叫环回口，是一个逻辑的、虚拟的接口；</li>
<li>使用全局配置命令interface loopback 加上接口编号可创建一个Loopback接口，创建完成后即可为接口配置IP地址； </li>
<li>Loopback接口在手工创建后，除非人为shutdown，否则不会DOWN掉；</li>
<li>Loopback接口常用于： </li>
</ol>
<ul>
<li>模拟路由器的直连网段，可用于测试； </li>
<li>可用于设备管理（Loopback接口比较稳定，如果用其他接口的话，如果路由器的某一个接口由于故障down 掉了，但是其他的接口却仍旧可以telnet ，也就是说，到达这台路由器的TCP连接依旧存在，用Loopback接口就能成功Telnet这台设备。）； </li>
<li>供其他协议使用，例如OSPF、BGP、MPLS等，通常用作Router ID；</li>
<li>SNMPTraps消息的源地址； </li>
</ul>
<h2 id="路由表"><a href="#路由表" class="headerlink" title="路由表"></a>路由表</h2><h3 id="路由表的概念"><a href="#路由表的概念" class="headerlink" title="路由表的概念"></a>路由表的概念</h3><blockquote>
<p>In computer networking a routing table, or routing information base (RIB), is a data table stored in a router or a network host that lists the routes to particular network destinations, and in some cases, metrics (distances) associated with those routes. The routing table contains information about the topology of the network immediately around it.</p>
</blockquote>
<p>在计算机网络世界中，路由表，或者路由信息表（RIB），是存储在路由器或网络主机上的数据表，数据表中列出了去往特定网络目的地的路由，在某些情况下，还列出了与这些路由相关的度量值（距离）。路由表包含有关其周围网络拓扑的信息。</p>
<ul>
<li>每一台<strong>路由器、防火墙或三层交换机等三层设备</strong>都会维护一个路由表，在路由表中包含着路由器发现的路由（路由条目、路由表项）； </li>
<li>路由表相当于路由器的地图，路由器能够正确转发IP报文的前提是在其路由表中存在匹配该数据包目的IP地址的路由条目； </li>
<li>路由表中的路由条目获取来源有多种：直连路由、静态路由及动态路由协议。</li>
<li>路由表储存在RAM中，一般包括–源信息, 网络地址和子网掩码, 下一跳路由的IP地址</li>
</ul>
<p>举一个不太严谨的例子，路由表有点像我们去一个不认识地方时候问那附近的人路该怎么走，知道下一步如何走的这个人的功能类似于路由表。</p>
<h3 id="路由表的构成"><a href="#路由表的构成" class="headerlink" title="路由表的构成"></a>路由表的构成</h3><p>每个路由表项最少必须包括下面三个项目： </p>
<ul>
<li>目标地址（路由前缀） ： 这是路由条目所关联的目的网络号。一条完整的路由前缀由：网络号+前缀长度构成，两者缺一不可，例如 192.168.1.0/24 与 192.168.1.0/25，虽然两者的网络号相同，都是 192.168.1.0，但 是两者绝对是两条不同的路由、两个不同的路由前缀，因为他们的前缀长度不相同。 </li>
<li>指向目标的指针： 指针不是指向路由器的直连目标网络就是指向直连网络内的另一台路由器地址,或者是到这个链路的本地接口。更接近目标网络一跳的路由器叫下一跳(next hop)路由器。 </li>
<li>路由信息的来源： 本条路由是通过什么途径学习到的，例如是静态的，或者是通过 OSPF、IS-IS、 EIGRP、BGP 等动态路由学习到的。 </li>
</ul>
<h3 id="如何查看路由表"><a href="#如何查看路由表" class="headerlink" title="如何查看路由表"></a>如何查看路由表</h3><p>查看路由表的命令为：show ip route</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-50-46.jpg" alt="Snipaste_2020-05-04_19-50-46"></p>
<p>上图中的C表示直连路由，S表示静态路由。其他常用的路由获取来源还有O，也就是通过OSPF协议获得的，以及D，通过EIGRP协议获得。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-57-10.jpg" alt="Snipaste_2020-05-04_19-57-10"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_19-58-52-1588593580832.jpg" alt="Snipaste_2020-05-04_19-58-52"></p>
<p>思科路由器接口开机以后默认是关闭状态，必须到接口中使用“no shutdown”命令将接口开启，路由表才能更新该路由。</p>
<h2 id="路由条目获取的来源"><a href="#路由条目获取的来源" class="headerlink" title="路由条目获取的来源"></a>路由条目获取的来源</h2><h3 id="直连路由"><a href="#直连路由" class="headerlink" title="直连路由"></a>直连路由</h3><h4 id="直连路由定义"><a href="#直连路由定义" class="headerlink" title="直连路由定义"></a>直连路由定义</h4><p>路由器的直连接口所在网络的信息。这种路由不需要手工进行添加，只要端口连通信正常即可自动加入路由表。</p>
<h4 id="直连路由产生条件"><a href="#直连路由产生条件" class="headerlink" title="直连路由产生条件"></a>直连路由产生条件</h4><ol>
<li>接口配置IP地址</li>
<li>接口状态是UP</li>
</ol>
<p><strong>在满足以上两个条件时，直连路由自动产生，自动填充到路由表中。</strong></p>
<h4 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h4><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-02-48.jpg" alt="Snipaste_2020-05-05_13-02-48"></p>
<p>R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-04-11.jpg" alt="Snipaste_2020-05-05_13-04-11"></p>
<p>R1的路由表中有两条路由，一条前缀为C的路由表示这条路由的性质是connect，也就是靠直连获得的，这条路由是通往192.168.12.0/24这个网段的，出口是G0/0，也就是说如果收到一个目标IP地址是属于192.168.12.0网段的消息，将它从G0/0接口发出即可，这条直连路由是由R2的G0/1接口提供的，图中R1的G0/0接口和R2的G0/1接口直接连接；另一条前缀为L表示这条路由的性质为local，也就是本地路由，这条路由目的地址是192.168.12.1/32这个IP地址，连接到G0/0接口，这条路由是由本地的G0/0接口提供的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-13-09.jpg" alt="Snipaste_2020-05-05_14-13-09"></p>
<p>要注意的是，R2的G0/1接口和R1的G0/0接口直接连接，所以R1只有R2的G0/1这个直连接口，也就是192.168.12.0/24这个网段的路由，但并没有R2的G0/0，192.168.23.0/24这个网段的路由，因为R2的G0/0接口和R1不直接连接。</p>
<p>R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-06-22.jpg" alt="Snipaste_2020-05-05_13-06-22"></p>
<p>R2的路由表中有四条路由，两条本地路由两条直连路由。两条本地路由分别由G0/1和G0/0提供，目的地址分别是192.168.12.2/32以及192.168.23.2/32这两个IP地址。两条直连路由其中一条是由R1的G0/0提供的192.168.12.0/24网段的路由，因为R1的G0/0和R2的G0/1直连；另一条直连路由是由R3的G0/0提供的192.168.23.0/24网段的路由，因为R3的G0/0接口和R2的G0/0接口直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-14-58.jpg" alt="Snipaste_2020-05-05_14-14-58"></p>
<p>R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-07-45.jpg" alt="Snipaste_2020-05-05_13-07-45"></p>
<p>R3的路由表中有两条路由，一条本地路由一条直连路由，本地路由是到192.168.23.3/32这个IP地址的，由G0/0接口提供；直连路由时由R2的G0/0接口提供的到192.168.23.0/24这个网段的路由，因为R2的G0/0和R3的G0/0直连。</p>
<p>这里也要注意，R3只有R2的G0/0这个接口IP地址所处的网段，192.168.23.0/24的路由因为两者直连，但并没有R2的G0/1接口IP地址所处网段192.168.12.0/24的路由，因为R2的G0/1接口不和R3直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_14-24-19.jpg" alt="Snipaste_2020-05-05_14-24-19"></p>
<p>如果其中一个接口和对端的连通性出了问题，比如R2的G0/0或对端对应的接口（R3的G0/0）如果被shutdown或中间网线断开连接，则192.168.23.0这条路由会在R2的路由表中消失。直连的网络是指R1和R2之间，R2和R3之间这种中间没有其他三层设备的情况，R1和R3之间因为有R2路由器隔离了三层，不处于相同的广播域所以不算直连。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-04_20-32-23.jpg" alt="Snipaste_2020-05-04_20-32-23"></p>
<p> <a href="/download/static-route.zip">实验文件下载</a></p>
<p>此文件在EVE模拟器中使用，IOS如下图，我这个实验用的是VIOS，如果你的EVE里没有这个IOS记得在设备开机前对设备点击右键将设备的IOS换成其他的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_13-08-48.jpg" alt="Snipaste_2020-05-05_13-08-48"></p>
<h3 id="静态路由"><a href="#静态路由" class="headerlink" title="静态路由"></a>静态路由</h3><p>静态路由就是由手工为路由器添加的静态路由条目。</p>
<h3 id="动态路由"><a href="#动态路由" class="headerlink" title="动态路由"></a>动态路由</h3><p>通过在路由器上运行动态路由协议，使得路由器之间能够交互“用于路由计算的信息”，从而路由器动态的“学习”到网络中的路由。</p>
<h2 id="路由协议"><a href="#路由协议" class="headerlink" title="路由协议"></a>路由协议</h2><h3 id="路由协议的定义"><a href="#路由协议的定义" class="headerlink" title="路由协议的定义"></a>路由协议的定义</h3><blockquote>
<p>A routing protocol specifies how routers communicate with each other to distribute information that enables them to select routes between any two nodes on a computer network. Routers perform the “traffic directing” functions on the Internet; data packets are forwarded through the networks of the internet from router to router until they reach their destination computer. Routing algorithms determine the specific choice of route. Each router has a prior knowledge only of networks attached to it directly. A routing protocol shares this information first among immediate neighbors, and then throughout the network. This way, routers gain knowledge of the topology of the network. The ability of routing protocols to dynamically adjust to changing conditions such as disabled data lines and computers and route data around obstructions is what gives the Internet its fault tolerance and high availability.</p>
</blockquote>
<p>路由协议规定了路由器之间如何交换选路信息，这些选路信息使得路由器能够在计算机网络上的任意两个节点之间选择路径，并利用选择出的路径发送数据。路由器在互联网上承担了“流量指挥”的功能。数据在互联网上从一个路由器传递到另一个路由器直到到达目的计算机。路由算法决定了选择路径的方式。正常连接情况下每个网段只知道自己直连的网段。路由协议首先会在直连的邻居之间共享路由信息，然后在整个网络中共享这些信息，这样一来路由器就获得了网络拓扑的结构。路由器能够根据不断变化的网络情况（如线路中断或计算机宕机）进行动态调节，使得被路由数据传输能绕开障碍设备传递，这就是互联网具有容错性和高可用性的原因。</p>
<h3 id="路由协议的分类"><a href="#路由协议的分类" class="headerlink" title="路由协议的分类"></a>路由协议的分类</h3><p><img src="/2020/05/04/11-route-basic/Cisco-CCNA-static-routing-2.jpg" alt="Cisco-CCNA-static-routing-2"></p>
<h4 id="静态路由协议"><a href="#静态路由协议" class="headerlink" title="静态路由协议"></a>静态路由协议</h4><p>根据数据访问需求手工在每台设备上进行静态路由条目的创建。静态路由协议只能知道局部地点的静态信息，因为运行了静态路由协议的路由器之间<strong>不会</strong>互相交换网络信息，所以它不知道网络整体是如何连接的，只知道手动添加的那些局部地点的路由。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_12-41-09.jpg" alt="Snipaste_2020-05-05_12-41-09"></p>
<p>从前一节的知识可知，R1和R2之间是直连的，因为中间没有其他三层设备，所以R1只知道和它直连的R2的路由信息，192.168.12.0网段如何去，但由于R2的另一个接口2.2.2.0/24并未和R1直连，所以R1的路由表中并没有该网段的信息，R1即使收到去往2.2.2.0/24网段的数据也不知道如何处理只能丢弃，因为路由表中并没有去往该网段的路由条目。这时候为了让数据在R1上被正确发送，我们可以手工添加一条静态路由到路由表中，让路由器知道如何处理，添加完静态路由后，路由表中即会出现2.2.2.0/24这个网段的路由条目。</p>
<p>举一个不太恰当的例子说明一下加深理解，静态路由生成的路由条目有点类似咱们看到的静态的指路牌，每个路标相当于静态路由中的一个路由条目，这些路牌的信息都是静态的，不能自己动态更新必须由人工添加或修改，静态路牌没有路况状态的实时信息，不知道所指出的路径是畅通还是拥堵，也不知道指出的路还能否到达目的地，比如你想下山，这个路牌上指出了下山的方向，只要不人为的翻修、更新这个路牌的信息，它会一直指着同一个方向，但按静态路牌走能不能下山，下山这条路上是否拥堵，一概不知道，因为静态路牌没法动态的知道这条路上的路况以及这条路情况是否现在还能够通往下山。这就是前面说的静态路由只知道局部地点的静态信息的大概比喻。</p>
<p><img src="/2020/05/04/11-route-basic/65498746456-1589792877010.jpg" alt="65498746456"></p>
<h4 id="动态路由协议"><a href="#动态路由协议" class="headerlink" title="动态路由协议"></a>动态路由协议</h4><p>路由器自动进行路由或用于路由计算的相关信息的更新和同步，并且当网络拓扑变更时，能够动态收敛。 </p>
<p>由于静态路由协议需要手工配置每一条路由条目，使得静态路由协议在大规模的网络中（例如跨国企业的网络、ISP运行商网络）使用起来十分困难，为了解决这个问题动态路由协议应运而生，动态路由协议可以让路由器自动学习到其他路由器的网络信息，每台路由器根据所掌握的全网的网络信息，<strong>以自我为中心计算出</strong>去往网络中各网段应如何转发生成相应路由表（和别的设备交换的只是网络的信息，根据这些信息每台路由器独立计算出本路由器的路由表，计算出路由表的这个过程不会和别的路由器协商），并且在网络拓扑发生改变后能自动获取变化后的网络信息，并根据之前获取和新获取的信息自动重新计算更新路由表。网络管理员只需要配置动态路由协议即可，相比人工指定转发策略，工作量大大减少。常见的动态路由协议有：OSPF，BGP，IS-IS，RIP，EIGRP等。</p>
<p>在动态路由中，管理员不再需要与静态路由一样，手工对路由器上的路由表进行维护，而是在每台路由器上运行一个路由协议。这个路由协议会根据路由器上的接口的配置（如IP地址的配置）及所连接的链路的状态信息，计算并生成路由表中的路由表项。当网络拓扑结构改变时动态路由协议可以自动更新路由表，并负责决定数据传输最佳路径。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_15-37-51.jpg" alt="Snipaste_2020-05-05_15-37-51"></p>
<p>当R1和R2的所有接口都运行了动态路由协议时，R1和R2就能互相交互路由信息，使得路由器动态的“学习”到网络中其他运行了相同动态路由协议设备上的路由信息，并更新自己的路由表。上图中的R1和R2在运行相同动态路由协议的情况下，R1就能“学习”到R2上2.2.2.0/24的信息，然后独立计算出前往该网段的最佳路由添加到自身的路由表中以便以后使用。</p>
<p>举个不太恰当的例子方便理解，动态路由协议有点像底下视频中这个动态指路牌，首先动态路牌里的系统会学习并掌握到整个城市的地图以及实时的路径拥堵情况，而且是动态更新的，不管道路是拥塞、中断或畅通，这个电子动态路牌中的系统都会掌握并实时更新，并根据这些动态更新的路况计算出去往目的地最佳的路径，然后动态更新路牌的指路方向。这个动态路牌获取的是一个动态的全城的路径数据信息或者叫数据库更为准确一些，然后基于这个动态数据库自己计算出自己的动态路标。</p>
<iframe src="//player.bilibili.com/player.html?aid=5842876&bvid=BV1Fs411k7B8&cid=9488192&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h5 id="距离矢量路由协议"><a href="#距离矢量路由协议" class="headerlink" title="距离矢量路由协议"></a>距离矢量路由协议</h5><h6 id="距离矢量的概念"><a href="#距离矢量的概念" class="headerlink" title="距离矢量的概念"></a>距离矢量的概念</h6><p>距离矢量（distance vector）：距离矢量路由协议根据距离确定数据包的最佳路由。距离矢量路由协议用数据包经过路由器的数量来定义距离，当数据传递经过一个路由器时，算作一跳。有些距离矢量路由协议也加入了延迟或其他因素来决定路由的传递（eigrp协议）。为了确定通往一个网络号的最佳路径，运行了距离矢量路由协议的路由器会互相交换信息，它们交换的信息通常是路由表加上到目标网络的跳数，有时候还有一些其他的流量信息，比如上面提到的延迟。距离矢量路由协议通常还要求路由器定期通知其邻居关于网络拓扑的变化。距离矢量协议使用<a href="https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm">Bellman–Ford</a>算法和<a href="https://en.wikipedia.org/wiki/Ford%E2%80%93Fulkerson_algorithm">Ford–Fulkerson</a>算法来计算最佳路径。</p>
<p>距离矢量路由协议是“基于传闻的路由协议”，A发路由信息给B，B加上自己的度量值又发给C，路由表里的条目是听来的，每个路由器都不知道整个网络的拓扑是什么样，只知道自身与目标网络之间的距离，以及应该往哪个方向或使用哪个接口转发数据包。距离矢量路由协议选出最优路径的同时也可能会引发环路问题，它使用水平分割、毒性逆转以及触发更新等机制来避免环路。距离矢量路由协议一般采用定期更新、广播更新、路由表更新的方式更新路由表。</p>
<p>做一个不太恰当的比喻，距离矢量路由协议的工作过程有点类似于你到上海旅游想去迪士尼公园，出了旅馆的门到一个十字路口不知道该怎么走了，你就在十字路口附近问别人，要去迪士尼乐园我应该在这个路口怎么拐？被问的这个人告诉你，他也不是本地人不认识上海也没去过迪士尼，但他听别人（基于传闻的路由）说从这右拐（左拐）这个方向就是去迪士尼。距离矢量协议的工作特点就是路由一跳一跳的传递，到了一个路由器（十字路口）查了路由表（问别人如何去迪士尼）才知道下一跳应该从哪个接口发送出去是去迪士尼的大致方向（左拐或右拐），但路上被问路的人除了最后一个人确切知道迪士尼公园肯定是在哪以外，其他人既不知道迪士尼公园的确切位置，也不知道上海整体的地图是什么样，它们唯一知道的只是别人告诉他去迪士尼大概的方向是哪，应该怎么走。</p>
<p>距离矢量协议除了BGP、EIGRP可能在现网中有部署以外，其他的比如RIP协议已经几乎不可能在现网中看到了。</p>
<h6 id="最大跳数"><a href="#最大跳数" class="headerlink" title="最大跳数"></a>最大跳数</h6><p>距离矢量协议中的“距离”也称为“跳数”（hop），每经过一个路由器，跳数就增加1，距离矢量协议使用最大跳数来避免环路，超过最大跳数则说明该路由不可达。例如在RIP协议中，一条路径只能包含15个路由器，也就是一条路由最大只能经过15跳，当距离（跳数）为16时，则说明这条路由不可达。</p>
<h6 id="水平分割"><a href="#水平分割" class="headerlink" title="水平分割"></a>水平分割</h6><p>水平分割（Split horizon route advertisement）是在距离矢量路由协议中<strong>防止环路</strong>的一种方式，是通过禁止路由器将所学到的路由条目通告给学到该路由条目的接口的方式实现的。用人话说就是从这个接口收到的路由，就不会再从这个接口发回去。</p>
<p>举个例子：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>有R1、R2、R3三台路由器如上图所示连接好，全部运行距离矢量协议，根据水平分割原则，路由器R1不会将收到的关于R3的8.8.8.8的路由条目通告给R2，因为8.8.8.8的路由是由R3通告给R2，然后R2通告给R1的，R1是从R2学到的该路由，所以不会通告回R2，为了防止产生环路。我们来看看如果没有水平分割原则会如何，如果R2和R3的链路发生故障，R2没有了去往8.8.8.8网段的路由，如果没有水平分割原则，则R1会将8.8.8.8的路由回告给R2，这种情况下，R2通过R3去往8.8.8.8的路由条目此时消失了，因为G0/0口已经down了，获取的所有路由就会从路由表中消失，而R2收到了R1能去往8.8.8.8的路由，认为通过R1能到达8.8.8.8，所以此时R2会把发往8.8.8.8的路由发给R1，但R1的路由表上去往8.8.8.8的下一跳是R2，也就是要把去往8.8.8.8的数据发给R2，然后R2收到目的IP地址为8.8.8.8的数据后，路由表上去往8.8.8.8的下一跳是R1，数据又发给了R1，循环往复，就形成了环路，所以水平分割原则十分重要。</p>
<h6 id="路由中毒"><a href="#路由中毒" class="headerlink" title="路由中毒"></a>路由中毒</h6><p>路由中毒（Route poisoning）。路由中毒是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值为无穷大明白该路由是无效的。</p>
<p>距离矢量路由协议使用路由中毒来告诉其他路由器，某条路由已经失效无法传送数据到目的地址，不要将该路由加入其他路由器的路由表。和具有毒性反转的水平分割不同，路由中毒会立刻向网络中所有节点发送某条路由的路由更新，这条路由更新中该路由的跳数为不可到达。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36-1589447716551.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>依旧用这个拓扑来说明路由中毒，三台路由器依旧运行距离矢量路由协议，这里用RIP举例，在RIP协议中，不可达的metric为16跳，R1的8.8.8.8的路由是R3发送给R2然后再传递给R1的，如果R3到8.8.8.8的链路中断，那么在下次发送给其他路由器更新RIP的路由表中就不会有8.8.8.8这个网络，而R2 和R1由于RIP路由的过期时间为180秒，这两个路由器的路由表中依旧有8.8.8.8这个路由条目因为还没到老化删除该条目的时间所以依旧会存在。但除了R3以外其他路由器不会知道此时R3已经没法去往8.8.8.8了，在R1、R2收到发往8.8.8.8的数据时，还会发给R3，可能会导致环路的产生。路由中毒的做法是，当R3发现前往8.8.8.8的网络中断后，在下次发送路由更新时，依旧会有8.8.8.8这个条目并将其跳数变更为不可达的metric，在RIP中就是协议跳数最大值+1，15+1也就是16，因为16超过了跳数的协议最大值15，所以R2收到路由更新时会发现去往8.8.8.8的路由条目中的metric变为了16跳，也就是不可达，R2会立刻知道8.8.8.8网络不可达，无需等待180秒RIP条目老化才将其删除。</p>
<h6 id="毒性反转"><a href="#毒性反转" class="headerlink" title="毒性反转"></a>毒性反转</h6><p>毒性反转（Poison Reverse），和水平分割功能类似，也是在网络中避免环路的原则。它是指收到路由中毒消息的路由器，不遵守水平分割原则将中毒的路由消息转发给所有的相邻路由器，也包括发送中毒信息的源路由器，也就是通告相邻路由器这条路由信息己失效了。主要目的是达到快速收敛的目的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_16-17-36-1589447716551.jpg" alt="Snipaste_2020-05-14_16-17-36"></p>
<p>依旧用上面的拓扑来解释毒性反转，三台路由器依旧运行距离矢量路由协议，这里用RIP举例，在RIP协议中，不可达的metric为16跳，R1的8.8.8.8的路由是R3发送给R2然后再传递给R1的，如果R3到8.8.8.8的链路中断，那么在下次发送给其他路由器更新RIP的路由表中就不会有8.8.8.8这个网络，而R2 和R1由于RIP路由的过期时间为180秒，这两个路由器的路由表中依旧有8.8.8.8这个路由条目因为还没到老化删除该条目的时间所以依旧会存在。但除了R3以外其他路由器不会知道此时R3已经没法去往8.8.8.8了，在R1、R2收到发往8.8.8.8的数据时，还会发给R3，可能会导致环路的产生。前面说过此时就该路由中毒出场了，路由中毒做法是，当R3发现前往8.8.8.8的网络中断后，在下次发送路由更新时，依旧会有8.8.8.8这个条目并将其跳数变更为不可达的metric，在RIP中就是协议跳数最大值+1，15+1也就是16，因为16超过了跳数的协议最大值15，所以R2收到路由更新时会发现去往8.8.8.8的路由条目中的metric变为了16跳，也就是不可达，R2会立刻知道8.8.8.8网络不可达，无需等待180秒RIP条目老化才将其删除。此时路由中毒已经完成任务了，接下来毒性反转原则，是将带有无穷大metric的这条8.8.8.8的路由发送给R1而且会不遵守水平分割原则，这样会大大加快网络的收敛速度。</p>
<h6 id="水平分割、毒性反转、路由中毒"><a href="#水平分割、毒性反转、路由中毒" class="headerlink" title="水平分割、毒性反转、路由中毒"></a>水平分割、毒性反转、路由中毒</h6><p>再用个例子来更好的说明这三个概念。R1和R2运行RIP V2，均宣告了自己的loop0接口和G0/0接口网段进RIP，彼此路由表中均有对方loop0的路由条目。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-45-46.jpg" alt="Snipaste_2020-06-17_15-45-46"></p>
<p><strong>水平分割原则</strong>（Split Horizon）是从这个接口收到的路由，就不会再从这个接口发回去。R2通过G0/0从R1处学到了1.1.1.1的路由，根据水平分割原则，R2从G0/0学到的1.1.1.1的路由不会再通过G0/0发送回R1，抓包也能看出来，R2只向R1发送了自身2.2.2.2的路由条目：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-52-50.jpg" alt="Snipaste_2020-06-17_15-52-50"></p>
<p><strong>路由中毒</strong>（Route Poisoning）是指在路由信息在路由表中失效时，先将度量值变为无穷大的数，而不是马上从路由表中删掉这条路由信息。 然后再将中毒路由信息发布出去，当相邻的路由器收到该中毒路由就可以通过其度量值为无穷大明白该路由是无效的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_15-45-46.jpg" alt="Snipaste_2020-06-17_15-45-46"></p>
<p>在这个例子中，我们将R1的loop1接口shutdown，这样这条1.1.1.1的RIP路由就在路由表中失效了，来抓包看看结果如何：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_17-02-36.jpg" alt="Snipaste_2020-06-17_17-02-36"></p>
<p>此时R1在得知1.1.1.1的路由失效后，并没有删除该条路由而是立刻将该条路由的度量值变为无穷大，在RIP中就是16跳，并发送出去。</p>
<p><strong>毒性反转</strong>（Poison Reverse）指的是收到路由中毒消息的路由器，不遵守水平分割原则将中毒的路由消息转发给所有的相邻路由器，也包括发送中毒信息的源路由器，也就是通告相邻路由器这条路由信息己失效了。在这里收到中毒消息的路由器是R2，按照毒性反转的定义，它应该违反水平分割原则，将带有中毒的路有消息发送给R1，现在来抓包看看：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-17_17-07-54.jpg" alt="Snipaste_2020-06-17_17-07-54"></p>
<h6 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h6><p>触发更新（trigger update）。当路由表发生变化时，更新报文立即广播给相邻的所有路由器，而不是等待30秒的更新周期。同样，当一个路由器刚启动RIP时，它广播请求报文。收到此广播的相邻路由器立即应答一个更新报文，而不必等到下一个更新周期。这样，网络拓扑的变化会最快地在网络上传播开，减少了路由循环产生的可能性。</p>
<h6 id="抑制计时器"><a href="#抑制计时器" class="headerlink" title="抑制计时器"></a>抑制计时器</h6><p>抑制计时器（hold-down timer）。一条路由信息无效之后，一段时间内这条路由都处于抑制状态，即在一定时间内不再接收关于同一目的地址的路由更新。大概过程是如果一个路由器从邻居路由器收到一条更新，提示以前可达的网络现在不可达了，或有一个更大跳数的路由，则路由器标识该路由为不可达并启动一个抑制计时器，如果在定时器到时之前收到该路由又可达的更新，或者新度量值比之前的度量值更好，则路由器标识这个路由可达并删除定时器。路由器从一个网段上得知一条路径失效，然后，立即在另一个网段上得知这个路由有效。这个有效的信息往往是不正确的，抑制计时避免了这个问题，而且，当一条链路频繁起停时，抑制计时减少了路由的浮动，增加了网络的稳定性。 </p>
<h5 id="链路状态路由协议"><a href="#链路状态路由协议" class="headerlink" title="链路状态路由协议"></a>链路状态路由协议</h5><p>链路状态路由协议的工作流程是，发现其他同样运行了该链路状态路由协议的设备——所有设备交换相关链路信息——每个设备自己形成整体的连接图——每个设备独立计算最短路径形成路由表。首先运行了链路状态协议的所有节点共同构建一个连接图，这个连接图显示了网络上设备相互连接的情况。运行了该路由协议的节点会从本设备上所有可能的路径中，计算出本设备上的最佳下一跳是哪条路径，每个设备上最佳的路径构成了每个设备的路由表。</p>
<p>链路状态路由协议有点像你用导航去迪士尼乐园，导航软件从一开始就知道整个上海的地图以及从你所在的地点到迪士尼乐园有哪些可能存在的路线，然后对这些潜在的路线进行比较，看看哪条路线拥堵哪条路径通畅，最后选择出一条最优的路线告诉你应该怎么走。</p>
<h6 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h6><ol>
<li>形成的路由表更加精确。链路状态路由协议是根究互相交换的LSA构成LSDB，在构成路由表，且路由表是在充分了解全网状况的条件下形成的，而距离矢量路由协议仅根据邻居路由宣告的信息生成自己的路由表。</li>
<li>触发更新，收敛更快。链路状态路由协议采用触发更新机制，当网络发生变化时，路由器收到LSA后，立刻向除了接收到此LAS接口的其他接口泛洪出去，然后执行算法更新路由表，而距离矢量路由表采用周期性更新路由表。</li>
<li>分层设计。链路状态路由协议都采取了区域设计，为链路状态更新范围设定了边界。LSA的传播和SPF的计算被限制在一个区域内，同一区域内路由器具有相同的LSDB，区域间路由信息的交换由区域边界路由器完成，因此路由表更小，并降低了链路状态更新的开销。</li>
</ol>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>内存需求更大，处理器要求更高，带宽需求更大。</p>
<h2 id="度量值及管理距离"><a href="#度量值及管理距离" class="headerlink" title="度量值及管理距离"></a>度量值及管理距离</h2><h3 id="管理距离"><a href="#管理距离" class="headerlink" title="管理距离"></a>管理距离</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>管理距离（Administrative Distance，AD）是指一种路由协议的路由可信度。每一种路由协议按可靠性从高到低，依次分配一个信任等级，这个信任等级就叫管理距离。管理距离是一个从0~255的整数值，0是最可信赖的，而255意味着不会有业务量从这个路由通过。<strong>管理距离仅在本设备具有重要意义，因此不会在路由更新中进行通告。</strong></p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>当去往同一网段有两个或多个不同路由协议的路由表项时，管理距离用来选择使用哪种路由协议去往该网段。正常情况下，管理距离越小，它的优先级就越高，也就是可信度越高。也就是说，当到达一个目的地有多个不同的路由协议时，路由器根据管理距离来决定相信哪一个协议，AD是用于不同路由协议之间比较的参数。</p>
<h4 id="理论分析"><a href="#理论分析" class="headerlink" title="理论分析"></a>理论分析</h4><p>如果路由器分别收到使用开放最短路径优先 (OSPF)（默认管理距离为110）和 Interior Gateway Routing Protocol (IGRP)（默认管理距离为100）通往特定网络的路由，则路由器将选择 IGRP，因为 IGRP 更可靠。这意味着路由器将路由的 IGRP 版本添加到路由表。</p>
<p>如果丢失了 IGRP 协议的设备信息（例如，由于电源关闭），则会使用 OSPF 协议的路由表进行数据转发，一直到 IGRP 的路由信息再次出现。</p>
<h4 id="设备默认AD值"><a href="#设备默认AD值" class="headerlink" title="设备默认AD值"></a>设备默认AD值</h4><p>不同厂家对于设备的默认AD值规定不相同，具体参见下表。</p>
<h5 id="思科设备默认AD值"><a href="#思科设备默认AD值" class="headerlink" title="思科设备默认AD值"></a>思科设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_15-51-14.jpg" alt="Snipaste_2020-05-05_15-51-14"></p>
<h5 id="juniper设备默认AD值"><a href="#juniper设备默认AD值" class="headerlink" title="juniper设备默认AD值"></a>juniper设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-01-24.jpg" alt="Snipaste_2020-05-05_16-01-24"></p>
<h5 id="华为设备默认AD值"><a href="#华为设备默认AD值" class="headerlink" title="华为设备默认AD值"></a>华为设备默认AD值</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-14-46.jpg" alt="Snipaste_2020-05-05_16-14-46"></p>
<h3 id="度量值"><a href="#度量值" class="headerlink" title="度量值"></a>度量值</h3><p>度量值（metrics），是网络上路由的参数之一，用来在多个可行的路由路径中选出最佳的一条路径，路由器会选择metric值最小的那一条路径。度量值包括了被路由算法使用来决定哪一条路径较另一条路径好的所有数值。度量可能包括许多资讯，例如带宽、延迟、经过节点数、路径成本、负载、最大传输单元（MTU）、可靠性及传输成本等。路由表只储存最佳的可能路径，但拓扑表或邻接表数据库可能储存其他相关的资讯。</p>
<p><strong>当同一个路由协议</strong>到达某一个网段有两条或以上的路径时，用metric决定选用哪条路径，路由会选择最低度量值的路径转发数据。如果度量值为0，代表该路径的目的地，与本地端界面是连接在同一个网络上。如果度量值大于零，该路径的目的地会被认为外部位址，必须通过转发才能抵达目的地。</p>
<p>IP 路由协议中使用的度量如下：</p>
<ul>
<li>带宽   —EIGRP</li>
<li>开销   —OSPF&amp;IS-IS</li>
<li>延迟   — EIGRP</li>
<li>跳数   —-RIP</li>
<li>负载   —- EIGRP</li>
<li>可靠性  — EIGRP</li>
</ul>
<h3 id="度量值VS管理距离"><a href="#度量值VS管理距离" class="headerlink" title="度量值VS管理距离"></a>度量值VS管理距离</h3><p>度量值metirc是<strong>相同路由协议内部到达同一目的网段有多条路径时，比较最佳路径的参数</strong>，<strong>管理距离AD是不同路由协议之间比较选路的参数</strong>。如果前往一个网段，有既有OSPF，也有BGP等其他路由协议，每个协议中也有多个打到该网段的路径，是应该先是各自的路由协议内部用metric（BGP用自己那套13条选路原则）选出各自路由协议中最优的路径，然后这些不同的路由协议之间，用AD比较选出最终的最优路径。</p>
<h2 id="路由的负载均衡"><a href="#路由的负载均衡" class="headerlink" title="路由的负载均衡"></a>路由的负载均衡</h2><p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/5212-46.html#perper">路由负载均衡（Load Balancing）</a>，是一种技术解决方案。用来在多个资源中分配负载，达到最优化资源使用，避免过载。具体到路由中，就是到某个网段有两个或多个路径，负载均衡使路由器在转发数据包时可以使用到目标的多个路径。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-17_16-53-16.jpg" alt="Snipaste_2020-05-17_16-53-16"></p>
<p>当R4要发送数据到R7身后的7.7.7.0网段时，如果所有路由器之间链路状态良好，路由协议配置相同且开启了负载均衡的话，很可能形成负载均衡，也就是路由表中到该网段有两条路径，类似下图所示：</p>
<p><img src="/2020/05/04/11-route-basic/053014_1250_TrafficLoad9.png" alt="053014_1250_TrafficLoad9"></p>
<h3 id="基于目的地地址"><a href="#基于目的地地址" class="headerlink" title="基于目的地地址"></a>基于目的地地址</h3><h4 id="简化过程："><a href="#简化过程：" class="headerlink" title="简化过程："></a>简化过程：</h4><p>基于目的地的负载均衡（Per-destination load balancing）的含义是，路由器基于目的地的IP地址分配数据包，例如当前往同一网段有两条路径时，当去往该网段的IP地址1走路径1，前往该网段IP地址2走路径2。例如如果去往192.168.1.0/24网段有两条负载相同的路径，G1/0和G2/0，前往192.168.1.X这个地址的流量走G1/0接口，前往192.168.1.Y这个地址的流量走G2/0接口。基于目的地址的负载均衡可能导致链路使用的不平衡，如果只有一个地址使用负载均衡的线路，那么它只使用了两条负载均衡线路中的一条，另一条如果没有另一个地址通信的话，则完全不会使用。</p>
<h4 id="实际过程"><a href="#实际过程" class="headerlink" title="实际过程"></a>实际过程</h4><p>实际上这种基于目的地的负载均衡其实是基于flow的，也就是基于流的，每个数据流进行哈希然后根据哈希值决定下一跳走哪条路径，相同哈希值走的路径是固定的。如何定义一个flow的话，juniper一般是基于源目地IP地址，源目地MAC地址再加上协议，这个五元组去确定一个flow，也叫5个key，让这5个key去计算一个哈希结果，根据哈希结果不同发送到不同的下一跳，如果这个哈希结果相同就会走固定的下一跳，不会乱序。用哪几个key去计算哈希结果可以在设备上自行设置，比如在MPLS中可以加入MPLS的label当作key，使得负载更加均衡，厂家也有自动检测下一跳流量是否均衡，如果出现大量流量去往同一个下一跳而另一个负载均衡的目的地流量较少的情况，则系统会自动改哈希的key，使得流量负载自动均衡，个人感觉这个自动调节的技术好牛X。</p>
<h3 id="基于数据包"><a href="#基于数据包" class="headerlink" title="基于数据包"></a>基于数据包</h3><p>基于数据包的负载均衡（Per-packet load-balancing）的含义是，路由器发送数据到一个目的地时，第一个数据走路径1，第二个数据走路径2，以此类推。基于数据包的负载均衡保证所有链路上负载相等。</p>
<h1 id="静态路由-1"><a href="#静态路由-1" class="headerlink" title="静态路由"></a>静态路由</h1><h2 id="静态路由的概念"><a href="#静态路由的概念" class="headerlink" title="静态路由的概念"></a>静态路由的概念</h2><p>静态路由（英语：Static routing），一种路由的方式，路由条目（routing entry）由手动配置，而非动态决定。与动态路由不同，静态路由是固定的，不会改变，即使网络状况已经改变或是重新被组态。一般来说，静态路由是由网络管理员逐项加入路由表。</p>
<p>路由器的天职，就是维护路由表以及利用路由表进行数据转发。而路由表中包含通过各种途径学习到的路由表项或路由条目，其中最简单最直接的方法，就是使用静态手工配置的方式，为路由器创建路由条目，这种方式最直接，可控性最高，配置也最简单。在小型的网络中，全网静态路由似乎没有什么问题，但是在一个大型网络中，如果纯用静态路由来做，工作量就非常大了，不仅仅工作量大，另外一个更重要的缺陷是静态路由无法根据网络拓扑结构的变更而做出调整，因此，在大规模网络中，我们往往采用静态+动态路由协议的方式来完成路由的部署。</p>
<h2 id="静态路由的特点"><a href="#静态路由的特点" class="headerlink" title="静态路由的特点"></a>静态路由的特点</h2><p>需要通过手工的方式进行添加及维护，适用于组网规模较小的场景，如果网络规模较大，配置和维护的成本就会较高，所以一般网络中都采用动态、静态路由相结合的方式进行部署。</p>
<p>优点：对CPU、内存等硬件的需求不高；不占用带宽，因为静态路由不会产生更新流量。</p>
<p>不足：必须手动添加配置工作量大且容易出错；适应拓扑变化的能力较差，当网络拓扑发生变化时必须手动对静态路由进行维护。</p>
<p>重复一下上面那个不太恰当的例子说明一下加深理解，静态路由生成的路由条目有点类似咱们看到的静态的指路牌，每个路标相当于静态路由中的一个路由条目，这些路牌的信息都是静态的不能自己动态更新必须人工添加或修改，也没有路况状态信息，不知道所指出的路径是畅通还是拥堵，更不知道指出的路还能否到达目的地，比如你想下山，这个路牌上有，能指引去往这个地方的方向，只要不人为的翻修这个路牌，它会一直指着同一个方向，但按静态路牌走能不能下山，下山这条路上是否拥堵，一概不知道，因为静态路牌没法动态的知道这条路上的路况以及这条路情况是否现在还能够通往下山。这就是前面说的静态路由只知道局部地点的静态信息的大概比喻。</p>
<p><img src="/2020/05/04/11-route-basic/65498746456.jpg" alt="65498746456"></p>
<h2 id="静态路由的配置"><a href="#静态路由的配置" class="headerlink" title="静态路由的配置"></a>静态路由的配置</h2><h3 id="基础配置命令"><a href="#基础配置命令" class="headerlink" title="基础配置命令"></a>基础配置命令</h3><p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface } </p>
<p>IP route 表示该路由是一条静态路由；network-address   subnet-mask  是目标网络的网络号和网络掩码，前缀和掩码配合主机位不能有1，也就是不能配置成：ip route 10.10.20.1 255.255.255.0 10.12.12.2，因为10.10.20.1和255.255.255.0做与运算以后，主机位是1，不是一个网络号，违反了配置的规则；{ Next hop ip-address  |  exit-interface } 是到达前面网络号的出口IP地址或出接口，当配置IP地址最好是路由器所直连的地址，否则还要进行递归查询，消耗路由器资源，当配置出接口时，是配置的自身路由器的一个接口而这个接口能将数据发送给目标网络号。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-18_10-11-27.jpg" alt="Snipaste_2020-06-18_10-11-27"></p>
<p>例如，ip route  192.168.1.0   255.255.255.0   192.168.12.2，表示去往网络地址为192.168.1.0/24这个网络号，要将数据交给192.168.12.2发出；ip route 192.168.1.0 255.255.255.0 serial 0，表示去往网络地址为192.168.1.0/24这个网络号，要将数据从Serial 0 接口发出；后面也可以同时配置上出口IP地址和出接口：ip route  192.168.1.0  255.255.255.0  G0/0  192.168.12.2，具体讲解参见后面“静态路由的下一跳”部分。</p>
<h3 id="查看命令"><a href="#查看命令" class="headerlink" title="查看命令"></a>查看命令</h3><p>show   ip   static-route</p>
<h3 id="配置要点"><a href="#配置要点" class="headerlink" title="配置要点"></a>配置要点</h3><p>路由要配置来回路由，不能有去无回，且沿途所有路由器必须有到达目的网络的路由。</p>
<h3 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h3><h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><h5 id="题干"><a href="#题干" class="headerlink" title="题干"></a>题干</h5><p>共有3台路由器，R1，R2，R3，现在需要让R1和R3之间能够通信，请用静态路由完成此实验。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<h5 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h5><p>配置静态路由前R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-07.jpg" alt="Snipaste_2020-05-10_14-58-07"></p>
<p>R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-44.jpg" alt="Snipaste_2020-05-10_14-58-44"></p>
<p>R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_15-14-05.jpg" alt="Snipaste_2020-05-10_15-14-05"></p>
<p>如果要从R1发送数据给R3，通过查看R1和R3的路由表我们发现，两者均没有去往对方网段的路由条目，为什么这里需要看R1和R3是否有<strong>彼此</strong>的路由条目呢，是因为<a href="https://renyuan431.github.io/2020/05/04/11-route-basic/#%E9%80%9A%E4%BF%A1%E6%98%AF%E5%8F%8C%E5%90%91%E7%9A%84">路由是双向的</a>，所以我们需要在R1和R3上分别配置到对方的静态路由，路由有来有回这个要求满足了，下面来看沿途的所有路由器是否都有到达目标网络的路由。沿途的路由器只有R2，由于路由是双向的，所以R2既要有去往R1，192.168.12.0这个网段的路由，又要有去往R3，192.168.23.0这个网段的路由，经过查看R2的路由表，我们看到R2确实有这两条路由，所以这个要求也满足了。</p>
<p>在封装数据时有几个重要的常用参数，三层封装中的源、目的IP地址以及二层封装中的源、目的MAC地址，也就是二层和三层的地址。</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200507184145.jpg" alt="微信图片编辑_20200507184145"></p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200507184549.jpg" alt="微信图片编辑_20200507184549"></p>
<h5 id="实验配置"><a href="#实验配置" class="headerlink" title="实验配置"></a>实验配置</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<p>R1：</p>
<p><strong>配置前的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_14-58-07-1589450121599.jpg" alt="Snipaste_2020-05-10_14-58-07"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#config t                                            进去全局配置模式</span><br><span class="line">R1(config)#ip route 192.168.23.0 255.255.255.0 192.168.12.2</span><br><span class="line">               去往192.168.23.0网段的数据，交给192.168.12.2这个IP地址</span><br></pre></td></tr></table></figure>

<p>R1和R3通信，也就是192.168.12.0网段和192.168.23.0这两个网段通信，但此时路由表中并没有这条路由，这里我们配置上这条静态路由，告诉R1如果想发送数据到192.168.23.0这个网段将数据发送给R2即可，因为R2的路由表中有该条路由。在这条静态路由中，配置的是192.168.23.0 255.255.255.0 ，IP地址和子网掩码做与运算以后，得出的是192.168.23.0/24这个网段，也就是只要以后R1发往23.0这个网段的数据，不管是ping 192.168.23.1 - 192.168.23.254这些地址，都会匹配到这条静态路由，因为他们都属于192.168.23.0/24网段。 在查看路由表时，之所以用do show ip route是因为此时在全局模式下，并没有show ip route这个特权模式下的命令，但前面加上do以后就可以正确运行了，其他命令也是如此，比如后面的do ping 192.168.23.3。</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-56-56.jpg" alt="Snipaste_2020-05-14_17-56-56"></p>
<p>发送给192.168.23.0/24网段的路由条目，S表示是静态路由，[ 1 / 0 ]，1是这条路由的管理距离AD值，因为思科默认静态路由的管理距离为1。后面的0是静态路由的metric值，192.168.12.2是这条路由的下一跳，表示去往192.168.23.0/24网段的数据发送给192.168.12.2，在路由表上192.168.12.0网段的路由是一条直连路由，表示去往该网段从G0/0发出即可，所以去往192.168.23.0/24的数据从G0/0接口发出。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-07_18-26-28.jpg" alt="Snipaste_2020-05-07_18-26-28"></p>
<p>R3：</p>
<p><strong>配置前的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-10_15-14-05-1589878743252.jpg" alt="Snipaste_2020-05-10_15-14-05"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#config t</span><br><span class="line">R3(config)#ip route 192.168.12.0 255.255.255.0 192.168.23.2</span><br><span class="line">               去往192.168.12.0网段的数据，交给192.168.23.2这个IP地址</span><br></pre></td></tr></table></figure>

<p><strong>配置后的路由表：</strong></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-14_17-53-53.jpg" alt="Snipaste_2020-05-14_17-53-53"></p>
<p>因为前面分析过，绝大多数通信都是双向的，所以R3上也要有去往R1的回程路由，所以需要配置去往192.168.12.0网段的静态路由。配置完静态路由后查看路由表，S是Static的缩写，表示静态路由，192.168.23.0/24是目标网段，192.168.12.2是下一跳地址，表示如果要发送数据去往192.168.23.0/24网段，需要将数据发送给192.168.12.2这个IP地址，路由表中去往192.168.12.0/24这个网段从G0/0接口发出，也就意味着发往192.168.12.0/24这个网段的数据从G0/0接口发出即可。</p>
<h5 id="数据传递分析"><a href="#数据传递分析" class="headerlink" title="数据传递分析"></a>数据传递分析</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-19_16-18-54.jpg" alt="Snipaste_2020-05-19_16-18-54"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p>在控制层面的路由表中有了所需要的路径后，开始进行数据层面的发送，按照上面的流程图，当R1要发送数据给192.168.23.0网段发送数据时，首先看对方是否和自己处于相同网段，192.168.12.0/24网段和192.168.23.0/24处于不同网段，由于是第一次和该网段通信，所以要先把数据发给网关，由于是R1和R3通信，R1自身的G0/0口就是网关也就不用把数据发给网关了，这时候查R1路由表上关于23.0网段的路由条目：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-19_16-51-51.jpg" alt="Snipaste_2020-05-19_16-51-51"></p>
<p>前面的S表示静态路由，192.168.23.0/24是目标网段，[ 1 / 0 ]中的1是AD值，因为思科静态路由默认的管理距离AD值为1，后面的0是度量值metric。封装数据所需的四个地址分别是，源目地IP地址和源目地MAC地址，源IP地址为R1的G0/0的IP地址，192.168.12.1，目的地址为R3上G0/0接口的IP地址，192.168.23.3，因为是12.0和23.0两个网段通信；源MAC地址是R1的G0/0接口的MAC地址，因为数据从这个接口发出，目的MAC地址是下一跳的MAC地址，根据路由表中的信息，下一跳是192.168.12.2，所以目标MAC地址是R2的G0/1口的MAC地址，此时用show ip arp命令查看arp缓存表中是否有该缓存：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-34-28.jpg" alt="Snipaste_2020-05-21_15-34-28"></p>
<p>可以看到，此时R1有目的地址的ARP缓存，所以可以直接封装，这里用ping包去测试连通性并抓取数据包：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-41-02.jpg" alt="Snipaste_2020-05-21_15-41-02"></p>
<p>封装需要的二层、三层地址已经都有了，三层、二层封装后交给一层也就是物理层，R1的物理层将上层的数据转换成电磁信号通过网线发送给R2。</p>
<p>当R1发送的数据到达R2的G0/1接口后，R2将电磁信号还原成帧，然后对二层（数据链路层）进行解封装，首先查看数据帧的CRC Checksum部分，看数据帧在传输过程中是否有损坏：</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704.jpg" alt="微信图片编辑_20200611145704"></p>
<p>确定数据帧无损坏以后，开始对二层进行解封装，看看数据帧中目的MAC地址和收到这个数据帧的G0/1口是否一致，发现目的MAC地址和收到该数据的G0/1接口一致，然后查看数据帧头部的Ether Type字段，发现类型为0X0800，表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<p>三层（网络层）收到来自二层的数据后，继续对三层进行解封装，首先校验一下在传输过程中IP报头部分是否损坏：</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749.jpg" alt="微信图片编辑_20200611150749"></p>
<p>查看IP报头的数据没有损坏以后，继续查看三层报头中的目的IP地址，此时发现目的IP地址并不是自身的IP地址，于是根据目的IP地址按照最长匹配原则查询路由表中是否有对应的路由：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-52-39.jpg" alt="Snipaste_2020-05-21_15-52-39"></p>
<p>经过查询，路由表中去往23.0网段从G0/0口发出，所以不对三层报头进行其他操作（由于没有剥离三层报头所以不需要重新封装三层报头），发送回给二层继续封装。封装需要的四个地址中，源目地IP地址已经有了，依旧是之前的192.168.12.1和192.168.23.3，源MAC地址是R2的G0/0接口MAC地址，目的MAC地址是G0/0接口对端R3的G0/0接口的MAC地址，查看ARP缓存中是否有该ARP缓存：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_15-56-56.jpg" alt="Snipaste_2020-05-21_15-56-56"></p>
<p>有所需的MAC地址后，由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给物理层转换成电磁信号发送给R3，封装好后的数据抓包为：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_16-01-31.jpg" alt="Snipaste_2020-05-21_16-01-31"></p>
<p>R3将收到的数据还原成帧后，对二层进行解封装，发现目标MAC地址和收到该数据的G0/0接口的MAC地址相同，然后交给上层处理，网络层收到该数据后，对三层进行解封装发现目标IP地址为自己，进行进一步解封装后，根据三层的Protocol字段交给相应的上层应用进行处理。R3收到该ICMP request（ping）后，根据ICMP协议要回复一个reply，reply中的源地址为自身G0/0口的IP地址，192.168.23.3，目标IP地址为R1的G0/0接口，192.168.12.1，通过查询路由表可知，发往12.0网段的数据应发往192.168.23.2，而在路由表中，去往192.168.23.0的数据应从G0/0口发出，所以源MAC地址为G0/0接口的MAC地址，目的MAC地址为R2的G0/0接口的MAC地址，经过查询源目地MAC地址在ARP缓存表中均有相应条目，所以可以直接封装，将数据从G0/0口发出，由物理层将数据帧转化成电磁信号经由网线发送给R2。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_17-16-48.jpg" alt="Snipaste_2020-05-21_17-16-48"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-21_17-20-39.jpg" alt="Snipaste_2020-05-21_17-20-39"></p>
<p>R2收到R3发送的ICMP reply后，将电磁信号还原成帧，然后对二层进行解封装，发现目标MAC地址和收到该数据的G0/0口的MAC地址相同后，交给上层应用。三层收到二层发送的数据后，对三层进行解封装，发现目标IP地址不是自身的，经查询路由表后发现应从G0/1口将数据发出，所以在三层重新封装好原来的源目地IP地址后，将数据发给二层继续处理，二层收到上层发送来的数据后，由于要将数据从G0/1口发出，所以源MAC地址为G0/1口的MAC地址，目标MAC地址为R1的G0/0口MAC地址，查询ARP表后封装好数据，由物理层将数据帧转化成电磁信号经由网线发送给R1。</p>
<p>R1收到数据后对电磁信号还原成帧，而后进行二层解封装发现目标MAC地址和接收到该数据的G0/0的MAC地址相同，于是将该数据交给上层处理。三层收到下层交给的数据后对三层进行解封装，发现目标IP地址为自身的IP地址，于是根据三层中的Type字段交给相应的上层应用处理。整个数据双向的发送——接收过程结束。</p>
<h4 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h4><h4 id="题干-1"><a href="#题干-1" class="headerlink" title="题干"></a>题干</h4><p>PC1希望和PC2能正常通信，使用静态路由完成此实验，相关IP地址在图中已标出。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-15-21.jpg" alt="Snipaste_2020-05-26_11-15-21"></p>
<h5 id="实验分析-1"><a href="#实验分析-1" class="headerlink" title="实验分析"></a>实验分析</h5><p>为了更直观的看到路由的走向，此处用路由器代替PC，在配置时用路由器的IOS，然后PC1配置默认网关ip default-gateway 192.168.1.254，PC2配置默认网关ip default-gateway  192.168.2.254，并关闭路由器的路由功能，no ip routing。此时该设备就和PC一样。</p>
<p>配置前R1的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-43-53.jpg" alt="Snipaste_2020-05-26_11-43-53"></p>
<p>由于PC1要和PC2通信，两者处于不同网段（192.168.1.0网段和192.168.2.0网段），按照通信流程，PC1要把发往不同网段的数据发送给网关，也就是R1的G0/1接口，进行下一步的发送，由于数据的目的网段为192.168.2.0所以R1的路由表中应有去往192.168.2.0网段的路由才能顺利发送数据，所以R1上应该配置一条去往2.0网段的静态路由。根据通信大多是双向的这个原则，R1既要有去往2.0网段的去向路由，又要有去往1.0网段的回向路由，这里回向路由是有的，因为R1和PC1直连，有彼此的路由。</p>
<p>配置前R2的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-52-55.jpg" alt="Snipaste_2020-05-26_11-52-55"></p>
<p>收到R1发送的由1.0网段发往2.0网段的数据后，由于路由是双向的，R2必须有这两个网段的路由条目才能成功的发送数据，所以此处应该配两条路由，分别是发送数据的出向路由，也就是去往2.0网段的路由，以及回向路由，去往1.0网段的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-15-21.jpg" alt="Snipaste_2020-05-26_11-15-21"></p>
<p>配置前R3的路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_11-58-13.jpg" alt="Snipaste_2020-05-26_11-58-13"></p>
<p>收到R2发送来的由1.0网段发往2.0网段的数据后，由于路由是双向的，所以R3必须有去往1.0和2.0的路由，由于R3和PC2直连已经获得了去往2.0网段的路由，此处只配置去往1.0网段的路由即可。</p>
<h4 id="实验配置-1"><a href="#实验配置-1" class="headerlink" title="实验配置"></a>实验配置</h4><p>R1</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.2.0 255.255.255.0 192.168.12.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-47-46.jpg" alt="Snipaste_2020-05-26_15-47-46"></p>
<p>R2</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.2.0 255.255.255.0 192.168.23.3</span><br><span class="line">ip route 192.168.1.0 255.255.255.0 192.168.12.1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-49-48.jpg" alt="Snipaste_2020-05-26_15-49-48"></p>
<p>R3</p>
<p><strong>配置过程及配置后的路由表：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 192.168.1.0 255.255.255.0 192.168.23.2</span><br></pre></td></tr></table></figure>

<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-50-51.jpg" alt="Snipaste_2020-05-26_15-50-51"></p>
<p>PC1如何用路由器的IOS配置成PC用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip default-gateway 192.168.1.254                      配置默认网关为R1的G0/1接口</span><br><span class="line">no ip routing                                         关闭路由功能</span><br><span class="line">interface g0/0                                        进入G0/0口配置</span><br><span class="line">no shutdown                                           打开G0/0接口</span><br><span class="line">ip address 192.168.1.1 255.255.255.0                  配置G0/0的IP地址</span><br></pre></td></tr></table></figure>

<p>PC2如何用路由器的IOS配置成PC用</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip default-gateway 192.168.2.254                      配置默认网关为R3的G0/1接口</span><br><span class="line">no ip routing                                         关闭路由功能</span><br><span class="line">interface g0/0                                        进入G0/0口配置</span><br><span class="line">no shutdown                                           打开G0/0接口</span><br><span class="line">ip address 192.168.2.1 255.255.255.0                  配置G0/0的IP地址</span><br></pre></td></tr></table></figure>

<h5 id="数据传递分析-1"><a href="#数据传递分析-1" class="headerlink" title="数据传递分析"></a>数据传递分析</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2019-12-10_16-36-13-1590479894157.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p>当PC1要和PC2通信时，假设这个通信是ping也就是ICMP协议的通信，由于发生通信的两个IP地址分别在192.168.1.0和192.168.2.0两个不同的网段，所以PC1会将该数据发送给网关所以要查询ARP缓存表中是否有网关的ARP表项，如果没有该ARP表项则用ARP协议发送ARP请求去获取网关的MAC地址然后封装的四个地址分别为：源IP地址为192.168.1.1，目的IP地址为192.168.2.1，源MAC地址为G0/0的MAC地址，目的MAC地址为网关192.168.1.254的MAC地址。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_16-01-54.jpg" alt="Snipaste_2020-05-26_16-01-54"></p>
<p>从ARP表中可以看到1.1和1.254的ARP，1.254的ARP表项中的age表示该ARP条目进入ARP表中以来的时间，也就是3分钟，距离ARP超时的4小时（思科普通交换机过期时间为4小时，Nexus系列交换机为25分钟）还有很长的时间。</p>
<p>封装好该数据以后，PC1的物理层将该数据转换成电磁信号然后发送给网关，也就是R1的G0/1接口，R1的G0/1口抓到的ping包数据为：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_15-56-28.jpg" alt="Snipaste_2020-05-26_15-56-28"></p>
<p>R1收到该数据后，物理层将该数据还原成帧，检查完二层的CRC字段确认数据无所坏后，数据链路层解二层封装后发现该数据的目的MAC地址和自身接口G0/1的MAC地址一致，于是将二层报头剥离后交给上层继续处理；网络层收到数据链路层发来的数据后继续对三层解封装发现目标IP地址不在本路由器上，于是根据目的IP地址按照最长匹配原则查询路由表中是否有对应的路由：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_17-17-58.jpg" alt="Snipaste_2020-05-26_17-17-58"></p>
<p>根据路由表中的路由，递归出要将数据发送给192.168.2.0的目标网段，需要将数据从G0/0口发出，R1将数据交给下层数据链路层继续封装，数据链路层封装源MAC地址为R1的G0/0接口，目标MAC地址为R2的G0/1接口的MAC地址：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-26_17-20-20.jpg" alt="Snipaste_2020-05-26_17-20-20"></p>
<p>R1的数据链路层封装好后交给物理层，由物理层转换成电磁信号发送给R2的G0/1接口。</p>
<p>R2收到数据后物理层还原成帧——解二层封装、剥离二层报头交给上层——解三层封装——查找路由——封装二层——发送给R3，R3依旧也是同样的步骤处理数据，然后发给PC2，PC2解二层封装、剥离二层报头——解三层封装后发现目标IP地址是自己，于是将该数据交给上层继续处理，整个ICMP request的发送过程完毕。</p>
<p>ICMP reply过程和上面的情况类似，就不再赘述了。</p>
<h2 id="静态路由的下一跳"><a href="#静态路由的下一跳" class="headerlink" title="静态路由的下一跳"></a>静态路由的下一跳</h2><p>在配置静态路由时，下一跳既可以使用下一路由器的IP地址，也可以使用本地路由器的出接口，在点对点网络中，无论是哪种配置并没有影响，但在以太网multiple access多路访问环境中，两者有所差别。</p>
<p>在以太网中，两个邻居接口之间的通信是依靠MAC地址，因为二者处于同一网段。这两个接口互相通信时就必须知道彼此的MAC地址，因为根据MAC地址才能将数据帧交给对方进行进一步处理，如何获得对方的MAC地址呢？就是之前提到过的ARP协议。</p>
<p>为了比较直观的说明下一跳用IP地址和出接口的区别，这里用实验来对比二者的差别。</p>
<h3 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-03-51.jpg" alt="Snipaste_2020-06-04_15-03-51"></p>
<p>R4要和R5身后的5.5.5.5/32通信，这里用R5的loop back0接口来代替这个IP地址。</p>
<h4 id="配置为下一跳"><a href="#配置为下一跳" class="headerlink" title="配置为下一跳"></a>配置为下一跳</h4><p>在R4上配置下一跳为IP地址：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip route 5.5.5.5 255.255.255.255 192.168.45.5</span><br></pre></td></tr></table></figure>

<p>此时ping5.5.5.5可以ping通，通过抓包发现，该数据包封装的源目地IP地址分别位192.168.45.4和5.5.5.5，源目地MAC地址分别位R4的G0/0接口的MAC地址以及R5的G0/0接口的MAC地址，具体过程和之前上面静态路由实验中的结果类似，这里就不赘述了。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_17-20-08.jpg" alt="Snipaste_2020-06-04_17-20-08"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-07-44.jpg" alt="Snipaste_2020-06-04_15-07-44"></p>
<h4 id="配置为出接口"><a href="#配置为出接口" class="headerlink" title="配置为出接口"></a>配置为出接口</h4><p>在R4上配置下一跳为出接口：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-12-22.jpg" alt="Snipaste_2020-06-04_15-12-22"></p>
<p>将下一跳配置成出接口以后，发现ARP表中多出了5.5.5.5的ARP缓存条目，而这个缓存条目和192.168.45.5，也就是路由表中去往5.5.5.5这个目标IP地址出接口G0/0的下一跳的MAC地址相同，这是为什么呢？我们继续来看路由表：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-04_15-13-20.jpg" alt="Snipaste_2020-06-04_15-13-20"></p>
<p>路由表中去往5.5.5.5的路由条目后面有一个“directly connected”也就是直连的意思，但5.5.5.5在R5身后，和R4并未直连，为什么路由条目中显示直连呢？因为在配置静态路由时，后面的下一跳跟的是出接口，在这种情况下，路由器会认为去往5.5.5.5从G0/0接口发出就行了，所以路由器认为这个5.5.5.5和路由器直连，而在直连的情况下，路由器认为源目地IP地址在同一网段，所以会直接用ARP协议请求目标IP地址，5.5.5.5的MAC地址，这个ARP的源IP地址为192.168.45.4，目的IP地址为5.5.5.5，源MAC地址为G0/0对应的MAC地址，目的MAC地址为全F的广播，去请求5.5.5.5的MAC地址，这个广播到R5的G0/0接口后，我们知道三层设备不转发广播，也就是隔绝了该广播，这个广播是没法到达5.5.5.5的，所以R5怎么处理呢？R5将电磁信号还原成帧然后对二层进行解封装，发现是个目的MAC地址为全F的广播包，type字段为0X8060，所以这是一个ARP的广播包，于是交给上层继续处理，网络层收到下层交给的数据后，对三层解封装，发现ARP请求（通过operation code字段为1得知是ARP请求，如果该字段为2时为ARP reply）目的IP地址为5.5.5.5，经查询路由表发现有这个网段的路由信息，此时由于R5打开了代理ARP功能（思科设备默认开启该功能，如果关闭了此功能则这个场景下无法通信），因此会回复R4一个善意的“谎言”，告诉R4说5.5.5.5的MAC地址就是我G0/0的MAC地址，让R4把发往5.5.5.5的数据发给自己的G0/0接口，然后R5再将数据转发给5.5.5.5这个地址。</p>
<h3 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_09-35-49.jpg" alt="Snipaste_2020-06-15_09-35-49"></p>
<p>在这个拓扑环境中，R1和R2均连接到2.2.2.0/24网段，当R3用出接口配置静态路由时，R3会认为2.2.2.0/24网段和本路由器直连，当有数据发送到该网段时，假设是R3ping2.2.2.2，R3会发送ARP请求来获取该IP地址的MAC地址，这时如果R1和R2下联的端口启用了ARP代理功能，则两者都会把自身和R3相连接口的MAC地址发送给R3，这也是一种变相的ARP欺骗，如果R1的ARP回应报文先到，R2的ARP回应报文后到，则R3会将晚到的R2的ARP回应报文放入ARP缓存中使用。此后凡是去往2.2.2.2的数据包，均使用R2的F0/0口的MAC地址进行封装，不在发送ARP请求，如果R2的F0/0口DOWN掉，在R3上关于2.2.2.2的ARP条目超时之前（思科默认ARP超时时间，Nexus系列为25分钟，其他的交换机如6XXX系列交换机为4小时）或手动清除2.2.2.2的ARP条目之前，R3无法再PING通2.2.2.2，因为此时ARP缓存表中的MAC地址是错的是R2的，而R2此时DOWN了。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_10-12-53.jpg" alt="Snipaste_2020-06-15_10-12-53"></p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了将数据包<strong>转发到目的地</strong>，路由器必须先确定出口接口并在数据链路层重写2层头部（主要参数为源MAC地址、目的MAC地址以及type），然后再将数据通过物理层传递出去，在以太网环境中为了重写2层头部，路由器使用ARP协议通过已知的IP地址获得相对应的MAC地址。在配置静态路由时，既可指定发送接口，也可指定下一跳地址，<strong>在点对点环境下，无论是指定下一跳地址还是出接口，其效果都是一样的。但是在广播网络环境下，指定下一跳地址和指定出接口将会达到不同的效果。</strong></p>
<p><strong>在点对点的情况下</strong>，不论指定下一跳地址还是出接口都是一样的，因为两个设备直接相连，下一跳只可能是彼此，是固定的，下一跳二层报头的MAC地址也是固定的。</p>
<p><strong>在以太网环境下，当下一跳配置为出接口时</strong>，首先只有当该出接口状态为UP时该条路由才会加入路由表；其次路由器会认为该路由的目的IP地址和本地直连，由于二层封装需要目标IP地址的MAC地址，所以在这种情况下在以太网环境中，每次发送数据前往目的网段中的任一IP地址时，路由器都会尝试从静态路由配置的下一跳出接口发送ARP去获取目标IP地址所对应的MAC地址，而不会去请求网关的MAC地址。比如配置成：ip route 5.5.5.0 255.255.255.0 G0/0的时候，当发送数据去5.5.5.5时，路由器会认为5.5.5.5和G0/0接口直连，它会从G0/0口发出ARP去请求5.5.5.5的MAC地址，当发送数据去5.5.5.6时，路由器依旧会从G0/0口发出ARP去请求5.5.5.6的MAC地址，使得ARP表项过于庞大影响设备性能。当通过中间的代理ARP设备收到“善意欺骗”的MAC地址（假设该MAC地址为AA.AA.AA.AA）后，路由器会将该善意欺骗的MAC地址放入ARP缓存中，ARP缓存过期时间在思科设备上默认为25分钟，在这段时间里即使更换了新代理ARP设备，新的ARP代理设备的MAC地址为BB.BB.BB.BB，路由器中的ARP缓存条目还是之前的AA.AA.AA.AA，无法正确发送数据。</p>
<p><strong>在以太网环境下，当静态路由的下一跳配置为IP地址时</strong>，发送数据去往目的网段需要用到下一跳IP地址对应的MAC地址，比如上面配置的：ip route 5.5.5.0 255.255.255.0 192.168.45.5，当封装去往目标网段的数据时，路由器只需要请求下一跳IP地址的MAC地址，也就是192.168.45.5的MAC地址去构建二层头部，发送数据去往该网段的所有IP地址只需要192.168.45.5的MAC地址，一条ARP条目即可完成整个网段的二层封装。</p>
<p><strong>所以在广播或多路访问情况下，静态路由的下一跳用IP地址更为合适，因为这样可以避免每次发送数据时频繁请求目标IP地址对应的MAC地址，既能减少ARP缓存条目，也防止中间代理ARP设备更换但ARP缓存没到期没刷新引发的无法访问情况。</strong></p>
<h2 id="缺省（默认）路由"><a href="#缺省（默认）路由" class="headerlink" title="缺省（默认）路由"></a>缺省（默认）路由</h2><p>默认路由是当没有其他路由与目标IP地址匹配时最后生效的路由。一般来说，路由表会根据最长匹配原则，先明细路由，而后汇总路由，最后使用默认路由。</p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# ip route 0.0.0.0 0.0.0.0 &#123;ip-address | exit-interface&#125;</span><br></pre></td></tr></table></figure>

<p>0.0.0.0  0.0.0.0 前面的网络号和后面子网掩码都是0，表示所有的网络和指定网络中所有的主机，后面可以跟出接口或者下一跳IP地址，比如可以配置成：ip route 0.0.0.0 0.0.0.0  G0/0，表示所有不知道该怎么走的数据均从G0/0口发出，当然上面章节中写过，静态路由的下一跳最好还是配置成和运营商直连的IP地址，以防止ARP导致的问题。</p>
<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>一般常见于内网的出口路由器上，避免维护过多的路由表加重路由器负担。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-27_15-39-53.jpg" alt="Snipaste_2020-05-27_15-39-53"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-27_15-40-06.jpg" alt="Snipaste_2020-05-27_15-40-06"></p>
<h3 id="静态路由进阶配置"><a href="#静态路由进阶配置" class="headerlink" title="静态路由进阶配置"></a>静态路由进阶配置</h3><h4 id="浮动静态路由"><a href="#浮动静态路由" class="headerlink" title="浮动静态路由"></a>浮动静态路由</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>浮动静态路由是指管理距离大于其他静态路由或动态路由的管理距离的静态路由。通过配置一个比主路由的管理距离更大的静态路由，保证网络中主路由失效的情况下，提供备份路由。 但在主路由存在的情况下它不会出现在路由表中。</p>
<h5 id="使用场景-1"><a href="#使用场景-1" class="headerlink" title="使用场景"></a>使用场景</h5><p>用静态路由作为动态路由协议的备份路由手段。静态路由的AD（Administrative Distance，管理距离）在思科设备上的默认值为1，这意味着路由器在选择路径时，相对于管理距离更高的动态路由选择协议（OSPF的AD为110，EIGRP的AD为90）来说，会优先选择AD值更小的静态路由协议，当我们希望使用静态路由作为动态路由协议的备份路由手段时，我们得使用浮动静态路由。</p>
<p>配置多条静态路由只希望有一条静态路由工作。当设备有多出口时，比如分别有电信和联通两个互联网出口，但希望联通作为主用出口，当联通线路中断时再使用备份的电信路径作为出口，浮动静态路由也非常有用。对于主用路径，可以使用默认管理距离，对于备用路径，使用更大的管理距离（管理距离越小路径越优先，越大越不优先），当主用路径的接口或链路出现故障时，主用路径从路由表中消失，路由器使用备用路径进行通信。</p>
<h5 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h5><p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface }   AD值</p>
<p>比如配置成 ip route  0.0.0.0  0.0.0.0  192.168.12.2  10，意味着配置一条管理距离为10的，下一跳是192.168.12.2的默认静态路由。由于管理距离是10，比一般静态路由的AD值大，所以如果同时有一条 ip route  0.0.0.0  0.0.0.0  192.168.34.4  的静态路由时，AD为10的静态路由由于AD值大不会加入路由表，当没配置浮动静态路由的默认路由线路中断从路由表中消失后，AD为10的静态路由加入路由表，作为备份路由发挥作用。</p>
<h5 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h5><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-32-08.jpg" alt="Snipaste_2020-06-15_11-32-08"></p>
<p>在一个典型的教育园区网中，我们往往有两条以上的外网出口线路，假设一条为电信， 一条为教育网出口。那么我们一般为出口路由器添加一条默认路由，指向电信的下一跳地址，为的是让内网用户能够通过电信线路访问Internet资源。然而，如果电信出口出现故障呢？我们可以在路由器上增加一条默认路由， 我们知道，如果你配置两条默认路由，分别关联两个不同的下一跳，那么这两条路由将会在路由表中进行负载均 衡，但是这里我们并不希望出现这个现象，我们希望一主一备，那么这条新增的默认路由就可以这么来配置： Ip route 0.0.0.0  0.0.0.0  教育网下一跳IP   10   。我们知道静态路由的AD值是1，上面的配置方法，实际上是将该条静态路由的AD值修改为10。这样一来我们有两条默认路由，一条指向电信出口，AD 值为默认的 1；另一条指向教育网出口，AD 值为 10。那么经过 PK 之后，毫无疑问指向电信的默认路由出现在了路由表里，而指向教育网这条默认路由， “猥琐”的躲了起来。 当指向电信的默认路由失效的时候它就从路由表里消失了，那么这时候，指向教育网的这条默认路由，就“浮” 了出来。</p>
<h4 id="permanent参数"><a href="#permanent参数" class="headerlink" title="permanent参数"></a>permanent参数</h4><p>当静态路由后面使用permanent参数时，即使该静态路由使用的接口出现故障，它也将停留在路由表中，如果不配置permanent参数，则静态路由使用的接口出现故障时，路由器将把该路由条目从路由表中删除，尝试寻找替代路由条目加入路由表。因此如果不希望数据包经其他路径前往目标网络（通常是基于安全考虑），应使用permanent参数。</p>
<p>R1(config)#  ip   route   network-address   subnet-mask     { Next hop ip-address  |  exit-interface }   permanent</p>
<h1 id="路由汇总"><a href="#路由汇总" class="headerlink" title="路由汇总"></a>路由汇总</h1><h2 id="技术背景"><a href="#技术背景" class="headerlink" title="技术背景"></a>技术背景</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-37-18.jpg" alt="Snipaste_2020-06-15_11-37-18"></p>
<p>这台出口路由器由于和三层交换机之间是三层链路，因此需配 置到内网的回程路由，也就是上图中红色字体部分，这个场景中内网只有三个网段，因此配置了三条静态路 由，但是如果有100个网段呢？岂不是要配100条路由？如此一来路由表就变的非常庞大和臃肿，维护和管理和非常不方便，更重要的是，这无疑浪费了设备的资源。因此从网络优化的角度，不管是何种网络场景何 种网络模型，我们都需时刻关心网络中路由器路由表里的路由条目数量，是否足够优化，是否有可优化的空间。应该如何优化？</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-39-15.jpg" alt="Snipaste_2020-06-15_11-39-15"></p>
<p>答案是使用路由汇总，在这个场景中，如果使用单独的静态路由，一共需要3条，但此时可以使用一条汇总路由就能达到同样的效果，配置汇总路由的好处是，路由器的条目大大减少，能够降低路由器的负载。</p>
<h2 id="路由汇总的计算"><a href="#路由汇总的计算" class="headerlink" title="路由汇总的计算"></a>路由汇总的计算</h2><p>路由的汇总实际上是通过对子网掩码的操作来完成的。</p>
<p>假设我们有192.168.1.0/24，192.168.2.0/24……..192.168.8.0/24这几个子网，现在需要经过计算，得出刚好包括这几个明细的汇总网段。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-46-27.jpg" alt="Snipaste_2020-06-15_11-46-27"></p>
<ol>
<li>将他们写成二进制形式，实际上，我们只要考虑第三个8位组即可，因为这几个明细子网中只有第三个八位组是不同的。</li>
<li>现在，我们要画一根竖线，这根线的左侧，每一个列二进制数都是一样的，线的右侧则无所谓，可以是不同的，注意这根竖线，可以从默认的掩码长度，也就是/24开始，一格一格的往左移，直到你观察到线的左端每一列数值都相等，即可停下，这时候，这根线，所处的位置就是刚刚好。</li>
<li>如上图，线的位置是16+4=20，所以我们得到汇总地址：192.168.0.0/20，这就是一个最精确的汇总地址。</li>
</ol>
<h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-52-13.jpg" alt="Snipaste_2020-06-15_11-52-13"></p>
<p>路由汇总虽然确实是一个非常非常重要的思想和工具，但是使用起来要持谨慎态度，毕竟减少路由条目 的同时，也降低了路由的颗粒度和精确性。看上图，在出口路由器上配置了静态汇总路由，下一跳是三层交 换机。而三层交换机为了将访问外网的流量送到出口路由器，配置了一条默认路由，下一跳是出口路由器。 这个网络在流量正常的情况下不会有问题，但是，现在内网用户中毒了，于是这些 PC 开始疯狂的发送 内网的扫描报文，这些报文的目的地址是一些192.168打头的不知名地址，甚至根本不存在的地址。数据包 被送到了网关也就是三层交换机上，由于三层交换机配置了默认路由，因此这些数据包目的地被默认路由匹 配并被引导到了出口路由器上，而出口路由器上部署了汇总路由，这些数据包的目的地址虽然在内网中不存 在，但是却是这个汇总路由里的一个IP，因此又被出口路由器转发回给三层交换机，接下去三层交换机又根 据默认路由，将数据包转发回出口路由器，这就形成了数据的环路。 因此，从这里我们可以看出来，路由汇总，是有产生环路的风险的，解决上述问题的一个办法就是，我 们在三层交换机上，增加一条静态路由：ip route 192.168.0.0 255.255.0.0 null 0，这样一来，当它收到访问 192.168开头的、不存在的目的地址的数据包，就会直接丢弃。而正常的访问192.168内网其他子网的流量会根据最长匹配原则被正常转发。 这个思想被应用到了诸如OSPF等这类动态路由协议上，细心的童鞋会发现，你在OSPF中部署了路由 汇总后，它会自动在本地产生一条指向 null0 的汇总路由，道理跟上面讲解的是一样的。</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_11-52-37.jpg" alt="Snipaste_2020-06-15_11-52-37"></p>
<p>有些时候，路由汇总的颗粒度不够细的话，可能会包含一些不必要的网段，比如在R2上， 为了到达R1下联的网络， R2配置了使用路由汇总的工具， 指了一条汇总路由： 192.168.0.0/16 到R1，虽然这确实起到了网络优化的目的，但是，这条汇总路由太“粗犷”了，它甚至将R3这一侧的网段也囊括在内，在使用路由汇总时一定要注意避免发生这种情况。</p>
<h1 id="路由器的工作原理"><a href="#路由器的工作原理" class="headerlink" title="路由器的工作原理"></a>路由器的工作原理</h1><h2 id="路由器的基本概念"><a href="#路由器的基本概念" class="headerlink" title="路由器的基本概念"></a>路由器的基本概念</h2><p>路由器工作在OSI参考模型的第三层网络层，利用网络层定义的”逻辑地址”（IPV4或IPV6地址）来区别不同网络，它不转发广播消息，并将广播消息限制在每个网络内部，也就是之前笔记曾经提到的隔绝广播域，每个接口是一个广播域；发往其他网段的数据根据路由表转发。</p>
<p>目前在Internet网络中采用子网掩码来确定IP地址中的网络号和主机号；并规定，子网掩码（二进制形式）中数字”1”对应的IP地址中的部分为网络号，子网掩码中数字”0”所对应的IP地址中的部分为主机号，相同网络号的主机可以直接通信，不同网络号的主机需要通过网络中某个路由（网关）使他们能够通信。</p>
<p>路由上不同端口对应不同IP子网，不同端口的网络号必须不同。</p>
<h2 id="路由器转发原则"><a href="#路由器转发原则" class="headerlink" title="路由器转发原则"></a>路由器转发原则</h2><h3 id="转发IP包的条件"><a href="#转发IP包的条件" class="headerlink" title="转发IP包的条件"></a>转发IP包的条件</h3><ol>
<li>目的网络可达(路由表中必须存在到达目的网络的路由).</li>
<li>下一跳的接口地址必须可达.</li>
<li>重写源MAC地址使得成功到达下一跳.–应该是ARP获得MAC地址更新ARP表然后才可正常转发.</li>
</ol>
<h3 id="数据处理步骤"><a href="#数据处理步骤" class="headerlink" title="数据处理步骤"></a>数据处理步骤</h3><p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704-1592451122884.jpg" alt="微信图片编辑_20200611145704"></p>
<p>首先将物理层的比特流还原成帧，然后对数据帧尾部的FCS进行校验看数据是否损坏，如果损坏就丢弃，如果没损坏则进行解封装，检查二层帧头中的目的MAC地址是否是收到此数据接口的MAC地址，如果不是则丢弃，如果目的MAC地址和接口MAC地址相同则说明这个数据是发给自己的，而后查看数据帧头部的Ether Type字段，发现类型为0X0800（一般情况为0X0800，但具体问题具体分析），表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4（或其他协议）封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<p><img src="/2020/05/04/11-route-basic/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749-1592451131369.jpg" alt="微信图片编辑_20200611150749"></p>
<p>当数据到了网络层后，继续解三层数据包的封装，继续对IP报头进行解封装，首先校验一下在传输过程中IP报头部分是否损坏，如果没损坏则继续查看目的IP地址是否是自身的IP地址，这个自身的IP地址不仅是收到数据那个接口的IP地址，而是要看和所有接口及环回接口的IP地址是否相同，如果相同的话，则将三层报头剥离将数据传递，然后根据Protocol字段内容给相应的上层继续处理，如果IP地址不是自身的IP地址，如果该IP地址的网段在路由表中有相应条目则修改源、目的MAC地址将数据包按路由表转发出去。</p>
<h2 id="递归查询"><a href="#递归查询" class="headerlink" title="递归查询"></a>递归查询</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-15_15-26-04.jpg" alt="Snipaste_2020-06-15_15-26-04"></p>
<p>R1的路由表如图中所示，当数据发送到192.168.30.0网段的数据时，根据查询路由表的第一行可知，该数据需要发送给下一跳192.168.23.3，如何前往192.168.23.3呢？由路由表第二行可知，去往192.168.23.0网段需将数据发送给下一跳为192.168.12.2，所以去往192.168.30.0只要将数据发送给192.168.12.2即可，通过进一步查询路由表可知，去往192.168.12.0网段需要从S0/0口发送出去，所以经过上面的路由查询可知，去往192.168.30.0网段的数据从S0/0口发送出去即可。这个过程就叫递归查询。</p>
<h2 id="最长匹配原则"><a href="#最长匹配原则" class="headerlink" title="最长匹配原则"></a>最长匹配原则</h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>最长匹配原则是CISCO IOS路由器默认的路由查找方式。当路由器收到一个IP数据包时，会将数据包的目 的IP地址与自己本地路由表中的表项进行bit by bit的逐位查找， 直到找到匹配度最长的条目， 这叫最长匹配原。</p>
<h3 id="举例分析"><a href="#举例分析" class="headerlink" title="举例分析"></a>举例分析</h3><p>因为路由表中的每个表项都指定了一个网络，所以一个目的地址可能与多个表项匹配。最明确的一个表项——即子网掩码最长的一个——就叫做最长前缀匹配。之所以这样称呼它，是因为这个表项也是路由表中，与目的地址的高位匹配得最多的表项。</p>
<p>例如，考虑下面这个IPv4的路由表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">192.168.20.16/28</span><br><span class="line">192.168.0.0/16</span><br></pre></td></tr></table></figure>

<p>在要查找地址192.168.20.19的时候，这两个表项都“匹配”，因为192.168.20.16/28包含了从192.168.20.16-192.168.20.31这几个IP地址，而192.168.0.0/16包含了从192.168.0.1-192.168.255.254这所有的IP地址。也就是说，两个表项都包含着要查找的地址。这种情况下，前缀最长的路由就是192.168.20.16/28，因为它的子网掩码（/28）比其他表项的掩码（/16）要长，使得它更加明确，如果此时路由表中有一个192.168.20.19/32的路由，则这条路由比192.168.20.16/28要更加匹配，因为32/的掩码比28/要长。</p>
<p>路由表中常常包含一个默认路由。这个路由在所有表项都不匹配的时候有着最短的前缀匹配。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-10_11-35-48.jpg" alt="Snipaste_2020-06-10_11-35-48"></p>
<h4 id="主类网络"><a href="#主类网络" class="headerlink" title="主类网络"></a>主类网络</h4><p>如上图所示，灰色的空间 172.16.0.0/16，这个网络号，我们称为主类网络号，所谓主类网络号，意思是该网络号，按照其所属的 IP 地址类别区分后，对应上的默认的子网掩码长度后得到的网络号。如 172.16.0.0 这是一个 B 类地址，B 类地址的默认子网掩码长度是 16 位，因此 172.16.0.0/16 本身就是一个主类网络号。再举过一个例 子，10.1.12.0/24，首先 10 开头的，这是一个 A 类地址，A 类地址默认的掩码是 255.0.0.0，因此 10.1.12.0/24 它的主类网络号是 10.0.0.0/8。再举一个C类网络的例子，192.168.10.1/26，C类地址的默认网络掩码是255.255.255.0，所以192.168.10.1/26的主类网络号是192.168.10.0/24。</p>
<h4 id="子网"><a href="#子网" class="headerlink" title="子网"></a>子网</h4><p>继续如上图所示，从172.16.0.0/16 开始往里走，下一个我们看到的网络号是 172.16.10.0/24，这很明 显是应用了 VLSM 可变长子网掩码之后， 得到的一个 172.16.0.0/16 这个主类网络的一个子网。 所以所谓的子网，我们可以理解为是在网络号所属类别的默认掩码长度的基础上，将掩码“拉长”或者向主机位借位从而得到的一个网络号。实际上 172.16.0.0/16 是将 172.16.10.0/24 囊括在内的一个区间。</p>
<h4 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h4><p>如图中所示，172.16.0.0/16 这个主类网络号，然后我们向外走，看上图。172.0.0.0/8 实际上是将这个 B 类 地址的掩码向左移了 8bits，这样一来得到的这个网络号实际上是囊括了 172.16.0.0/16 在内的一个大的网络号， 我们称其为超网。 </p>
<h4 id="如何最长匹配"><a href="#如何最长匹配" class="headerlink" title="如何最长匹配"></a>如何最长匹配</h4><p>如果我们有一个 IP： 172.16.10.1，实际上这个 IP 既可以理解为在 172.16.0.0/16 网络内，也是在 172.16.10.0/24 网络内，当然，从图上我们能看出来，谁更精确呢？很明显是 172.16.10.0/24 更精确，因为172.16.0.0/16只匹配了16位，而172.16.10.0/24则匹配了24位，所以我们说，它的匹配长度相比 172.16.0.0 更长。</p>
<p>当然子网 172.16.0.0/16 还可以进一步划分子网，得到 172.16.10.0/30，甚至 172.16.10.1/32，那么如果这些 前缀都存在的情况下，当我要去找 172.16.10.1，谁的匹配度最高呢？很明显，是 172.16.10.1/32 这条主机前缀， 或者说，主机路由吧？这就是最长匹配原则。 </p>
<p>举个具体例子看一下最长匹配的过程：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-11_16-34-31.jpg" alt="Snipaste_2020-06-11_16-34-31"></p>
<p>例如上图，当 R3 收到一个数据包，去往 172.16.1.1，那么实际上，172.16.1.1 是“掉落”在 172.16.1.0/24 及 172.16.0.0/16 网络中的，两者貌似皆可，但是 172.16.1.0/24 显然，匹配度要更长，因此，最终这个数据包被 丢给了 R1。同理若有数据包去往 172.16.2.1 呢？由于根据最长匹配原则，172.16.2.0/24 这个条目匹配度最高， 因此数据被扔给了 R2。具体匹配过程如下：</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-11_16-52-14.jpg" alt="Snipaste_2020-06-11_16-52-14"></p>
<p>当R2挂掉以后，172.16.2.0/24 的条目失效，去往 2.0 子网的数据此时匹配的路由条目是 172.16.0.0/16 这条路由，因此被送往了 R1。这也是利用最长匹配原则，实施的一种简单的数据分流及路径冗余的方法。</p>
<h2 id="路由所需的元素"><a href="#路由所需的元素" class="headerlink" title="路由所需的元素"></a>路由所需的元素</h2><p>目标网络和前缀、目的网络下一跳和/或出接口、管理距离、度量值和路由类型。其中目标网络和前缀以及下一跳和/或出接口是必须的，否则无法进行转发；管理距离及度量值用于比较路由的优先级，在一个目标网络有多种路由或多条路径时用于比较到底使用哪条路由转发。</p>
<h2 id="路由查找原则总结"><a href="#路由查找原则总结" class="headerlink" title="路由查找原则总结"></a>路由查找原则总结</h2><ul>
<li>不同的前缀（网络号+掩码，做与运算后得出前缀，网络号和掩码缺一不可） ，在路由表中属于不同的路</li>
<li>相同的前缀，通过不同的协议获取，一般情况下先比AD，后比metric，特殊情况具体问题具体分析</li>
<li>默认采用最长匹配原则，匹配，则转发；无匹配，则找默认路由，默认路由都没有，则丢弃 </li>
<li>路由器的行为是逐跳的，到目标网络的沿路径每个路由器都必须有关于目的地的路由，没有路由则丢弃数据</li>
<li>数据是双向的，考虑流量的时候，要关注流量的往返都有路由，数据才能进行传递。</li>
</ul>
<h2 id="路由器发送数据的方式"><a href="#路由器发送数据的方式" class="headerlink" title="路由器发送数据的方式"></a>路由器发送数据的方式</h2><h3 id="交换的概念"><a href="#交换的概念" class="headerlink" title="交换的概念"></a>交换的概念</h3><p>switching is the process of mapping layer 2 to layer 3 addresses and forwarding to a destination interface. </p>
<p>交换是一个将二层地址映射到三层地址互相关联并且转发到目标接口的过程。这里路由器这个三层设备的交换概念和之后二层的交换不是一个概念，注意区分。</p>
<h3 id="进程交换"><a href="#进程交换" class="headerlink" title="进程交换"></a>进程交换</h3><p>进程交换（process switching），在这种模式下，一条数据流(flow)中的第一个包(packet)将被置入系统缓存(system buffer)，其目的地址将会拿到路由表中去查询比对，路由器的处理器(CPU or Processer)同时将进行CRC校验,检查包是否正确。然后数据 包的二层 MAC 地址将会被重写,替换为下一跳接口的 MAC 地址，这样的过程将会继续,对这条数据流(flow) 中的第2个、第3个数据包……相同的操作，包括查询路由表、重写MAC地址,CRC校验等，也就是每个数据包都需要CPU进行处理。这种方式是最古老，占用CPU最多，速度最慢，延迟最大的，因为它要利用system buffer以及processor去处理每个收到的包，但是我们仍然有机会使用这种交换方式，比如在进行基于每个包的负载分担时,或是debug ip packet时。 </p>
<h3 id="快速交换"><a href="#快速交换" class="headerlink" title="快速交换"></a>快速交换</h3><p>进程交换由于CPU占用率高，转发速度慢，已经跟不上互联网发展的需要，于是出现了速度更快的转发技术，快速交换（Fast Switching）。</p>
<p>快速交换（Fast Switching）采用了route cache(路由缓存)来存储关于某条数据流(flow)的特定信息, 这个特定信息会包括诸如目的MAC地址，目的接口等内容，这时我们只需要对一条数据流(flow)中的第一个包做process switching（也就是上面的进程交换），大概过程就是对第一个数据包执行最长匹配查找算法获得下一跳IP地址，然后查找ARP缓存获得第二层的MAC地址信息，并把得出的信息存入cache（高速缓存），所有后续数据包，可以不必再中断system processor去执行查询等操作，直接从 cache（缓存） 中提取目的接口，目的 MAC 地址等，根据已经生成的高速缓存的条目直接重写MAC头信息完成交换操作，这样大大加速了包转发速度。</p>
<p>但进程交换也有自己的问题，其中比较严重的就是由于路由更改，路由缓存条目中在一开始是没有缓存的，有时必须通过进程交换转发，导致转发效率下降。</p>
<h3 id="思科CEF"><a href="#思科CEF" class="headerlink" title="思科CEF"></a>思科CEF</h3><p>由于快速交换的缓存机制原理问题，路由改变会导致之前的缓存无效，重建缓存的过程开销很大，而互联网中信息的大量增加导致缓存的负担增大，从而导致路由器性能的降低，此时快速交换已经不能适应需求了，所以CEF横空出世，该技术能解决进程交换存在的缓存无效问题，也能减少CPU消耗。其他厂家也有类似思科快速转发的技术，不过换了不同的名称，技术原理上都是类似的。</p>
<p>CEF转发主要好处是减少了CPU的占用，提升设备稳定性。CEF采用了基于硬件的平台，不仅仅是将数据都存入system buffer，而是将整个路由表、拓扑表，以及所有的下一跳地址、MAC地址全部进行“预存”，只要路由表、拓扑表中存在的条目，无论是否有数据请求发往该地址，都会提前预读取，设置缓存，采用这种方式，当有新的数据请求发送时，就不需要CPU去查询目的接口，目的MAC地址等信息，而是直接从缓存中读取，从而使得转发速度得以大大提高。</p>
<p>Cisco快速转发是最快的交换模式，这种方式比快速转发和进程转发交换使用更少的CPU，对于启用了CEF的路由器，其控制平面CPU会使用路由表和地址解析协议表中的3层和2层信息（IP地址、MAC地址），来创建两个基于硬件的表，这两个表分别是转发信息表（FIB）和邻接表（ADJ），<strong>当网络收敛时，FIB和ADJ表中会包含路由器在转发数据包时会使用的所有信息，两个基于硬件的表会用来转发数据包中的所有数据帧，包括第一个帧，FIB包含预先算出来的逆向查找和下一跳信息（包括2层信息和接口）</strong>。</p>
<p>查看CEF是否开启的命令是：show ip cef，如果想在未开启CEF的设备上开启CEF，命令是：ip cef distributed</p>
<p><img src="/2020/05/04/11-route-basic/CEF.png" alt="CEF"></p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-06-18_11-37-59.jpg" alt="Snipaste_2020-06-18_11-37-59"></p>
<h4 id="FIB表"><a href="#FIB表" class="headerlink" title="FIB表"></a>FIB表</h4><p>FIB（forwarding information base）是一个动态构建的数据库，位于路由器转发（数据）层面，路由器使用它来做出基于前缀的转发决策，也就说路由器按照FIB表来转发数据，真正指导数据转发的是FIB表。FIB表中数据往往被存储在一个ASIC专用集成电路中，这使得设备在FIB表中进行数据查询时，可以实现相当高的速度。当然，FIB表空间是有限的，因此要注意用各种机制来减小设备路由表的规模，比如上文提到的路由汇总。</p>
<p>FIB中的信息和IP路由表中的条目之间有一一对应的关系，FIB不仅有路由表的信息还提前对这些信息进行了路径的递归查询，节省了大量时间，提高了转发效率。由于FIB表存储存储在一个ASIC专用集成电路中，因此该表格不存在过期作废或定时刷新的问题，只有当网络拓扑或路由表发生变化时，IP路由表被更新，FIB也随之产生变化，重新进行递归等步骤生成FIB表。FIB表中一般包含IP前缀，递归的下一跳，出战接口，其他非转发核心的参数FIB表中并不包含，查看FIB（CEF）表的命令是show ip cef。</p>
<p>路由器启动时默认使用CEF进行转发，路由表中的所有路由传入FIB的维护进程，该进程根据收到的前缀描述项和路径生成FIB（转发信息库）项目，例如把需要递归的路由提前算好。当主路由表内容改变时，会通知FIB维护进程，根据新路由信息改变收到路由改变影响的FIB条目。</p>
<p><img src="/2020/05/04/11-route-basic/200807181216359487780.jpg" alt="200807181216359487780"></p>
<h4 id="邻居表"><a href="#邻居表" class="headerlink" title="邻居表"></a>邻居表</h4><p>邻居表的英文是Adjacency table，当两个节点之间只间隔二层意义上的一跳时，那么说这两个节点相邻。CEF在叫做邻居表的数据库中为相邻节点存储转发信息，转发信息主要包括出栈接口以及二层报头重写信息。CEF使用邻居表提前为数据包准备二层地址信息。</p>
<p>邻居发现的过程生成了邻居表，邻居表中的邻居条目可以由间接手动配置，也可以通过自动发现而自动添加进邻居表，例如由ARP协议自动添加邻居表的条目。邻居表还可以由路由协议（比如BGP或OSPF）在建立邻居时添加。邻居表每次创建一个相邻条目时，都会计算出该相邻节点的链路层报头，并存储在相邻表中。邻居表中的相关信息会在之后CEF转发过程中的封装步骤里使用到，也就是说二层帧的报头重写工作要根据邻接表中的信息来完成。</p>
<p>当路由器确定了目标网络的可达性及下一跳后，下一步是确定发出接口的二层封装信息（源、目的MAC地址）以及其他传输需要的信息，这些信息都储存在邻居表中。这些二层信息通过ARP、ATM、帧中继的映射状态，路由协议的邻居关系等方式学习到。</p>
<p>邻居表存储了与FIB条目中相关联的二层信息，避免了每次查找路由表都需要运行ARP协议。</p>
<p><img src="/2020/05/04/11-route-basic/200807181216359461673.jpg" alt="200807181216359461673"></p>
<h1 id="路由选择过程"><a href="#路由选择过程" class="headerlink" title="路由选择过程"></a>路由选择过程</h1><h2 id="需要路由选择的情况"><a href="#需要路由选择的情况" class="headerlink" title="需要路由选择的情况"></a>需要路由选择的情况</h2><p>当遇到类似于下图的情况，R2从两个不同的路由协议，OSPF和RIP同时获得了10.1.1.0/24的路由信息，或</p>
<p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-05_16-33-58.jpg" alt="Snipaste_2020-05-05_16-33-58"></p>
<h2 id="选择最佳路由的步骤"><a href="#选择最佳路由的步骤" class="headerlink" title="选择最佳路由的步骤"></a>选择最佳路由的步骤</h2><p>根据最长匹配原则，最先使用匹配位数最多的明细路由，然后是汇总路由，最后才是默认路由。如果到达一个目标网段有多种路由协议且每种路由协议有多条路径，这种情况下，每种路由协议内部的多条路径先比较metric值（BGP由13条选路原则决定），决出本路由协议内的最优路径，然后不同路由协议之间再由AD值决出不同路由协议之间的最优协议。</p>
<p>1、比管理距离AD（可以是多种路由协议的比较；也可以是同种路由协议的比较，比如双线出口所配置的两条默认浮动路由比较）</p>
<p>2、比度量值metric（路由协议不同则度量值不能做比较，比如rip度量值为跳数；ospf度量值为带宽；eigrp度量值为带宽+延迟等。所以在不同种协议之间先比较管理距离）</p>
<h2 id="数据包的转发过程"><a href="#数据包的转发过程" class="headerlink" title="数据包的转发过程"></a>数据包的转发过程</h2><p><img src="/2020/05/04/11-route-basic/Snipaste_2020-05-11_16-19-39.jpg" alt="Snipaste_2020-05-11_16-19-39"></p>
<p>经过交换机，不会改变帧，源目MAC地址不会改变，源目IP地址不会改变</p>
<p>经过路由器，会改变帧，源目MAC地址会改变，源目IP地址不会改变</p>
<h1 id="控制平面和数据平面"><a href="#控制平面和数据平面" class="headerlink" title="控制平面和数据平面"></a>控制平面和数据平面</h1><h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="https://blog.csdn.net/chiyuwei1766/article/details/47334125">最佳路由选择的原则与步骤————管理距离和度量值</a></p>
<p><a href="https://blog.csdn.net/szcarewell/article/details/51246271">路由器数据转发过程</a></p>
<p><a href="https://www.qingsword.com/qing/520.html">[CCNA图文笔记]-9-静态路由与默认路由</a></p>
<p><a href="https://www.bilibili.com/read/cv575583/">Cisco交换方式理论+实践</a></p>
<p><a href="https://blog.csdn.net/zdh45222/article/details/3987577">cisco路由器 CEF,快速，过程交换</a></p>
<p><a href="https://www.networkurge.com/2020/04/process-switching-vs-fast-switching-vs.html">Process Switching Vs Fast Switching Vs CEF</a></p>
<p><a href="https://blog.51cto.com/389333/945282">进程交换 快速交换 CEF</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/63094377">动态路由选择原理（距离矢量路由协议RIP）</a></p>
<p><a href="https://blog.csdn.net/mypanlong/article/details/49000285">配置静态路由的下一跳使用出站接口和下一跳IP的差别</a></p>
<p><a href="http://ccietea.com/">IP routing（红茶三杯）</a></p>
<p><a href="https://forum.huawei.com/enterprise/zh/thread-272917-1-1.html">路由选择的最长匹配原则</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>8、子网划分</title>
    <url>/2020/02/19/8-subnet/</url>
    <content><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>此篇笔记是在<a href="https://blog.51cto.com/6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a>以及<a href="https://blog.51cto.com/6930123/2115072">IP地址和子网划分学习笔记之《超网合并详解》</a>两篇笔记的基础上进行了部分改动。</p>
<h2 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h2><h3 id="子网划分的定义"><a href="#子网划分的定义" class="headerlink" title="子网划分的定义"></a>子网划分的定义</h3><p>可以自由的加减子网掩码长度，也就是不限制于A/B/C类默认的掩码长度，A类地址不必须使用8/位的掩码，也可以用诸如：10/位掩码或者7/位掩码。</p>
<h3 id="子网划分的原因"><a href="#子网划分的原因" class="headerlink" title="子网划分的原因"></a>子网划分的原因</h3><p>子网就是把一个大网划分为几个小网，而如果按照默认的A\B\C类默认使用的话，比如一个B类地址，默认掩码为255.255.0.0，意味着这个地址空间里有2的16次方个IP，并且该网络号只能用于一个广播域，造成了IP地址的极大浪费，如果一个广播域中的PC数量过于庞大，网络可能被广播报文消耗大量资源。把一个大网络划分成几个不同的小网络以后，他们之间的网络号和广播地址各不相同，可以尽可能多的使用IP地址避免浪费，一个网段中的主机数量相对少一些的话，广播报文消耗的资源也会少很多，使得网络更有层次性。</p>
<p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是<strong>VLSM（可变长子网掩码）</strong>和<strong>CIDR（无类别域间路由）</strong>，把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。</p>
 <span id="more"></span>  

<p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率。</p>
<h3 id="子网掩码的作用"><a href="#子网掩码的作用" class="headerlink" title="子网掩码的作用"></a>子网掩码的作用</h3><p>知道划分子网的实质就是把host-id分出若干位数来作net-id，这时外界是怎样和划分好了的子网内的主机联系的呢？</p>
<p>在没有子网掩码的情况下，外界要和子网内的主机联系必须通过先前没划分的总的网络路由器，然后由路由器查找网内的各主机，这样效率就很低下。可不可以让各个子网独自通过自己的路由和外界通信呢？掩码正是为了解决这个问题。</p>
<p>各个子网要和外界独自通信，必须让外界知道你是划分了的子网，你的具体网络ID。但路由表并没有划分子网的具体信息，所以外界也无法通过你的路由器和你联系。掩码就是在你划分了的子网IP地址中，net-id相对应的地方标上1, host-id相对应的地方标上0.再在路由表中添加掩码这一项，这样外界就很容易知道你的具体网络ID了。这就是掩码的作用。</p>
<h3 id="子网划分的方法"><a href="#子网划分的方法" class="headerlink" title="子网划分的方法"></a>子网划分的方法</h3><p>子网划分的总体思路是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网：</p>
<ol>
<li><p>把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p>
</li>
<li><p>把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p>
</li>
<li><p>原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p>
</li>
</ol>
<p>网络ID等同于网络位，主机ID等同于主机位，翻译方式不同。</p>
<p><strong>必须注意的是，子网ID和网络位、主机位概念类似，都是一个范围，根据借位的多少有所区别，因为IP地址都是二进制的，所以接1位会多出2个子网，借两位多出4个子网，借三位多出8个子网，以此类推。后面会结合实际例子进一步说明，这里一定要记住这个概念。</strong></p>
<p><img src="/2020/02/19/8-subnet/afdf9cfdadeda8e3fce05fd4857b1947.png" alt="afdf9cfdadeda8e3fce05fd4857b1947"></p>
<p><strong>全0子网与全1子网</strong></p>
<p>①、“全0子网”代表的是对应子网的“子网ID”部分各位都是0，是第一个子网。</p>
<p>②、“全1子网”代表的是对应子网的“子网ID”部分各位都是1，是最后一个子网。</p>
<p>③、按照RFC950参考规定，划分子网后，只有n-2个可用的子网（n表示总的子网数）。</p>
<p>④、后来<strong>RFC1878</strong>参考规定，划分子网后，可以有n个可用的子网（n表示总的子网数）。</p>
<blockquote>
<p>RFC950参考规定：第一个子网（也就是“全0子网”）和最后一个子网（也就是“全1子网”）不可用，为的就是避免全0子网的网络地址和全1子网的广播地址分别与没有划分子网前的网络地址和广播地址相冲突。 但是在后来RFC1878规定中，该项规定已被废止了，现在的设备基本上都普遍支持RFC1878。</p>
</blockquote>
<p><strong>子网划分的任务：</strong></p>
<p>①、确定子网掩码的长度。</p>
<p>②、确定子网下的主机可用地址范围（第一个可用IP和最后一个可用IP）。</p>
<p>③、确定网络地址（主机位全为0）和广播地址（主机位全为1），不能分配计算机主机用。</p>
<h3 id="等长子网划分"><a href="#等长子网划分" class="headerlink" title="等长子网划分"></a>等长子网划分</h3><p>等长子网划分就是将一个有类网络等分成多个网络，也就是等分成多个子网，所有子网的子网掩码都相同。</p>
<h4 id="C类网络子网划分示例"><a href="#C类网络子网划分示例" class="headerlink" title="C类网络子网划分示例"></a>C类网络子网划分示例</h4><h5 id="等分位两个字网"><a href="#等分位两个字网" class="headerlink" title="等分位两个字网"></a>等分位两个字网</h5><p>将192.168.0.0 255.255.255.0这个网络等分成2个子网，并写出每个子网的地址信息</p>
<p>分析步骤：</p>
<p>该子网掩码位/24位，要划分成2个子网，<strong>网络位向主机位接用1位作为子网位</strong>，因为IP地址都是2进制，1位2进制数字有两种可能，0以及1，0是A子网，1是B子网。</p>
<p>接用主机位1位，所以子网掩码+1位，由原来的255.255.255.0（/24）变为255.255.255.128（/25）</p>
<p><strong>结论：C类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。</strong></p>
<p><img src="/2020/02/19/8-subnet/cc05ee8e14483fc9144d7f74397aa78e.png" alt="cc05ee8e14483fc9144d7f74397aa78e"></p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_14-52-56.jpg" alt="Snipaste_2020-03-10_14-52-56"></p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_14-59-24.jpg" alt="Snipaste_2020-03-10_14-59-24"></p>
<p><strong>最终结果：</strong></p>
<p>A子网的网络地址：192.168.0.0/25，可用地址（192.168.0.1、192.168.0.2….～192.168.0.126），广播地址：192.168.0.127。</p>
<p>B子网的网络地址：192.168.0.128/25，可用地址（192.168.0.129、192.168.130….～192.168.0.254），广播地址：192.168.0.255。</p>
<h5 id="等分为四个子网"><a href="#等分为四个子网" class="headerlink" title="等分为四个子网"></a>等分为四个子网</h5><p>同样将192.168.0.0 255.255.255.0 这个网络等分成4个子网</p>
<p>分析：要想分成4个子网，需要将子网掩码往右移动两位，这样第1位和第2位就变为网络位，就可以分成4个子网，因为二进制数0和1按两位排列组合，只有这4种，分别为：00，01，10，11，如下图所示：</p>
<ul>
<li>00为A子网</li>
<li>01为B子网</li>
<li>10为C子网</li>
<li>11为D子网</li>
</ul>
<p>借用主机2位，所以子网掩码+2位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/26）</p>
<p>结论：C类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p>
<p><img src="/2020/02/19/8-subnet/b238a2ab335a04d7c47484f6d6b63528.png" alt="b238a2ab335a04d7c47484f6d6b63528"></p>
<p><img src="/2020/02/19/8-subnet/e4a37fd71224bf10f85f89b656e395ba.png" alt="e4a37fd71224bf10f85f89b656e395ba"></p>
<p>最终结果：</p>
<p>A子网的网络地址：192.168.0.0/26，可用地址（192.168.0.1～192.168.0.62），广播地址：192.168.0.63/26。</p>
<p>B子网的网络地址：192.168.0.64/26，可用地址（192.168.65～192.168.0.126），广播地址：192.168.0.127。</p>
<p>C子网的网络地址：192.168.0.128/26，可用地址（192.168.129～192.168.0.190），广播地址：192.168.0.191。</p>
<p>D子网的网络地址：192.168.0.192/26，可用地址（192.168.193/26～192.168.0.254），广播地址：192.168.0.255。</p>
<h5 id="等分为八个子网"><a href="#等分为八个子网" class="headerlink" title="等分为八个子网"></a>等分为八个子网</h5><p>同样将192.168.0.0 255.255.255.0 这个网络等分成8个子网</p>
<p>分析：要想分成8个子网，需要将子网掩码往右移动三位</p>
<p>这样第1位、第2位和第3位就变为网络位，就可以分成8个子网</p>
<p>因为二进制数0和1按两位排列组合，只有这8种，分别为：000，001，010，011，100，101,110,111，</p>
<p>借用主机3位，所以子网掩码+3位，由原来的255.255.255.0 （/24）变为255.255.255.192 （/29）</p>
<p>结论：C类网络等分成8个子网，子网掩码往右移动3位，就能等分成8个子网，即2^3。</p>
<p><img src="/2020/02/19/8-subnet/2e44e2a13a05f4de228f0a1eec2f173c.png" alt="2e44e2a13a05f4de228f0a1eec2f173c"></p>
<p>最终结果：</p>
<p>子网掩码：255.255.255.224 （/27）</p>
<p>A子网的网络地址：192.168.0.0/27，可用地址（192.168.0.1～192.168.0.30），广播地址：192.168.0.31。</p>
<p>B子网的网络地址：192.168.0.32/27，可用地址（192.168.33～192.168.0.62），广播地址：192.168.0.63。</p>
<p>C子网的网络地址：192.168.0.64/27，可用地址（192.168.65～192.168.0.94），广播地址：192.168.0.95。</p>
<p>D子网的网络地址：192.168.0.96/27，可用地址（192.168.97～192.168.0.126），广播地址：192.168.0.127。</p>
<p>E子网的网络地址：192.168.0.128/27，可用地址（192.168.129～192.168.0.158），广播地址：192.168.0.159。</p>
<p>F子网的网络地址：192.168.0.160/27，可用地址（192.168.161～192.168.0.190），广播地址：192.168.0.191。</p>
<p>G子网的网络地址：192.168.0.192/27，可用地址（192.168.193～192.168.0.222），广播地址：192.168.0.223。</p>
<p>H子网的网络地址：192.168.0.224/27，可用地址（192.168.225～192.168.0.254），广播地址：192.168.0.255。</p>
<h4 id="B类网络子网划分示例"><a href="#B类网络子网划分示例" class="headerlink" title="B类网络子网划分示例"></a>B类网络子网划分示例</h4><p>将131.107.0.0/16等分成2个子网，写出各个子网的第一个和最后一个可用的IP地址</p>
<p>分析：要划分为2个子网，就要借用主机位1位作为子网位。</p>
<ul>
<li>0是A子网</li>
<li>1是B子网</li>
</ul>
<p>借用主机1位，所以子网掩码+1位，由原来的255.255.0.0 （/16）变为255.255.128.0（/17）</p>
<p>结论：B类网络等分成2个子网，子网掩码往右移动1位，就能等分成2个子网，即2^1。</p>
<p>最终结果：</p>
<p>A子网<br>网络地址：131.107.0.0/17，<br>可用地址（131.107.0.1 ~ 131.107.127.254）<br>广播地址：131.107.127.255</p>
<p>B子网<br>网络地址：131.107.128.0/17<br>可用地址（131.107.128.1 ~ 131.107.255.254）<br>广播地址：131.107.255.255</p>
<p><img src="/2020/02/19/8-subnet/93b1e2732ce3bf7a221c62cad65482ed.png" alt="93b1e2732ce3bf7a221c62cad65482ed"></p>
<h4 id="A类网络子网划分示例"><a href="#A类网络子网划分示例" class="headerlink" title="A类网络子网划分示例"></a>A类网络子网划分示例</h4><p>将A类网络42.0.0.0/8等分成4个子网，写出各个子网的第一个和最后一个可用的IP地址？</p>
<p>分析：要划分为4个子网，就要借用主机位2位作为子网位</p>
<ul>
<li>00是A子网</li>
<li>01是B子网</li>
<li>10是C子网</li>
<li>11是D子网</li>
</ul>
<p>借用主机2位，所以子网掩码+2位，由原来的255.0.0.0 （/8）变为255.192.0.0（/10）</p>
<p>结论：A类网络等分成4个子网，子网掩码往右移动2位，就能等分成4个子网，即2^2。</p>
<p>最终结果：</p>
<p>A子网的网络地址：42.0.0.0/10，可用地址（42.0.0.1 ~ 42.63.255.254），广播地址：42.63.255.255</p>
<p>B子网的网络地址：42.64.0.0/10，可用地址（42.64.0.1 ~ 42.127.255.254），广播地址：42.127.255.255</p>
<p>C子网的网络地址：42.128.0.0/10，可用地址（42.128.0.1 ~ 42.191.255.254），广播地址：42.191.255.255</p>
<p>D子网的网络地址：42.192.0.0/10，可用地址（42.192.0.1 ~ 42.255.255.254），广播地址：42.255.255.255</p>
<p><img src="/2020/02/19/8-subnet/ddcabb080e751306e58335a533daeb20.png" alt="ddcabb080e751306e58335a533daeb20"></p>
<h3 id="变长子网划分"><a href="#变长子网划分" class="headerlink" title="变长子网划分"></a>变长子网划分</h3><p>VLSM规定了如何在一个进行了子网划分的网络中，不同子网使用不同的子网掩码。这对于网络内部不同网段需要不同大小子网的情形来说很有效，这种划分子网的方式叫变长子网划分。</p>
<p>变长子网划分其实就是在等长子网的划分上，分别取不同等分子网中的某个或者多个子网。</p>
<p><img src="/2020/02/19/8-subnet/76c86f103dd758c8dc3cd81d7aa85005.png" alt="76c86f103dd758c8dc3cd81d7aa85005"></p>
<p>如上示例划分分析结果：</p>
<p>A子网<br>网络地址：192.168.10.32，255.255.255.224（/27），可用地址（192.168.10.33 ~ 192.168.10.62），广播地址：192.168.10.63<br>相当于取了等长子网划分为8个子网中的一个子网</p>
<p>B子网<br>网络地址：192.168.10.64，255.255.255.192（/26），可用地址（192.168.10.65 ~ 192.168.10.126），广播地址：192.168.10.127<br>相当于取了等长子网划分为4个子网中的一个子网</p>
<p>C子网<br>网络地址：192.168.10.128，255.255.255.128（/25），可用地址（192.168.10.129 ~ 192.168.10.254），广播地址：192.168.10.255<br>相当于取了等长子网划分为2个子网中的一个子网</p>
<p>D子网<br>网络地址：192.168.10.0，255.255.255.252（/30），可用地址（192.168.10.1 ~ 192.168.10.2），广播地址：192.168.10.3<br>相当于取了等长子网划分为64个子网中的第一个子网</p>
<p>E子网<br>网络地址：192.168.10.4，255.255.255.252（/30），可用地址（192.168.10.5 ~ 192.168.10.6），广播地址：192.168.10.7<br>相当于取了等长子网划分为64个子网中的第二个子网</p>
<p><strong>变长子网划分总结</strong></p>
<p>①、变长子网划分规律</p>
<p>如果一个子网地址块是原来网段的(1/2)^n，子网掩码就在原网段的基础上右移n位，不等长子网，子网掩码也不同。</p>
<p>②、点到点网络的子网掩码</p>
<p>每个子网是原来网络的(1/2)×(1/2)×(1/2)×(1/2)×(1/2)×(1/2)，也就是(1/2)^6，子网掩码往右移动6位。</p>
<p>例如：11111111.11111111.11111111.11111100写成十进制子网掩码也就是255.255.255.252。</p>
<h3 id="子网划分总结和技巧"><a href="#子网划分总结和技巧" class="headerlink" title="子网划分总结和技巧"></a>子网划分总结和技巧</h3><p><img src="/2020/02/19/8-subnet/de085bbf8eb4753018b7e8c8bbbad651.png" alt="de085bbf8eb4753018b7e8c8bbbad651"></p>
<p>1、确定划分子网数</p>
<p>子网数 = 2^n，n代表子网掩码往右移动的位数<br>例如：<br>要划分2个子网，子网掩码需要往右移动1位，2^1=2<br>要划分4个子网，子网掩码需要往右移动2位，2^2=4<br>要划分8个子网，子网掩码需要往右移动3位，2^3=8<br>……<br>子网数只能为2倍的关系划分。</p>
<p>2、确定子网划分后的地址</p>
<p>每个子网地址块大小（IP_block）= 2^(8-n)<br>每个子网可用地址个数（IP_num）= 2^(8-n)-2<br>①、子网的网络地址 = 从0到255，取每段地址块的首个值<br>②、子网的广播地址 = 下一个子网的网络地址-1<br>③、子网的可用地址 = 子网的网络地址到子网的广播地址区间</p>
<p>例如：<br>要划分为4个网段（2^2），子网掩码右移2位<br>每个子网地址块大小（IP_block）= 2^(8-4) = 64<br>每个子网可用地址个数（IP_num）= 2^(8-4)-2 = 62<br>每段取值分别为：0，64，128，192<br>第一个子网<br>①、网络地址 = 0<br>②、广播地址 = 63<br>③、可用地址 = 1到62</p>
<p>第二个子网<br>①、网络地址 = 64<br>②、广播地址 = 127<br>③、可用地址 = 65到126</p>
<p>第三个子网<br>①、网络地址 = 128<br>②、广播地址 = 191<br>③、可用地址 = 129到190</p>
<p>第四个子网<br>①、网络地址 = 192<br>②、广播地址 = 255<br>③、可用地址 = 193到254</p>
<p>3、确定子网掩码</p>
<p>划分后的子网掩码CIDR = 原网络的子网掩码CIDR+n，如要写成十进制：256-2^(8-n)<br>例如：<br>原来子网掩码：255.255.255.0（/24），往右移动3位，则划分为8个子网<br>子网掩码就变为为 /27，256-2^(8-3) = 256-2^5 = 256-32 = 224<br>最后子网掩码结果：255.255.255.224（/27）</p>
<p>如还有不明白的，请参照上面给出的VLSM可变长子网掩码对应CIDR值这个图就一目了然。</p>
<h3 id="子网划分举例"><a href="#子网划分举例" class="headerlink" title="子网划分举例"></a>子网划分举例</h3><p>1、计算一下172.16.1.0/27这个子网的网络号、广播号，及可用IP地址</p>
<p>答案：</p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-10_17-11-40.jpg" alt="Snipaste_2020-03-10_17-11-40"></p>
<p>2、200.200.200.0是一个C类地址。要求划分一个子网100主机，另外四个子网20主机。</p>
<p>解析过程：</p>
<p>我们可以先把该网络划分成两个子网。一个给100主机的子网，一个给另外20主机的四子网。</p>
<p>C类地址有8bit的主机号，划分子网就是把主机号拿出若干位来作网络ID。</p>
<p>具体要拿出多少位这里有一个公式：子网内主机数=2的x次方-2（x是主机号的位数）</p>
<p>现在主机数是100，我们取2的x次方-2略大于100。即x=7。</p>
<p>也就是说主机号位数是7位，这个子网才能够连100台主机。本来有8位的，剩下的一位拿去当网络号。（也实在是巧，这一位刚好可以标识两个子网（0或者1）下面的红色部分！）</p>
<p>NET ID              200.200.200.00000000</p>
<p>NETMASK        255.255.255.00000000</p>
<p>子网1:</p>
<p>NET ID           200.200.200.00000000               </p>
<p>NETMASK     255.255.255.10000000  （掩码就是用1标识网络ID，看蓝色部分）</p>
<p>子网2:</p>
<p>NET ID          200.200.200.10000000               </p>
<p>NETMASK     255.255.255.10000000</p>
<p>接下来划分四个子网，用上面任何一个子网划分都行。这里用子网2吧。</p>
<p>由上面的公式，子网内主机数=2的x次方-2</p>
<p>取2的x次方-2略大于20，也即x=5.</p>
<p>也就是主机号位数是5位，刚才是7位，剩下2位作网络ID,</p>
<p>子网2.1:</p>
<p>NET ID             200.200.200.10000000               </p>
<p>NETMASK       255.255.255.11100000</p>
<p>子网2.2:</p>
<p>NET ID             200.200.200.10100000               </p>
<p>NETMASK        255.255.255.11100000</p>
<p>子网2.3:</p>
<p>NET ID             200.200.200.11000000               </p>
<p>NETMASK       255.255.255.11100000</p>
<p>子网2.4:</p>
<p>NET ID            200.200.200.11100000               </p>
<p>NETMASK      255.255.255.11100000</p>
<p>这样，子网划分就完成了。</p>
<p>接下来写出五个子网的子网掩码、网络地址、第一个主机地址、最后一个主机地址、广播地址就比较简单了。</p>
<p>记住这一条：</p>
<p><strong>主机号全0是网络地址,网络地址+1是第1个主机地址,主机号全1是广播地址.广播地址-1是最后的主机地址.</strong></p>
<p>子网一主机号全是0的：NET ID  200.200.200.00000000   后面八个0是二进制，换成十进制就是它的网络地址了，然后+1是主机地址；广播地址要注意，那个红色0已是网络ID，主机号是后面七个0，把7个0全置为1就是他的广播地址。</p>
<p>接下来以此类推。</p>
<p><img src="/2020/02/19/8-subnet/Snipaste_2020-03-17_15-35-30.jpg" alt="Snipaste_2020-03-17_15-35-30"></p>
<p>这篇<a href="https://blog.csdn.net/gui951753/article/details/79412524">子网划分详解与子网划分实例精析</a>的博客写的非常不错，就不搬运了，贴出链接可以自己做一下后面的子网划分题目。</p>
<h2 id="超网"><a href="#超网" class="headerlink" title="超网"></a>超网</h2><h3 id="超网的概念"><a href="#超网的概念" class="headerlink" title="超网的概念"></a>超网的概念</h3><p>超网(Supernetting)是与子网类似的概念，IP地址根据子网掩码被分为独立的网络地址和主机地址。超网，也称无类别域间路由选择（CIDR），它是集合多个同类互联网地址的一种方法。</p>
<p>与子网划分（把大网络分成若干小网络）相反，它是把一些小网络组合成一个大网络，就是超网。</p>
<h4 id="合并网段"><a href="#合并网段" class="headerlink" title="合并网段"></a>合并网段</h4><p>示例：某企业有一个网段，该网段有200台主机，使用192.168.0.0 255.255.255.0网段。</p>
<p>后来计算机数量增加到400台，为后来增加的200台主机使用192.168.1.0 255.255.255.0网段，如下图：</p>
<p><img src="/2020/02/19/8-subnet/5d24088e7d02bd4ed72abd42b3a7da8e.png" alt="5d24088e7d02bd4ed72abd42b3a7da8e"></p>
<p>在路由器配置了192.168.0.1的IP地址接口，再添加192.168.1.1地址后，这样192.168.0.0和192.168.1.0这两个网段内的主机就通过路由器转发来实现通信了。</p>
<p>那么有没有更好的办法，让这两个C类网段的计算机认为在一个网段？</p>
<p>这就需要将192.168.0.0/24和192.168.1.0/24 两个C类网络合并。</p>
<p><img src="/2020/02/19/8-subnet/f47b84ff5c676c5ab1c7b164777c3255.png" alt="f47b84ff5c676c5ab1c7b164777c3255"></p>
<p>网段合并：子网掩码向前移动1位，使得网络部分保持前部分相同。</p>
<p>注：子网掩码往左移1位，能够合并2个连续的网段，但<strong>不是任何连续的网段都能合并</strong>。</p>
<p>合并网段之后，如下图，这样所有主机相互通信就不再经过路由器转发了。</p>
<p><img src="/2020/02/19/8-subnet/aac305e52a42ee6b66c91467e700ff01.png" alt="aac305e52a42ee6b66c91467e700ff01"></p>
<p>①、合并之后网段为：192.168.0.0/23，IP分配如下图：</p>
<p>②、合并之后IP地址192.168.0.255/23也是可以给计算机使用的，因为主机部分往左增加了一位0（并不是全1），如下图：</p>
<p><img src="/2020/02/19/8-subnet/b7a8122e3f4cb53da6150d1e665ed15e.png" alt="b7a8122e3f4cb53da6150d1e665ed15e"></p>
<h4 id="不是任何连续的网段都能合并"><a href="#不是任何连续的网段都能合并" class="headerlink" title="不是任何连续的网段都能合并"></a>不是任何连续的网段都能合并</h4><p>示例，如下两个连续的网段是不能合并（往前移动1位，网络部分不能保持相同）的。</p>
<p><img src="/2020/02/19/8-subnet/c1a0729463af746735f8bc6e9f363c69-1584431224823.png" alt="c1a0729463af746735f8bc6e9f363c69"></p>
<p>如果非要合并，就要往前移动2位，这时候网络部分保持相同，这样一来，等于合并了4个网段，如下图：</p>
<p><img src="/2020/02/19/8-subnet/3856bdd5d929cc7a387cdde9f897d7ea.png" alt="3856bdd5d929cc7a387cdde9f897d7ea"></p>
<h4 id="哪些连续的网段能够合并"><a href="#哪些连续的网段能够合并" class="headerlink" title="哪些连续的网段能够合并"></a>哪些连续的网段能够合并</h4><p>（1）判断2个网段是否能够合并</p>
<p><img src="/2020/02/19/8-subnet/39d316df0dc23263117006deafc8cc35.png" alt="39d316df0dc23263117006deafc8cc35"></p>
<p>子网掩码往左移动相应位数后，网络部分保持相同才能合并。</p>
<p><strong>结论：判断连续的2个网段是否能够合并，只要第一个网络号能被2整除，就能够通过左移1位子网掩码合并。</strong></p>
<p>（2）判断4个网段是否能够合并</p>
<p><img src="/2020/02/19/8-subnet/9d6bf7bb37c193e6ff334f315c7bbab4.png" alt="9d6bf7bb37c193e6ff334f315c7bbab4"></p>
<p><strong>结论：判断连续的4个网段是否能够合并，只要第一个网络号能被4整除，就能够通过左移2位子网掩码合并。</strong></p>
<p>依次类推，要想判断连续的8个网段是否能够合并，只要第一个网络号能被8整除，这8个连续的网段就能够通过左移3位子网掩码合并。</p>
<h4 id="网段合并的规律"><a href="#网段合并的规律" class="headerlink" title="网段合并的规律"></a>网段合并的规律</h4><p>子网掩码左移1位能够将能够合并两个网段，左移2位，能够合并四个网段，左移3位，能够合并8个网段。</p>
<p><img src="/2020/02/19/8-subnet/8a0dbd60f0d4db1a709e316c7b2628c4.png" alt="8a0dbd60f0d4db1a709e316c7b2628c4"></p>
<h4 id="判断一个网段是超网还是子网"><a href="#判断一个网段是超网还是子网" class="headerlink" title="判断一个网段是超网还是子网"></a>判断一个网段是超网还是子网</h4><ol>
<li><p>通过左移子网掩码合并多个网段，右移子网掩码将一个网段划分成多个子网，使得IP地址打破了传统的A类、B类、C类的界限。</p>
</li>
<li><p>判断一个网段到底是子网还是超网，就要看该网段是A类网络、还是B类网络、还是C类网络，默认A类子网掩码/8，B类子网掩码是/16，C类子网掩码是/24。</p>
</li>
<li><p>如果该网段的子网掩码比默认子网掩码长，就是子网，如果该网段的子网掩码比默认子网掩码短，则是超网。</p>
</li>
</ol>
<p>引用文章：</p>
<p><a href="https://blog.csdn.net/lemontree1945/article/details/79553187">划分子网例题详解</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>13、ospf</title>
    <url>/2020/06/18/13-ospf/</url>
    <content><![CDATA[<h1 id="OSPF"><a href="#OSPF" class="headerlink" title="OSPF"></a>OSPF</h1><p>OSPF（Open Shortest Path First，开放最短路径优先，RFC2328）是一个被各厂商设备广泛支持的链路状态路由协议，也是现网中采用最多的路由协议，<strong>OSPF协议出现的原因</strong>是因为RIP协议限制比较多，在可扩展性方面以及协议性能上已经不适应网络发展现状的需要，例如最大跳数为15跳，大规模网络中的跳数超过了RIP所规定的15跳，而超过15跳在RIP中就表示不可达，所以RIP注定被淘汰。OSPF目前共有两个版本，为IPV4使用的OSPF V2以及为IPV6使用的OSPF V3。</p>
 <span id="more"></span>  

<p>OSPF采用SPF算法，不会产生环路；支持VLSM和CIDR；可以用于大型网络；采用层次化设计，容易扩展；区域化设计，减小路由更新给设备带来的负担；路由快速收敛，采用触发式更新；支持针对区域和链路的验证。执行OSPF的路由默认每隔30分钟会泛洪一次链路状态通告（LSA），成为链路状态刷新（并非周期性更新）；当一条LSA被接收并存储到链路状态数据库后，路由器会给这条记录增加一个老化时间标识，默认是一小时，所以为了防止一些正常的LSA被清除，这条LSA的路由会每隔30分钟泛洪一次这条LSA的一个新拷贝。</p>
<p>OSPF路由协议的管理距离为110，使用IP协议号89，采用COST作为度量标准（Metric），OSPF维护邻居表、拓扑表和路由表三张表项；OSPF的消息有Hello，DBD（Database Description），LSR（Link State Request），LSU（Link State Update），LSAck（Link State Acknowledge）；OSPF的网络类型有广播多路访问（BMA，Broadcast Multi Access），非广播多路访问（NBMA，None Broadcast Multi Access）。</p>
<p>SPF算法要求同一个OSPF区域中的每个路由器都有一致的LSDB，一个OSPF区域的每个路由器都以自己位根计算最短路径，到达每个目的地的最小Cost的路径最优，将最优的路径放入FIB中。  </p>
<h2 id="协议工作流程"><a href="#协议工作流程" class="headerlink" title="协议工作流程"></a>协议工作流程</h2><p>链路状态路由协议有点像你用导航去迪士尼乐园，导航软件从一开始就知道整个上海的地图以及从你所在的地点到迪士尼乐园有哪些可能存在的路线，然后对这些潜在的路线进行比较，看看哪条路线拥堵哪条路径通畅，最后选择出一条最优的路线告诉你应该怎么走。</p>
<p><img src="/2020/06/18/13-ospf/Cisco-CCNA-OSPF-1.jpg" alt="Cisco-CCNA-OSPF-1"></p>
<ul>
<li>首先向激活OSPF的接口发送Hello包，比较Hello包中的几个字段（Area ID，Hello Interval，Router Dead Interval、Authentication Type、Authentication），参数匹配后将对端放入自己的第一张表——邻居表（Neighbor Table，用show ip ospf neighbor命令查看）</li>
<li>第二步向邻居（Neighbor）发送本路由器的OSPF数据库（LSDB，Link-State DataBase）中所拥有的LSA，从各个邻居收来的LSA放入自己的第二张表——拓扑表（Topology Table）也叫Database数据库，使用show ip ospf database查看。</li>
<li>第三步运行SPF算法，以自己为根计算出一棵最短路径树，这棵树有两个特点，一是最短，二是无环，最后将计算出来的最优路径放入第三张表，路由表（OSPF Routing Table，用show ip route ospf查看）</li>
</ul>
<h3 id="最短路径树"><a href="#最短路径树" class="headerlink" title="最短路径树"></a>最短路径树</h3><p>“以自己为根计算出一棵最短路径树”这句话有点难理解，来把这句话拆成两部分分别解释，先看前半句，什么叫“以自己为根”呢？例如在现网中有一个拓扑，假设在咱们的角度来看是按下面的形式连接的：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-06-40.jpg" alt="Snipaste_2020-09-27_12-06-40" style="zoom:80%;">

<p>但在OSPF中，当各个路由器构建以自己为根的最短路径树时，和现网中的拓扑不同，每个路由器不是以物理连接形式来构建的，而是以逻辑连接方式看这个连接形式的，具体倒OSPF中就是以“根”（也就是每个路由器自己）为出发点构建的，都会假设自己这个路由器就是拓扑的核心或中心，所以每个路由器视角中的路径树分别如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-08-24.jpg" alt="Snipaste_2020-09-27_12-08-24" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_12-08-46.jpg" alt="Snipaste_2020-09-27_12-08-46" style="zoom:80%;">

<p>后半句的“一棵最短路径树”这个最短路径树中的“树”，指的其实是一种数据结构，这种树状的数据结构有一个根以及去往其他节点的分支，该分支也会有其他分支，大概看上去类似下图：</p>
<p><img src="/2020/06/18/13-ospf/u=2971199997,2574875640&fm=26&gp=0.jpg" alt="u=2971199997,2574875640&amp;fm=26&amp;gp=0"></p>
<h3 id="LSA的泛洪"><a href="#LSA的泛洪" class="headerlink" title="LSA的泛洪"></a>LSA的泛洪</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_16-52-00.jpg" alt="Snipaste_2020-08-01_16-52-00" style="zoom:67%;">

<p>运行OSPF的路由器之间首先会建立一个协议的邻居关系。路由器之间交互的是LSA，Link State Advertisement，而不是路由，与网络或其他路由器连接的每条链路都用LSA表示，LSA可以简单的理解为，每台路由器都产生一个描述自己直连接口状态（包括接口的开销、与邻居之间的关系等）的通告。收到LSA以后首先看该条LSA是否在本地的LSDB链路状态数据库中（通过LSA ID、Advertising Router ID、Sequence number、Age这几个字段检查自己的LSDB链路状态数据库中是否有相同的LSA，避免重复将一条LSA加入LSDB链路状态数据库中），如果不存在的话先将该LSA加入本地LSDB（链路状态数据库），然后泛洪LSA给邻居路由器（因为SPF算法要求同一个OSPF区域中的每个路由器都有一致的LSDB，该LSA我这台路由器没有，可能其他路由器也没有，所以要发送给其他路由器，使得OSPF域中的所有路由器的LSDB数据库尽快一致）。如果本地LSDB动态链路数据库中存在该LSA的话要比较LSA的序列号，如果序列号相同则收到的LSA将被丢弃，因为本地已经有了相同的LSA，不需要再将其加入LSDB中；在序列号不同时，如果本地LSDB的序列号旧，则用较新的LSA替换本地的旧LSA，发给邻居LSAck表示收到了该LSU更新；如果本地LSA比收到的LSA新，则将本地的LSA泛洪给邻居。</p>
<h3 id="LSDB的组建"><a href="#LSDB的组建" class="headerlink" title="LSDB的组建"></a>LSDB的组建</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-02-02-1596272540780.jpg" alt="Snipaste_2020-08-01_17-02-02"></p>
<p>经过了上面的LSA交互过程，路由器之间会彼此交互完所有LSA并利用LSA去构建LSDB，也就是链路状态数据库，构建了LSDB后路由器就清楚了全网的拓扑，因为LSDB中所存储的每条LSA都是由网络中各个路由器产生并且描述其直连接口的各项信息的条目，知道了这些接口的连接情况就可以根据LSDB“画出”全网络的拓扑。</p>
<h3 id="SPF计算"><a href="#SPF计算" class="headerlink" title="SPF计算"></a>SPF计算</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-08-48.jpg" alt="Snipaste_2020-08-01_17-08-48"></p>
<p>接下去，每台路由器基于LSDB，使用SPF（Shortest Path First，最短路径优先）算法，每个设备独立计算出一棵以自己为跟的、无环的、拥有最短路径的“树”，有了这棵树，事实上路由器就已经知道了到达网络各个角落的最优路径。</p>
<h3 id="维护路由表"><a href="#维护路由表" class="headerlink" title="维护路由表"></a>维护路由表</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_17-10-55.jpg" alt="Snipaste_2020-08-01_17-10-55"></p>
<p>最后，路由器将计算出来的最优路径，加载进自己的路由表。如果网络拓扑发生变化，路由器之间的LSDB链路状态数据库相互之间就不会完全一样，要重复上面的LSA交互过程。例如R4的某个接口down掉，那么R4的LSDB和其他域内的路由器不相同，会通过LSA知道；如果R4整个路由器down掉，那么其他路由器会通过hello包知道R4已经down掉，因为运行OSPF的路由器每过一段时间（Hello interval，不同网络类型的该数值不同，常见的以太网是MA类型，hello时间为10秒也就是每过10秒发送一次hello包查看邻居是否还正常工作）发送一个hello包查看邻居是否还正常工作，如果该邻居没有在规定时间内回复hello包超过了规定时间（Dead interval，默认为4倍Hello interval时间，以太网中是40秒）那么说明该邻居已经挂掉，必须重新同步本区域Area内的LSDB链路动态数据库。</p>
<p>当然上面这一段的讨论只限于OSPF协议中，实际中如果一条链路物理上挂掉，那么如果等Dead interval的40秒才知道邻居挂了，才开始反映显然是有点慢了，OSPF协议会通过IOS系统交互的信息了解到一条链路的状态从UP变为了DOWN。</p>
<h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="自治系统（AS）"><a href="#自治系统（AS）" class="headerlink" title="自治系统（AS）"></a>自治系统（AS）</h2><p>自治系统（Autonomous system），采用同一种路由协议交换信息的路由器及其网络构成一个自治系统。具体到OSPF协议中，简单来说就是所有运行OSPF的路由器所组成的网络是同一自治系统。</p>
<h2 id="内部网关协议（IGP）"><a href="#内部网关协议（IGP）" class="headerlink" title="内部网关协议（IGP）"></a>内部网关协议（IGP）</h2><p>内部网关协议，IGP，Interior Gateway Protocol，常见的OSPF、EIGRP、RIP这种都叫内部网关协议，每个自治系统（AS）都有一个IGP。 单独的自治系统（AS）可能会使用不同的IGP。与内部网关协议相对应的有外部网关协议（Exterior Gateway Protocol），与内部网关协议不同，外部网关协议其着眼点不在于发现和计算路由，而在于控制路由的传播和选择最佳路由。外部网关协议目前只有BGP这一种。</p>
<h2 id="链路（Link）"><a href="#链路（Link）" class="headerlink" title="链路（Link）"></a>链路（Link）</h2><p>相当于一个接口加入OSPF进程，就被当做是OSPF的一条链路。</p>
<h2 id="链路状态（Link-State）"><a href="#链路状态（Link-State）" class="headerlink" title="链路状态（Link-State）"></a>链路状态（Link-State）</h2><p>包括接口的IP、子网、网络类型、链路话费、链路上的邻居等。</p>
<h2 id="链路状态通告（LSA）"><a href="#链路状态通告（LSA）" class="headerlink" title="链路状态通告（LSA）"></a>链路状态通告（LSA）</h2><p>链路状态通告（LSA）是OSPF协议的一种基本通信手段，它将路由器的本地拓扑发送给同区域（Area）的其他路由器，待所有路由器的LSA彼此交换完毕后，所有路由器就能知道整个OSPF网络的连接情况，可以进行路由计算。OSPF协议设计之初考虑了可扩展性，所以有些LSA不会在所有接口上泛洪而是只在相应区域的接口上泛洪。LSA用来描述路由器的本地状态，LSA包括的信息有路由器接口的状态和所形成的邻接状态。</p>
<h2 id="泛洪"><a href="#泛洪" class="headerlink" title="泛洪"></a>泛洪</h2><p>在OSPF路由器之间发布并同步LSDB链路动态数据库的过程，叫做泛洪，由于LSA构成了LSDB，也可以将泛洪理解为路由器之间同步LSA。</p>
<h2 id="路由器ID（Router-ID，简称RID）"><a href="#路由器ID（Router-ID，简称RID）" class="headerlink" title="路由器ID（Router ID，简称RID）"></a>路由器ID（Router ID，简称RID）</h2><p>RID是一个用来标识路由器的IP地址，长度为32位，在AS中唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在OSPF路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。</p>
<h2 id="邻居路由器（Neighbor-routers）"><a href="#邻居路由器（Neighbor-routers）" class="headerlink" title="邻居路由器（Neighbor routers）"></a>邻居路由器（Neighbor routers）</h2><blockquote>
<p>Two routers that have interfaces to a common network.Neighbor relationships are maintained by, and usually dynamically discovered by, OSPF’s Hello Protocol.</p>
<p>​                                                                         ——RFC 2328 Page 10</p>
<p>In short, two OSPF routers are <strong>neighbors</strong> if they are connected to the same subnet and share a series of common configuration information:</p>
<ul>
<li>Same Area ID</li>
<li>Same Area type</li>
<li>Same subnet mask</li>
<li>Same timers</li>
<li>Same authentication</li>
<li>They see their own OSPF RID in each other’s Hello packet</li>
</ul>
<p>In essence, OSPF neighborhood is a relation of two routers that allows them to <strong>see and understand</strong> each other but <strong>nothing more</strong>. In particular, two OSPF neighbors <strong>do not exchange any routing information</strong> - the only packets they exchange is Hello packets.</p>
<p>​                                                                         ——<a href="https://community.cisco.com/t5/switching/ospf-neighbor-v-ospf-adjacency/td-p/1576785">出处</a></p>
</blockquote>
<p>OSPF的邻居（Neighbor）指的是两台运行OSPF协议的路由器彼此将对方置于2WAY状态，但2WAY状态只是知道还有个也运行OSPF切基本参数相匹配的路由器存在，并不交换任何的路由信息。从另一个角度来说，两台路由器如果允许彼此看到并且明白对方的信息，那么就可以说这两台路由器是OSPF邻居关系。</p>
<h2 id="邻接关系"><a href="#邻接关系" class="headerlink" title="邻接关系"></a>邻接关系</h2><p>简单来说就是到达了FULL状态的两台路由器之间的状态，如果想具体研究可以参考上面提到的<a href="https://community.cisco.com/t5/switching/ospf-neighbor-v-ospf-adjacency/td-p/1576785">帖子</a>及<a href="https://packetpushers.net/howdy-mr-neighbor-router-ospf-adjacency-vs-neighborship/">这篇文章</a>。</p>
<h2 id="邻居VS邻接"><a href="#邻居VS邻接" class="headerlink" title="邻居VS邻接"></a>邻居VS邻接</h2><p>是邻居关系不一定是邻接关系，但是邻接一定是已经建立起了邻居关系。因为邻居关系处在2WAY状态，而必须经过2WAY到达FULL以后才能叫邻接关系。说实话感觉二者的区别有点太咬文嚼字了，直接说2WAY和FULL不完了嘛，更精确，还整个neighbor和adjacency，用两个概念很相近容易混淆的词来概括。</p>
<h2 id="区域（Area）"><a href="#区域（Area）" class="headerlink" title="区域（Area）"></a>区域（Area）</h2><p>OSPF通过划分区域来实现分层设计，跨越两个或两个以上区域的路由被称作ABR（Area Border Router，区域边界路由）。所有的区域都和“Area 0”相连，“Area 0”被称作骨干区域（Backbone），骨干区域路由器具有整个自治系统用中所有路由条目，LSA的扩散进限制在本区域内，可以通过划分多个区域以减小LSA扩散过程中对硬件的负担。作为骨干区域的Area 0的存在是为了快速高效的传输数据包，通常不接用户，主要负责多个常规区域的流量传输。Area 0 之外的区域叫做Regular area普通区域或nonbackbone area非骨干区域，主要为了连接用户，且所有数据交互都要通过Area 0中转，所以常规区域必须和骨干区域连接。一般一个区域内的路由器数量是30-200台。</p>
<p>这种层次设计的好处有：</p>
<ol>
<li>减少了路由表的条目。</li>
<li>LSA的泛洪在网络边界停止，能加速汇聚速度。</li>
<li>缩小网络的不稳定性，一个区域的问题不会影响到其他区域。</li>
</ol>
<h3 id="单区域"><a href="#单区域" class="headerlink" title="单区域"></a>单区域</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-13-26.jpg" alt="Snipaste_2020-07-14_16-13-26"></p>
<p>单区域就是所有路由器都在同一个Area中，如果一个区域内的路由器过多，那么一旦出现变化，需要同步的LSA会非常多，LSA的泛洪会很严重，泛洪完LSA后还要重新用SPF算法根据庞大的LSDB进行复杂的计算，这样的话OSPF路由器的负担会很大，因为OSPF要求区域内的所有路由器的LSDB相同，以计算出一个统一的无环的拓扑。同时单区域内的路由器过多会导致LSDB庞大，资源消耗过多，设备性能下降，影响数据转发。一般情况下，思科建议一个Area内的路由器不超过50台。</p>
<h3 id="多区域"><a href="#多区域" class="headerlink" title="多区域"></a>多区域</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-16-42.jpg" alt="Snipaste_2020-07-14_16-16-42"></p>
<p>在部署OSPF时，可以采用多区域的方式部署，有且只能有一个Area 0，Area 0为骨干区域，骨干区域负责在非骨干区域之间发布由区域边界路由器汇总的路由信息，为避免区域间路由环路，非骨干区域之间不允许直接相互发布区域间路由，因此所有区域边界路由器都至少有一个接口属于Area 0，即每隔区域都必须连接到骨干区域。</p>
<h2 id="网络类型"><a href="#网络类型" class="headerlink" title="网络类型"></a>网络类型</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>OSPF是一个“接口敏感”的协议，这句话非常值得细细品味，比如路由的Cost值实际上应累加上接口的cost值，下面的DR\BDR选举也是基于接口的，另外邻居的建立也是与接口有关，因此很多机制的着眼点都与接口有关。一旦我们在某个接口上激活了OSPF协议，那么这个接口将会根据接口的二层，也就是数据链路层的封装捆绑对应的的OSPF网络类型，不同的OSPF接口的网络类型所对应的操作有所不同用。例如如果接口二层封装为以太网，那么OSPF在这个接口的网络类型为Broadcast也就是广播，如果接口的二层封装是HDLC或PPP，那么OSPF的网络类型则是P2P。OSPF定义了以下几种网络类型：</p>
<ul>
<li>点到点，Point-to-Point，P2P</li>
<li>广播，Broadcast Multi access</li>
<li>非广播，Non-Broadcast，非广播中又有5种模式，分别是NBMA（non-broadcast multiple access network，RFC规定），P2MP（Point-to-Multipoint，RFC规定），P2MP nonbroadcas（Cisco），Broadcast（Cisco），P2P（Cisco）。</li>
</ul>
<p>常见的数据链路层协议对应的默认网络类型：</p>
<p><img src="/2020/06/18/13-ospf/53a3f6538de55.png" alt="53a3f6538de55"></p>
<p>在接口上使用命令show ip ospf interface X可以查看到接口的网络类型：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-31_17-15-02.jpg" alt="Snipaste_2020-07-31_17-15-02"></p>
<h3 id="点到点（P2P）"><a href="#点到点（P2P）" class="headerlink" title="点到点（P2P）"></a>点到点（P2P）</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-31_17-34-05.jpg" alt="Snipaste_2020-07-31_17-34-05"></p>
<ul>
<li>如果二层的协议为PPP、HDLC等，则OSPF的网络类型为P2P</li>
<li>如果帧中继子接口类型为P2P的，则OSPF网络类型也为P2P</li>
<li>不用选举BDR\DR</li>
<li>使用组播地址224.0.0.5</li>
<li>OSPF能够根据二层封装自动检测到P2P网络类型</li>
</ul>
<h3 id="多路访问（MA）"><a href="#多路访问（MA）" class="headerlink" title="多路访问（MA）"></a>多路访问（MA）</h3><blockquote>
<p>A <strong>multi access network</strong> is a <strong>network</strong> which can have <strong>multiple</strong> (more than 2) machines participating in the <strong>network</strong>. A point to point <strong>network</strong> can have only 2 and a <strong>multi access network</strong> can have more than 2. The most common example of a <strong>multi access network</strong> is Ethernet (and FastEthernet etc).</p>
</blockquote>
<p>多路访问网络是有多个（超过两个）设备参与通信的网络。点对点（P2P）网络有且只有2个设备，多路访问网络可以有超过2个设备。最典型的多路访问网络就是日常生活中最常见的以太网，Ethernet。OSPF在点到点网络上是不选取DR的，正常情况下，DR只在多路访问时选取。在多路访问类型网络中，所有路由器均与DR及BDR建立邻接关系，其他路由器（DR Other）之间处于2WAY状态。DR和BDR之间使用224.0.0.5的组播地址交换信息，其他路由器（DR Other）使用224.0.0.6和DR\BDR交换信息。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_16-58-10.jpg" alt="Snipaste_2020-06-25_16-58-10"></p>
<p>多路访问网络有两种类型：广播型多路访问网络（BMA）及非广播型多路访问网络（NBMA）。以太网是一种典型的广播型多路访问网络。在OSPF中使用show ip ospf interface查看接口类型。</p>
<h2 id="指定路由器（DR）"><a href="#指定路由器（DR）" class="headerlink" title="指定路由器（DR）"></a>指定路由器（DR）</h2><p>在广播多路访问网络中（Multi access）中，例如以太网接口，所有的路由器都是相同网段，处于同一个广播网络中，这些接口如果两两建立起OSPF邻接（Adjacency）关系，这就意味着，网络有：N（N-1）/2   这么多个邻接（Adjacency）关系，维护如此多的邻接关系不仅仅额外消耗设备硬件资源，更是增加了网络中LSA的泛洪数量，占用网络资源。所以为了减小多路访问网络中的OSPF流量和硬件消耗，OSPF会在每一个MA网络中选举出一个指定路由器和备用指定路由器，也就是DR和BDR。DR及BDR的身份是基于OSPF接口的，所以如果我们说“这台路由器是DR”的话，实际上这种说法是不严谨的，因为DR是接口的属性而不是路由器的属性，严格的说应该是“这台路由器的这个接口，在这个MA网络上是DR”。每台路由器都把拓扑变化发给DR和BDR，然后由DR通知多路访问网络中的其他路由器。在OSPF网络中，既不是DR也不是BDR的接口，它的角色是DR Other。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_11-59-29.jpg" alt="Snipaste_2020-06-25_11-59-29"></p>
<p>如上图中的四台路由器，R1、R2、R3、R4，运行OSPF协议且已经建立起了邻居且选举完DR\BDR，R1的接口为DR，R3的接口为BDR，R2和R4的接口为DR Other，此时，这四台设备并不是相互之间两两交互LSA，而是R2、R3、R4分别和R1交换LSA，然后由R1将其他路由器没有的LSA传送给它们。DR Other 只于DR和BDR建立完全邻接关系，其它路由器处于two-way状态。有了DR以后，MA网络中需要维护的OSPF邻接关系大幅减小，M=（n-2）X 2 +1，LSA的泛洪问题也能得到一定缓解：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-06_15-01-03.jpg" alt="Snipaste_2020-08-06_15-01-03"></p>
<p>假设网络已经完成了OSPF收敛，现在突然R3下挂的一个网络发生了故障，路由器R3使用224.0.0.6将这个情况通知DR及BDR，DR\BDR监听224.0.0.6获得这个情况，DR向组播地址224.0.0.5发送更新通知其他路由器，所有的OSPF路由器监听224.0.0.5这一组播地址获知携带LSA更新的LSU，更新自己的LSDB并发送LSAck确认收到该信息，经过一段时间后（SPF延迟），对更新的链路状态数据库执行SPF算法，必要时更新路由表。</p>
<p>之所以要选举DR是为了避免路由器之间建立完全邻接关系而引起的大量开销，OSPF要求在多路访问的网络中选举出一个DR，每个路由器都与DR建立邻接关系。选举出DR的同时也选举出一个BDR（Backup Designated Router），BDR也就是备份DR路由器，BDR在DR失效时承担起DR的职责，DR Other路由器只与DR和BDR建立邻接关系。DR和BDR通信的组播地址为224.0.0.6，<strong>DR的选举是一个路由器的接口特性而不是整个路由器的特性</strong>，也就是说，一个路由器如果有3个接口，G0/0、G0/1和G0/2，G0/0是DR，G0/1是BDR，G0/2是DR Other也是没问题的，可能在一个MA网络种存在多个DR。比如下图的R3，两个接口分别是BDR和DR Other：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-25_18-48-46.jpg" alt="Snipaste_2020-06-25_18-48-46"></p>
<h2 id="DR-BDR选举"><a href="#DR-BDR选举" class="headerlink" title="DR\BDR选举"></a>DR\BDR选举</h2><p>如果想了解完全版的具体过程请参见<a href="https://tools.ietf.org/html/rfc2328#page-75">RFC</a>，但因为我看了两遍也没搞明白所以然，故这里采用红茶三杯总结的方式加上一点自己的理解，如果哪天突然开窍了看明白了RFC再回来补上这部分的笔记。</p>
<h3 id="选举的前提"><a href="#选举的前提" class="headerlink" title="选举的前提"></a>选举的前提</h3><ul>
<li>DR和BDR的选举发生在每个网段上，也就是说，如果有4个网段运行了OSPF，那么这4个网段都要选举DR和BDR，最后会选举出4个DR和4个BDR。</li>
<li>参与选举并和选举出的DR\BDR建立邻接关系需要Hello包种的参数相一致（Hello\Dead 时间，Area ID也是同一区域，认证通过，Router ID具有唯一性不与其他路由器相同）。</li>
</ul>
<h3 id="选举的过程"><a href="#选举的过程" class="headerlink" title="选举的过程"></a>选举的过程</h3><p>当一台OSPF路由器有效（Active）并去发现它的邻居路由器时，它将去检查有效的DR和BDR路由器（如果路由器的Priority为0那么就意味着它是无效的，不能参与选举DR和BDR），如果DR路由器存在的话（网络中某台路由器发出的Hello包中的DR字段为其自身的Router ID时就说明DR存在），这台路由器将接受已经存在的DR和BDR（为什么要接受已经存在的DR和BDR呢，是因为DR具有非抢占性的，也就是说已经有了DR了，新加入的路由器接口的Priority再低也不会重新选举DR了，如果没有非抢占性，新加入一个Priority 更大的就被选举成新的DR，所有DR Other都和这个新DR再建立邻接关系达到Full状态，太消耗系统资源，所以当一台路由器发现已经存在DR和BDR时就会接受已经存在的DR和BDR），如果BDR和DR路由器都不存在（也就是Hello包种的DR以及BDR字段都为0.0.0.0），将执行一个选举<strong>BDR</strong>的过程，没错一开始是选举BDR而不是DR，选举出具有最高优先级的路由器作为BDR路由器，选举中如果存在多台路由器具有相同的优先级（Priority），那么在数值上具有最高路由器ID的路由器将被选举成<strong>BDR</strong>（如果两台运行OSPF路由器路由器的接口的Priority都是1，那么此时一台路由器的Router-ID为1.1.1.1，另一台的Router-ID为2.2.2.2，Router-ID为2.2.2.2的显然比1.1.1.1更大，这台Router-ID为2.2.2.2的路由器的接口将被选举成BDR）。<strong>如果没有有效的DR路由器存在，那么之前选举出的BDR路由器将被选举成（或者说成提升）DR路由器，然后再选举出来BDR路由器。</strong>至此BDR和DR选举完毕。</p>
<h3 id="选举的补充说明"><a href="#选举的补充说明" class="headerlink" title="选举的补充说明"></a>选举的补充说明</h3><h4 id="什么情况选举BDR-DR"><a href="#什么情况选举BDR-DR" class="headerlink" title="什么情况选举BDR\DR"></a>什么情况选举BDR\DR</h4><img src="/2020/06/18/13-ospf/123456.png" alt="123456" style="zoom:67%;">

<h4 id="BDR晋升成DR"><a href="#BDR晋升成DR" class="headerlink" title="BDR晋升成DR"></a>BDR晋升成DR</h4><p>选举BDR\DR的场景中，绝大多数情况下，选举出的BDR都能顺利晋升成DR，也有极端场景比如俩OSPF路由器R1 R2在2-way刚选出BDR，另一台OSPF路由器R3接入进来发的hello里 DR是自己，这样R1 R2不知道会咋办。</p>
<h4 id="已有DR-BDR"><a href="#已有DR-BDR" class="headerlink" title="已有DR\BDR"></a>已有DR\BDR</h4><p>什么情况下，一个路由器会发现链路中已经有DR或BDR出现呢，常见的一种情况是，一个路由器新加入已经运行了一段时间OSPF协议的网络，常见的另一种情况是，只有两台路由器相连，R1——R2，其中一台已经先行运行了OSPF协议而且在DR选举计时器结束前没有其他OSPF的Hello包出现，这时这台路由器会把接口设定为DR。当路由器的接口运行OSPF协议时，已经启动了一个DR选举的计时器，这个计时器时4倍的Hello时间，在以太网这个MA网络中也就是和Dead时间一样的40秒，RFC上对这个计时器的描述是“A single shot timer that causes the interface to exit the Waiting state, and as a consequence select a Designated Router on the network. The length of the timer is RouterDeadInterval seconds.”，可以用命令 show ip ospf interface XX | incl timer   查看，默认的计时器是：Timer intervals configured, Hello 10, Dead 40, <strong>Wait 40</strong>, Retransmit 5。这个Wait就是DR选举的计时器。当这个计时器到时的时候，也就是OSPF启动了40秒以后依旧没其他路由器发来Hello包进行选举时，这个路由器就会把自身这个接口设置为DR，因为思科规定即使MA网络中只有一台路由器运行OSPF协议也要选举DR。</p>
<h4 id="BDR-DR的抢占性"><a href="#BDR-DR的抢占性" class="headerlink" title="BDR\DR的抢占性"></a>BDR\DR的抢占性</h4><p>DR和BDR具有非抢占性，也就是说当DR\BDR选举完成后，新加入的路由器即使Priority再小，DR\BDR也不会发生变化，为的是维持网络的稳定性。当DR失效后，BDR会成为DR，同时产生新的BDR。DR与BDR，DR与DR Other，BDR与DR Other之间都是Full状态，DR Other相互之间是2-way状态。所有的DR Other都只和DR以及BDR建立全毗邻关系。</p>
<h4 id="如何重新选举BDR-DR"><a href="#如何重新选举BDR-DR" class="headerlink" title="如何重新选举BDR\DR"></a>如何重新选举BDR\DR</h4><p>由于DR选举是非抢占的，所以选举完毕后除非人工干预否则BDR\DR是不会改变的，重新选举方法有两种，一种是所有参与选举的路由器在短时间内（默认的BDR\DR选举等待的Wait计时器是40秒）重新启动；另一种是执行“clear ip ospf process”命令，如果在DR Other上执行则不会影响BDR\DR，如果在BDR上执行则会重新选举一个BDR，如果在DR上执行，则会重新执行整个BDR\DR选举过程。</p>
<h4 id="其他概念"><a href="#其他概念" class="headerlink" title="其他概念"></a>其他概念</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-02_15-30-35.jpg" alt="Snipaste_2020-07-02_15-30-35"></p>
<ul>
<li>R1、R2接口的Priority值均为0，则R1和R2之间不能建立邻居，因为在MA网络下必须选举出DR，而R1、R2相连接口的Priority值均为0，失去了选举资格，所以两者无法建立邻居。</li>
<li>R1接口优先级为0，R2接口优先级为1，则R2成为DR，且该多路访问网络中没有BDR。</li>
<li>在上一步已经选出DR的基础上，R1接口优先级改为100，对网络没有影响，因为DR的非抢占性。</li>
<li>在上一步已经选出DR且R1接口优先级改为100的基础上，如果身为DR的R2重启了OSPF进程（clear IP ospf process X，X为该OSPF进程号），则R1成为DR，R2成为BDR。因为R2重启进程后会重新建立邻居重新选举DR。</li>
<li>如果R1和R2接口优先等级相同，但R2的Router ID大，一般情况下，R2应成为DR，但如果R1已经先配置了OSPF，且R2在R1配置之后40秒菜配置，那么这时候即使R2的Router-ID更大，R1已经成为了DR，原因在于Wait timer 等待计时器，这个计时器是在开始选举DR\BDR之前，路由器等待邻居路由器Hello包通告DR\BDR的时长（收集所有候选人的信息），等待计时器的长度就是Router Dead Interval的时间，因此只要R2在40秒之后才配置的，那么R1就会认为自己是DR，并且在Hello包的Designated Router部分写上自己的地址。</li>
</ul>
<h3 id="选举的几个为什么"><a href="#选举的几个为什么" class="headerlink" title="选举的几个为什么"></a>选举的几个为什么</h3><h4 id="为什么选举DR-BDR"><a href="#为什么选举DR-BDR" class="headerlink" title="为什么选举DR\BDR"></a>为什么选举DR\BDR</h4><p>之所以选举DR\BDR是因为如果运行OSPF协议的路由器两两之间建立完全邻接关系会引起大量的开销，消耗大量资源，OSPF采取了每个DR Other路由器和DR以及BDR建立邻接关系的方法，来减少资源消耗。</p>
<h4 id="为什么除了DR也要有BDR"><a href="#为什么除了DR也要有BDR" class="headerlink" title="为什么除了DR也要有BDR"></a>为什么除了DR也要有BDR</h4><p>之所以除了选举DR以外还要选举出一个BDR是因为，DR Other要和DR以及BDR形成邻接关系，然后DR和BDR这两者也要形成邻接关系，如果DR由于某种情况挂掉，那么BDR就能接替DR的位置，因为所有DR Other和BDR也形成了邻接关系，DR掌握的关于网络的信息和BDR是一样的，所以BDR可以顺利完美接替DR，这样可以把DR挂掉对网络的影响降到最低。</p>
<h4 id="为什么先选举BDR"><a href="#为什么先选举BDR" class="headerlink" title="为什么先选举BDR"></a>为什么先选举BDR</h4><p>之所以先选举BDR再选举DR是因为：”The reason behind the election algorithm’s complexity is the desire for an orderly transition from Backup Designated Router to Designated Router, when the current Designated Router fails. This orderly transition is ensured through the introduction of hysteresis: no new Backup Designated Router can be chosen until the old Backup accepts its new Designated Router responsibilities.”——RFC 2328 - OSPF Version 2，section 9.4 - Electing the Designated Router。先选取BDR的原因是，当DR发生故障挂掉时，需要BDR来接替DR的位置和作用，如果先选举DR，则可能会在BDR接替之前挂掉的DR前，选举出一个不是之前BDR的新DR，这个新DR还得重新从224.0.0.6上学习信息才能执行DR的角色，重新学习信息可能使得网络无法顺利转发数据。而先选举BDR则不会出现上面的问题，DR掌握的网络信息BDR都掌握，BDR可以不经过信息交互直接接替DR的功能，待BDR完美接替挂掉的旧DR的功能成为新DR后，空出来BDR的角色以后再选取BDR，不会对网络有影响。</p>
<h3 id="选举的优化"><a href="#选举的优化" class="headerlink" title="选举的优化"></a>选举的优化</h3><p>由于所有DR Other要与DR\BDR交互LSA信息，会消耗一定系统资源，所以建议在接口上灵活使用ip ospf priority 避免一个路由器的多个接口成为DR，降低硬件开销，减小网络变化时产生的影响。因为如果不在接口上进行灵活配置，选举过程是先看Priority再看Router ID，默认情况下所有接口的Priority都为1，此时Router ID为最大的路由器上的所有接口都将为DR，不仅会使得路由器开销变大，也会使得万一Router ID最大的路由器一旦挂掉，会对网络造成比较大的影响，因为各网段都要重新选举BDR\DR。</p>
<h2 id="组播地址"><a href="#组播地址" class="headerlink" title="组播地址"></a><a href="https://community.cisco.com/t5/routing/dr-bdr-communication/td-p/1142718">组播地址</a></h2><blockquote>
<p>All OSPF routers continue to <strong>multicast HELLOS</strong> to 224.0.0.5, so they can keep track of their neighbors.</p>
<p>DROTHERs will send <strong>multicast updates</strong> to 224.0.0.6 (DR/BDR listen). DR will flood <strong>multicast updates</strong> to DROthers on 224.0.0.5.</p>
<p>DR and BDR can listen 224.0.0.5 not only to 244.0.0.6. DR Other listen 224.0.0.5 but not 224.0.0.6.</p>
<p>Summary:</p>
<p>* All OSPF enabled routers listen to/send LSA’s on multicast address 224.0.0.5</p>
<p>* DR/BDR listens on multicast-address 224.0.0.6 in addition to 224.0.0.5. This allows DR/BDR in a particular segment to figure out status updates.</p>
</blockquote>
<p>OSPF通过发送Hello包到组播地址224.0.0.5来建立邻居，所以只要是运行了OSPF协议的路由器，不管是DR 、BDR还是DR Other都会监听这个地址用来建立邻居。DR Other使用224.0.0.6的组播地址，将LSU发送给DR和BDR，所以DR和BDR会监听224.0.0.6的组播地址。DR使用224.0.0.5的组播地址将LSU发送给DR Other路由器。综上所述，所有运行了OSPF的路由器都会监听224.0.0.5的组播地址，但只有DR和BDR在监听224.0.0.5地址的同时额外监听224.0.0.6的组播地址。</p>
<h2 id="Cost"><a href="#Cost" class="headerlink" title="Cost"></a>Cost</h2><p>OSPF协议使用Cost值当作Metric去衡量到达目标网络的远近，Cost值越小越优。接口的带宽越大，计算出的Cost值越小，接口的带宽越小，计算出的Cost值越大。在每一个运行OSPF协议的接口上，都维护着一个接口的Cost值，接口的Cost值=100M / 接口带宽，也就是：10的8次方/BW（bit），这个100M（10的8次方）指的是参考带宽。一条路由的Cost值，是该路由从来源一路过来的所有入口方向的接口Cost值的总和，也就是这条路由经过接口的Cost值的综合。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-06-26_16-36-41.jpg" alt="Snipaste_2020-06-26_16-36-41" style="zoom:67%;">

<p>例如1.1.1.0/24的路由，由于是loop back接口，所以相对于Router A来说，Cost值为1，对于Router B来说，B与A相连接的接口Cost值为64，所以1.1.1.0/24的路由相对B来说，Cost值就是1+64，也就是65。</p>
<p>修改Cost的方法：</p>
<ol>
<li>修改参考带宽，也就是修改10的8次方这个数值，因为计算Cost的公式是10的8次方/BW（bit），通过修改参考带宽也可以修改Cost值。命令在ospf进程下配置：auto-cost reference-bandwidth XXX ，该数值的设置范围是1-4294967。</li>
<li>修改接口带宽，带宽和Cost值成反比，带宽越大，cost值越小，通过修改带宽也可以达到修改Cost值的目的。修改接口带宽的命令是在接口下配置：bandwidth XXX。该数值设置的范围是1-10000000。</li>
<li>直接修改Cost值，在接口上使用ip ospf cost  XX，可以直接修改Cost值。</li>
</ol>
<h2 id="ospf数据包类型"><a href="#ospf数据包类型" class="headerlink" title="ospf数据包类型"></a>ospf数据包类型</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-26_11-34-24.jpg" alt="Snipaste_2020-06-26_11-34-24"></p>
<ul>
<li>Hello：发现直连链路上的OSPF邻居、维护邻居关系。</li>
<li>DBD：Database Description，数据库描述包，DBD一共有两种类型，一种是空的DBD，用于协商Master/Slave，另一种则包含LSA的头部信息（不是全部的LSA信息，相当于一个LSA的目录），用于描述LSDB的摘要。 </li>
<li>LSR：Link State Request，链路状态请求报文，用于向OSPF邻居请求链路状态信息。</li>
<li>LSU：Link State Update，链路状态更新报文，在LSU报文中包含完整的链路状态信息，也就是完整的LSA。</li>
<li>LSACK：Link State Acknowledge，链路状态确认报文，OSPF协议规定收到每个LSA后要进行确认，LSACK就是确认收到LSA的报文。</li>
</ul>
<h2 id="协议的三张表"><a href="#协议的三张表" class="headerlink" title="协议的三张表"></a>协议的三张表</h2><p>邻居表（Neighbor Table）：邻居表由临界数据库（Adjacency Database）生成，两台路由器的OSPF要协同工作，最基本的要求是两者要形成邻接（Adjacency）关系，邻居表储存了OSPF路由器邻居状态以及关于该邻居的其他数据，每台路由器的邻居表和其他路由器的不同，用 ‘show ip ospf neighbor ‘命令查看邻居表 。</p>
<p>拓扑表（Topology Table）：拓扑表由链路状态数据库（Link-State Database，LSDB）生成，储存着网络中其他路由器的信息，用于构建网络拓扑，同一个区域（Area）内的路由器中的拓扑表相同（因为拓扑表用于构建区域内的网络拓扑，每个路由器都在相同网络拓扑的区域内），LSDB的概念有点不太好理解，可以理解成LSDB中的这些数据相当于本AS内的网络拓扑图一样，用 ‘show ip ospf database ‘命令查看拓扑表。</p>
<p>OSPF路由表（OSPF Routing Table）：路由表由转发数据库（Forwarding Database）生成，在链路状态数据库（Link-State DataBase，LSDB）基础上运行SPF算法后得出路由表，用 ‘show ip route’查看路由表。</p>
<h2 id="路由种类"><a href="#路由种类" class="headerlink" title="路由种类"></a>路由种类</h2><p>OSPF的路由共有O、O IA、O E1、O E2、O N1和O N2这五种类型，其中O是某个区域的域内路由，由这个区域的1类和2类LSA生成；OIA是区域间路由，由3类LSA生成；OE1和OE2都是由5类LSA生成的，区别在于OE1是OSPF的域外路由，会累加Metric值，默认带的Metric也就是Cost值是20；OE2也是域外路由，不过不累加Metric值，默认Metric值也就是Cost值就是20，由外部重分布进OSPF的路由默认使用OE2类型；ON1和ON2由7类LSA生成。这几种路由之间优先级简单的来说是：O &gt; O IA &gt; N1 &gt; E1 &gt; N2 &gt; E2，但各厂家对这几种路由的理解不同，所以在不同品牌的网络设备中，这几种路由的优先级也不同，具体哪种路由更优先要结合设备的版本以及厂家规定来看。</p>
<h2 id="触发更新"><a href="#触发更新" class="headerlink" title="触发更新"></a>触发更新</h2><p>当路由器、链路或网段的状态在up-down之间切换时会引发触发更新。假设下图中的网络已经完成了OSPF路由收敛，突然R3下面的一个网络发生了故障，R3用224.0.0.6的组播地址通知DR及BDR，监听224.0.0.6的DR和BDR在得知该网段故障后向组播地址224.0.0.5发送更新通知其他路由器，由于除了DR及BDR的其他路由器都会监听224.0.0.5这一组播地址，路由器收到包含变化后的LSA的LSU后，更新本路由器的LSDB，待SPF延迟计时器到期后运行SPF算法，对更新后的链路状态数据库执行SPF算法必要时更新路由表。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_16-06-29.jpg" alt="Snipaste_2020-07-14_16-06-29"></p>
<h2 id="LSA的确认"><a href="#LSA的确认" class="headerlink" title="LSA的确认"></a><a href="https://community.cisco.com/t5/routing/ospf-lsack-packet/td-p/3220386">LSA的确认</a></h2><p>LSA的确认方式一共有两种，显示确认和隐式确认，显示确认通过LSAck完成；隐式确认通过发送回整个相同的LSA去确认该LSA完成的，隐式确认常见在OSPF的广播网络中，大概过程如下：</p>
<blockquote>
<ol>
<li>A non-DR router on an Ethernet segment detects a topology change and needs to inform other routers about it. It sends the LSU packet to the DR and BDR using the 224.0.0.6 destination IP address.</li>
<li>Both DR and BDR receive the packet. Normally, you would expect that the DR would send an LSAck acknowledging the successful receipt of the LSU. However, the DR needs to propagate the LSU back to the segment using the 224.0.0.5 destination IP address anyway, so it just does exactly that, without sending a standalone LSAck.</li>
<li>The original router receives the same update from the DR it sent it a moment ago, and it considers it as an implicit acknowledgement. No further LSAck from the DR is expected.</li>
<li>Other routers on the segment receive the LSU and acknowledge its receipt via an explicit LSAck message back to the DR. This is an explicit form of acknowledgement.</li>
</ol>
</blockquote>
<ol>
<li>当一个在以太网MA环境下的非DR路由器，路由器A发现拓扑变化后，它需要将这个拓扑变化通知给其他邻居，这时路由器A会使用LSU数据包并把数据包发送给224.0.0.6这个组播地址，因为DR和BDR监听着这个组播地址而其他DR Other只监听着224.0.0.5且DR Other只和DR、BDR建立了完全邻接关系，所有LSU都是先发给DR\BDR再由DR\BDR发送给其他DR Other的。</li>
<li>当DR和BDR都收到这个LSU后，通常情况下，DR会发送LSAck给路由器A告诉A此时DR已经接收到了这个LSU了，然而DR此时也需要将A发过来的LSU通过224.0.0.5泛洪出去，所以DR这时不会发送LSAck去确认那条A的LSA。</li>
<li>那么路由器A如何知道DR收到了那条LSA呢，假定它发送的这条LSU叫AA，A通过224.0.0.6发送特定的LSU-AA给DR，由于DR需要将这个变化通告给域内其他的路由器，所以DR再把这条LSU-AA通过224.0.0.5发送给域内其他包括A在内的路由器，A也就从DR收到了LSU-AA，A收到DR发来的相同的LSU就知道DR已经收到了之前的LSU-AA，也就不用再等待DR的LSAck了，如果没收到的话DR不可能会泛洪这条LSU-AA，这就是<strong>隐式确认</strong>。</li>
<li>在该网段的其他路由器会收到LSU-AA并返回给DR一个LSAck表示收到了这条LSU-AA，这是显示确认。</li>
</ol>
<h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Router(config)# router ospf process-id </span><br><span class="line">/*创建OSPF进程并进入OSPF进程配置模式，Process-id为OSPF进程号，</span><br><span class="line">范围必须在1-65535之间，进程号只具有本地意义，不同路由器之间的OSPF进程号可以相同也可以不同，</span><br><span class="line">互相之间不影响.例如：router ospf 1,也就是配置一个进程号为1的OSPF进程*/</span><br><span class="line"></span><br><span class="line">Router(config-router)# network  address  wildcard-mask  areaarea-id</span><br><span class="line">/*在特定网段上激活OSPF，例如：network 192.168.1.1 0.0.0.0 area 0</span><br><span class="line">就是在192.168.1.1所属网段上激活OSPF*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf neighbor </span><br><span class="line">/*查看OSPF邻居表*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf database</span><br><span class="line">/*查看OSPF的LSDB链路状态数据库*/</span><br><span class="line"></span><br><span class="line">Router# show ip ospf database router x.x.x.x</span><br><span class="line">/*查看OSPF中Link ID为x.x.x.x的1类LSA，router意味着查看1类LSA*/</span><br></pre></td></tr></table></figure>

<p><img src="/2020/06/18/13-ospf/ospf-if-e-0-0-1593085167925.png" alt="ospf-if-e-0-0"></p>
<ul>
<li>show ip ospf interface E0/0，就是查看E0/0接口上关于OSPF的配置情况。</li>
<li>Process ID 1，也就是之前配置的router ospf 后面的process-id，这里可以看到该OSPF进程号为1。</li>
<li>Router ID 0.0.0.2，就是该路由器的ID。</li>
<li>Network Type BROADCAST，表示E0/0接口的OSPF网络类型为广播。</li>
<li>Cost ：10，OSPF使用开销来作为路由的度量值，一条路由的Cost值越小越优，可以在接口下使用ip ospf cost  XX命令来修改cost值。</li>
<li>State BDR，表示该E0/0接口的角色为BDR，也就是Backup Designated Router，备份指定路由器。</li>
<li>Priority 1，表示该接口的OSPF Priority值为1，这个值在决定接口性质，也就是链路在决定一个接口的DR、BDR或DR Other时使用。Priority 最高的为DR。</li>
</ul>
<img src="/2020/06/18/13-ospf/ospf-database-2.1-768x814.jpg" alt="ospf-database-2.1-768x814" style="zoom:67%;">

<p>show ip ospf database 命令及相关输出说明会在后面LSA类型中具体说，这里就不展开了。</p>
<p>clear ip route *是否会出发SPF算法的重新计算？</p>
<p>clear ip route *触发了SPF算法的重新计算，SPF算法运行的次数增加了，实验结果如下：</p>
<p><img src="/2020/06/18/13-ospf/dadadfad1234.png" alt="dadadfad1234"></p>
<h1 id="OSPF计时器"><a href="#OSPF计时器" class="headerlink" title="OSPF计时器"></a>OSPF计时器</h1><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_18-44-35.jpg" alt="Snipaste_2020-07-14_18-44-35"></p>
<ul>
<li>MaxAge：LSA的老化计时器，LSA在LSDB中能存在的最长时间，说白了就是LSA的寿命上限，到了这个时间就必须从LSDB动态链路数据库中删除，LSA的寿命上限为60分钟，也就是60分钟内没收到该LSA的刷新信息就会将其从LSDB中删除；</li>
<li>LSRefresh：LSA刷新计时器，定期1800秒刷新一次有效的LSA，让这些LSA继续在LSDB中存在，避免因到达Max Age而过期从LSDB中删除；</li>
<li>Hello interval：Hello包发送间隔，也就是运行OSPF协议的接口每隔多久发送一次Hello消息。进入接口后用命令：ip ospf hello-interval X 进行更改。Hello interval是接口属性，可以每个接口的Hello interval不同，只要和邻居相同能建立起邻居就可以；</li>
<li>Dead interval：失效间隔，表示如果多少秒后没收到邻居路由器的消息，会认为邻居路由器已Down掉进入接口后用命令：ip ospf dead-interval X 进行更改。Dead interval是接口属性，可以每个接口的Hello interval不同，只要和邻居相同能建立起邻居就可以；</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-07_17-52-20.jpg" alt="Snipaste_2020-10-07_17-52-20" style="zoom:67%;">

<p>OSPF协议根据接口的网络类型不同，Hello Interval、Dead Interval时间也不同，总结见下图：</p>
<img src="/2020/06/18/13-ospf/OSPF-Network-Interface-types.png" alt="OSPF-Network-Interface-types" style="zoom:80%;">

<ul>
<li>Wait：等待计时器（接口属性，各接口可以不同），和Dead interval的值相同，定义了路由器在到达2WAY状态时，等待多久后会宣告自己就是DR。比如如果Wait时间是40秒，那么当一台处于MA网络的路由器到达2WAY状态后，会等待40秒，如果40秒内都没有收到邻居的Hello跟本路由器一起选举DR，那么它就会宣告自己就是DR。</li>
<li>Retransmission：重传计时器（接口属性，各接口可以不同），表示发送完LSU以后，经过多久没收到ACK消息确认收到本设备发送的LSU，就认为这个LSU没成功发送到对方，会进行重新发送。</li>
</ul>
<h1 id="OSPF数据包"><a href="#OSPF数据包" class="headerlink" title="OSPF数据包"></a>OSPF数据包</h1><h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><p>OSPF数据包有邻居发现、形成邻接关系、泛洪LSA信息等功能，共有5种数据包，分别是Hello、DBD、LSR、LSU、LSAck。OSPF数据包的二层采用以太网封装，前面说过，OSPF使用的协议组播地址为224.0.0.5或224.0.0.6，所以以太网中的目标MAC地址字段为01-00-5E-00-00-05或01-00-5E-00-00-06；三层用IP封装（Protocol字段为89），目标IP地址为224.0.0.5或224.0.0.6.OSPF部分分为OSPF Header和OSPF Message两部分，Header决定了OSPF为5种类型种的哪种数据包，Message携带了该种类型包含的信息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-11_18-44-34.jpg" alt="Snipaste_2020-07-11_18-44-34" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-10-07_18-30-40.jpg" alt="Snipaste_2020-10-07_18-30-40" style="zoom:67%;">

<h3 id="OSPF-Header"><a href="#OSPF-Header" class="headerlink" title="OSPF Header"></a>OSPF Header</h3><p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200710115532.jpg" alt="微信图片编辑_20200710115532"></p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_14-32-10.jpg" alt="Snipaste_2020-07-10_14-32-10"></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_11-53-16.jpg" alt="Snipaste_2020-10-08_11-53-16" style="zoom:67%;">

<p>所有5种OSPF数据包都有着共同通用的24字节长度的OSPF报头，通用的报头让接收端路由器能进行后续的验证和处理。OSPF并不适用TCP或UDP作为四层的报头而是使用单独的协议，协议号为89。OSPF的5种数据包，Header部分只有Type字段有所区别，后面具体分析的时候就不再涉及Header部分而只说Message部分了。</p>
<ul>
<li>Version：版本，OSPF v2版本该字段为2，字段长度为8位。</li>
<li>Packet Type：类型，根据类型字段数值不同表示不同的OSPF数据包，1为Hello，2为DBD，3为LSR，4为LSU，5为LSAck，字段长度为8位。</li>
<li>Packet Length：OSPF报头总长度，字段长度为16位。</li>
<li>Router ID：产生该OSPF包的源路由器的Router ID，Router ID在AS中唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在OSPF路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。，字段长度为32位。</li>
<li>Area ID：用于标识该数据包所属的区域（Area），字段长度为32位。</li>
<li> Checksum：校验和，用来检查OSPF报头在传输中的完整性，这个校验和不包括后面的身份验证（Authentication）字段，也就是从Version到Authentication Type的部门，字段长度为16位。</li>
<li>Authentication Type：认证方式字段，定义该数据包的认证方式。0表示没有密码，1表示明文密码，2表示MD5认证，字段长度为16位。</li>
<li>Authentication：认证字段，共64位，之所以在图中占两行是因为一行是32位，两行才是64位。</li>
</ul>
<h3 id="OSPF-Message"><a href="#OSPF-Message" class="headerlink" title="OSPF Message"></a>OSPF Message</h3><p>OSPF Message部分根据Packet Type的不同携带不同的信息：</p>
<ul>
<li>Type 1：当Type为1时表示这是一个Hello包，携带的信息是已知的邻居。</li>
<li>Type 2：当Type为2时表示这是一个DBD包，携带的信息是LSDB的目录，目录中包括Router ID、序列号等。</li>
<li>Type 3：当Type为3时表示这是一个LSR包，携带的信息为需要的LSR以及需要LSR的路由器的Router ID。</li>
<li>Type 4：当Type为4时表示这是一个LSU包，携带的信息是完整的LSA条目，一个LSU种可携带多条LSA。</li>
<li>Type 5：当Type为5时表示这是一个LSAck包，携带的信息为空。</li>
</ul>
<h2 id="Hello"><a href="#Hello" class="headerlink" title="Hello"></a>Hello</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Hello数据包用于与邻居<strong>建立并维持</strong>毗邻关系、交互参数以及选举BDR/DR，当接口类型为广播和P2P时默认每10秒交换一次Hello包，其他接口类型时30秒发送一次Hello包，发送地址为组播的224.0.0.5。Hello包的Packet Type为1。Hello包会周期性的在运行了OSPF的接口上用组播发送出去。为了顺利建立起邻居，所有连接到网络种的路由器的相关参数必须<strong>互相相同</strong>，这些参数包括网络掩码、Hello时间和Dead时间等。</p>
<h3 id="格式分析"><a href="#格式分析" class="headerlink" title="格式分析"></a>格式分析</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_15-08-07.jpg" alt="Snipaste_2020-07-10_15-08-07"></p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200710151006.jpg" alt="微信图片编辑_20200710151006"></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-10_15-08-40.jpg" alt="Snipaste_2020-07-10_15-08-40" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/add20392830280.jpg" alt="add20392830280" style="zoom:80%;">

<ul>
<li>Network Mask：网络掩码，指的是路由器要发送的网络的掩码，字段长度为32位。</li>
<li>Hello Interval：Hello包发送间隔，也就是运行OSPF协议的接口每隔多久发送一次Hello消息，字段长度为16位。</li>
<li>Opinion：选项，代表着路由器支持OSPF的哪些可选功能，字段长度为8位。</li>
<li>Router Priority：路由器优先级，在选举BDR\DR时使用，字段长度为8位。</li>
<li>Router Dead Interval：路由器失效间隔，表示如果多少秒后没收到邻居路由器的消息，会认为邻居路由器已Down掉，字段长度为32位。</li>
<li>Designated Router：指定路由器，在NBMA以及广播这两种类型的网络中，要选举DR路由器，选举后DR的IP地址在该字段，所有DR Other路由器和DR建立完全邻接关系并交换LSA，如果没有DR则该字段为全0，字段长度为32位。</li>
<li>Backup Designated Router：备份指定路由器，在NBMA以及广播这两种类型的网络中，要选举BDR路由器，BDR是DR的备份，先选举BDR然后将BDR晋升为DR，当DR Down掉后由BDR接替DR的位置并发挥DR的作用，如果没有BDR则该字段为全0，字段长度为32位。</li>
<li>Neighbor：邻居，当收到其他路由器发送来的Hello包时，将其他路由器的IP地址放在此字段，如收到多个路由器的Hello包时，会存放多个，收到一个其他路由器的Hello包占据32位，收到两个占据64位，以此类推，用Wireshark抓包时此字段为Active Neighbor，比如上图有两个Active Neighbor分别是1.1.1.1和3.3.3.3，表示该路由器分别收到了1.1.1.1和3.3.3.3这两个路由器发来的Hello包。</li>
</ul>
<p>Hello包中的Area ID，Hello Interval，Router Dead Interval、Authentication Type、Authentication几个字段在邻居建立时必须相同邻居才能成功建立。如果Hello 时间不同Debug时就会出现以下提示，说明两个路由器之间Hello时间Mismatch，也就是Hello时间不相匹配：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-12_13-46-07.jpg" alt="Snipaste_2020-07-12_13-46-07" style="zoom:80%;">

<h2 id="DBD"><a href="#DBD" class="headerlink" title="DBD"></a>DBD</h2><h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><p>DBD是DataBase Description的缩写，出现在邻居建立过程中的ExStart及Exchange阶段，DBD是链路状态数据摘要，也就是LSDB的摘要或者说它是LSDB中有什么LSA的简略列表，用于描述链路状态数据库（LSDB）的内容，一个域中所有路由器的LSDB必须相同，在交换LSA之前先通过比较DBD来知道需要交换哪些LSA，这个是DBD的主要作用。</p>
<h3 id="格式分析-1"><a href="#格式分析-1" class="headerlink" title="格式分析"></a>格式分析</h3><p>整体的DBD包：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-42-26.jpg" alt="Snipaste_2020-07-15_15-42-26" style="zoom:67%;">

<p>DBD数据包的<strong>Header部分</strong>中的Packet Type为2，表示这是一个DBD数据，其他字段之前分析过这里就不再赘述了，Header部分如下图：</p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200715120054.jpg" alt="微信图片编辑_20200715120054"></p>
<p><strong>Message部分</strong>：</p>
<p><img src="/2020/06/18/13-ospf/ospfdatabasedescriptionformat.png" alt="ospfdatabasedescriptionformat"></p>
<ul>
<li>Interface MTU：长度为16位，一个路由器的接口在不分片情况下，所能传递的IP信息的最大值。这个值两台路由器必须相等才能建立Full Adjacency的关系。</li>
<li>Option：长度为8位，本地路由器在此字段中告知其所支持的功能。</li>
<li>Flages：长度为8位，前5位保留值为0，后三位分别为I位（Initial位，当它置1时表示这是初始的第一个DBD包，用来协商Master\Slave关系；置0时表示这不是初始的第一个DBD包了，标志着Master\Slave选举结束）、M位（More位，当它置1时表示后续还有DBD包需要发送；置0时表示后续没有DBD包需要发送了）、MS位（Master\Slave位，当它置1时表示路由器认为自己的角色时Master；置0时表示对方为Master。）。</li>
<li>DD Sequence number：长度为32位，主从关系（Master\Slave）确定前，两台路由器各自用一个随机的大数字作为自己的DD Sequence；当主从关系确定后，Slave一方会用Master一方的DD Sequence作为自己的DD Sequence发送DBD给Master表示确认收到了Master的DBD，也就是隐式确认。</li>
<li>LSA Header：这部分包含了用来表述路由器LSDB的LSA头部。</li>
</ul>
<p>DBD的Wireshark抓包如下：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20DBD%20packet%20capture.png" alt="OSPF DBD packet capture"></p>
<h3 id="补充说明"><a href="#补充说明" class="headerlink" title="补充说明"></a>补充说明</h3><p>两台路由器的DBD包中的Interface MTU必须相等才能建立Full Adjacency的关系，如果不相等会出现如下的提示，提示10.1.1.2的Interface MTU更小使得Adjacency无法建立：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-17-34.jpg" alt="Snipaste_2020-07-15_15-17-34" style="zoom: 67%;">

<h2 id="LSR"><a href="#LSR" class="headerlink" title="LSR"></a>LSR</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>LSR用于请求邻居路由器发送其链路状态数据库（LSDB）中的特定项。LSR一般用在两台路由器交换完DBD后，当然如果路由器发现彼此之间并不用交换LSA的话，则LSR不会出现。</p>
<h3 id="格式分析-2"><a href="#格式分析-2" class="headerlink" title="格式分析"></a>格式分析</h3><p>整体格式：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-15_15-43-35.jpg" alt="Snipaste_2020-07-15_15-43-35" style="zoom:67%;">

<p>Header部分中的OSPF Type为3，其他部分与其他包的Header部分相同这里就不再赘述了。</p>
<p>Message部分：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSR%20header%20format.png" alt="OSPF LSR header format"></p>
<ul>
<li>LS type：长度为32位，表示所传递的LSA的类型。</li>
<li>Link State ID：长度32位，传递的LSA的ID，通常来说是路由器的ID或链路的ID。</li>
<li>Advertising Router：长度32位，发送LSR请求的路由器的Router ID 。</li>
</ul>
<p>LSR的Wires hark抓包如下：</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSR%20packet%20capture.png" alt="OSPF LSR packet capture"></p>
<h2 id="LSU"><a href="#LSU" class="headerlink" title="LSU"></a>LSU</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p>LSU用于向邻居路由器发送其所需要的链路状态通告（LSA）。这些LSU实现了LSA的泛洪。每条LSA中包含着描述网络的一部分信息，这些信息包括路由、度量值和拓扑信息等。本地路由器的LSA通过LSU被发送到邻居路由器，邻居路由器通过LSR来回应LSU。</p>
<h3 id="格式分析-3"><a href="#格式分析-3" class="headerlink" title="格式分析"></a>格式分析</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-16_16-11-39.jpg" alt="Snipaste_2020-07-16_16-11-39" style="zoom: 67%;">

<p>Header部分中的OSPF Type为4，其他部分与其他包的Header部分相同这里就不再赘述了。</p>
<p>Message部分：</p>
<p><img src="/2020/06/18/13-ospf/ospf-lsu-lsa-packet-structure-lsa-types-overview-1234.png" alt="ospf-lsu-lsa-packet-structure-lsa-types-overview-1234"></p>
<p><img src="/2020/06/18/13-ospf/ospf-lsu-lsa-packet-structure-lsa-types-overview-2.png" alt="ospf-lsu-lsa-packet-structure-lsa-types-overview-2"></p>
<p>需要更新给邻居的LSA，是以上图的形式，也就是LSA包含在LSU中，以LSU的形式发送给邻居路由器的，下面来看字段具体含义。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-16_16-42-45.jpg" alt="Snipaste_2020-07-16_16-42-45" style="zoom:80%;">

<ul>
<li>Number of Link State Advertisments：长度32位，表示这条LSU携带了几条LSA；</li>
<li>LSAs：长度可变，表示所携带的LSA，具体报文格式参考后面的LSA部分。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_12-23-59.jpg" alt="Snipaste_2020-10-08_12-23-59" style="zoom: 67%;">

<p>下图中的LSU中包含着1条1类LSA，这条1类LSA中包含着3个链路，其中两个链路为Stub类型，一个链路为P2P类型。</p>
<p><img src="/2020/06/18/13-ospf/OSPF%20LSU%20Packet%20Capture.png" alt="OSPF LSU Packet Capture"></p>
<h2 id="LSACK"><a href="#LSACK" class="headerlink" title="LSACK"></a>LSACK</h2><h3 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h3><p>LSAck用来向发送方确认收到特定的LSU，由于OSPF在四层不适用TCP或UDP，而协议又对可靠性有要求，因此增加LSAck包来保证可靠性。</p>
<h3 id="格式分析-4"><a href="#格式分析-4" class="headerlink" title="格式分析"></a>格式分析</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-47-05.jpg" alt="Snipaste_2020-07-17_10-47-05" style="zoom:80%;">

<p>OSPF的Header部分除了Type字段为5以外，其他部分之前已经写过，这里就不再赘述。</p>
<p>Message部分包含了已经确认收到的LSA的报头，如果收到N个LSA的话就会有N个LSA报头在其中，关于LSA的Header部分在下一节LSA中具体讨论。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-48-57.jpg" alt="Snipaste_2020-07-17_10-48-57" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_10-50-17.jpg" alt="Snipaste_2020-07-17_10-50-17" style="zoom: 67%;">

<h1 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h1><h2 id="LSA简介"><a href="#LSA简介" class="headerlink" title="LSA简介"></a>LSA简介</h2><p>LSA由路由器产生，路由器的角色不同会产生不同种类的LSA，LSA中包含着链路状态信息和路由信息，LSA构成了LSDB（Link-State DataBase，链路状态数据库），OSPF使用LSDB计算路由。每个区域（Area）中所有路由器的LSDB是相同的，也就是说这些路由器所掌握的LSA是相同的，LSA一共有11类，不同种类的LSA传播的范围各有不同，有些LSA只在本区域内传播，有些LSA可以跨区域传播。运行OSPF协议的路由器交换完LSA后，各自运行SPF算法，由于域内路由器的LSDB相同又采用同样的SPF算法，所以计算出的路由路径是相同的。LSA每30分钟全部刷新一次，60分钟内如果没刷新则会由LSA的始发路由器泛洪一条LSA已到达最大过期时间的LSA，让其他路由器删除该LSA。如果链路的状态因为某种原因产生了变化，那么直连该链路的路由器检测到变化后会触发关于该链路变化的更新。路由器只能对其产生的LSA进行修改，不能对其他路由器的LSA进行改动。当网络拓扑发生变化时，LSA会带着新的信息进行泛洪，如果网络收敛完毕后，拓扑没有变化则不会对LSA进行泛洪（除了30分钟的整体LSA刷新以外）。</p>
<h2 id="收到LSA后的动作"><a href="#收到LSA后的动作" class="headerlink" title="收到LSA后的动作"></a>收到LSA后的动作</h2><img src="/2020/06/18/13-ospf/Snipaste_2020-07-08_17-35-08.jpg" alt="Snipaste_2020-07-08_17-35-08" style="zoom:67%;">

<blockquote>
<p>Each LSA has an <strong>aging timer</strong> which carries the <strong>link-state age field.</strong> By default each OSPF LSA is only valid for <strong>30 minutes.</strong> If the LSA expires then the router that created the LSA will resend the LSA and increase the <strong>sequence number</strong>. </p>
<p>Let’s walk through this flowchart together. In this example a new LSA is arriving at the router and OSPF has to decide what to do with it:</p>
<ol>
<li>If the LSA isn’t already in the LSDB it will be added and a LSAck (acknowledgement) will be sent to the OSPF neighbor. The LSA will be flooded to all other OSPF neighbors and we have to run SPF to update our routing table.</li>
<li>If the LSA is already in the LSDB and the sequence number is the same then we will ignore the LSA.</li>
<li>If the LSA is already in the LSDB and the sequence number is different then we have to take action:<ol>
<li>If the sequence number is higher it means this information is newer and we have to add it to our LSDB.</li>
<li>If the sequence number is lower it means our OSPF neighbor has an old LSA and we should help them. We will send a <strong>LSU</strong> (<strong>Link state update)</strong> including the newer LSA to our OSPF neighbor. The LSU is an envelope that can carry multiple LSAs in it.</li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="LSA的删除"><a href="#LSA的删除" class="headerlink" title="LSA的删除"></a>LSA的删除</h2><blockquote>
<p>in OSPF, no router is allowed to prematurely delete other router’s LSAs from its link-state database. LSAs may only be removed from the link-state database either if they reached their maximum age, or if their original advertising router has explicitly flushed them by flooding them with the age set to MaxAge. The loss of a neighbor does not result in its LSAs being flushed.——<a href="https://community.cisco.com/t5/switching/ospf-lsa-flooding/td-p/1964852">OSPF LSA Flooding</a></p>
</blockquote>
<p>在OSPF协议中，路由器不能过早的删除自身LSDB中由其他路由器产生的LSA，也就是说如果R1收到一条由R2始发的LSA并将其加入LSDB后，不能无缘无故的删除这条LSA，要删除该LSA，要么是该LSA的老化计时器到时间（60分钟）R1将其删除，要么是通告该LSA的原始路由器R2泛洪一条LSA已到达最大过期时间的LSA，让其他路由器比如R1删除该LSA。</p>
<h2 id="LSA的刷新"><a href="#LSA的刷新" class="headerlink" title="LSA的刷新"></a>LSA的刷新</h2><h3 id="为什么需要刷新LSA"><a href="#为什么需要刷新LSA" class="headerlink" title="为什么需要刷新LSA"></a>为什么需要刷新LSA</h3><p>RFC 2328中规定：Every LSA has to be reoriginated (that is, refreshed) every 1800 seconds.也就是说每一条LSA每隔1800秒（30分钟）必须重新起源或者说刷新一次，不管LSA的老化计时器是否到期都会刷新LSA，为的是在LSA老化计时器的3600秒到达前还能在区域内存在并传播，路由器只刷新它生成的LSA。</p>
<h3 id="刷新LSA的步骤"><a href="#刷新LSA的步骤" class="headerlink" title="刷新LSA的步骤"></a>刷新LSA的步骤</h3><p>OSPF的刷新步骤是“What OSPF routers do each 30 minutes is that each router takes all LSAs it has originated itself, increments their sequence (revision) number, resets the age and floods them. Basically, each router floods a refreshed version of its own LSAs. Note that this is not an entire database resynchronization.——<a href="https://community.cisco.com/t5/routing/why-in-ospf-lsa-refresh-time-is-set-as-30-minutes/td-p/2600233">出处点击</a>”，以及“This is the 30 minute interval which you are asking about. As the age of some self-originated LSA approaches 1800 seconds, the router will generate a refreshed version of the same LSA and flood it - an incremented sequence number, the age timer set to 0. That’s it. Nothing more. There is no some kind of resynchronization of entire link-state databases or something. You just flood a new LSA, just like you would flood an LSA if some topological event occured. The DBD packets have nothing to do here. As with all LSA flooding operations, LSAs are flooded within LSU packets, and they are confirmed with LSAck packets.——<a href="https://community.cisco.com/t5/switching/when-was-dbd-database-descriptor-packets-sent/td-p/2080784">出处点击</a>”。简单来说就是LSA的起源路由器会在30分钟的时候发送一条和之前LSA相同的新版本的LSA去刷新该条LSA，这个新版本的LSA相比之前的LSA来说，增加了序列号的数值且老化计时器为0。在LSA刷新的时候不会发送DBD，只是用LSA去刷新LSA（LSA包含在LSU中用LSU的形式泛洪），收到刷新LSA的LSU以后，路由器也会发送LSAck用来确认收到LSU。这里注意，在MA网络中由于所有DR Other只和DR\BDR建立完全邻接关系，所以在刷新LSA时，起源路由器的的LSU也是和DR\BDR交互的，由DR\BDR再泛洪给其他路由器。</p>
<h3 id="刷新的对路由器是否有影响"><a href="#刷新的对路由器是否有影响" class="headerlink" title="刷新的对路由器是否有影响"></a>刷新的对路由器是否有影响</h3><p>答案是没有影响，因为近年来设备的CPU性能已足以应付每30分钟刷新一次的LSA，而且每隔域（Area）中有多个DR\BDR而不是一个，每个MA网络都有其自己的DR\BDR，只负责本MA网络的LSA泛洪就行。而且即使是一个有N台路由器的MA网络也不意味着同一时间同时泛洪LSA，因为LSA的老化计时器是在每条LSA生成泛洪时开始计时的，每条LSA生成的时间不同。即使因为巧合，所有路由器在同一时间刷新LSA，假设MA网络中有N个路由器，那么此时同时刷新的1类LSA为N条，需要更新的2类LSA由于在为1条（由于2类LSA由DR产生用来通告掩码），如果再有ABR或ASBR的话也需要泛洪的LSA也不多，所以不会对路由器有什么影响。</p>
<h2 id="LSA的新旧"><a href="#LSA的新旧" class="headerlink" title="LSA的新旧"></a><a href="https://tools.ietf.org/html/rfc2328#page-146">LSA的新旧</a></h2><p>当一个路由器遇到两条LSA实例时，它必须分辨出哪一条更新一些，这种情况一般在收到一条和本地LSDB一样的LSA时出现，在两台路由器的LSDB交换过程中也会出现。</p>
<p>两条LSA是否相同由LS Type、Link-State ID和Advertising Router三个参数决定。一条LSA的两个实例由LS Sequence number、LS age和LS checksum决定哪个实例是更新一些的。</p>
<p>首先比较LS Sequence Number，有着更新LS Sequence Number的LSA更新；如果两个实例有着相同的LS Sequence Number且LS checksum不同，那么LS checksum更大的被认为是更新的LSA。其他情况参见RFC 2328的<a href="https://tools.ietf.org/html/rfc2328#page-146">section13.1</a></p>
<h2 id="路由器的角色"><a href="#路由器的角色" class="headerlink" title="路由器的角色"></a><a href="https://www.geeksforgeeks.org/link-state-advertisement-lsa/">路由器的角色</a></h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-17_11-36-07.jpg" alt="Snipaste_2020-07-17_11-36-07"></p>
<blockquote>
<ol>
<li><strong>Backbone router –</strong> The area 0 is known as backbone area and the routers in area 0 are known as backbone routers.</li>
<li><strong>Internal router –</strong> An internal router is a router which have all of its interfaces in a single area.</li>
<li><strong>Area Boundary Router (ABR) –</strong> The router which connects backbone area with another area is called Area Boundary Router. The ABRs therefore maintain multiple link-state databases that describe both the backbone topology and the topology of the other areas.</li>
<li><strong>Area Summary Border Router (ASBR) –</strong> When an OSPF router is connected to a different protocol like EIGRP, or Border Gateway Protocol, or any other routing protocol then it is known as AS. The router which connects two different AS (in which one of the interface is operating OSPF in area 0) is known as Area Summary Border Router. These routers perform redistribution. ASBRs run both OSPF and another routing protocol, such as RIP or BGP.</li>
</ol>
</blockquote>
<ol>
<li>Backbone Router：翻译成中文是骨干路由器，就是至少有一个接口在Backbone区域中的路由器。</li>
<li>Internal Router：翻译成中文是内部路由器，也就是所有接口都在同一个非骨干区域的路由器。</li>
<li>Area Boundary Router (ABR)：翻译成中文是区域边界路由器，用以连接区域0和非骨干区域，ABR路由器在Backbone区域有一个或多个接口并且在非骨干区域也有一个或多个接口。</li>
<li>Area Summary Border Router (ASBR)：翻译成中文是自治系统边界路由器，当一个路由器既运行了OSPF协议，也运行了其他路由协议，比如EIGRP或BGP协议的时候，该路由器连接了两个不同的AS（其中一个接口在区域0运行OSPF）的路由器被称为自治系统边界路由器。</li>
</ol>
<h2 id="LSA的格式"><a href="#LSA的格式" class="headerlink" title="LSA的格式"></a><a href="https://www.networkgalaxy.org/2013/07/understanding-ospf-link-state.html">LSA的格式</a></h2><p><img src="/2020/06/18/13-ospf/OSPF%20Header.PNG" alt="OSPF Header"></p>
<p>LSA的报文格式分成两部分，Header和Body，也就是报头和信息。不管是哪种类型的LSA，都有一个相同的20位的LSA报头，根据LS Type字段数值不同，LSA信息部分包括的内容也不同。</p>
<h3 id="LSA报头"><a href="#LSA报头" class="headerlink" title="LSA报头"></a>LSA报头</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-07-18_19-02-42.jpg" alt="Snipaste_2020-07-18_19-02-42" style="zoom:80%;">

<ul>
<li>LS age：链路状态计时器，也就是这条LSA生成的时间，单位为秒，当这个字段到3600s，也就是60分钟的时候，这条LSA会从LSDB中删除，因为到达了最大存在时间；</li>
<li>Options：选项，表示了路由器所支持的OSPF功能有哪些；</li>
<li>LS type：LS类型，表示了这条LSA是哪种类型的LSA。该字段为1的时候是1类LSA也就是Router-LSA；2为2类LSA也就是Network-LSA；3为3类LSA也就是ABR产生的Summary-LSA；4为4类LSA也就是ASBR产生的Summary-LSA；5为5类LSA也就是AS-External-LSA；</li>
<li>Link State ID：链路ID，该字段定义了这条链路，标识了LSA正在通告的内容，通常是链路代表的路由器或网段的IP地址。和Link ID概念不一样，Link ID是一条链路的标识，而Link State ID标识的是一条可能携带多条链路的LSA；</li>
<li>Advertising Router：该字段表示了生成这条LSA的路由器的ID；</li>
<li>LS Sequence Number：用来检测重复LSA或分清LSA新旧的序列号；</li>
<li>LS Checksum：LSA的校验和，用来检测LSA在传输过程中是否被更改，在LS Sequence Number相同时也用于比较两条LSA的新旧，Checksum值大的LSA更新一些。LS Checksum的校验和包括了LSA的Header部分但并不包括LS age部分，因为前面说过LS age是这条LSA的生成时间，随时在变化，如果包括了这部分校验和肯定是每个经过的路由器校验和都不一样；</li>
<li>Length：包括了20位LSA Header在内的LSA的长度。</li>
</ul>
<p>这些信息在使用show ip ospf database X.X.X.X的时候也可以看得到</p>
<p><img src="/2020/06/18/13-ospf/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200801213649.jpg" alt="微信图片编辑_20200801213649"></p>
<p>报头中的信息使用show ip ospf database也能看到：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_21-46-08.jpg" alt="Snipaste_2020-08-01_21-46-08" style="zoom: 50%;">

<h3 id="Options字段"><a href="#Options字段" class="headerlink" title="Options字段"></a>Options字段</h3><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-16_16-56-25.jpg" alt="Snipaste_2020-09-16_16-56-25"></p>
<ul>
<li>E字段置1时表示它邻接的Area能处理5类LSA(ExternalRoutingCapability)；</li>
<li>MC字段置1时表示它支持多播扩展（MOSPF）；</li>
<li>N/P字段置1时表示它支持7类LSA；</li>
<li>EA字段置1时表示它有接收和转发外部LSA的能力；</li>
<li>DC字段置1时表示它支持demand circuits；</li>
</ul>
<p>Options字段常见的N/P及E字段，在后文7类LSA中有具体解释，这里就简单说一下各字段的作用。</p>
<h3 id="其他说明"><a href="#其他说明" class="headerlink" title="其他说明"></a>其他说明</h3><p>看懂输出中关于Link State ID（有时是Link ID）的关键在于，该字段并不是一个IP地址，Link ID中的1.1.1.1不代表这个网络和1.1.1.1/32相连，它表示的是在LSDB的图中中有一个叫做1.1.1.1的路由器节点。</p>
<p>不同类型的LSA中的Link ID和ADV ID不同，在后文1类LSA部分中有具体说明。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-01_22-28-42-1596292138082.jpg" alt="Snipaste_2020-08-01_22-28-42"></p>
<h3 id="LSA信息"><a href="#LSA信息" class="headerlink" title="LSA信息"></a>LSA信息</h3><p>根据LS Type值的不同，LSA共有11类，每一类的message部分差别都比较大，具体见后文。</p>
<h2 id="LSA的分类"><a href="#LSA的分类" class="headerlink" title="LSA的分类"></a><a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">LSA的分类</a></h2><h3 id="总览-1"><a href="#总览-1" class="headerlink" title="总览"></a><a href="https://www.packetflow.co.uk/ospf-areas-explained/">总览</a></h3><ul>
<li>所有运行了OSPF的路由器都会产生1类LSA，仅在本Area中传播，1类LSA用来通告，网络中的节点路由器和这些路由器之间的关系，直连接口的信息；</li>
<li>DR路由器产生2类LSA，仅在本Area中传播，2类LSA中用来通告掩码信息；</li>
<li>ABR路由器产生3类LSA，在除了特殊区域（Totally\Stub area、Totally\NSSA）以外的其他Area中传播，但传播范围仅为一个区域，就是从其他Area到骨干区域或从骨干区域到其他区域，通告了区域间路由；</li>
<li>ABR路由器在知道ASBR的情况下会产生4类LSA，在所有区域中传播，用来通告去往ASBR的路径；</li>
<li>5类LSA由ASBR产生，在所有区域中传播，用来描述ASBR从外部AS注入OSPF区域的重分布路由；</li>
<li>7类LSA也由ASBR产生，在NSSA区域内传播，用来描述外部路由，这个外部路由由ASBR发送给ABR并且由ABR转换成5类LSA后泛洪到其他区域。</li>
</ul>
<h3 id="Type-1"><a href="#Type-1" class="headerlink" title="Type-1"></a>Type-1</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-2.jpg" alt="ospf-lsa-types-explained-2"></p>
<p> 1类SLA的英文全称是：Router Link Advertisement，每台运行OSPF的路由器都会为其所属的每个Area产生1类LSA，1类LSA描述了该路由器在本区域内链路的状态，通告了直连这个区域接口的信息，1类LSA在本区域内泛洪。OSPF用1类LSA识别本链路为以下4种链路邻接方式的哪一种：</p>
<ol>
<li>Stub Network，Stub网络。</li>
<li>Point-to-Point links，点对点链路。</li>
<li>Link to a multiaccess network，多路访问链路。</li>
<li>Virtual Links，虚链路。</li>
</ol>
<p>注意，interface（接口）和link（链路）是有区别的，两者并不是同一个概念。一个接口（Interface）表示的是一个路由器上的物理或逻辑接口，逻辑接口比如loop back接口，物理接口比如以太网接口；而一个链路（link）描述的是表格种两个节点的关系，虚链路（Virtual link）是一个说明这个概念的很好的例子，一个虚链路描述的是逻辑上连接到另一个路由器。</p>
<h4 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-07-20_15-46-10.jpg" alt="Snipaste_2020-07-20_15-46-10" style="zoom: 67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-07-22_12-17-06.jpg" alt="Snipaste_2020-07-22_12-17-06" style="zoom: 50%;">

<p>Length及之前的部分都是LSA Header，有两个地方需要说一下，一个是LS Type为1，表示这是一个1类的LSA；另一个是Link State ID部分，这里该字段被设置成路由器的Router ID。LSA的Header也可以用命令”show ip ospf database”进行查看，但必须要注意这里的Link ID并不是上文倒数第二个字段Link ID，而是Link State ID，在1类LSA中就是Router ID。</p>
<p><img src="/2020/06/18/13-ospf/106-02-show_ip_ospf_database.png" alt="106-02-show_ip_ospf_database"></p>
<p>Link ID和ADV Router在不同类型的LSA中表示的不同含义，ADV Router就是生成这个LSA的Router ID，比如1类LSA的ADV Router就是每台路由器本身， 因为1类LSA由每台路由器自己产生；2类LSA的ADV Router是DR的Router ID，因为2类LSA由DR产生。Link ID，是本设备为链路另一端设备所起的名字。</p>
<p>LSA Header中其他的字段在前面已经写过，这里从Length之后的部分开始看。</p>
<ul>
<li>V位：当该位置1时，表示该路由器是一个或多个已经达到Full状态的虚链路（Virtual link）的终点。V代表了Virtual link endpoint。</li>
<li>E位：当该位置1时，表示该路由器时ASBR路由器，也就是AS边界路由器。E代表了External，E位不能在Stub area中置1，因为Stub area不能包含ASBR路由器。</li>
<li>B位：当该位置1时，表示该路由器是ABR路由器，也就是区域边界路由器。B代表了Border，当路由器连接到2个或更多区域时，B字段应马上置1表明它的ABR身份，即使该路由器目前还没连接到核心区域B位也应置1。</li>
<li>#Links：又叫Number of LSAs，也就是后面携带的LSA的数量，是路由器包含的一个区域中的总体链路的数量。</li>
<li>接下来的三个字段Link ID、Link Data以及Type，前两个字段，也就是Link ID和Link Data由Type所决定，当Type值为不同数值时，Link ID和Link Data的含义随之不同。Link ID字段定义了这条链路的对端是什么，也就是连接到的是什么；这里的Type其实是Link Type，主要用于描述OSPF路由器的接口或邻居，它的值取决于所连接网络的类型。当Type为1时，表示这是一个’Point-to-Point connection to another router’，翻译成中文就是‘点对点连接到另一台路由器’；相对应的Link ID为’Neighboring router’s Router ID’，也就是邻居路由器的路由器ID；相对应的Link Data为’the IP interface address of the associated router interface’，也就是和网络相连的始发路由器接口的IP地址。具体参见下面几张表：</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-01-45.jpg" alt="Snipaste_2020-07-21_17-01-45" style="zoom:80%;">

<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-02-14.jpg" alt="Snipaste_2020-07-21_17-02-14"></p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-02-21.jpg" alt="Snipaste_2020-07-21_17-02-21"></p>
<ul>
<li>#TOS：The type of service，如果没有TOS度量和一条链路相关，那么这个字段就设置为0X00，。</li>
<li>metric：度量值。</li>
<li>TOS：该字段思科设备只支持为0。</li>
<li>TOS metric：TOS特定的指标信息。</li>
</ul>
<h4 id="抓包"><a href="#抓包" class="headerlink" title="抓包"></a>抓包</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-10-08_14-33-52.jpg" alt="Snipaste_2020-10-08_14-33-52" style="zoom: 67%;">

<h4 id="Type字段"><a href="#Type字段" class="headerlink" title="Type字段"></a><a href="http://blog.sina.com.cn/s/blog_5ec353710102vcsc.html">Type字段</a></h4><h5 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h5><img src="/2020/06/18/13-ospf/capture-1596510103043.png" alt="capture" style="zoom:67%;">

<p>这个Type字段定义的是链路类型，注意这个链路类型（Link type）与网络类型（Network type）不同，链路类型（Link type）主要用于描述OSPF路由器的接口或邻居，比如Link ID字段能够了解链路对端是什么设备或者链路对端是否有设备，因为构建OSPF数据库和运行SPF算法需要每台路由器宣告它们的1类LSA，这个1类LSA中必须描述路由器链路的状态，链路状态一共有4种；而网络类型（Network type）是由OSPF协议在接口上针对不同的二层链路介质或封装而定义的，如果二层封装协议是以太网（Ethernet）那么OSPF在这个接口的网络类型为Broadcast，如果二层封装的是HDLC或PPP，那么OSPF的网络类型是P2P。网络类型（Network type）决定了路由器和相邻节点在网段上的行为，常见也比较重要的就是是否选举DR\BDR，以及Hello\Dead interval（Hello和过期时间，网络类型为广播时为10S\40S，P2P、P2MP和point to multipoint non-broadcast时为30S\120S），可以在进入接口以后用命令ip ospf network XXXX（point-to-point、broadcast….想修改成什么网络类型，这个XXXX就改成什么）进行修改。</p>
<p>在1类LSA中，可以看到始发该LSA的路由器所连接的所有链路、链路的类型以及相关内容，在设备上可以用show ip ospf database router internal或show ip ospf database router self-originate查看：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-24_15-36-33-1596510697675.jpg" alt="Snipaste_2020-07-24_15-36-33" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-03_17-24-25.jpg" alt="Snipaste_2020-08-03_17-24-25" style="zoom:67%;">

<p>上面说过，1类LSA中的Type字段的值也决定了后面的Link ID和Link Data的取值，下面两张图，第一张是红茶三杯笔记中的，第二张是我结合RFC文档写的，维基百科上的图和我总结的一样，区别在于虚链路的Link Data如何取值，RFC 2328的Page 128上写的是“For links to transit networks, numbered point-to-point links and virtual links, this field specifies the IP interface address of the associated router interface”。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-21_17-01-45.jpg" alt="Snipaste_2020-07-21_17-01-45" style="zoom:80%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-07_16-49-52.jpg" alt="Snipaste_2020-08-07_16-49-52" style="zoom: 50%;">

<p>OSPF链路类型分为四种，分别是Stub network link、Transit network link、Point-To-Point link、Virtual link。OSPF将链路分为以上的类型自然不是吃饱了没事儿干，一方面是描述网络连接方式，P2P link和Transit network link是用于描述网络拓扑结构的而Stub network link是用于描述子网的；另一方面是不同类型的Link消耗的硬件资源不同，比如Transit network消耗资源多一些，Stub network消耗资源少一点。必须注意的是，Stub network和后面的Stub area是完全不同的两个概念，千万不要混淆二者。</p>
<h5 id="Stub-network-link"><a href="#Stub-network-link" class="headerlink" title="Stub network link"></a>Stub network link</h5><h6 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h6><blockquote>
<p>A stub network’s vertex has only incoming edges.</p>
<p> ——RFC2328 Section 2.1</p>
</blockquote>
<p>RFC的定义过于严谨所以就比较难懂，通俗一些的说法就是在一个链路中只有一台OSPF路由器的情况下，该链路被OSPF链路类型定义为Stub network link，因为一个链路中只有一台OSPF路由器，所以这个链路的网段不可能有OSPF邻居，这个网段的网关就是这台路由器。如果路由器的一个接口被通告进OSPF，无论其二层链路是什么介质，只要在该接口上没有OSPF邻居，那么它就是Stub network link。</p>
<h6 id="举例说明"><a href="#举例说明" class="headerlink" title="举例说明"></a>举例说明</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-04_16-39-26.jpg" alt="Snipaste_2020-08-04_16-39-26"></p>
<p>图中R2身后有一个10.1.23.2/24的网络，它就是Stub network，因为这个网段中只有一个R2一个路由器运行OSPF协议没有其他OSPF邻居。R2产生的1类LSA用于描述FE0/0的Link 数据就是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line">  (Link ID) Network/subnet number: 10.1.23.0</span><br><span class="line">  (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">  Number of TOS metrics: 0</span><br><span class="line">   TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>第一行’Link connected to: a Stub Network’ 对应的是Type字段表达的意思，这里的10.1.23.2是一个Stub network，也就是Type字段值为3时的‘connect to a stub network’，也就是路由器连接到一个末梢网络；Link ID是IP network/subnet number，也就是网络号或子网号，这里10.1.23.2/24这个网段的网络号是10.1.23.0；Link Data是网络的IP地址或子网掩码，这里的255.255.255.0就是这个网络的子网掩码。</p>
<h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>运行OSPF的路由器会维护一张网络拓扑表，通常存储这个网络拓扑表的方式是内存的中邻接矩阵，矩阵图会在下文有说明这里先暂时不管，Stub network的连接图和邻接矩阵的对应图如下：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-25_17-17-16-1596609560127.jpg" alt="Snipaste_2020-07-25_17-17-16"></p>
<p>由于Stub network只有一个路由器就行，没有其他OSPF邻居，所以相比前面有两台路由器要承载穿越流量（也就是不以本地为源也不以本地为目的）的Transit network来说，Stub network需要存放的路由信息就会相对少一些。Stub network类似于快递公司中，最靠近收件人的小的快递投送点，它只需要负责周边收件人快件的投送即可，不需要将快件发送到其他快递否送点，所以只需要知道周边用户的地址即可，硬件消耗会降低一些。</p>
<h5 id="Transit-network-link"><a href="#Transit-network-link" class="headerlink" title="Transit network link"></a>Transit network link</h5><h6 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h6><blockquote>
<p>Transit networks are those capable of carrying data traffic that is neither locally originated nor locally destined. A transit network is represented by a graph vertex having both incoming and outgoing edges.</p>
<p> ——RFC2328 Section 2.1</p>
</blockquote>
<p>RFC给出的定义很严谨，但由于它过于严谨，使得理解起来过于费劲，通过RFC的定义我是没搞明白，又查了一些文章，这里以红茶三杯的笔记为主体，结合自己的理解谈谈这个概念：由于Transit有运输、经过和运送的意思，从定义上看，Transit network是指的有能力发送既不是本网段产生也不是以本网段为目的的数据。但这个定义十分的不好理解，所以也可以把Transit network等同于，至少有两台路由器需要选举DR\BDR的网络，红茶三杯的原话是“简单理解为有邻居的OSPF接口，使用Transit Link来描述。但网络类型为Point-To-Point和点到多点（Point-To-Multipoint）的接口除外，因为它们被定义为Point-To-Point Link。”（在<a href="https://community.cisco.com/t5/routing/does-the-transit-network-in-ospf-equal-ma-network/m-p/4125009#M337365">思科论坛</a>上看到几次有人讨论过这个问题&lt;transit network means there is at least one OSPF neighbor on the link but does not require the election of DR/BDR even if most of the times this happens.&gt;，也在另一个<a href="https://www.networkfuntimes.com/ospf-what-is-a-stub-network/">技术博客</a>上看到有人这么说&lt;What a transit network actually is, is any network that requires a designated router.&gt;，所以为了方便理解这里采用这个说法），这个Transit network可以是以太网LAN或者有多个虚链路的帧中继网络，不管是哪种网络，只要需要选举DR，那么它就是一个Transit network。在之前笔记中写过，由于DR和BDR选举时是每个网段上选的，所以这个Transit network中的network其实也可以理解成网段的意思（ Does the word ‘network’ in the ‘Transit network’ meaning ‘network segment’?Yes I agree——<a href="https://community.cisco.com/t5/routing/does-the-transit-network-in-ospf-equal-ma-network/m-p/4125009#M337365">出处</a>）。举一个不恰当的例子，Transit network有点类似于快递公司中相对大一点的集散中心，这个集散中心既能把周边地区的快递送到，也能把不属于本集散中心投送的快递交给其他靠近最终收件人的投送点进行投递，所以Transit network既要知道其他快递集散点的路径，又要知道周边收件人的地址，硬件消耗相对多一些。</p>
<h6 id="举例说明-1"><a href="#举例说明-1" class="headerlink" title="举例说明"></a>举例说明</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_14-46-10.jpg" alt="Snipaste_2020-08-05_14-46-10"></p>
<p>例如上图所示，R1的FE0/0接口激活了OSPF并且有一个OSPF邻居R2，因此R1在LSA1中描述这个接口时，使用Transit Link来描述，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Transit Network</span><br><span class="line">     (Link ID) Designated Router address: 10.1.23.2</span><br><span class="line">     (Link Data) Router Interface address: 10.1.23.1</span><br><span class="line">     Number of TOS metrics: 0</span><br><span class="line">      TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>第一行’Link connected to: a Transit Network’ 对应的是Type字段表达的意思，这里的10.1.23.2是一个Transit network，也就是Type字段值为2时的‘connect to a transit network’，也就是路由器连接到一个传送网络；Link ID是IP address of Designated Router，也就是DR接口的IP地址，这里DR接口的IP地址是10.1.23.1；Link Data是和Transit network这个链路相连的，始发路由器接口的IP地址，这里10.1.23.1就是这个始发路由器的IP地址。</p>
<h6 id="邻接矩阵-1"><a href="#邻接矩阵-1" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_14-49-40.jpg" alt="Snipaste_2020-08-05_14-49-40"></p>
<p>由于Transit network能发送那些既不是本地产生，也不以本地为目的地的数据，而且这货必须最少有2个路由器，所以不难想象，Transit network所需要存放的关于路由的数据相对后面的Stub network要多一些。</p>
<h5 id="Point-To-Point-link"><a href="#Point-To-Point-link" class="headerlink" title="Point-To-Point link"></a>Point-To-Point link</h5><p>OSPF网络类型（network type）为Point-to-Point和Point-to-Multipoint的接口（Loop back接口除外），使用Point-to-Point Link（Link type）来描述，也就是Type字段为1时的“Point-to-Point connection to another router”，表示路由器的接口通过P2P方式连接到另一个路由器。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-05_16-24-37.jpg" alt="Snipaste_2020-08-05_16-24-37"></p>
<p>例如上图，R1的S0/0口的OSPF网络类型是P2P，因此R1产生的1类LSA中用于描述该接口的网络类型就是P2P Link，输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: another Router (point-to-point)</span><br><span class="line">    (Link ID) Neighboring Router ID: 1.1.1.1</span><br><span class="line">    (Link Data) Router Interface address: 10.1.12.2</span><br><span class="line">    Number of TOS metrics: 0</span><br><span class="line">     TOS 0 Metrics: 64</span><br><span class="line"></span><br><span class="line">   Link connected to: a Stub Network</span><br><span class="line">    (Link ID) Network/subnet number: 10.1.12.0</span><br><span class="line">    (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">    Number of TOS metrics: 0</span><br><span class="line">     TOS 0 Metrics: 64</span><br></pre></td></tr></table></figure>

<p>值得注意的是，对于P2P的网络类型接口，OSPF使用了两个Link来描述，一个是P2P Link，用于描述链路对端连接的路由器ID及自己本地的接口IP地址，还用了一个Stub Network Link来描述该条链路的掩码。</p>
<p>点对点的链路类型比较奇怪，因为理论上来说这种类型的链路并不需要IP地址就可以通信，因为OSPF将这种类型的链路视为“unnumbered”，也就是未编号，也可以理解成没有IP地址。因为链路上只有两个设备，流量从一段发过来肯定是要到另一端去的，给它提供两个IP地址其实意义并不大，但思科IOS中，一个接口如果没有IP地址就没法发送数据，所以也可以用命令“ip unnumbered XX”来让一个接口借用其他IP地址，比如如果想让Ethernet 0 这个链路类型为P2P的接口接用其他IP地址类通信，可以配置“ip unnumbered Ethernet 0”命令。</p>
<h5 id="Virtual-link"><a href="#Virtual-link" class="headerlink" title="Virtual link"></a>Virtual link</h5><p>这种链路类型用来描述OSPF虚链路（Virtual Link）。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_11-43-00.jpg" alt="Snipaste_2020-08-12_11-43-00" style="zoom:67%;">

<p>在上图中，R1和R3之间建立了一条虚链路，则R1产生的LSA1中描述该虚链路的数据如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Virtual Link</span><br><span class="line">     (Link ID) Neighboring Router ID: 3.3.3.3                #虚链路对端设备的RouterID</span><br><span class="line">     (Link Data) Router Interface address: 10.1.12.1       #本地接口IP地址</span><br><span class="line">     Number of TOS metrics: 0</span><br><span class="line">      TOS 0 Metrics: 128</span><br></pre></td></tr></table></figure>

<p>上面输出的Metric：128，指的是从本地到虚链路对端，沿途所有出接口的COST累加，例如R1产生的描述虚链路的Link数据中包含的metric值就是如图中所示绿色标记的接口的cost值累加。</p>
<h5 id="为什么如此定义"><a href="#为什么如此定义" class="headerlink" title="为什么如此定义"></a>为什么如此定义</h5><p>为什么要定义Stub\Transit network呢？答案是为了减少内存使用（This distinction is made because of memory requirements of the OSPF implementation.——<a href="https://community.cisco.com/t5/switching/ospf-lsa-type-1-stub-network/td-p/1536761">出处</a>），OSPF最早是在1989年提出来的，当时路由器的硬件配置比较低，但现在设备的硬件性能有了很大的提高，已经不太需要去如此节约系统资源了，但理解OSPF如此规定的理念有助于对协议整体的把握，所以建议有时间还是了解一下。当然具体如何减少内存使用，说实话我也没完全搞懂，写一下目前的理解，也许有时间再把这一块完善一下。</p>
<p>OSPF会利用内存维护一个网络拓扑表的矩阵，这个矩阵通常的存在形式如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-38-29.jpg" alt="Snipaste_2020-07-28_15-38-29" style="zoom:67%;">

<p>矩阵最上面，行的备注是“form”，也就是“form object”：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-03-50.jpg" alt="Snipaste_2020-07-28_15-03-50" style="zoom:67%;">

<p>矩阵最左边，列的备注是“to”，也就是“to object”：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-04-54.jpg" alt="Snipaste_2020-07-28_15-04-54" style="zoom:50%;">

<p>做标记的N1和RT1交汇处的数值为3，表示从RT1（行代表的意思为form，也就是从的意思）路由器去到N1（列代表的意思为to，也就是去的意思）网段的cost值为3，当然从N1网段到RT1的cost也是3。其实这个网络拓扑矩阵也就是把物理连接图用矩阵图的形式存在了路由器中，从图中也可以看出这个拓扑矩阵：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_15-41-18.jpg" alt="Snipaste_2020-07-28_15-41-18" style="zoom:67%;">

<p>那么这个拓扑矩阵和减少内存使用有毛关系呢？从矩阵图可以看出，有两个重要元素，路由器和网段。每个<strong>路由器</strong>都在该矩阵的“from”和“to”中出现（如果路由器不在该矩阵中出现，表示这个路由器和其背后的网络均无法到达），但不是每个<strong>网段</strong>在“from”和“to”中都出现，具体来说就是，Transit network属性的网段不论是在“form”的行上，还是在“to”的列中都会出现，但Stub network属性的网段在“to”的列中会出现，因为这个网段作为其他路由器或网段的目的地（也就是在to这一列出现）是没问题的；但在“from”的行上不出现，因为Stub network中只有一个路由器没有其他邻居，而这个网段就是终点了，网段后面也没有其他网段了，它没有穿越流量，因此不需要知道去往其他网段或路由器的路径，只需要把出向流量交给和该Stub network相连的路由器就OK了，那个路由器不管是在“from”还是“to”上都有，知道所有的路径。所以Stub network在“to”的列中有，但在“from”行上不会出现。上面矩阵图中最上边的行中，只有N3、N6、N8、N9出现了，说明这几个网段为Transit network而除此之外的网段均为Stub network，Stub network不出现在from行中减少了矩阵的大小，节约了硬件资源。如果有兴趣可以看一下下面这段话的出处，感觉我的理解并不到位。</p>
<blockquote>
<p>The key observation here is that the stub networks are actually uninteresting for shortest path calculations between routers because they do not provide any further path to any other part of the network. The stub network is the edge - there is nothing behind it, only the network itself. It can be considered an attribute of the router to which it is connected but it is not interesting as a transit topology object. This idea allows us to save memory by <strong>not including the stub networks into the “from” rows of the adjacency matrix</strong> and thus reducing its size. If out of N networks, only N’ (N’ &lt; N) networks are transit networks, the adjacency matrix could be reduced to the size of (M+<strong>N’</strong>) rows x (M+<strong>N</strong>) columns.</p>
<p>This is why the OSPF actually has the stub/transit network distinction in the first place.                                    ——<a href="https://community.cisco.com/t5/switching/ospf-lsa-type-1-stub-network/td-p/1536761">出处</a></p>
</blockquote>
<p>关于节约资源的部分举一个简单的例子，比如一个网络拓扑中有4台路由器和5个网段：</p>
<p>（N1）R1—（N2）—R2—（N3）—R3—（N4）—R4（N5）</p>
<p>如果<strong>不区分Transit\Stub network</strong>，那么矩阵图的大小就是9X9，矩阵图的面基为81：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_16-04-43.jpg" alt="Snipaste_2020-07-28_16-04-43"></p>
<p><strong>区分了Transit\Stub network</strong>后，由于N1和N5这两个Stub network不用在表示from的行中出现，那么矩阵图的大小就是9X7，面基为63：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-28_16-08-40.jpg" alt="Snipaste_2020-07-28_16-08-40"></p>
<p>通过以上的例子能看出区分Transit和Stub链路类型后，能节约一定的资源。</p>
<h5 id="Loop-back接口"><a href="#Loop-back接口" class="headerlink" title="Loop back接口"></a>Loop back接口</h5><p>Loopback接口的链路类型（Link type）永远被定义为Stub host（红茶三杯笔记中这里写的时Stub network link，但看过RFC以后，我感觉还是用RFC中的Stub host更严谨一些&lt;To facilitate this, such interfaces are advertised in router-LSAs as single host routes, whose destination is the IP interface address.—RFC 2328，Page 68&gt;），默认使用32位掩码表示，无论配置loop back的IP地址时使用24/的掩码也是如此。如果进入loop back接口在里面配置一条ip ospf network point-to-point命令，将这个loop back接口的网络类型由loop back 变为了point-to-point，那么这个loop back接口的掩码长度就由32位变成了24位。但必须强调的是，这里更改的是接口的network type也就是网络类型，而接口的链路类型（Link type）由二层封装决定，没有变化，所以Link type还是Stub host\Stub network，也可以说除了网络掩码发生了变化其他都没有变化。</p>
<h6 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-11-52.jpg" alt="Snipaste_2020-08-11_16-11-52"></p>
<h6 id="基础配置："><a href="#基础配置：" class="headerlink" title="基础配置："></a>基础配置：</h6><p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> network 7.7.7.7 0.0.0.0 area 0</span><br><span class="line"> network 192.168.78.0 0.0.0.255 area 0</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R8</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 8.8.8.8</span><br><span class="line"> network 192.168.78.8 0.0.0.0 area 0</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.78.8 255.255.255.0</span><br></pre></td></tr></table></figure>

<h6 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h6><p>默认情况下，即使R7的loopback接口的IP地址配置成24/位掩码，但在<strong>R8</strong>的OSPF路由表中，依旧是32位掩码，因为此时R7的loop back 接口的Link type，也就是链路类型是stub host：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-28-22.jpg" alt="Snipaste_2020-08-11_16-28-22" style="zoom:67%;">

<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-27-16.jpg" alt="Snipaste_2020-08-11_16-27-16"></p>
<p>为了改变思科IOS默认将Loop back接口的掩码设置为32位的情况，我们在思科设备中只能将接口的网络类型（Network type）设置为点对点：</p>
<p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 7.7.7.7 255.255.255.0</span><br><span class="line"> ip ospf network point-to-point</span><br></pre></td></tr></table></figure>

<p>在R7的loop back接口的Network type，也就是网络类型设置为点对点后，R8的路由表中R7loop back接口的掩码由32位变成了loop back地址中配置的24位掩码：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-32-14.jpg" alt="Snipaste_2020-08-11_16-32-14" style="zoom:67%;">

<p>此时再看R7的loop back接口：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-11_16-34-22.jpg" alt="Snipaste_2020-08-11_16-34-22" style="zoom:67%;">

<h4 id="LSA实验"><a href="#LSA实验" class="headerlink" title="LSA实验"></a>LSA实验</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>在图中，R1有三条链路，一条是右边的E0/1口的链路，连接着R2，一条是上边的通向192.168.1.0/24网络的链路，另一条是通往下边的另一个网段的链路。R1需要用1类LSA描述这三条链路并将LSA宣告给R2。R1要给R2（或其他路由器）提供三种信息：</p>
<ol>
<li>一个ID，用于将自己标识为图中的节点；</li>
<li>链路邻接关系列表；</li>
<li>与链路上所有连接的节点的关系。</li>
</ol>
<p>为了标识图中的节点，OSPF使用32位长度的数字作为这些节点在LSDB中的标识符，成为路由器ID，英文为Router ID，简写为RID。默认情况下，OSPF选择loop back接口中最大的IP地址作为RID，如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID。RID也可以在OSPF进程中用“router-id XXXXX”配置。当R1生成它的1类LSA时，它将使用1.1.1.1这个RID作为Link State ID和Advertising Router字段的值，具体如下：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_17-22-24.jpg" alt="Snipaste_2020-08-18_17-22-24"></p>
<p>接下来我们看四种链路类型之一的Stub network在1类LSA中的体现：</p>
<h5 id="Describing-Stub-Network"><a href="#Describing-Stub-Network" class="headerlink" title="Describing Stub Network"></a>Describing Stub Network</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>R1是上面拓扑中的网段192.168.1.0/24中的唯一路由器，这种链路被OSPF分类为Stub network，因为该网段除了R1外没有其他的OSPF路由器，所以流量会从以该网段为起点或终点，但不会穿越该网段，换一种说法就是，网段192.168.1.0/24不会作为传输网段。</p>
<p>R1为Stub network类型的Link type在其1类LSA中建模，好像它是一个连接到另一个节点的链路，用网络前缀作为它的Link ID，用子网掩码作为Link Data。这样一来，这个网段看起来像是一个直接连接到R1上的节点。在所有1类LSA描述的链路邻接节点中，只有Stub network类型的链路描述中携带了网络层地址信息。下面是R1对链路类型为Stub network的192.168.1.0/24这个网段的描述：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line"> (Link ID) Network/subnet number: 192.168.1.0                   #该网段的网络前缀</span><br><span class="line"> (Link Data) Network Mask: 255.255.255.0                        #该网段的网络掩码</span><br><span class="line">  Number of MTID metrics: 0</span><br><span class="line">   TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>Link ID后面标注的是Network/subnet number，翻译成中文就是所描述网段的网络/子网前缀，在这就是192.168.1.0这个网络号，Link Data后面标注的是Network Mask，翻译成中文就是所描述网段的网络掩码，在这就是3个255。至此R1到192.168.1.0/24这个链路类型为Stub network的网段已经描述完毕，接下来看R1如何用1类LSA描述R1和R2之间的点对点链路。</p>
<h5 id="Point-to-Point"><a href="#Point-to-Point" class="headerlink" title="Point-to-Point"></a>Point-to-Point</h5><p>R1上看到的描述这个P2P链路输出为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: another Router (point-to-point)</span><br><span class="line">(Link ID) Neighboring Router ID: 2.2.2.2</span><br><span class="line">(Link Data) Router Interface address: 12.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>这个P2P链路描述了R1和R2之间直连的链路，Link ID字段后面标注的是Neighboring Router ID，翻译成中文就是链路另一端的邻居设备的RID，在这里也就是R2的RID2.2.2.2。Link Data字段标注的是Router Interface address，翻译成中文就是该本路由器连接到该链路的接口的IP地址，也就是R1的E0/1的IP地址，12.1.1.1。这里必须注意，Link Data字段并不包含地址信息，因此OSPF会用另一个Stub network的LSA来描述这个链路的掩码，Link ID是IP network/subnet number，也就是网络号或子网号，这里10.1.23.2/24这个网段的网络号是10.1.23.0；Link Data是网络的IP地址或子网掩码，这里的255.255.255.0就是这个网络的子网掩码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Link connected to: a Stub Network</span><br><span class="line">(Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">(Link Data) Network Mask: 255.255.255.0</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<h5 id="OSPF谎言"><a href="#OSPF谎言" class="headerlink" title="OSPF谎言"></a>OSPF谎言</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-18_16-27-27.jpg" alt="Snipaste_2020-08-18_16-27-27"></p>
<p>看起来OSPF在描述上面R1和R2之间的，链路类型为P2P的时候撒了个谎，因为在上面说过，在宣告P2P链路时有两条LSA，一个是P2P，用来描述直连到对方的链路，另一个是Stub network，用来描述掩码，但前面同样说过Stub network是没有邻居的，也不能用于传输穿越流量，而R1和R2是邻居关系，这条链路也承载穿越流量了，比如从R2到192.168.1.0/24的网段就是穿越流量，所以两者矛盾了。</p>
<p>但其实是，逻辑上R1将R2和12.1.1.0/24视作网络中的两个不同节点，当用SPF算法计算路由时，通向这两个节点的每条链路都作为独立的个体，当计算1.1.1.1和2.2.2.2这两个节点之间的路径时，用P2P链路的描述参数计算，当计算通向12.1.1.0/24的网络时，用Stub network链路的描述参数计算：</p>
<p><img src="/2020/06/18/13-ospf/image-20200827163801952.png" alt="image-20200827163801952"></p>
<p>具体请参见<a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">该贴</a>中的The OSPF Lie部分。</p>
<h3 id="Type-2"><a href="#Type-2" class="headerlink" title="Type-2"></a>Type-2</h3><h4 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-3.jpg" alt="ospf-lsa-types-explained-3"></p>
<p>2类LSA的英文是Network-LSA，两个或多个路由器组成广播或NBMA类型的网络时，在DR和至少一个路由器形成全邻接状态（Full adjacency）后，会由DR产生2类LSA，2类LSA描述了包括DR本身在内的连接到网络的所有路由器。2类LSA在本区域内传播。2类LSA的Link state ID字段列出了DR接口的IP地址，这个IP地址和掩码地址（2类LSA中携带着掩码地址）做与运算后，可以得出网络号。</p>
<h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_16-54-39.jpg" alt="Snipaste_2020-08-12_16-54-39" style="zoom:50%;">

<p>LSA的Header部分之前分析过，这里只看message部分。</p>
<ul>
<li>Network Mask：网络的掩码。</li>
<li>Attached Router：连接到网络的路由器的Router ID，事实上，只有那些和DR形成了全邻接关系（Full adjacency）的设备才会在这里面显示出来，DR的Router ID也会显示在这里面。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_17-03-38.jpg" alt="Snipaste_2020-08-12_17-03-38" style="zoom:50%;">

<h4 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h4><h5 id="只用1类LSA的情况"><a href="#只用1类LSA的情况" class="headerlink" title="只用1类LSA的情况"></a>只用1类LSA的情况</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_16-52-47.jpg" alt="Snipaste_2020-08-27_16-52-47" style="zoom:67%;">

<p>上图中R1、R2和R3各有一个接口在同一网段，是MA类型的网络，这种情况下，如果只用1类LSA中的P2P链路类型描述三个路由器之间的关系，而完全不用2类LSA的话，也可以描述，但只能一个一个链路的描述，也就是说一个路由器需要两条1类LSA描述，比如R1的话，需要节点1.1.1.1连接到节点3.3.3.3，1.1.1.1连接到4.4.4.4这两条1类LSA才能描述，只用1类LSA描述后的逻辑拓扑如下：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_17-05-30.jpg" alt="Snipaste_2020-08-27_17-05-30" style="zoom:50%;">

<p>只用1类LSA描述网络的连接关系不仅看起来过于繁琐，也会使LSDB显得很臃肿，庞大的LSDB数据库在运行SPF算法计算路由时会极大的消耗路由器的内存，再具体的解释请参见<a href="https://community.cisco.com/t5/other-network-architecture/why-ospf-lsa-type-2-s/td-p/288472">这个帖子</a>。</p>
<h5 id="使用2类LSA的情况"><a href="#使用2类LSA的情况" class="headerlink" title="使用2类LSA的情况"></a>使用2类LSA的情况</h5><p>用2类LSA描述MA网络信息的方式，就是构筑一个虚拟的节点，这个虚拟节点表示这个MA网络的网段，并让该网段上的每个路由器向新节点通告他们的关系：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_17-26-34.jpg" alt="Snipaste_2020-08-27_17-26-34" style="zoom:50%;">

<p>如果上图的连接转换成语言描述的话就是：1.1.1.1、4.4.4.4和3.3.3.3这三个节点都连接到134.1.1.4这个Transit network上。这样宣告几台路由器之间的MA网络及连接关系占用的空间比较少，OSPF认为134.1.1.4这个节点为其他与之相连的路由器（图中就是1.1.1.1、3.3.3.3、4.4.4.4）提供了连接，并将134.1.1.4这个节点视作另一个虚拟路由器。在134.1.1.0/24网段中会选举出DR，前面说过，DR\BDR是接口属性，从这里也能看出来原因，因为三台路由器各有一个接口连在这个网段中。选出的这个DR生成2类LSA宣告相关信息。在这个拓扑中，在几台路由器R4的Router ID是4.4.4.4比其他路由器的Router ID大，所以一般情况下，R4会被选举（选举过程详见之前的DR\BDR选举）为该网段的DR并宣告2类LSA，该LSA中携带着以下信息：</p>
<ol>
<li>R4用自己在134.1.1.0/24的接口的IP地址134.1.1.4，作为虚拟节点产生的2类LSA的Link State ID；</li>
<li>由R4产生的2类LSA，包含着和该虚拟节点相连的所有路由器的列表，也就是后面的Attached Router。</li>
</ol>
<p>下面来看由R4生成的这条2类LSA，这条LSA描述的是134.1.1.4这个虚拟节点以及该虚拟节点连接的1.1.1.1、3.3.3.3、4.4.4.4这三个节点。因为2类LSA的Link State ID是DR的IP地址，所以其他路由器使用DR的IP地址加上后面的Network mask，也就是部分写的是/24，这两个做与运算后就是网络号，134.1.1.0/24：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# show ip ospf database network</span><br><span class="line">— omitted —</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Network Links</span><br><span class="line">Link State ID: 134.1.1.4 (address of Designated Router) </span><br><span class="line">Advertising Router: 4.4.4.4</span><br><span class="line">LS Seq Number: 80000001</span><br><span class="line">Checksum: 0x9CDC</span><br><span class="line">Length: 36</span><br><span class="line">Network Mask: /24</span><br><span class="line">Attached Router: 4.4.4.4</span><br><span class="line">Attached Router: 1.1.1.1</span><br><span class="line">Attached Router: 3.3.3.3</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-08-27_16-52-47.jpg" alt="Snipaste_2020-08-27_16-52-47" style="zoom:67%;">

<p>连接到134.1.1.0/24网段中的R1这个路由器，用一个链路类型为Transit network的1类LSA去描述R1和虚拟路由器之间的链路：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1# show ip ospf database router self-originate</span><br><span class="line">— omitted —</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Router Links</span><br><span class="line">Link State ID: 1.1.1.1</span><br><span class="line">Advertising Router: 1.1.1.1</span><br><span class="line">— omitted —</span><br><span class="line">Link connected to: a Transit Network</span><br><span class="line">   (Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">   (Link Data) Router Interface address: 134.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>上面描述的这个链路类型为Transit network的链路时，Link ID为134.1.1.4，既是DR（R4）在网段134.1.1.0/24上接口的IP地址，也同样时虚拟路由器的Link State ID，这个值是134.1.1.4；这条Transit network链路的Link Data部分，是R1连接到134这个网段上接口的IP地址，这个值是134.1.1.1 。</p>
<p>上面这两条LSA组合到一起可以后描述了R1的链路情况，节点1.1.1.1通过一个Transit link类型的链路连接到一个虚拟节点134.1.1.4，掩码为24/。这个虚拟节点连接到了节点1.1.1.1、3.3.3.3和4.4.4.4 。</p>
<h4 id="特殊情况分析"><a href="#特殊情况分析" class="headerlink" title="特殊情况分析"></a>特殊情况分析</h4><blockquote>
<p>A router that has formerly been the Designated Router for anetwork, but is no longer, should flush the network-LSA thatit had previously originated.  This LSA is no longer used inthe routing table calculation.  It is flushed by prematurely incrementing the LSA’s age to MaxAge and reflooding.</p>
</blockquote>
<p>如果一个路由器接口的角色由DR变成了非DR，那么它应该刷新之前产生的那条2类LSA，因为之前这个接口还是DR时会产生2类LSA，并将LSA中的age字段设置为最大，也就是3600秒，使这条2类LSA过期，好让其他路由器从LSDB中将这条已经不适用于计算路由的2类LSA删除，因为其他路由器并不能删除那些不是本身产生的LSA。</p>
<blockquote>
<p>In addition, in those rare cases where arouter’s Router ID has changed, any network-LSAs that were originated with the router’s previous Router ID must beflushed. Since the router may have no idea what it’s previous Router ID might have been, these network-LSAs are indicated by having their Link State ID equal to one of the router’s IP interface addresses and their Advertising Router equal to some value other than the router’s current RouterID .</p>
</blockquote>
<p>此外，在那些路由器的Router ID改变的极少数情况下，任何之前产生的带有旧的Router ID的2类LSA都必须被刷新成带有新Router ID的2类LSA，比如在MA网络中的R12的E0/1接口角色为DR，这台路由器一开始的Router ID是1.1.1.1，后来通过配置将Router ID改成了2.2.2.2，这时候这台路由器就得重新发送2类LSA通告其他路由器它的Router ID进行了更改，因为之前2类LSA中的Advertising Router部分是DR的Router ID，而这个Router ID已经发生了变化。2类LSA的Link State ID字段的值为该路由器接口之一的IP地址，Advertising Router字段的值为路由器当前Router ID以外的值。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-08-12_16-50-32.jpg" alt="Snipaste_2020-08-12_16-50-32" style="zoom:67%;">

<h3 id="Type-3"><a href="#Type-3" class="headerlink" title="Type-3"></a>Type-3</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-4.jpg" alt="ospf-lsa-types-explained-4"></p>
<h4 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-08-29_15-44-12-1602320576543.jpg" alt="Snipaste_2020-08-29_15-44-12"></p>
<p>1类和2类LSA解决了区域内路由计算问题，计算并生成了标识为O的区域内路由，解决了区域内部的通信问题，那么区域间的路由怎么办呢？如果路由器需要访问其他区域呢？这时就需要3类LSA。3类LSA是网络汇总LSA，由ABR路由器生成，3类LSA与1类2类LSA不同的是，3类LSA不是详细描述一个区域种存在着哪些节点以及这些节点之间如何连接，它描述的是一个网络号、AS边界路由器或一个IP地址范围段（The destination described by a summary-LSA is either an IP network, an AS boundary router or a range of IP addresses——RFC2328 - Page 135），也可以理解成是路由表中需要通告给其他Area的路由条目的网络号，也就是网络前缀。3类LSA通告范围只有一个区域，也就是把3类LSA传递给邻接的Area0（flood them into the other areas to which it is attached），再由Area 0的ABR生成到其他非Backbone区域的3类LSA。</p>
<h5 id="OSPF的网络号"><a href="#OSPF的网络号" class="headerlink" title="OSPF的网络号"></a>OSPF的网络号</h5><p>在一个多区域OSPF网络中，存在着两种不同的路由，区域内路由和区域间路由，这两种路由也有对应的网络号（网络前缀）：</p>
<ul>
<li>区域内：来自区域内路由的网络号；</li>
<li>区域间：来自区域外路由的网络号；</li>
</ul>
<h5 id="OSPF的层次结构"><a href="#OSPF的层次结构" class="headerlink" title="OSPF的层次结构"></a>OSPF的层次结构</h5><p>还必须了解一下OSPF的层次结构。为了提高抗路由环路能力，OSPF将拓扑分成两层，顶层是Area 0，也就是Backbone Area（骨干区域），下层是除了Area 0之外的其他Area。所有的区域必须和最顶层的Area 0相连接，所有的3类LSA通过位于顶层的骨干区域进行交换后，再发送到下层的其他Area中。这种层次的结构去交换3类LSA就相当于创建了一个下图的“Hub-and-Spoke”（中心辐射型）类型的拓扑：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-01_13-07-04.jpg" alt="Snipaste_2020-09-01_13-07-04" style="zoom:50%;">

<h5 id="3类LSA的泛洪"><a href="#3类LSA的泛洪" class="headerlink" title="3类LSA的泛洪"></a>3类LSA的泛洪</h5><p>由于采用了层级设计，有区域间、区域类两种路由要传递，且3类LSA的通告范围只有一个区域，所以3类LSA的泛洪方式如下：</p>
<ul>
<li>ABR会为骨干区域的区域内路由和区域间路由产生3类LSA，并将3类LSA从骨干区域泛洪到非骨干区域；</li>
<li>ABR会为非骨干区域的区域内路由产生3类LSA，并将3类LSA从非骨干区域泛洪到骨干区域；</li>
<li>ABR使用SPF算法计算路由时，只会用骨干区域产生的3类LSA进行计算。</li>
</ul>
<p>比如上面的拓扑中，ABR1会为Area 1这个非骨干区域的内部路由生成3类LSA，并将该LSA泛洪到骨干区域Area 0，同样ABR1也会为骨干区域Area 0的内部路由和外部路由（剔除出原属于Area 1这个区域的路由后）生成3类LSA并将该LSA泛洪到Area1这个非骨干区域。</p>
<p>上面的算法意味着ABR只有连接到Area 0的时候才会产生3类LSA，在思科设备中ABR是这个工作模式，但可能其他厂商的设备中会有所不同。</p>
<p>有些人认为，3类LSA的通告范围是除了特殊区域的整个OSPF网络，但实际上这种说法是不严谨的，比较严谨的说法是3类LSA的通告范围只有一个区域，也就是邻接的其他那个区域。比如下面这个拓扑中，身处Area256中的R5身后192.168.5.0/24这个网段，由所在区域Area 256的ABR路由器R2生成3类LSA泛洪到Area 0中，这时可能有人要问，如果你说3类LSA的通告范围是邻接的一个区域，那么这个代表192.168.5.0/24网段的3类LSA就不会泛洪到Area 37或Area 489了，可实际实验中这两个区域是有192.168.5.0/24这个OIA的区域间路由的，这和上面3类LSA传播范围只有一个区域的说法矛盾了。是这样，R2生成的这条3类LSA发送到Area 0后，如果想将192.168.5.0/24这个OIA区域间路由用3类LSA继续传递给Area 37或Area 489，这时候R3会为Area 37重新生成一条3类LSA然后传递到这个区域中，R4会为Area 489重新生成一条3类LSA传递到这个区域中，也就是说这条由R2生成的3类LSA由Area 256泛洪到Area 0以后这条3类LSA的泛洪就结束了，如果要继续泛洪到其他Area，就要由其他的ABR，比如R3或R4重新生成，虽然表示192.168.5.0/24这条路由的的3类LSA在每个Area中都有，但由于每过一个区域就要重新生成一次3类LSA，所以严格来说已经不是同一条LSA了，因为这两条LSA的Advertising Router不同。</p>
<h4 id="LSA实验-1"><a href="#LSA实验-1" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-29_22-47-33.jpg" alt="Snipaste_2020-08-29_22-47-33" style="zoom:50%;">

<p>查看路由器R2的LSDB得到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database</span><br><span class="line">OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line">Router Link States (Area 0)</span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         842         0x80000019 0x00AC74 4</span><br><span class="line">2.2.2.2         2.2.2.2         851         0x80000012 0x00034D 3</span><br><span class="line">3.3.3.3         3.3.3.3         834         0x80000011 0x003338 2</span><br><span class="line">4.4.4.4         4.4.4.4         834         0x80000011 0x000A57 2</span><br><span class="line">— some output has been omitted —</span><br><span class="line">Router Link States (Area 256)</span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         851         0x80000006 0x002BAB 1</span><br><span class="line">5.5.5.5         5.5.5.5         852         0x8000000A 0x00A7F9 3</span><br><span class="line">6.6.6.6         6.6.6.6         853         0x80000007 0x000CE5 2</span><br><span class="line">— some output has been omitted —</span><br></pre></td></tr></table></figure>

<p>这里需要注意，由于是多区域的拓扑，R2在Area 0和Area256中间，所以R2分别为这两个区域生成了1类LSA。R2的Area 0中的1类LSA中并没有R5或者R6，是因为这两个路由器处于Area 256中，同理R1、R3、R4这三个属于Area 0的路由器的1类LSA也没出现在Area 256中。show ip ospf database给出的是LSDB的摘要情况，现在我们来看看R1（Area 0）和R6（Area 256）上的1类LSA，也就是Router LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1769        0x80000019 0x00AC74 4</span><br><span class="line">2.2.2.2         2.2.2.2         1780        0x80000012 0x00034D 3</span><br><span class="line">3.3.3.3         3.3.3.3         1761        0x80000011 0x003338 2</span><br><span class="line">4.4.4.4         4.4.4.4         1761        0x80000011 0x000A57 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (6.6.6.6) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         10          0x80000007 0x0029AC 1</span><br><span class="line">5.5.5.5         5.5.5.5         1831        0x8000000A 0x00A7F9 3</span><br><span class="line">6.6.6.6         6.6.6.6         1830        0x80000007 0x000CE5 2</span><br></pre></td></tr></table></figure>

<p>从拓扑图中可以看到，R1、R6、R7、R8和R9这几台路由器的全部接口都在单一区域内，所以这几台路由器只有他们所在区域的拓扑信息，比如R7只有Area 37的信息，R8和R9只有Area 489的信息。因为R2、R3和R4这三台路由器的接口连接到了多个区域，所以它们是ABR（Area Border Router），也就是区域边界路由器，它们有所连接所有区域的拓扑信息，比如R2有接口在Area 256和Area 0中，所以它会有Area 256和Area 0的拓扑信息。</p>
<p>为了提供不同区域之间的连通性，作为ABR的R2执行了以下四个步骤：</p>
<ol>
<li>查询路由表中来自Area 256的所有区域内路由条目；</li>
<li>将这些区域内的路由条目作为3类LSA宣告进骨干区域，Area 0；</li>
<li>查询路由表中来自骨干区域Area 0的区域内路由和区域间路由的网络号；</li>
<li>将这些网络号，剔除出原本属于Area 256区域的路由后，以3类LSA的形式泛洪到非骨干区域Area 256。</li>
</ol>
<p>来看R2路由表中关于前缀192.168.5.0的条目：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2# show ip route ospf | include 192.168.5.0</span><br><span class="line">O     192.168.5.0/24 [110/11] via 25.1.1.5, 02:10:12, Ethernet0/2</span><br></pre></td></tr></table></figure>

<p>注意这条路由最前方用的标识是“O”，也就是说这条路由对于R2来说是区域内部的路由，所以按照上面提到的四个步骤，R2将会把这条属于Area 256的内部路由用3类LSA宣告并宣告进Area 0，现在来看看关于192.168.5.0这个网络号的3类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database summary 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1947</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)                              #该LSA是3类LSA</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)          #该LSA所表示的网络号是192.168.5.0</span><br><span class="line">  Advertising Router: 2.2.2.2                                  #该LSA由路由器2.2.2.2（R2）生成</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0xCCEB</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>R2的Link State ID后面的备注是summary Network Number，说明该值为需要汇总那条路由的网络号也就是192.168.5.0；路由的子网掩码在‘Network Mask’中体现，为24/位；Advertising Router的值设为自己的Router ID，因为3类LSA由ABR产生而自己就是ABR。最后我们可以看到这条LSA发送到了Area 0中：Summary Net Link States (Area 0)。</p>
<p>在Area 0 中的路由器会进行以下步骤：</p>
<ul>
<li>将这条3类LSA发送过来的网络前缀放入路由表中；</li>
<li>运行SPF算法算出到2.2.2.2这个路由器的最短路径；</li>
<li>在路由计算时加入LSA中的Metric值进行计算。</li>
</ul>
<p>执行完以上步骤后，会计算出区域间的路由前缀，在路由表中用“O IA”进行标识：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | i 192.168.5.0</span><br><span class="line">O IA  192.168.5.0/24 [110/21] via 12.1.1.2, 02:46:49, Ethernet0/1</span><br></pre></td></tr></table></figure>

<h5 id="距离矢量特征"><a href="#距离矢量特征" class="headerlink" title="距离矢量特征"></a>距离矢量特征</h5><p>执行完以上的所有3类LSA需要的步骤后会发现，这些步骤和距离矢量路由协议执行的步骤相同，只是简单的将路由前缀、方向（发给路由器2.2.2.2也就是3类LSA的Advertising Router）和Cost（在这个例子中是Metric：11）通告给邻居。这样一来，在区域间添加或删除路由前缀时不需要经过完整的SPF计算。当删除区域间路由时，只需要R2这个ABR将这条3类LSA中的LS age字段设置为超过3600的值，即表示这条LSA已经过期，其他路由器就会将它们LSDB中的条目删除。看完这一段，是不是发现OSPF这个链路状态协议的区域间路由，其实和RIP这种距离矢量协议比较像，都是告诉其他路由器区你要去往X网段发给我就行，是基于传闻的，运行OSPF的路由器只知道本区域内的拓扑但并不知道其他Area的连接方式，具体参照红茶三杯的<a href="http://blog.sina.com.cn/s/blog_5ec353710101bkg6.html">这篇博文</a>，这里就不再赘述了。</p>
<h5 id="传播范围验证"><a href="#传播范围验证" class="headerlink" title="传播范围验证"></a>传播范围验证</h5><p>下面来验证刚才说的3类LSA传播范围，先看Area 256区域中192.168.5.0/24这条路由的的3类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 601</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD2E8</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>再来看Area 0中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 726</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD2E8</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 11</span><br></pre></td></tr></table></figure>

<p>Area 37中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R7#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (7.7.7.7) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 37)</span><br><span class="line"></span><br><span class="line">  LS age: 653</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 3.3.3.3</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0x7D26</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 31</span><br></pre></td></tr></table></figure>

<p>Area 489中的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R9#show ip ospf database summ 192.168.5.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (9.9.9.9) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 489)</span><br><span class="line"></span><br><span class="line">  LS age: 1061</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.5.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0x5F40</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 31</span><br></pre></td></tr></table></figure>

<p>Area 256和Area 0中的LSA是一样的，但和Area 37以及Area 489中的LSA不同，说明3类LSA的泛洪距离为一个Area，想泛洪到其他Area中的话，必须由连接到其他Area的ABR重新生成LSA。</p>
<h3 id="Type-5"><a href="#Type-5" class="headerlink" title="Type-5"></a>Type-5</h3><h4 id="概述-9"><a href="#概述-9" class="headerlink" title="概述"></a>概述</h4><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-6.jpg" alt="ospf-lsa-types-explained-6"></p>
<p>1 、2类LSA解决了本区域的路由，3类LSA解决了区域间的路由，如果有从外部注入的路由信息该如何表示呢？这种外部注入的路由信息可能是通过重分布注入的其他路由协议的路由，亦或是由其他OSPF进程重分布进本OSPF进程的路由，比如说一个公司A并购了同一楼层的另一个公司B，A公司网络所采用的的网络协议是OSPF，但B公司的网络用的是RIP，两个公司在同一层楼，为了方便交换信息需要把网络连接起来，这时候该如何处理呢？这时就要用到5类LSA了，也就是AS external link advertisement。5类LSA描述的是去往AS外部路由，由ASBR（AS boundary routers）路由器生成，泛洪范围为所有Area，5类LSA也是唯一一种泛洪到除了特殊区域（Stub, Totally Stubby and Not-so-stubby areas）之外的整个AS的LSA（’AS-external-LSAs are the only type of LSAs that are flooded throughout the entire Autonomous System; all other types of LSAs are specific to a single area.However, AS-external-LSAs are not flooded into/throughout stub areas’——RFC 2328，Page 40）。LSA的Link State ID的值为目标网络的IP地址，当5类LSA的Link State ID设置为0.0.0.0时，LSA用来描述到AS的默认路由。ASBR路由器通过另一个路由协议（比如BGP）或通过配置信息（比如配置静态路由然后重分布）学到外部路由，并为这些学到的外部路由生成一个5类LSA。</p>
<h4 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-09_15-44-11.jpg" alt="Snipaste_2020-09-09_15-44-11">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-10_15-04-49.jpg" alt="Snipaste_2020-09-10_15-04-49">

<ul>
<li>Network Mask：被宣告路由的IP地址的子网掩码；</li>
<li>E位：标识了外部路由的Metric类型。Metric有两种类型，1和2，当E位置1时，表示该路由为OE2，此时这条路由的cost值为ASBR到外部目标网络的值，固定为20；当E位为0时，表示该路由为OE1，此时这条路由的cost值为整个路径的cost值，也就是外部路由到ASBR的cost，与内部路由到ASBR的cost，两者之和。具体差别详见后面的OE1 VS OE2部分。</li>
<li>metric：表示这条路由的cost值，取决于之前E位的取值，具体见后面的OE1 VS OE2部分。</li>
<li>Forwarding address：要发送到外部路由的数据将被发送到Forwarding address这个地址中，如果该字段被设置为0.0.0.0，则数据将被发送到这条LSA的起源路由器，例如ASBR路由器。必须注意的是，当Forwarding address字段不为0.0.0.0时，此字段应指向一个属于其他AS的地址，也就是一个不属于OSPF协议的地址。Forwarding address字段也可以指向一个默认路由，这时Link State ID字段设置为默认路由的目的地址。</li>
<li>External Route Tag：为路由打上标签，防止重分布时产生路由环路。</li>
</ul>
<h4 id="OE1-VS-OE2"><a href="#OE1-VS-OE2" class="headerlink" title="OE1 VS OE2"></a><a href="https://ipwithease.com/ospf-external-e1-and-e2-routes/">OE1 VS OE2</a></h4><p>E1类型路由的cost值，不仅包含了内部路由到达ASBR的cost值，还包括了ASBR到达外部路由的cost，所以E1的cost值是上面提到的两个cost值之和，而E2路由并没包含内部到达ASBR的cost值。看下面图表中的例子能更好的理解E1、E2两种外部路由类型的区别：</p>
<p><img src="/2020/06/18/13-ospf/OSPF-E1-VS-E2.jpg" alt="OSPF-E1-VS-E2"></p>
<p>拓扑如上图所示，有一个外部网段10.1.1.0/24，通过R3重分布进OSPF协议，此时这条外部路由的seed metric（seed metric一般翻译成初始度量值或种子度量值，个人觉得初始度量值更容易理解。主要是因为各种不同的路由协议计算度量值的方法不一致，如RIP是跳数，OSPF则基于带宽，所以使用seed metrics建立一个标准的重分布metric值。）为20，这个seed metric对于E1和E2来说都是存在的。现在轮到R2计算去往外部网段10.1.1.0/24的metric/cost值了，这时E1和E2两种外部路由类型计算的方式出现了不同：</p>
<p>当这条路由为O E1时：R2会把R2和R3之间的cost值，也就是cost=1，加上外部路由原有的seed metric值，也就是20，二者之和就是1+20=21，把21当作外部网段10.1.1.0/24的cost值；R1则会在R2的cost=21的基础上再加上R1到R2的cost值，也就是说R1会认为到10.1.1.0/24这条路由的cost为1+1+20=22。</p>
<p>当这条路由为O E2时：R2只会计算外部网段10.1.1.0/24的seed metric值，而不会加上R2和R3之间的cost值，也就是说E2类型的外部路由的cost值恒为20，R1也将20视为这条外部路由的cost值。</p>
<h4 id="LSA实验-2"><a href="#LSA实验-2" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:50%;">

<p>上面拓扑中的5类LSA由R6产生，这条LSA中包含着以下三种重要信息：</p>
<ul>
<li>Link State ID字段的备注时External Network Number，也就是被注入OSPF路由协议的外部网段的网络号，在本例中被注入的网段是172.16.56.0/24和172.16.65.0/24；</li>
<li>Advertising Router字段是ASBR路由器的Router ID，在本例中是R6的Router ID，也就是6.6.6.6；</li>
<li>Forwarding Address字段的值为0.0.0.0，表示所有的其他路由器想给外部注入的网段发送数据时，只要将数据发送给ASBR路由器，也就是R6即可。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R6#show ip ospf database external</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (6.6.6.6) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">  LS age: 572</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.56.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0x4151</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br><span class="line"></span><br><span class="line">  LS age: 572</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.65.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0xDDAB</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br></pre></td></tr></table></figure>

<p>这两条5类LSA也可以简单的理解为“去往外部网段172.16.56.0/24和172.16.65.0/24的数据可以通过节点6.6.6.6到达”，由于可以通过6.6.6.6去往外部网段，所以问题从“如何去往外部网段172.16.56.0/24和172.16.65.0/24”，变成了“如何去往节点6.6.6.6”。在Area 256域中的路由器，比如R2或R5，知道如何前往节点6.6.6.6，因为他们的LSDB中有ASBR6.6.6.6的1类LSA（1类LSA描述了路由器在本区域内链路的状态，通告了直连这个区域接口的信息，所以R5有足够的信息知道去往R6的路径）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">2.2.2.2         2.2.2.2         908         0x80000004 0x002FA9 1</span><br><span class="line">5.5.5.5         5.5.5.5         890         0x80000007 0x00C3DF 3</span><br><span class="line">6.6.6.6         6.6.6.6         933         0x80000006 0x0024CD 2</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database router 6.6.6.6</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">  LS age: 10</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 6.6.6.6</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 8000000B</span><br><span class="line">  Checksum: 0xABB</span><br><span class="line">  Length: 60</span><br><span class="line">  AS Boundary Router</span><br><span class="line">  Number of Links: 3</span><br><span class="line"></span><br><span class="line">               [–omitted–]</span><br><span class="line">               </span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 5.5.5.5</span><br><span class="line">     (Link Data) Router Interface address: 56.1.1.6</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 56.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br></pre></td></tr></table></figure>

<p>从上面的例子我们可以看出，在ASBR所在的Area中，1类LSA扮演了一个重要的角色，这个角色就是让ASBR域内的其他路由器获知到ASBR的路径，也就是如何到R6。但不在ASBR的Area的路由器的LSDB中，没有像R5一样有通告R6位置的1类LSA，毕竟1类LSA的泛洪范围只限于本Area中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">Link ID         ADV Router      Age         Seq#       Checksum Link count</span><br><span class="line">1.1.1.1         1.1.1.1         1463        0x8000000A 0x00CA65 4</span><br><span class="line">2.2.2.2         2.2.2.2         1632        0x80000007 0x001942 3</span><br><span class="line">3.3.3.3         3.3.3.3         1400        0x80000009 0x004330 2</span><br><span class="line">4.4.4.4         4.4.4.4         1656        0x80000009 0x001A4F 2</span><br></pre></td></tr></table></figure>

<p>这时候就需要4类LSA来告诉其他Area的路由器如何到达ASBR了。</p>
<h3 id="Type-4"><a href="#Type-4" class="headerlink" title="Type-4"></a>Type-4</h3><p><img src="/2020/06/18/13-ospf/ospf-lsa-types-explained-5.jpg" alt="ospf-lsa-types-explained-5"></p>
<h4 id="概述-10"><a href="#概述-10" class="headerlink" title="概述"></a>概述</h4><p>由于5类LSA需要泛洪到AS中的所有Area中，而其他区域中的路由器并没有关于ASBR的LSA，不知道去往ASBR的路径，在这种情况下，ASBR所在区域的ABR会产生4类LSA，用来告知其他Area的路由器如何前往ASBR，所以4类LSA由ASBR所在区域的ABR生成，泛洪范围也是一个区域，4类LSA泛洪到骨干区域后，其他的ABR将重新生成一个4类LSA并将其扩散到自己的区域中。4类LSA对于那些处于非ASBR区域的区域来说，有以下两个重要的作用：</p>
<ol>
<li>为其他Area的LSDB注入关于ASBR的拓扑信息；</li>
<li>使得其他Area的路由器能够选出最佳路径。</li>
</ol>
<p>关于第一点，4类LSA会告知所有在其他Area的路由器，它们所在区域的哪台路由器有足够的信息可以到达ASBR。这样就能让其他Area的路由器做区域间路由查找，解决去往ASBR的路径问题。第二点适用于Area中有多个ABR且这些ABR到达ASBR的cost值不同的情况，当生成4类LSA时，ABR会列出它自身去往ASBR的cost值，该区域的路由器就可以根据列出的ABR值知道哪个ABR有到达ASBR的最佳路径。没有4类LSA的话，在其他Area中的路由器无法知道选择哪个ABR有前往ASBR的最佳路径了。名称中的这个summary的含义，也就是说在一个有多ABR的Area中，summary这些ABR到达ASBR的cost值，让其他路由器知道选择哪个ABR去ASBR，能算出整条路经的cost值。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-27_17-05-40.jpg" alt="Snipaste_2020-09-27_17-05-40" style="zoom:80%;">

<p>为什么不把5类LSA限制在ASBR这个区域内，让它乱跑不是增加网络负担嘛？对于常规区域的OSPF设计而言，5类LSA的确是可以在OSPF区域内到处乱跑，在某些场合，可能由于OSPF网络的设计，使得OSPF路由器需要维护大量的外部路由，从而导致设备负担过重，那么你可以进行OSPF规划上的调整，例如使用特殊区域——Stub Area、NSSA Area的来优化网络。这些特殊区域能够限制4类LSA或5类LSA的泛洪，并用默认路由来解决网络连通性的问题，因此一来降低了外部路由条目过多带来的影响，二来也解决了去往AS外的连通问题，然而这也带来了一个问题，就是丢失了外部路由的精细度，只知道去往外部路由如何去，但不知道具体有那些路由，好比之前我跟你说的是韩国的妹纸ABCD都很漂亮，现在告诉你韩国的妹纸都不错，你去就是了，这就是所谓的丢失路由的精细度，这在某些特定的网络环境中可能会带来诸如次优路由等等的问题。</p>
<h4 id="LSA实验-3"><a href="#LSA实验-3" class="headerlink" title="LSA实验"></a>LSA实验</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:50%;">

<p>在上面的拓扑中，R6在重分布外部路由进入OSPF时，它的1类LSA中的Flags字段表示R6现在已经时一个ASBR路由器了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LSA-type 1 (Router-LSA), len 60</span><br><span class="line">— omitted —</span><br><span class="line">Link State ID: 6.6.6.6</span><br><span class="line">Advertising Router: 6.6.6.6</span><br><span class="line">Sequence Number: 0x80000004</span><br><span class="line">Checksum: 0x18b4</span><br><span class="line">Length: 60</span><br><span class="line">Flags: 0x02 ((E) AS boundary router)</span><br><span class="line">…. .0.. = (V) Virtual link endpoint: No</span><br><span class="line">…. ..1. = (E) AS boundary router: Yes</span><br><span class="line">…. …0 = (B) Area border router: No</span><br></pre></td></tr></table></figure>

<p>Flags字段中的E位置1时，会告知并提醒Area中的ABR（R2），R6将外部信息注入到了OSPF中，也可以用’show ip ospf database router 6.6.6.6’这条命令查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5#show ip ospf database router 6.6.6.6</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (5.5.5.5) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 256)</span><br><span class="line"></span><br><span class="line">  LS age: 302</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 6.6.6.6</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0x18B4</span><br><span class="line">  Length: 60</span><br><span class="line">  AS Boundary Router                                    #表示R6是ASBR路由器</span><br><span class="line">  Number of Links: 3</span><br></pre></td></tr></table></figure>

<p>和ASBR（R6）同一个Area的ABR（R2）会产生4类LSA并泛洪到所有和ABR相连接的域中，在上面的拓扑中，也就是R2会产生4类LSA泛洪到Area 0中，为了告诉Area0中的路由器如何到达ASBR路由器，也就是到达R6的路径：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip ospf database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (2.2.2.2) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 585</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000002</span><br><span class="line">  Checksum: 0xF016</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 20</span><br></pre></td></tr></table></figure>

<p>必须注意的是，没有必要将4类LSA泛洪到ASBR（R6）所在的Area 256中，因为前面说过，Area 256中的路由器中的LSDB有足够的信息让它们有到达ASBR的路径。</p>
<p>4类LSA中的Advertising Router字段的值为2.2.2.2，Link State ID（后面的补充信息为AS Boundary Router address，也就是ASBR的地址）值为6.6.6.6，这两个值合起来看表示R1、R3和R4为了到达ASBR（R6），必须有到达R2的最短路径，因为ABR将它自己设置成为宣告4类LSA的路由器，这些4类LSA的泛洪范围不像5类LSA那样覆盖所有的Area，4类LSA的泛洪范围只有1个Area。R2上的4类LSA其实就是在告诉其他路由器：通过我可以到达ASBR 6.6.6.6，我到ASBR的cost值是20。其他拓扑中的ABR路由器，R3和R4，会重新生成一条信的4类LSA，将它们自己设置成为LSA中的Advertising Router，例如Area 489中的4类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip ospf 1 489 database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (4.4.4.4) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 489)</span><br><span class="line"></span><br><span class="line">  LS age: 504</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000003</span><br><span class="line">  Checksum: 0x7B6E</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 40</span><br></pre></td></tr></table></figure>

<p>4类LSA中有ASBR的RID、宣告这条4类LSA的ABR的RID以及ABR到ASBR的cost值。</p>
<h3 id="1-5类LSA组合说明"><a href="#1-5类LSA组合说明" class="headerlink" title="1-5类LSA组合说明"></a>1-5类LSA组合说明</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-08-31_15-14-43-1602248783083.jpg" alt="Snipaste_2020-08-31_15-14-43" style="zoom:67%;">

<p>分别看完了1-5类LSA，是否感觉它们各自为战并没有组成一个有机的整体呢？事实上LSDB中不同类型LSA是用某些因素串联起来的，这些因素就是Link State ID以及Link ID。利用这些关键因素，LSDB掌握了计算两个节点之间最短距离的所有关键信息。接下来用上面的拓扑中的，R1是如何计算到网段192.168.8.0/24，以及到外部网段172.16.65.0/24的路径为例，具体说说各类LSA是如何在LSDB中组合使用去计算路由的。在每次计算路由发现下一跳时，R1会结合使用Link State ID和Link ID，将二者当作R1计算出下一跳并最终到达目标节点的关键因素。</p>
<h4 id="到192-168-8-0"><a href="#到192-168-8-0" class="headerlink" title="到192.168.8.0"></a>到192.168.8.0</h4><p>先看R1的LSDB中关于192.168.8.0/24的条目：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_13-25-13.jpg" alt="Snipaste_2020-09-19_13-25-13" style="zoom:67%;">

<p>从R1的LSDB中能看到，关于192.168.8.0/24的LSA为3类LSA，所以下面看这条LSA的具体内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database summary 192.168.8.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 339</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(Network)</span><br><span class="line">  Link State ID: 192.168.8.0 (summary Network Number)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000001</span><br><span class="line">  Checksum: 0xD9CC</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        MTID: 0         Metric: 21</span><br></pre></td></tr></table></figure>

<p>从这条3类LSA中可以看出，192.168.8.0这个网段由R4宣告（Advertising Router: 4.4.4.4）进本Area，cost值为21（Metric: 21），R1把4.4.4.4当作关键因素，接下来查找去往节点4.4.4.4的LSA，也就是说问题由’R1如何去往192.168.8.0/24网段’变成了’R1如何去往节点4.4.4.4’，因为这个3类LSA由R4宣告，前面说过3类LSA相当于R4告诉其他路由器，我R4到192.168.8.0/24网段的cost是21，去往该网段的数据交给我就能到达，这时R1查找去往R4的LSA，并找到了一条1类LSA能到达节点4.4.4.4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router 4.4.4.4</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 626</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 4.4.4.4</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000006</span><br><span class="line">  Checksum: 0x204C</span><br><span class="line">  Length: 48</span><br><span class="line">  Area Border Router</span><br><span class="line">  Number of Links: 2</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 192.168.4.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: a Transit Network</span><br><span class="line">     (Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">     (Link Data) Router Interface address: 134.1.1.4</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，R1去往R4有两条链路（link），一条是链路类型为Stub network的192.168.4.0，另一条是链路类型为Transit Network的134.1.1.4。前面我们说过，Stub network无法承载穿越流量，所以不能用这条link到达R4；后面的Transit network能够承载穿越流量，这条link是到达134.1.1.4这个虚拟网络节点的，R1用134.1.1.4作为关键因素，问题由’R1如何去往192.168.8.0/24网段’，发展成’R1如何去往节点4.4.4.4’，再发展成’R1如何去往虚拟节点134.1.1.4’，因为要去往节点4.4.4.4，必须先到达虚拟节点134.1.1.4。R1此时去LSDB中查找关于134.1.1.4的LSA，可以看到是一条2类LSA，来看看具体这条2类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database network 134.1.1.4</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Net Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 446</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Network Links</span><br><span class="line">  Link State ID: 134.1.1.4 (address of Designated Router)</span><br><span class="line">  Advertising Router: 4.4.4.4</span><br><span class="line">  LS Seq Number: 80000003</span><br><span class="line">  Checksum: 0x98DE</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Attached Router: 4.4.4.4</span><br><span class="line">        Attached Router: 1.1.1.1</span><br><span class="line">        Attached Router: 3.3.3.3</span><br></pre></td></tr></table></figure>

<p>R1发现134.1.1.4这个虚拟节点有通往节点1.1.1.1的链路，也就是有通往R1的链路。所以上面’R1如何去往虚拟节点134.1.1.4’的问题有了部分答案，也就是R1可以去往虚拟节点134.1.1.4，至于如何去，还要继续看LSDB，所以R1要查看自己的哪条链路能够到达虚拟节点：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router self-originate</span><br><span class="line">OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line">Router Link States (Area 0)</span><br><span class="line">LS age: 1079</span><br><span class="line">Options: (No TOS-capability, DC)</span><br><span class="line">LS Type: Router Links</span><br><span class="line">Link State ID: 1.1.1.1</span><br><span class="line">Advertising Router: 1.1.1.1</span><br><span class="line">LS Seq Number: 80000005</span><br><span class="line">Checksum: 0x290C</span><br><span class="line">Length: 72</span><br><span class="line">Number of Links: 4</span><br><span class="line">— omitted —</span><br><span class="line">Link connected to: a Transit Network</span><br><span class="line">(Link ID) Designated Router address: 134.1.1.4</span><br><span class="line">(Link Data) Router Interface address: 134.1.1.1</span><br><span class="line">Number of MTID metrics: 0</span><br><span class="line">TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>从上面的1类LSA中能看出，R1可以去往虚拟节点134.1.1.4，因为它有一条和虚拟节点相连接的Transit network，只要将数据从R1的134.1.1.1接口发出就能到达虚拟节点134.1.1.4。所以问题由’R1如何去往192.168.8.0/24网段’，发展成’R1如何去往节点4.4.4.4’，再发展成’R1是否能去往并如何去往虚拟节点134.1.1.4’，答案是R1能去往虚拟节点134.1.1.4，因为R1的1类LSA中有一条Transit network能到达虚拟节点134.1.1.4，只要将数据从R1的IP地址为134.1.1.1的E0/0接口发出即可。所以R1将R4接口地址134.1.1.4作为下一跳，加上cost值21，写入RIB表中，得到了以下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | include 192.168.8.0</span><br><span class="line">O IA  192.168.8.0/24 [110/31] via 134.1.1.4, 01:43:25, Ethernet0/0</span><br></pre></td></tr></table></figure>

<p>当然R1也会计算经由R3去往虚拟节点134.1.1.4的路径，但该路径的cost值为31，大于经由R4前往虚拟节点的cost值。具体怎么得到的31想彻底搞懂的麻烦自行翻译：</p>
<blockquote>
<p><em>NOTE: R1 will also calculate R3’s path to reach the pseudo-node, but the cost value would be 31 vs the 21 of going directly to R4. This is because R1 would forward to R3, which would forward to R4. R4’s cost to the pseudo-node is not used in R1’s calculation, because it is the incoming interface and not the outgoing interface for the traffic. This leads to the cost of 21 instead of 31. In R3’s case, R3’s interface would be used to both receive R1’s packet and forward the packet to R4, which is why it is added in the total cost of the path.</em></p>
</blockquote>
<h4 id="到172-16-65-0"><a href="#到172-16-65-0" class="headerlink" title="到172.16.65.0"></a>到172.16.65.0</h4><p>为了将数据发送到外部网段172.16.65.0/24，R1开始在LSDB中查找相关条目：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_15-12-38.jpg" alt="Snipaste_2020-09-19_15-12-38" style="zoom:80%;">

<p>R1发现一条5类LSA有到达该网段的信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database external 172.16.65.0</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Type-5 AS External Link States</span><br><span class="line"></span><br><span class="line">  LS age: 709</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: AS External Link</span><br><span class="line">  Link State ID: 172.16.65.0 (External Network Number )</span><br><span class="line">  Advertising Router: 6.6.6.6</span><br><span class="line">  LS Seq Number: 80000004</span><br><span class="line">  Checksum: 0xD9AD</span><br><span class="line">  Length: 36</span><br><span class="line">  Network Mask: /24</span><br><span class="line">        Metric Type: 2 (Larger than any link state path)</span><br><span class="line">        MTID: 0</span><br><span class="line">        Metric: 20</span><br><span class="line">        Forward Address: 0.0.0.0</span><br><span class="line">        External Route Tag: 0</span><br></pre></td></tr></table></figure>

<p>从上面的5类LSA中可以看出，由于Metric字段值为20，Forward Address字段的值为0.0.0.0（当该字段为0.0.0.0时，数据将被发送到这条LSA的起源路由器，ASBR路由器，在这里就是R6）且Advertising Router字段的值为6.6.6.6，说明要将数据发送给外部网段172.16.65.0/24，只需要将数据发送到R6，R6到达外部网段的cost为20。这时问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给R6’，因为R6宣告的5类LSA中的Forward Address字段的值为0.0.0.0，说明发送给外部网段的数据发送到R6即可，从R6可以到达外部网段，cost值为20。由于R1和R6处于不同Area，R1就需要以自己为根构建一个到R6的SPT（shortest path tree，最短路径树），大概意思就是要找到一条去往R6的最短且无环路的路径。这时R1会用LSA中的Advertising Router字段的6.6.6.6为关键因素，去查找如何去往节点6.6.6.6，上面说过，由于和ASBR不在同一个Area的其他路由器不知道如何前往ASBR，所以会用4类LSA告诉其他区域的路由器，如何去往ASBR，这里来看4类LSA是如何宣告RID为6.6.6.6的ASBR的位置的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database asbr-summary</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Summary ASB Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 751</span><br><span class="line">  Options: (No TOS-capability, DC, Upward)</span><br><span class="line">  LS Type: Summary Links(AS Boundary Router)</span><br><span class="line">  Link State ID: 6.6.6.6 (AS Boundary Router address)</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000006</span><br><span class="line">  Checksum: 0xE81A</span><br><span class="line">  Length: 28</span><br><span class="line">  Network Mask: /0</span><br><span class="line">        MTID: 0         Metric: 20</span><br></pre></td></tr></table></figure>

<p>通过4类LSA中的Advertising Router: 2.2.2.2和Metric: 20部分，R1知道节点2.2.2.2可以到达节点6.6.6.6，cost值为20，节点2.2.2.2可以到达节点6.6.6.6，也就是到达ASBR。所以问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，继续发展为’R1如何将数据发送给节点2.2.2.2，R2’，因为数据要达到6.6.6.6先要发送给2.2.2.2才行。这里R1用2.2.2.2作为关键因素查找去往节点2.2.2.2的路径，R1中有一条2.2.2.2的1类LSA：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router 2.2.2.2</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1123</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 2.2.2.2</span><br><span class="line">  Advertising Router: 2.2.2.2</span><br><span class="line">  LS Seq Number: 80000008</span><br><span class="line">  Checksum: 0x1743</span><br><span class="line">  Length: 60</span><br><span class="line">  Area Border Router</span><br><span class="line">  Number of Links: 3</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 192.168.2.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 1</span><br><span class="line"></span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 1.1.1.1</span><br><span class="line">     (Link Data) Router Interface address: 12.1.1.2</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>这条1类LSA中的Stub Network无法承载穿越流量，所以无法使用，它还有另一条通往节点1.1.1.1的P2P链路，这条链路说明R1和节点2.2.2.2是相连接的，相互连接自然在一个Area中，所以这时R1以自己的RID为关键因素，查看1类LSA。问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，再发展为’R1如何将数据发送给节点2.2.2.2，R2’，因为R1和2.2.2.2相连，继续发展成’R1如何连接到节点2.2.2.2’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip ospf database router self-originate</span><br><span class="line"></span><br><span class="line">            OSPF Router with ID (1.1.1.1) (Process ID 1)</span><br><span class="line"></span><br><span class="line">                Router Link States (Area 0)</span><br><span class="line"></span><br><span class="line">  LS age: 1867</span><br><span class="line">  Options: (No TOS-capability, DC)</span><br><span class="line">  LS Type: Router Links</span><br><span class="line">  Link State ID: 1.1.1.1</span><br><span class="line">  Advertising Router: 1.1.1.1</span><br><span class="line">  LS Seq Number: 8000000B</span><br><span class="line">  Checksum: 0xC866</span><br><span class="line">  Length: 72</span><br><span class="line">  Number of Links: 4</span><br><span class="line"></span><br><span class="line">    Link connected to: another Router (point-to-point)</span><br><span class="line">     (Link ID) Neighboring Router ID: 2.2.2.2</span><br><span class="line">     (Link Data) Router Interface address: 12.1.1.1</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br><span class="line"></span><br><span class="line">    Link connected to: a Stub Network</span><br><span class="line">     (Link ID) Network/subnet number: 12.1.1.0</span><br><span class="line">     (Link Data) Network Mask: 255.255.255.0</span><br><span class="line">      Number of MTID metrics: 0</span><br><span class="line">       TOS 0 Metrics: 10</span><br></pre></td></tr></table></figure>

<p>R1查看自己的1类LSA后发现自己IP地址为12.1.1.1的E0/1接口，有一条P2P链路和节点2.2.2.2相连，cost值为10，所以问题由’R1如何将数据发送到外部网段172.16.65.0/24’，发展成’R1如何将数据发送给节点6.6.6.6，R6’，再发展为’R1如何将数据发送给节点2.2.2.2，R2’，这个问题解决了，也就是把数据从12.1.1.1的P2P接口发送出即可，下一跳设置成为对端的12.1.1.2，也就是R2和R1相连的的E0/1口即可。但要注意，R1不会为外部网段增加cost，因为这里的外部路由类型为E2，cost值恒为20：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip route ospf | include 172.16.65.0</span><br><span class="line">O E2     172.16.65.0 [110/20] via 12.1.1.2, 03:34:32, Ethernet0/1</span><br></pre></td></tr></table></figure>

<p>本例引用自<a href="https://packetpushers.net/ospf-graphs-lsas-and-the-lsdb/">这篇文章</a>，这个例子只是简单说明各类LSA的使用方式，在实际中，R1使用一种更彻底的方法来构建其SPT，这里就不继续写了，因为我还不会，等会了也许会继续更新本章。</p>
<h3 id="Type3、Type4报文格式"><a href="#Type3、Type4报文格式" class="headerlink" title="Type3、Type4报文格式"></a>Type3、Type4报文格式</h3><p>由于3类LSA和4类LSA的格式几乎一样，所以RFC上将二者合并起来写的，笔记这里也用这种方式介绍这两种LSA的报文格式。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-09_15-18-15.jpg" alt="Snipaste_2020-09-09_15-18-15" style="zoom:50%;">

<ul>
<li>Network Mask：在3类LSA里，这个字段表示目标网络IP地址的掩码；在4类LSA里，这个字段没有实际意义必须取值为全0。</li>
<li>Metric：这条路由的cost值。和1类LSA中的接口的Cost值一个意思。</li>
</ul>
<p>为了和之前的OSPF版本规范相兼容，LSA中还可以包含TOS-specific信息，TOS字段值的不同表示不同的意思，一般情况下为全0，表示‘normal service’。</p>
<h3 id="TYPE-6"><a href="#TYPE-6" class="headerlink" title="TYPE 6"></a>TYPE 6</h3><p>6类LSA（OSPF GROUP MEMBERSHIP LSA）是OSPF中的组播，但现在已经被PIM所代替，思科设备根本就不支持6类LSA，所以这里就不继续提了。</p>
<h3 id="TYPE-7"><a href="#TYPE-7" class="headerlink" title="TYPE 7"></a>TYPE 7</h3><h4 id="概述-11"><a href="#概述-11" class="headerlink" title="概述"></a>概述</h4><p> 7类LSA又叫做not-so-stubby-area（NSSA） LSA，因为NSSA区域不让外部LSA，也就是不让5类LSA进入，所以为了将外部路由引入NSSA area，就要用7类LSA。7类LSA由NSSA ASBR生成，只在原始NSSA区域中泛洪，也就是生成这个7类LSA的NSSA区域中泛洪，不会进入其他常规区域。</p>
<h4 id="报文格式-3"><a href="#报文格式-3" class="headerlink" title="报文格式"></a>报文格式</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_17-18-11.jpg" alt="Snipaste_2020-09-19_17-18-11" style="zoom:50%;">

<h5 id="Options字段："><a href="#Options字段：" class="headerlink" title="Options字段："></a>Options字段：</h5><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-19_17-27-12.jpg" alt="Snipaste_2020-09-19_17-27-12"></p>
<h6 id="E位"><a href="#E位" class="headerlink" title="E位"></a>E位</h6><p><img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_17-20-11.jpg" alt="Snipaste_2020-09-30_17-20-11"></p>
<p>5类LSA不能泛洪到Stub区域和NSSA区域中，E比特确保Stub区域和NSSA区域中的所有路由器都同意5类LSA不能泛洪进入的区域属性。E位只在Hello包和DBD包中有意义。当某一特定接口发出的Hello包中的E位置0时，意味着这个接口不会发送也不会接收5类LSA，换句话说这个接口连接到的是Stub区域或NSSA区域。两个路由器只有在对E位匹配时，也就是E位数值相同时才能成为邻居。</p>
<ul>
<li>E位：5类LSA不能泛洪到Stub区域和NSSA区域中，E比特确保Stub区域和NSSA区域中的所有路由器都同意5类LSA不能泛洪进入的区域属性。E位只在Hello包和DBD包中有意义。当某一特定接口发出的Hello包中的E位置0时，意味着这个接口不会发送也不会接收5类LSA，换句话说这个接口连接到的是Stub区域或NSSA区域。两个路由器只有在对E位匹配时，也就是E位数值相同时才能成为邻居。</li>
</ul>
<h6 id="N-P位"><a href="#N-P位" class="headerlink" title="N/P位"></a>N/P位</h6><ul>
<li>N位：N位决定了路由器是否支持NSSA。N位只在Hello包中有作用有意义，N位确保了区域内所有路由器都同意NSSA区域的属性。当特定接口发出的Hello包中的N位置1时，表示路由器将从那个接口中接收和发送7类LSA。两个路由器只有在N位互相匹配时，也就是N位数值相同时才能成为邻居。如果一个路由器的N位置1，那么它的E位必须置0。因为N位置1意味着能接收发送7类LSA也就是该区域为NSSA area，但如果E位置1意味着能接收发送5类LSA，二者相互冲突，而NSSA area中不能存在5类LSA。</li>
<li>P位：P位只在7类LSA的Header中使用。置1时标识NSSA的边界路由器可以将7类LSA转换成5类LSA。通常P位置0。</li>
</ul>
<p>N/P位其实是一个字段，在Hello包中，该位是N位，用来协商路由器是否支持NSSA区域：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-10_19-39-03.jpg" alt="Snipaste_2020-10-10_19-39-03"></p>
<p>在7类LSA的Header中，该位是P位，用来标识NSSA的边界路由器是否能将7类LSA转换成5类LSA：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-10_19-41-08.jpg" alt="Snipaste_2020-10-10_19-41-08"></p>
<h3 id="其他LSA"><a href="#其他LSA" class="headerlink" title="其他LSA"></a>其他LSA</h3><p>Type8、Type9两种LSA属于在IPV6情况下的OSPF V3版本使用，会在IPV6部分笔记中涉及；Type10、11属于MPLS-TE使用，会在MPLS中进行讨论。</p>
<h1 id="区域种类"><a href="#区域种类" class="headerlink" title="区域种类"></a><a href="https://www.packetflow.co.uk/ospf-areas-explained/">区域种类</a></h1><blockquote>
<ul>
<li><strong>Backbone area</strong> - The backbone area is the core of the OSPF network. Furthermore, OSPF states that every area must be connected to the backbone area (aka area 0).</li>
<li><strong>Standard areas</strong> - This is an area that is not “stub based”. This includes the backbone area.</li>
<li><strong>Stub area</strong> - With stub areas external routes are not propagated into the stub area by the ABR but replaced with a default route instead. This reduces the OSPF topology along with LSA overhead.</li>
<li><strong>Totally stubby area</strong> - This area is the same as a stub area with the addition that they do not receive type 3 LSA’s. The ABR injects a default route.</li>
<li><strong>Not-so-stubby area</strong> - Also known as NSSA, is an area similar to a stub area but with the addition of an ASBR.</li>
</ul>
</blockquote>
<ul>
<li><p>Backbone Area：翻译成中文是骨干区域，也被称为区域0或区域0.0.0.0，骨干区域组成了OSPF网络的核心，所有其他区域都必须和骨干区域（Area 0）相连接，要么直接连接要么经过其他路由器和骨干区域相连，比如通过虚链路和Area 0相连，这样做是因为OSPF的所有非骨干区域之间不能直接传递LSA，必须将非骨干区域的LSA信息发送给骨干区域，再由骨干区域发送到其他区域，这样做的目的是因为OSPF的各区域间的路由是距离矢量路由（对，你没看错确实是距离矢量，我看到以后也很难以置信，但它就是距离矢量路由），所以很容易出现环路，为了避免环路强制其他区域的区域间路由先发送到Area 0 再发送给其他区域。</p>
</li>
<li><p>Standard areas：翻译成中文是标准区域，也就是除了Stub area以外的其他area，上文的骨干区域（区域0）也属于标准区域，绝大多数的区域都是Standard area。标准区域中可以存在1、2、3、4、5类LSA，也可以存在ASBR路由器。</p>
</li>
<li><p>Stub area：翻译成中文是末节区域，在Stub area中，外部路由不会通过ABR路由器直接传播进Stub area，而是采用<strong>自动下发默认路由</strong>的方式代替，这条默认路由代替了所有外部路由。这样减少了路由器的LSDB的大小从而能够减少内存消耗。Stub area中不允许引入外部路由，就是4、5类LSA。</p>
</li>
<li><p>Totally stubby area：翻译成中文是完全末节区域，这个区域和之前的Stub area的性质一样，不过和Stub area的区别在于也<strong>不能有3类LSA存在</strong>，也不允许引入外部路由，综合起来就是不允许有3、4、5类LSA的存在，同时自动下发一条默认路由（以3类LSA形式，自动下发的3类LSA是允许的）。</p>
</li>
<li><p>Not-so-stubby area：翻译成中文是非完全末节区域，另一种英文叫法是NSSA区域，和之前的Stub area性质一样，不过和Stub area的区别在于域中可以有ASBR路由器，由于ASBR既运行了OSPF协议，也运行了其他路由协议，所以表示非完全末节区域中可以引入外部路由，综上所述，NSSA区域内不允许有4、5类LSA，但外部路由可以用7类LSA的形式在NSSA中泛洪，但由于7类LSA不允许进入包括骨干区域在内的常规区域，所以NSSA的ABR会负责将7类LSA转换成5类LSA，但NSSA区域不会像其他特殊区域一样自动下发默认路由，可以使用default-information-originate命令产生默认路由（7类LSA形式）。</p>
</li>
<li><p>Totally NSSA：翻译成中文是完全非末梢区域，继承了所有NSSA区域特性（不允许4、5类LSA，外部路由用7类LSA在NSSA内泛洪，外部路由进入常规区域需要7转5）的同时，区别在于Totally NSSA区域也会将3类LSA过滤并会自动下发一条默认路由（3类LSA形式）。</p>
</li>
</ul>
<h2 id="常规区域"><a href="#常规区域" class="headerlink" title="常规区域"></a>常规区域</h2><blockquote>
<ul>
<li><strong>Backbone area</strong> - The backbone area is the core of the OSPF network. Furthermore, OSPF states that every area must be connected to the backbone area (aka area 0).</li>
<li><strong>Standard areas</strong> - This is an area that is not “stub based”. This includes the backbone area.</li>
</ul>
</blockquote>
<ul>
<li>Backbone Area：翻译成中文是骨干区域，也被称为区域0或区域0.0.0.0，骨干区域组成了OSPF网络的核心，所有其他区域都必须和骨干区域（Area 0）相连接，要么直接连接要么经过其他路由器和骨干区域相连，比如通过虚链路和Area 0相连，这样做是因为OSPF的所有非骨干区域之间不能直接传递LSA，必须将非骨干区域的LSA信息发送给骨干区域，再由骨干区域发送到其他区域，这样做的目的是因为OSPF的各区域间的路由是距离矢量路由（对，你没看错确实是距离矢量，我看到以后也很难以置信，但它就是距离矢量路由），所以很容易出现环路，为了避免环路强制其他区域的区域间路由先发送到Area 0 再发送给其他区域。</li>
<li>Standard areas：翻译成中文是标准区域，也就是除了Stub area以外的其他area，上文的骨干区域（区域0）也属于标准区域，绝大多数的区域都是Standard area。标准区域中可以存在1、2、3、4、5类LSA，也可以存在ASBR路由器。</li>
</ul>
<h2 id="特殊区域"><a href="#特殊区域" class="headerlink" title="特殊区域"></a>特殊区域</h2><h3 id="为什么需要特殊区域"><a href="#为什么需要特殊区域" class="headerlink" title="为什么需要特殊区域"></a><a href="http://ccietea.com/">为什么需要特殊区域</a></h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_11-07-03.jpg" alt="Snipaste_2020-09-23_11-07-03" style="zoom:67%;">

<p>OSPF网络共有三个区域，骨干区域area 0为银行的一级行及二级行设备运行的区域三级行运行的是OSPF的常规区域，为了保证网络的通畅，我们将网络的各个角落都宣告进了OSPF，感觉上很爽，但其实路由器运行的压力很大，因为随着设备使用年限的增加，设备数量的增多，网络前缀越来越多，路由条目势必逐渐增多，那么路由器的压力也会越来越大，毕竟庞大的路由表、LSA以及SPF算法的运行都在极大的消耗着路由器的资源。</p>
<p>从网络优化的角度来看，我们一直在输途保证网络通畅的情况下减少网络中传递的路由条目以及LSA的数量，路由汇总是一种很好的方法，当然，从OSPF的设计规划角度来看，我们还有特殊区域可供使用，下面来看看OSPF的特殊区域是如何帮助我们减少LSA泛洪的。</p>
<p>我们拿area 1做参考区域，当area1为常规区域时，区域中有多少种LSA在泛洪呢？1类LSA肯定有，由于区域中存在MA网络，所以2类LSA也有。其他区域的前缀被ABR注入了本区域，所以3类LSA也有。此外由于area2中的ASBR引入的外部路由，10.1.1.0/24，所以5类LSA也会被泛洪进area1，由于area1的路由器不知道area2中的ASBR路由器的位置，所以4类LSA也在area1中存在。综上所述，area1中有1-5共计种LSA存在。但仔细一想就会发现，area1作为“叶”区域，没必要知道外部路由的详细情况，我只需要知道有这么一条路让我到达区域外即可，此时就需要特殊区域来解决这个问题，例如特殊区域种的stub area就能满足这种需求。</p>
<p>所以综上所述，特殊区域是为了应对多区域时网络设备性能不够的产物，现在设备的性能已经不能和开发OSPF协议的80年代同日而语，所以特殊区域在现网中已经很难见到了。</p>
<h3 id="概述-12"><a href="#概述-12" class="headerlink" title="概述"></a>概述</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_10-38-00.jpg" alt="Snipaste_2020-09-23_10-38-00" style="zoom: 50%;">

<p>OSPF中的特殊区域可以在一个区域中注入默认路由来取代3类或5类LSA，这样做的好处是可以将LSA的泛洪限制在最小的范围内、最小化LSDB、减少SPF算法运算并使路由表变得更小。这些特殊区域一共有四种，分别是：</p>
<ul>
<li>Stub area：Stub Area的ABR上会过滤4、5类LSA，同时用3类LSA的形式向内部传递一条默认路由；配置命令：area x stub；</li>
<li>Totally stub area：ABR上会过滤3、4、5类LSA，同时用3类LSA的形式向内部传递一条默认路由，但不允许引入外部路由；配置命令，ABR：area x stub no-summary；其他路由器：area x stub；</li>
<li>NSSA (not so stubby area)：ABR上会过滤4、5类LSA，默认不会向内部传递默认路由，使用default-information-originate命令产生默认路由（7类LSA的形式），但允许引入外部路由。当NSSA中有两个ABR时需要执行7转5时，只有一个会进行转换，router-id大的转换，所有的stub区域的ABR总是会过滤掉5类LSA；配置命令：area x nssa；</li>
<li>Totally NSSA (totally not so stubby area)：思科私有协议，ABR上会过滤3、4、5类LSA，同时向内部传递一条默认路由（3类LSA），允许引入外部路由。当NSSA中有两个ABR需要执行7转5时，只有一个会转换，也就是router-id大的转换，所有的stub area总是会过滤掉5类LSA；配置命令：ABR：area x nssa no-summary；其他路由器：area x nssa；</li>
</ul>
<h3 id="Stub-area"><a href="#Stub-area" class="headerlink" title="Stub area"></a>Stub area</h3><h4 id="概述-13"><a href="#概述-13" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_11-46-25.jpg" alt="Snipaste_2020-09-23_11-46-25" style="zoom:67%;">

<p>我们可以通过配置，将一个常规区域设置为stub区域。Stub区域将禁止4、5类LSA进入该区域（也就是不让10.1.1.0/24这条外部路由进入），同时该区域会自动下发一条默认路由（3类LSA）进入该区域，以保证数据去往外部路由的路径没有问题。这可以形象的理解为“外面的世界再怎么精彩，你不用告诉我细节，只需要告诉我怎么出去就行了”。这就是stub area的设计思路，当引入大量外部路由进入OSPF时，适当规划某些区域为stub，可以起到不错的网络优化作用。</p>
<p>有一点值得注意，不能将骨干区域area 0配置为stub区域，同时，让一个区域为stub的话，该区域不允许注入外部路由，也就是不能做重发布。</p>
<h4 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1 </span><br><span class="line">area 1 stub </span><br></pre></td></tr></table></figure>

<p>此命令需配置在stub区域中的所有路由器上，如果某台路由器没有配置该命令，那么它无法和其他stub area 中的路由器建立邻接关系。</p>
<h4 id="实现效果"><a href="#实现效果" class="headerlink" title="实现效果"></a>实现效果</h4><p>Area 1中将不会有4、5类LSA，也就是Area 2重发布进来的关于网段10.1.1.0/24的路由被ABR过滤掉了，同时Area 1中的路由器将获得一条3类LSA的默认路由，该默认路由是由area 1的ABR自动下发。</p>
<h3 id="Totally-Stub-area"><a href="#Totally-Stub-area" class="headerlink" title="Totally Stub area"></a>Totally Stub area</h3><h4 id="概述-14"><a href="#概述-14" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_15-51-20.jpg" alt="Snipaste_2020-09-23_15-51-20" style="zoom:67%;">

<p>通过将区域规划成Stub area，可以起到一定的网络优化作用，但感觉上还是不够彻底，因为Stub area只是不知道外部路由，但除了外部路由，其他区域的路由（约等于其他区域的LSA）其实我也没必要知道太多细节，用一条默认路由代替去往其他area的路由也没问题，那么这里就可以将area 1设置为完全末梢区域，也就是totally stub area，当一个区域被配置为完全末梢区域时，这个区域将：</p>
<ul>
<li>阻挡3、4、5类LSA进入本区域；</li>
<li>区域的ABR自动下发一条3类LSA的默认路由进入本区域；</li>
</ul>
<p>这么一来，area 1区域内的路由器收到的LSA数量进一步减小，LSDB进一步变小，在存储LSA及运行SPF算法的时候消耗的资源自然也就减少了，另外当区域外拓扑出现变更的时候，对本区域的影响也将变为最小，因为内部没有其他区域的LSA了。</p>
<p>与Stub area区域类似，无法将骨干区域area 0配置成totally stub area，当然如果一个区域被指定为totally stub area，将不能在区域中的路由器上做路由重发布动作。</p>
<h4 id="配置命令-1"><a href="#配置命令-1" class="headerlink" title="配置命令"></a>配置命令</h4><p>ASBR配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1 </span><br><span class="line">area 1 stub no-summary </span><br></pre></td></tr></table></figure>

<p>其他路由器配置命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub</span><br></pre></td></tr></table></figure>

<h4 id="实现效果-1"><a href="#实现效果-1" class="headerlink" title="实现效果"></a>实现效果</h4><p>完成上述配置后，area 1内的路由器将只有本区域的路由（ABR除外），同时能获取到ABR下发的3类默认路由，也就是说其他区域的路由以及外部注入的路由都被ABR挡在外面，取而代之的是一条默认路由。</p>
<h3 id="NSSA"><a href="#NSSA" class="headerlink" title="NSSA"></a>NSSA</h3><h4 id="概述-15"><a href="#概述-15" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_17-14-16.jpg" alt="Snipaste_2020-09-23_17-14-16" style="zoom:67%;">

<p>在前面的知识基础上，我们已经了解到，在保证网络连通性的情况下，减少LSA的泛洪以及精简路由表，我们可以将特定区域配置为末梢区域（Stub area）或完全末梢区域（totally stub area），上面的拓扑中，如果我们将area 2配置为stub area，那么该area一方面会阻挡4、5类LSA的进入，另一方面会同时禁止重发布外部路由看，那么如果此时我们期望这个区域保持“阻挡其他区域过来的4、5类LSA”这个特性，同时允许在本area 内重发布路由，该怎么办呢？</p>
<p>例如，假设area 2原来时作为一个stub area运行的，但突然有一个外部网络，需要接入到我们这个OSPF网络中，并且连在area 2中，这种情况下为了保证路由可达，就必须向area 2中注入外部路由了，但注入路由违反了stub area的规则，stub area禁止4、5类LSA进入，外部路由的LSA为5类，无法注入。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-23_17-32-23.jpg" alt="Snipaste_2020-09-23_17-32-23" style="zoom:67%;">

<p>如何解决呢？引入NSSA（not-so-stubby-area）的概念，中文翻译就是“非完全末梢区域”，当一个区域配置为NSSA时，这个区域一方面将阻挡其他区域传来的4、5类LSA，同时“允许区域本地注入”外部路由，这些外部路由以一种特殊的LSA类型—7类LSA在NSSA中泛洪，并且7类LSA不允许进入骨干区域或常规区域，NSSA的ABR会负责将7类LSA“转换”成5类LSA，从而在常规区域中进一步泛洪。上面的“允许区域本地注入”的意思是，NSSA这个区域的路由器配置重新发布。</p>
<p>必须注意的是，与Stub area及totally stub area不同的是，如果你将一个区域配置为NSSA，默认情况下，NSSA的ABR不会自动下发默认路由进NSSA，因此在NSSA环境下，需要留意网络连通信问题。</p>
<h4 id="配置命令-2"><a href="#配置命令-2" class="headerlink" title="配置命令"></a>配置命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<p>上述命令需配置在NSSA内的所有路由器上。</p>
<h4 id="实现效果-2"><a href="#实现效果-2" class="headerlink" title="实现效果"></a>实现效果</h4><p>将area 2配置为NSSA区域后，从骨干过来的4、5类LSA将无法进入NSSA，也就是说，如果area 1做了重发布，那么这些重发布的外部路由无法进入NSSA区域（NSSA中不许出现5类LSA），与此同时，area 2允许本地的路由器做重发布动作，重发布进来的路由，以7类LSA在NSSA中泛洪，在路由表中可以看到这些外部路由的标记为“O N”，这些7类LSA在“穿越”NSSA的ABR进入骨干区域之前，由ABR负责将7类LSA“转换”成5类LSA，最终area 0和area 1也能学到这些外部路由，不过它们路由表中呈现的是“O E”标记。</p>
<h4 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h4><p><strong>NSSA ABR上的路由汇总动作</strong></p>
<p>NSSA 的ABR会将7类LSA转换为5类LSA，在7转5的过程中可以使用summary-address 通告汇总的5类LSA，注意，这里汇总的是针对NSSA区域外部引入路由的汇总，但如果仍想对area 1 nssa 区域自己内部的路由做汇总，则应使用area  range命令。</p>
<p><strong>NSSA的ABR，在某种程度上可以理解成为常规区域的ASBR，它不会为常规区域生成4类LSA。</strong></p>
<p>NSSA的ABR产生了5类LSA（通过7转5）并通告进骨干区域，因此这台NSSA的ABR对于骨干区域而言就是一台ASBR，由于存在这个7转5的过程，真正的ASBR（NSSA区域中执行重发布的那台路由器）信息就不需要被骨干区域路由器知道，因此NSSA区域的ABR也不会为这个区域里的ASBR产生4类LSA并通告进骨干区域。</p>
<p><strong>NSSA的双ABR问题</strong></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-44-34.jpg" alt="Snipaste_2020-09-30_16-44-34" style="zoom:67%;">

<p>上图中，两个ABR都会收到7类LSA，但只有Router ID大的ABR才会执行7转5动作，两台ABR都会在NSSA区域泛洪1类LSA，并从中了解到对方的存在。</p>
<p><strong>N/P位</strong></p>
<p>N/P位为1bit，在HELLO和LSA中都携带option字段，N/P位在两者中分别有不同的意义。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-51-32.jpg" alt="Snipaste_2020-09-30_16-51-32" style="zoom:67%;">

<ul>
<li>在Hello报文中：N bit标识该路由器位NSSA区域路由器，当N  bit被置1时，E  bit就必须被清零。</li>
<li>在LSA报文中：P bit 仅在7类LSA中出现，置1时标识NSSA区域的ABR能够将这条7类LSA转成5类LSA，而P位置0时不能进行7到5的LSA转换。</li>
</ul>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_16-53-50.jpg" alt="Snipaste_2020-09-30_16-53-50" style="zoom:67%;">

<ul>
<li>P bit 为0时，ABR将不能将该7类LSA转换成5类LSA，只有NSSA区域的ABR重发布路由时，通告的7类LSA中的P bit才为0。NSSA区域在ABR重发布时，将7类LSA的P bit 置0，通知其他NSSA区域的ABR不要对该LSA进行7转5，因为骨干区域内的其他路由器已经从骨干区域内收到该路由的5类LSA，因此NSSA区域其他ABR执行7转5是没意义的。</li>
</ul>
<p><strong>P bit为0，ABR将不能将该7类LSA转换成5类LSA：</strong></p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-30_17-14-12.jpg" alt="Snipaste_2020-09-30_17-14-12" style="zoom: 67%;">

<p>NSSA区域的ABR在重发布时，将7类LSA的P位置0，用来通知NSSA区域内的其他ABR不要对该LSA进行7转5，因为骨干区域内的其他路由器已经从骨干区域内收到该路由器的5类LSA，因此NSSA区域内其他ABR执行7转5是没有意义的。</p>
<h3 id="Totally-NSSA"><a href="#Totally-NSSA" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h3><h4 id="概述-16"><a href="#概述-16" class="headerlink" title="概述"></a>概述</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_10-28-51.jpg" alt="Snipaste_2020-09-26_10-28-51" style="zoom:67%;">

<p>Totally NSSA，翻译成中文是一个非常尴尬的名字，完全非末梢区域，Totally NSSA是在NSSA区域的基础上，进一步阻挡NSSA区域外的其他区域过来的3类LSA，同时ABR自动下发一条3类LSA的默认路由进入NSSA区域。</p>
<h4 id="配置命令-3"><a href="#配置命令-3" class="headerlink" title="配置命令"></a>配置命令</h4><p>ABR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa no-summary</span><br></pre></td></tr></table></figure>

<p>其他路由器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<h4 id="实现效果-3"><a href="#实现效果-3" class="headerlink" title="实现效果"></a>实现效果</h4><p>Area 2之外的其他OSPF area 过来的3、4、5类LSA，都会被ABR阻挡在NSSA区域外，同时ABR会自动下发默认路由进NSSA，这条自动下发的默认路由是3类LSA。另外，NSSA区域内的路由器做重发布动作，由于NSSA区域不让传播外部路由的4、5类LSA，所以区域内的其他路由器会学习到7类的外部LSA，这些外部LSA会被ABR转换成5类LSA并注入骨干区域。</p>
<h3 id="区域LSA总结"><a href="#区域LSA总结" class="headerlink" title="区域LSA总结"></a>区域LSA总结</h3><p><img src="/2020/06/18/13-ospf/655555.png" alt="655555"></p>
<ul>
<li>骨干区域：1、2、3、4、5；</li>
<li>标准区域：1、2、3、4、5；</li>
<li>Stub区域：1、2、3以及3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）；</li>
<li>完全Stub区域（totally stub area）：1、2、3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）；</li>
<li>NSSA：1、2、3、7；</li>
<li>Totally NSSA：1、2、7、3类0.0.0.0/0（ABR向区域内发起的一条3类缺省路由LSA）。</li>
</ul>
<h3 id="特殊区域实验"><a href="#特殊区域实验" class="headerlink" title="特殊区域实验"></a>特殊区域实验</h3><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_11-27-38.jpg" alt="Snipaste_2020-09-26_11-27-38" style="zoom:67%;">

<h4 id="无特殊区域"><a href="#无特殊区域" class="headerlink" title="无特殊区域"></a>无特殊区域</h4><h5 id="基础配置及结果："><a href="#基础配置及结果：" class="headerlink" title="基础配置及结果："></a>基础配置及结果：</h5><p>CO1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line"> !</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-00-19.jpg" alt="Snipaste_2020-09-26_12-00-19" style="zoom:67%;">

<p>CO2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.26.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.26.2 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-01-25.jpg" alt="Snipaste_2020-09-26_12-01-25" style="zoom:67%;">

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.35.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 192.168.13.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.35.3 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-02-27.jpg" alt="Snipaste_2020-09-26_12-02-27" style="zoom:67%;">

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 192.168.35.4 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-03-05.jpg" alt="Snipaste_2020-09-26_12-03-05" style="zoom:67%;">

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 192.168.35.5 0.0.0.0 area 1</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-03-39.jpg" alt="Snipaste_2020-09-26_12-03-39" style="zoom:67%;">

<p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.26.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.67.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.68.6 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 6.6.6.6</span><br><span class="line"> network 192.168.26.6 0.0.0.0 area 0</span><br><span class="line"> network 192.168.67.6 0.0.0.0 area 2</span><br><span class="line"> network 192.168.68.6 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-04-17.jpg" alt="Snipaste_2020-09-26_12-04-17" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-04-43.jpg" alt="Snipaste_2020-09-26_12-04-43" style="zoom:67%;">

<p>R7：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback1                       #loopback1 接口用作引入外部路由</span><br><span class="line"> ip address 10.1.1.7 255.255.255.0</span><br><span class="line"> ip ospf network point-to-point           #网络类型配置成P2P使该路由为24/</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.67.7 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 7.7.7.7</span><br><span class="line"> redistribute connected subnets</span><br><span class="line"> network 192.168.67.7 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-05-29.jpg" alt="Snipaste_2020-09-26_12-05-29" style="zoom:67%;">

<p>R8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.68.8 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 8.8.8.8</span><br><span class="line"> network 192.168.68.8 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-06-04.jpg" alt="Snipaste_2020-09-26_12-06-04" style="zoom:67%;">



<p>此时Area1中有哪几类LSA呢？之前分析过1-5类LSA都有，实际情况是不是这样呢？</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_11-58-21.jpg" alt="Snipaste_2020-09-26_11-58-21" style="zoom: 67%;">

<p>从输出结果可知，确实有5种LSA，但对于一个“叶”area来说，知道这么多种LSA，其实意义不大，这时我们引入Stub area，看结果如何。</p>
<h4 id="Stub-area-1"><a href="#Stub-area-1" class="headerlink" title="Stub area"></a>Stub area</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-11-14.jpg" alt="Snipaste_2020-09-26_12-11-14" style="zoom:50%;">

<p>此时我们将Area 1配置成Stub area，理论上应该由身为ABR的R3下发一条3类LSA的默认路由，然后Area 1阻止4、5类LSA进入，现在来看是不是这样。</p>
<h5 id="变更的配置"><a href="#变更的配置" class="headerlink" title="变更的配置"></a>变更的配置</h5><p>在R3、R4和R5下加入配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB"><a href="#LSDB及RIB" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-17-46.jpg" alt="Snipaste_2020-09-26_12-17-46" style="zoom:67%;">

<p>从上面的输出结果中可以看到LSDB相比配置之前进行了一定程度的精剪，R4和R5中原本存在的4、5类LSA已经被ABR阻隔了，由身为ABR的R3下发了一条默认路由，这条默认路由是以3类LSA的形式自动下发的，因为并没有进行任何关于默认路由的配置：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-21-02.jpg" alt="Snipaste_2020-09-26_12-21-02" style="zoom: 80%;">

<h4 id="Totally-Stub-area-1"><a href="#Totally-Stub-area-1" class="headerlink" title="Totally Stub area"></a>Totally Stub area</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_12-47-18.jpg" alt="Snipaste_2020-09-26_12-47-18" style="zoom:50%;">

<p>现在将Area 1配置成Totally Stub area，理论上应阻止3、4、5类LSA进入Area 1并下发3类LSA构成的默认路由。</p>
<h5 id="变更配置"><a href="#变更配置" class="headerlink" title="变更配置"></a>变更配置</h5><p>R3:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 1 stub no-summary</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-1"><a href="#LSDB及RIB-1" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-03-47.jpg" alt="Snipaste_2020-09-26_13-03-47" style="zoom:80%;">

<p>从上面的输出可以看出，LSDB比之前有了大幅精剪，除了由ABR，R3<strong>自动下发</strong>的一条3类LSA的默认路由以外，其他3、4、5类LSA都被阻隔在了外面，所以路由表中自然没有了其他区域的网络号，这些均由一条默认路由代替。</p>
<h4 id="NSSA-1"><a href="#NSSA-1" class="headerlink" title="NSSA"></a>NSSA</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-19-54.jpg" alt="Snipaste_2020-09-26_13-19-54" style="zoom:50%;">

<h5 id="变更的配置-1"><a href="#变更的配置-1" class="headerlink" title="变更的配置"></a>变更的配置</h5><p>R6、R7、R8：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-2"><a href="#LSDB及RIB-2" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-23-42.jpg" alt="Snipaste_2020-09-26_13-23-42" style="zoom:80%;">

<p>从上面的输出可以看出，外部路由10.1.1.0/24由7类LSA引入NSSA区域的，而不是本来的4、5类LSA，因为NSSA阻止了4、5类LSA的传播。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-36-45.jpg" alt="Snipaste_2020-09-26_13-36-45" style="zoom:67%;">

<p>由于7类LSA不允许传入常规区域，所以由作为ABR的R6进行了转换，由7类LSA转换成5类LSA，然后传入骨干区域Area 0。</p>
<p>必须注意的是，默认情况下NSSA的ABR是<strong>不会</strong>自动下发默认路由到NSSA区域的，需要进行如下配置才能下发默认路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> Area 2 nssa default-information-originate</span><br></pre></td></tr></table></figure>

<p>具体见：</p>
<blockquote>
<p>This configuration generates a type 7 default route. You can configure this command on any NSSA ASBR or NSSA ABR with these rules:</p>
<ul>
<li>NSSA ASBR can generate a default only when it has a default route in its routing table.</li>
<li>The default route must be known through non-OSPF protocol</li>
<li>NSSA ABR can generate a default route with or without a default route in its own routing table.</li>
</ul>
<p>This command is used in order to generate an NSSA default route:</p>
<blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> Area 1 nssa default-information-originate</span><br></pre></td></tr></table></figure>
</blockquote>
</blockquote>
<h4 id="Totally-NSSA-1"><a href="#Totally-NSSA-1" class="headerlink" title="Totally NSSA"></a>Totally NSSA</h4><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-46-56.jpg" alt="Snipaste_2020-09-26_13-46-56" style="zoom:50%;">

<h5 id="变更的命令"><a href="#变更的命令" class="headerlink" title="变更的命令"></a>变更的命令</h5><p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line">area 2 nssa no-summary</span><br></pre></td></tr></table></figure>

<h5 id="LSDB及RIB-3"><a href="#LSDB及RIB-3" class="headerlink" title="LSDB及RIB"></a>LSDB及RIB</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-49-22.jpg" alt="Snipaste_2020-09-26_13-49-22" style="zoom:67%;">

<p>Area 2之外的其他area的3、4、5类LSA都会被阻挡在NSSA之外，同时ABR，R6会自动下发默认路由进NSSA，默认路由以3类LSA的形式下发。LSDB相比NSSA有了进一步的缩小。NSSA引入的外部7类LSA会被ABR转换成5类LSA注入骨干区域：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_13-52-21.jpg" alt="Snipaste_2020-09-26_13-52-21" style="zoom:67%;">

<img src="/2020/06/18/13-ospf/Snipaste_2020-09-26_16-21-06.jpg" alt="Snipaste_2020-09-26_16-21-06" style="zoom:67%;">

<p>从R6的LSDB中可以看到，在R6上执行了7转5的步骤，在抓包中，标识可以进行7转5操作的是P位：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_14-25-50.jpg" alt="Snipaste_2020-10-11_14-25-50"></p>
<h1 id="邻居建立"><a href="#邻居建立" class="headerlink" title="邻居建立"></a>邻居建立</h1><h2 id="邻居状态机"><a href="#邻居状态机" class="headerlink" title="邻居状态机"></a>邻居状态机</h2><h3 id="Down"><a href="#Down" class="headerlink" title="Down"></a>Down</h3><p>初始化状态，这是OSPF邻居状态机的第一个状态，在Down状态下，意味着没从其他路由器收到OSPF的Hello包，运行OSPF协议的接口仍然有尝试发现邻居的意愿，因此会不断的发送组播Hello包。</p>
<h3 id="Attempt"><a href="#Attempt" class="headerlink" title="Attempt"></a>Attempt</h3><p>仅在NBMA网络类型上存在，如果一个路由器，它邻居处于Attempt状态，表示它从邻居没有收到任何信息，但做了努力来与邻居联系。在NBMA网络上具有DR选取资格的路由器与其邻居路由器相连的接口开始变为有效（Active）时，或当这台路由器成为DR或BDR时，这台具有DR选举资格的路由器会把邻居路由器的状态转换到Attempt状态，在Attempt状态下，路由器将在指定的hello间隔时间内向该邻居发送单播hello包。</p>
<h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><p>当OSPF接口收到链路上某个邻居发来的第一个Hello包时，它会在接口上将该邻居状态设置为init，注意这个Hello包种可能并未包含任何的邻居信息，也就是hello包中没有active neighbor这个字段，但这个Hello包至少证明，在运行了OSPF协议的这个接口的链路上，至少有个活着的邻居。当路由器收到邻居发来的Hello包以后，它应该将邻居Hello包中的Router-ID放入它自己的Hello包中的Active Neighbor字段，用来确认它收到了一个有效的Hello数据包。</p>
<p>没有active neighbor的hello包：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-06-30_17-33-46.jpg" alt="Snipaste_2020-06-30_17-33-46"></p>
<p>有active neighbor的hello包：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-06-30_17-34-52.jpg" alt="Snipaste_2020-06-30_17-34-52" style="zoom:67%;">

<h3 id="2-—-Way"><a href="#2-—-Way" class="headerlink" title="2 — Way"></a>2 — Way</h3><p>当两个路由器之间建立起了双向通信时，进入2-Way状态，双向通信意味着两个路由器都收到了对方的Hello包，而Hello包中的Active Neighbor字段中是对方的Router-ID。当OSPF路由器在某个链路上发现了邻居后，它自己发送的Hello包里就会增加一个叫“Active Neighbor”的字段，用于存储在该链路上发现的OSPF邻居。当一台OSPF Router看到自己的Router ID出现在邻居发过来的Hello包中，它就会将该邻居置为Two-Way，该状态是OSPF邻居之间可以具有的最基本的关系，也是第一个稳定状态，但此时两者还不能共享路由信息。</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-03_17-29-25.jpg" alt="Snipaste_2020-07-03_17-29-25"></p>
<p>在2-way状态下，路由器决定是否和邻居形成邻接状态。在类型为广播（MA）或非广播多路访问的情况下，路由器只和DR以及BDR形成FULL的关系，和其他的DR Other形成2-way的关系；在点对点和点对多点的网络中，路由器和所有其他链接的路由器形成FULL关系。在2-way的时候还要选举BDR和DR，<strong>注意是先选举BDR然后再选举DR，DR/BDR具体选举步骤上文写过，这里再简单写一下重点：</strong></p>
<p>当一台OSPF路由器有效（Active）并去发现它的邻居路由器时，它将去检查有效的DR和BDR路由器（如果路由器的Priority为0那么就意味着它是无效的，不能参与选举DR和BDR），如果DR和BDR路由器存在的话，这台路由器将接受已经存在的DR和BDR（为什么要接受已经存在的DR和BDR呢，是因为DR具有非抢占性的，也就是说已经有了DR了，新加入的路由器接口的Priority再低也不会重新选举DR了，如果没有非抢占性，新加入一个Priority 更大的就被选举成新的DR，所有DR Other都和这个新DR再建立邻接关系达到Full状态，太消耗系统资源，所以当一台路由器发现已经存在DR和BDR时就会接受已经存在的DR和BDR），如果BDR和DR路由器都不存在（也就是Hello包种的DR以及BDR字段都为0.0.0.0），将执行一个选举<strong>BDR</strong>的过程，选举出具有最高优先级的路由器作为BDR路由器，选举中如果存在多台路由器具有相同的优先级（Priority），那么在数值上具有最高路由器ID的路由器将被选举成<strong>BDR</strong>（如果两台运行OSPF路由器路由器的接口的Priority都是1，那么此时一台路由器的Router-ID为1.1.1.1，另一台的Router-ID为2.2.2.2，Router-ID为2.2.2.2的显然比1.1.1.1更大，这台Router-ID为2.2.2.2的路由器的接口将被选举成BDR）。<strong>如果没有有效的DR路由器存在，那么之前选举出的BDR路由器将被选举成（或者说成提升）DR路由器，然后再选举出来BDR路由器。</strong>至此BDR和DR选举完毕。</p>
<h3 id="ExStart-amp-Exchange"><a href="#ExStart-amp-Exchange" class="headerlink" title="ExStart &amp; Exchange"></a>ExStart &amp; Exchange</h3><h4 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h4><p><img src="/2020/06/18/13-ospf/Snipaste_2020-07-06_16-49-52.jpg" alt="Snipaste_2020-07-06_16-49-52"></p>
<p>在<strong>ExStart</strong>状态下，双方开始交互DBD选举Master，<strong>Router ID大的一方在选举以后会成为Master</strong>。在DBD包中有3个标记为用来管理邻居关系的建立过程：</p>
<ul>
<li>I 位，Initial bit，中文翻译成初始位，当该位置位为1时，表示这是第一个用于ExStart协商主从关系的初始化协商的DBD包。当两个路由已经选举完Master、Slave时，I位置0。</li>
<li>M位，More bit，中文翻译为后继位，当该位置位为1时，表示后续还有其他DBD报文需要交互，当该位置0时表示没有其他DBD报文需要交互，表示从ExStart到<strong>Exchange</strong>的整个LSDB目录交换过程结束。</li>
<li>MS位，Master/Slave bit，中文翻译为主/从位，当该位置位为1时，表示自己时Master，Router ID大的一方为Master，大多数情况下DR会成为Master。当两个路由器给对方发送第一个DBD报文时，双方都会将自己的MS位置位为1，然后相互比较Router ID决定主从关系。当决出主从关系时，Master的MS位不变依旧为1而Slave的MS位会置0表示自己为Slave。</li>
</ul>
<p>双方的第一、第二个DBD的I、M、MS位均置1，用来比较出谁是Master/Slave（注意不是BDR\DR），第三个包由Slave发给Master，Slave采用了Master的序列号，I位置0因为已经不是第一个初始化的DBD了，M位置1因为之后还有DBD要交互，MS位置0因为我不是Master而对方是Master。三个数据交互完确定了Master/Slave，从此只有Master可以设置并且增加序列号，而Slave不行。确定了Master/Slave关系后进入Exchange阶段，进入Exchange阶段后，Exchange以后Master发送一个DBD，Slave必须回一个DBD（主从关系确定后，Slave不能主动发送DBD只能被动回应Master的DBD），两者用这种方式交换DBD信息。如果Slave已经没有更多DBD需要交换（也就是M位置0）而Master依旧还在发送DBD，则Slave必须用DBD响应并用Master的序列号隐式确认，但由于Slave端已经发送了所有LSA目录，此时Slave的DBD包中没有LSA的相关信息包含在内了。<strong>Master/Slave关系只在DBD中存在，DBD数据包只在ExStart/Exchange过程中存在。</strong>下面看看抓包的对比，首先是Master发送的包含有LSA目录的DBD：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-13_16-44-11.jpg" alt="Snipaste_2020-07-13_16-44-11" style="zoom:67%;">

<p>接下来是Slave回应上面Master发送的DBD的消息，这个DBD用的序列号是2990，和上面Master发送的序列号相同，属于隐式确认，可以看到由于Slave的I、M、MS位都为0，说明此时它已经发送完了所有的LSA的目录，没有其他可发送了，所以抓包中并没有关于LSA的部分：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-13_16-44-35.jpg" alt="Snipaste_2020-07-13_16-44-35" style="zoom:67%;">

<p><strong>选举完Master/Slave</strong>以后，路由器会进入<strong>Exchange</strong>阶段，在该阶段中执行DBD的交换过程，并且通过交换DBD明白下一步要从邻居路由器下载哪些LSA。为什么要交换DBD呢？因为OSPF是链路状态路由协议，本Area内路由器里的LSDB要相同，这就需要邻居之间相互交换彼此没有的LSA，如何知道哪些LSA需要交换呢？先比较LSDB的目录，也就是比较DBD，DBD是链路状态数据摘要，也就是LSDB的摘要，用于描述链路状态数据库（LSDB）的内容。</p>
<p>在Exchange阶段，双方使用包含自己LSA头部的DBD报文进行交互，并且将对方发过来的LSA头部、自己感兴趣的LSA或自己没有的LSA存储在一个本地的OSPF接口的队列里，以便在下一个阶段进行LSA详细请求。当某个接口收到邻居发来的DBD中的M位置0，说明对方已经发完DBD了，与此同时，如果该路由器的这个OSPF接口上存在待请求的LSA，那么它会将这个邻居置为loading状态。在Exchange状态也有可能发送LSR去请求对方发送LSU。</p>
<h4 id="抓包说明"><a href="#抓包说明" class="headerlink" title="抓包说明"></a>抓包说明</h4><h5 id="空DBD包"><a href="#空DBD包" class="headerlink" title="空DBD包"></a>空DBD包</h5><p>空DBD包中只有LSA头部的信息，并没有整个LSA的信息：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_17-29-34.jpg" alt="Snipaste_2020-07-04_17-29-34" style="zoom:67%;">

<p>而完整的LSA中包含的信息要多得多：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-06_16-42-23.jpg" alt="Snipaste_2020-07-06_16-42-23" style="zoom:67%;">

<h5 id="初始化协商的DBD消息"><a href="#初始化协商的DBD消息" class="headerlink" title="初始化协商的DBD消息"></a>初始化协商的DBD消息</h5><p>初始化协商的DBD消息中的I、M以及MS位均为1。I位置1，因为这是第一个用于ExStart协商主从关系的初始化协商的DBD包；M位为1，因为这不是Router发送的最后一个DBD包，因为还没开始交换DBD，所以这位肯定为1；MS也为1，因为这时Master/Slave选举还没得出结论，得出结论前两个协商的路由器都会认为自己是Master，所以都会把MS位置位为1。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-09-31.jpg" alt="Snipaste_2020-07-04_19-09-31" style="zoom:67%;">

<p>我是10.0.0.1，Router ID为1.1.1.1，这是我协商主从关系的第一个DBD包（I位为1），我还有更多的DBD包要发送（M位为1），我是Master（MS位为1），我的DBD的序列号是3138。该DBD包中不包含LSA的信息。接下来我们看对方（10.0.0.3）发送的DBD初始消息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-10-48.jpg" alt="Snipaste_2020-07-04_19-10-48" style="zoom:67%;">

<p>我是10.0.0.3，Router ID为3.3.3.3，这是我协商主从关系的第一个DBD包（I位为1），我还有更多的DBD包要发送（M位为1），我是Master（MS位为1），我的DBD的序列号是2989。该DBD包中不包含LSA的信息。</p>
<p>交互完DBD包以后，Router ID大的一方也就是ID为3.3.3.3的10.0.0.3成为Master，Router ID小的10.0.0.1成为Slave。</p>
<h5 id="交互LSDB目录的过程"><a href="#交互LSDB目录的过程" class="headerlink" title="交互LSDB目录的过程"></a>交互LSDB目录的过程</h5><img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-25-33-1593861960005.jpg" alt="Snipaste_2020-07-04_19-25-33" style="zoom:67%;">

<p>第三个DBD由Slave（10.0.0.1）发给Master（10.0.0.3），序列号采用Master发送初始DBD中的序列号，I位置0因为已经不是初始化的DBD包了，也意味着此时<strong>进入了Exchange状态</strong>；M位置1表示还有后续的DBD包，不过一般实验中LSU较少所以这位为0也是正常的，因为一个DBD就交互完事儿了；MS位为0表示我是Slave。同时DBD包中也有LSA的摘要信息，但并没有LSA的具体信息，主要是交换了LSA的Router ID，表明自己有哪些路由器的信息。Master（10.0.0.3）收到这个DBD包以后，发现I位为0，于是将对方的状态改为Exchange，再查看Sequence号发现这个序号是自己这个Master产生的，于是在这个序列号的基础上+1生成新的序列号，这么做是隐式确认告诉对方之前你发的这个DBD我收到了，然后带上了自己的LSA摘要信息，发送给对方开始交互LSDB的摘要目录。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_19-28-29.jpg" alt="Snipaste_2020-07-04_19-28-29" style="zoom:67%;">

<p>第四个DBD由Master发给Slave，序列号在之前的基础上+1，也就是2990，用以隐式确认之前收到的序列号为2899的DBD。I位为0，因为已经不是初始化的DBD包了；M位为1，表示还有后续的DBD包；MS位为1，因为自身是Master。后面带上了自己的LSA摘要信息。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_20-59-33.jpg" alt="Snipaste_2020-07-04_20-59-33" style="zoom:67%;">

<p>第五个DBD由Slave（10.0.01）发送给Master（10.0.0.3），序列号和之前Master发给它的序列号相同，且M位置0，说明Slave没有需要发送给Master的其他LSDB目录了，这个DBD完全是用来确认之前Master的那个序列号为2990的DBD。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_21-03-53.jpg" alt="Snipaste_2020-07-04_21-03-53" style="zoom:67%;">

<p>第六个DBD由Master（10.0.0.3）发送给Slave（10.0.0.1），序列号为之前Slave确认DBD的序列号+1，也就是2991，这时M位置0，说明Master（MS位置1）没有更多的DBD要发送了。</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-04_21-05-19.jpg" alt="Snipaste_2020-07-04_21-05-19" style="zoom:67%;">

<p>最后一个DBD由Slave（10.0.0.1）发送给Master（10.0.0.3），序列号和刚才Master发送的序列号一致，也是个用来确认的DBD。至此两方都没有DBD信息要交换了，Exchange阶段结束。</p>
<h4 id="补充说明-1"><a href="#补充说明-1" class="headerlink" title="补充说明"></a>补充说明</h4><h5 id="为什么用空DBD包？"><a href="#为什么用空DBD包？" class="headerlink" title="为什么用空DBD包？"></a>为什么用空DBD包？</h5><p>当两个路由器决定建立完全邻接关系时（Full adjacent），二者必须同步彼此的LSDB（Link State DataBase，链路状态信息数据库），因为OSPF是一个链路状态路由协议，每台设备都要知道网络的整体信息（在OSPF中就是了解全网的LSA）所以邻居的LSDB自己也必须掌握，掌握清楚全网的信息以后，再根据自己掌握的信息计算出路由。为了优化LSDB数据库同步过程，两台路由器会先比较它们LSDB的条目列表，这样就不用交换整个LSDB数据库了，再根据LSDB条目列表比较的情况决定去交互哪些LSA，发送空DBD包就是LSDB的条目列表，空DBD是并不包含LSA头部的DBD包，既能达到比较两台设备LSDB的目的，又减小网络及系统的开销，就好像两个商店之间互相比较存货的差异，这时只要比较两个商店的存货目录清单而不用把所有货物搬出来彼此比较一样。</p>
<h5 id="如何确定对方收到DBD？"><a href="#如何确定对方收到DBD？" class="headerlink" title="如何确定对方收到DBD？"></a>如何确定对方收到DBD？</h5><p>由于链路状态路由协议要获知全网的网络信息，所以必须知道和邻居之间LSDB中的LSA差别在哪，这时候需要交换空DBD以交换彼此掌握的LSA目录，但由于OSPF协议中并没给DBD包设计专门的DBD确认（必须注意，LSAck是用来确认LSU的而不是确认DBD的），这时如何确定对方收到了DBD包呢？<strong>用DBD包中的序列号做隐式确认。</strong>当Master发送M位置1\0、MS位置1的DBD并且Sequence为X的DBD时（表示我是Master，我还有后或者没有续的DBD需要发送），Slave会发送一个<strong>序列号同为X</strong>、M位置1\0，MS位置0的DBD<strong>隐式确认</strong>之前Master发送的DBD（表示我是Slave，我有或没有后续的DBD发送，我的序列号是X）。</p>
<h3 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h3><p>DBD交换完成后，进入Loading状态，在Exchange状态时已经对链路状态数据库和收到的DBD的LSA头部进行了比较，已经知道要向邻居请求哪些自身没有的LSA了，于是在Loading阶段向邻居发送LSR用来请求这些没有的LSA；邻居收到LSR后，回应LSU（LSU中包含着LSA）；收到邻居发来的LSU，存储这些LSA到自己的链路状态数据库，并发送LSAck确认。也就是一个LSR — LSU — LSAck的数据包交互过程，当需要交互的LSU全部发送完毕后，Loading状态结束进入Full状态。在发送LSU时，路由器中也维护着一个LSU的重传列表以便确定所有发送的LSU都能被正确接收到，如果没收到某个LSU的LSAck的话会重传该LSU，例如下图：</p>
<img src="/2020/06/18/13-ospf/Snipaste_2020-07-14_18-19-36.jpg" alt="Snipaste_2020-07-14_18-19-36" style="zoom:67%;">

<ol>
<li>R2需要向R1请求A2和B2两条LSA的LSU，R1要向R2请求B1这一条LSA的LSU。</li>
<li>R1向R2发送了A2和B2这两个LSU，R2发送了A2的LSAck，表示已经收到了A2的LSU</li>
<li>当R1的LSA计时器过期（5秒）后仍然没收到关于B2的LSAck，R1明白该LSU对方并未受到于是重新发送了B2的LSU给R2。</li>
<li>R2收到B2的LSU后发送了关于B2的LSAck表示该LSU已收到。</li>
<li>R2发送B1的LSU给R1。</li>
<li>R1发送B1的LSAck表示该LSU已收到。</li>
</ol>
<h3 id="Full"><a href="#Full" class="headerlink" title="Full"></a>Full</h3><p>LSU全部交互完毕后，两台路由器拥有的LSDB，并保持在该状态。为了保持邻接状态，路由器之间会交互Hello包，确保对方的状态，如果在Deaf interval计时器到期前都未收到对方的Hello包，则邻接状态终结。一旦发现和其他路由器邻接状态终结，路由器将会泛洪该变化置域内其他路由器。</p>
<h2 id="邻居无法建立常见原因"><a href="#邻居无法建立常见原因" class="headerlink" title="邻居无法建立常见原因"></a>邻居无法建立常见原因</h2><ol>
<li>Hello间隔和Dead间隔不同。默认情况下，Dead间隔是Hello间隔的4倍，可以在接口下通过“ip ospf hello-interval”和“ip ospf dead-interval”命令来调整。</li>
<li>区域号不一致（Area号不同）。</li>
<li>特殊区域（Stub区域和Nssa区域等）区域类型不匹配。</li>
<li>认证类型或密码不一致。</li>
<li>路由器ID相同。</li>
<li>Hello包被ACL给Deny掉。</li>
<li>链路上的MTU不匹配。</li>
<li>接口下的OSPF网络类型不匹配。</li>
</ol>
<h1 id="OSPF路由汇总"><a href="#OSPF路由汇总" class="headerlink" title="OSPF路由汇总"></a><a href="http://blog.sina.com.cn/s/blog_5ec353710102vtfy.html">OSPF路由汇总</a></h1><h1 id="虚链路"><a href="#虚链路" class="headerlink" title="虚链路"></a>虚链路</h1><h2 id="概述-17"><a href="#概述-17" class="headerlink" title="概述"></a>概述</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-17-35.jpg" alt="Snipaste_2020-10-11_16-17-35"></p>
<p>OSPF规定每个区域都必须与区域0相连，当出现了以上情况，可以在区域1中建立一条虚链路（Virtual-link）来过度，配置命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">area X（过渡区域的ID） virtual-link A.B.C.D（虚链路对端router 的Router ID）</span><br><span class="line">举例：area 1 virtual-link 3.3.3.3    </span><br><span class="line">#过渡区域为区域1，虚链路对端Router的Router ID为3.3.3.3</span><br></pre></td></tr></table></figure>

<p>查看虚链路命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip ospf virtual-links</span><br></pre></td></tr></table></figure>

<p>虚链路用来连接不连续的区域，只是一种临时或割接的手段，不建议用在常规网络的实施中。本质上虚链路是一条属于区域0的线路，所以如果在Area 0上开启了验证那么Virtual-link也要做验证，如果Area 0不做验证，只虚链路上自己做认证，那验证的范围就在虚链路上。虚链路用Hello包建立，以单播形式，虚链路一旦建立起邻居则Hello包不再发送，凡是通过虚链路学到的LSA都会标注DNA表示永远不会老化。</p>
<h2 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h2><p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-17-35.jpg" alt="Snipaste_2020-10-11_16-17-35"></p>
<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> area 2 virtual-link 3.3.3.3</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 1</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 2</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> area 2 virtual-link 2.2.2.2</span><br><span class="line"> network 192.168.23.3 0.0.0.0 area 2</span><br><span class="line"> network 192.168.34.3 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R2上的部分LSDB：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-34-57.jpg" alt="Snipaste_2020-10-11_16-34-57"></p>
<p>R2上的邻居表：</p>
<p><img src="/2020/06/18/13-ospf/Snipaste_2020-10-11_16-37-22.jpg" alt="Snipaste_2020-10-11_16-37-22"></p>
<h1 id="OSPF选路"><a href="#OSPF选路" class="headerlink" title="OSPF选路"></a>OSPF选路</h1><ol>
<li>直连路由：本路由器发起的LSA 1、2；</li>
<li>区域内路由：O；LSA 1、2；</li>
<li>区域间路由：O IA；LSA 3；</li>
<li>1类外部路由：O E1；LSA 5类型1；</li>
<li>2类外部路由：O E2；LSA 5类型2；</li>
<li>1类NSSA路由：O N1；LSA7类型1；</li>
<li>2类NSSA路由：O N2；LSA 7类型2。</li>
</ol>
<p>简单版总结就是：<strong>O&gt;&gt; O IA &gt;&gt; E1 &gt;&gt; N1 &gt;&gt;E2 &gt;&gt; N2</strong>，但实际中不同厂家的优先选择方式不同，以各厂家的文档为准。</p>
<h1 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h1><p><a href="https://community.cisco.com/t5/routing/ospf-bdr-and-dr-other-relations/td-p/3758851">OSPF BDR and DR-OTHER relations</a></p>
<p><a href="https://community.cisco.com/t5/routing/why-bdr-is-elected-first/td-p/3207520">Why BDR is elected first?</a></p>
<p><a href="https://community.cisco.com/t5/switching/master-and-slave-concept/m-p/2411039#M285022">Master and Slave concept</a></p>
<p><a href="https://community.cisco.com/t5/switching/ospf-lsa-flooding/td-p/1964852">OSPF LSA Flooding</a></p>
<p><a href="https://community.cisco.com/t5/switching/when-was-dbd-database-descriptor-packets-sent/td-p/2080784">When was DBD(database descriptor) packets sent ?</a></p>
<p><a href="https://forum.huawei.com/enterprise/zh/thread-275125.html">OSPF协议介绍及配置 （上）</a></p>
<p><a href="https://www.computernetworkingnotes.com/ccna-study-guide/ospf-neighbor-states-explained-with-example.html">OSPF Neighbor States Explained with Example</a></p>
<p><a href="https://sites.google.com/site/amitsciscozone/home/important-tips/ospf/ospf-packet-types">OSPF Packet Types</a></p>
<p><a href="http://www.firewall.cx/networking-topics/routing/ospf-routing-protocol/1147-ospf-lsu-lsa-packet-structure-lsa-types-overview.html">ANALYSIS OF OSPF LINK STATE UPDATE (LSU) - LINK STATE ADVERTISEMENT (LSA) PACKET STRUCTURE. COMMON LSA TYPES</a></p>
<p><a href="https://community.cisco.com/t5/routing/ospf-implicit-ack-vs-explicit-ack/td-p/2353763">OSPF - Implicit ACK vs. Explicit ACK</a></p>
<p><a href="https://networklessons.com/ospf/ospf-lsas-and-lsdb-flooding-tutorial">OSPF LSAs and LSDB flooding Tutorial</a></p>
<p><a href="http://www.firewall.cx/networking-topics/routing/ospf-routing-protocol/1178-ospf-lsa-types-explained.html">OSPF LSA TYPES - PURPOSE AND FUNCTION OF EVERY OSPF LSA</a></p>
<p><a href="https://www.networkfuntimes.com/ospf-what-is-a-stub-network/">OSPF: WHAT IS A STUB NETWORK?</a></p>
<p><a href="http://ccietea.com/">红茶三杯OSPF笔记</a></p>
<p><a href="https://community.cisco.com/t5/other-network-architecture/why-ospf-lsa-type-2-s/td-p/288472">Why OSPF LSA Type 2’s</a></p>
<p><a href="https://community.cisco.com/t5/other-network-architecture/differences-between-n1-n2-e1-e2-in-ospf/td-p/398381">differences between n1 n2 e1 e2 in ospf?</a></p>
<p><a href="https://ipwithease.com/ospf-external-e1-and-e2-routes/">OSPF EXTERNAL E1 vs E2 ROUTES</a></p>
<p><a href="https://ipwithease.com/ospf-n1-and-n2-routes/">OSPF N1 Route and N2 Route</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>9、通信过程分析</title>
    <url>/2020/04/02/9-communication-process/</url>
    <content><![CDATA[<p>这一部分开始把前面那堆枯燥乏味的理论联系到实际数据传输的过程了，阅读这部分建议结合OSI模型以及TCP/IP模型中的“相关概念”部分一起看，实际通信过程结合理论分析，有助于真正掌握通信的过程和概念。</p>
<h2 id="数据总体通讯过程"><a href="#数据总体通讯过程" class="headerlink" title="数据总体通讯过程"></a>数据总体通讯过程</h2> <span id="more"></span>  

<p><img src="/2020/04/02/9-communication-process/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<p><img src="/2020/04/02/9-communication-process/TCPIP%20ENCAPSULATION.png" alt="TCPIP ENCAPSULATION"></p>
<p><img src="/2020/04/02/9-communication-process/Data_Flow_of_the_Internet_Protocol_Suite.png" alt="Data_Flow_of_the_Internet_Protocol_Suite"></p>
<h3 id="TCPIP模型回顾"><a href="#TCPIP模型回顾" class="headerlink" title="TCPIP模型回顾"></a>TCPIP模型回顾</h3><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-12-42.jpg" alt="Snipaste_2020-06-11_14-12-42"></p>
<p>TCP/IP模型是当今IP网络的基础（由OSI七层参考模型发展而来，也称为DoD模型）。分层参考模型的设计是非常经典的理念：</p>
<ul>
<li>层次化的模型设计将网络的通信过程划分为更小、更简单的部件，因此有助于各个部件的独立开发、设计和故障排除；</li>
<li>层与层之间相互独立，又互相依赖，每一层都有该层的功能、以及定义的协议标准。层与层之间相互配合，共同完成数据通信的过程；</li>
<li>通过组件的标准化，允许多个供应商进行开发；</li>
<li>通过定义在模型的每一层实现什么功能，鼓励产业的标准化；</li>
<li>允许各种类型的网络硬件和软件相互通信。</li>
</ul>
<p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-14-20.jpg" alt="Snipaste_2020-06-11_14-14-20"></p>
<h3 id="路由器的通信过程"><a href="#路由器的通信过程" class="headerlink" title="路由器的通信过程"></a>路由器的通信过程</h3><p>路由器（Router）是一种负责寻径的网络设备，连接不同网段，负责不同网段之间的数据转发，例如192.168.1.0/24和192.168.2.0/24之间通信，由于他们分别属于192.168.1.0和192.168.2.0这两个不同的网段，所以他们之间的通信需要三层设备也就是路由器来连同，它在互连网络中从多条路径中寻找通讯量最少的一条网络路径提供给用户通信。</p>
<p>Router 的责任是记录相应路由信息应该从哪个接口发出，并形成一张路由表，当收到数据时，根据网络层报头的目的地址去查询路由表中是否有相对应的条目，如果有就从该路由条目的出接口发出数据，如果没有就将数据丢弃。</p>
<h3 id="LAN内交换机的通信原则和过程"><a href="#LAN内交换机的通信原则和过程" class="headerlink" title="LAN内交换机的通信原则和过程"></a>LAN内交换机的通信原则和过程</h3><p>交换机（Switch）对数据的处理过程：</p>
<p><img src="/2020/04/02/9-communication-process/switch.jpg" alt="switch"></p>
<ul>
<li><p>交换机如果刚刚加电启动，它的MAC地址缓存为空，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址而且在同一网段，根据TCP/IP模型我们知道，由于在同一网段所以只需要二层交换机即可通信，封装数据时，下四层每一层需要封装本层的报头，三层网络层封装的时候需要源目的IP地址，二层数据链路层封装的时候需要原目的MAC地址，这里PC1只知道PC3的IP地址和自己的IP地址，所以三层需要封装的参数已经知道了，但在开始通信的时候，二层封装的目的MAC地址还不知道，所以需要获得MAC地址才能完成二层数据链路层的封装，PC1会使用ARP协议去获取目的MAC地址用来完成二层封装，PC1获取PC3 MAC地址的过程，请结合<a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/#ARP%EF%BC%88Address-Resolution-Protocol-%EF%BC%89">ARP</a>的部分学习。</p>
</li>
<li><p>假设PC1已经知道了PC3的MAC地址，而Switch的MAC地址表项为空，PC1将源IP、MAC地址为自身，目标IP、MAC地址为PC3相应地址的数据封装好发送给Switch，Switch从接口G0/1接收到PC1发过来的数据后，首先对数据进行解封装，将物理层0101的比特流还原成数据帧后对二层进行解封装，知道了该数据帧的源、目的MAC地址，将这个数据帧的源MAC地址，既PC1的MAC地址（AAAAAAAAAA）和对应的端口G0/1添加到自己的MAC地址表中方便以后再进行数据传输时使用，然后从自己的MAC地址表中去查找这个数据帧目的地PC3（CCCCCCCCCC）的MAC地址，但是此时由于MAC地址表项为空所以找不到对应的MAC地址，这时Switch将这个数据封装上初始的源、目的MAC地址作为二层帧头，从除了收到这个数据的G0/1以外的其他接口（G0/2、G0/3、G0/0）泛洪出去；</p>
</li>
<li><p>PC2和PC4都接收到了这个数据帧，这两台设备将比特流还原成帧后对数据帧进行解封装，查看该数据帧的目的MAC地址，发现目的MAC地址与自己的网卡MAC地址不相同，PC2和PC4丢弃这个数据帧；</p>
</li>
<li><p>在上一步中PC3也同时收到了这个数据帧，PC3对数据进行解封装后，检查目的MAC地址的时候发现，与本机相同，PC3接收这个数据包，并回发数据包对PC1进行确认，PC3封装一个源地址为自己MAC地址，目的地址是A的MAC地址，源IP为自己IP，目的IP为PC1的IP地址的数据发送给Switch；</p>
</li>
<li><p>Switch接收到这个数据，它首先添加PC3的MAC和对应的接口G0/3到自己的MAC地址表中，然后查询源MA地址表时候发现PC1的MAC地址在MAC地址表项中可以查到，此MAC地址对应端口为G0/1，Switch将这个数据帧发给接口G0/1的PC1；</p>
</li>
<li><p>PC1收到PC3发回的确认，通信成功；</p>
</li>
<li><p>通过这种形式，Switch学习到的MAC地址以及所在接口。如下：</p>
</li>
</ul>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191124185137.jpg" alt="微信截图_20191124185137"></p>
<p>通过不停的通信，最终Switch能够获得所有端口对应的MAC地址，但需注意，MAC地址表项的老化时间为300秒，如果超过老化时间，表项会被删除，Switch需重新泛洪以获取目的MAC地址对应的表项。思科交换机查看MAC地址表的命令为：<strong>show mac-address</strong> </p>
<h2 id="通信示例分析"><a href="#通信示例分析" class="headerlink" title="通信示例分析"></a>通信示例分析</h2><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-06-11_14-28-29.jpg" alt="Snipaste_2020-06-11_14-28-29"></p>
<p>网络上各设备的接口、IP和MAC地址如图所示，PC1要访问WebServer上的网页服务（HTTP、80端口），用这个例子分析数据在TCP/IP每层经历的过程。在阐述过程中，我们重点放在利用TCP/IP参考模型理解通信过程，因此可能会忽略部分技术细节，例如DNS、TCP三次握手等，这些技术细节这里暂不做讨论。事实上，整个过程的宏观层面如下：</p>
<p><img src="/2020/04/02/9-communication-process/53a14dfd2e01a-1591856957079.png" alt="53a14dfd2e01a"></p>
<h3 id="PC封装过程"><a href="#PC封装过程" class="headerlink" title="PC封装过程"></a>PC封装过程</h3><h4 id="应用层："><a href="#应用层：" class="headerlink" title="应用层："></a>应用层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e23b3ca6.png" alt="53a14e23b3ca6"></p>
<p>PC的用户在WEB浏览器中访问Server的WEB服务（这里我们暂且不去关注底层的HTTP交互、DNS交互等细节。重点看通信过程），PC的这次操作将触发HTTP应用为用户构造一个应用数据。当然这个数据最终要传递到Server并最终“递交”到Server的HTTP应用来处理，但是HTTP不关心数据怎么传、怎么寻址、怎么做差错校验等等，那么这些事情就交由专门的Layer也就是专门的层来完成，所以HTTP应用数据还的经过一番“折腾”才能从PC传出去到达Server，现在开始。<strong>应用层</strong>中的相关程序生成一个应用层的数据，也就是图中的DATA部分，然后交给下一层，传输层。</p>
<h4 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e35e03e1.png" alt="53a14e35e03e1"></p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145310-1585388711315.jpg" alt="微信图片编辑_20200113145310"></p>
<p>上层的DATA到达传输层后，首先查看数据类型，由于这是一个要发送给web服务器的HTTP数据，而HTTP是一种尽力而为的协议，本身没有纠错功能，所以选择能保证数据传输完整性的TCP协议去封装，而TCP报头中需要的两个重要参数就是源、目的端口地址。HTTP固定的端口是80，所以目的端口号为80，客户端使用的源端口号一般为系统中未使用的且大于1023的数字，在这我们假设设备使用1025作为源端口号。封装完TCP报头，形成了数据段（segment）后，交给下一层，网络层。</p>
<h4 id="网络层："><a href="#网络层：" class="headerlink" title="网络层："></a>网络层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e4be283e.png" alt="53a14e4be283e"></p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200328175537.jpg" alt="微信图片编辑_20200328175537"></p>
<p>上层数据到达网络层后，要加上网络层的IPV4报头，等以后如果IPV6普及了会加IPV6报头，以便该数据能够在IP网络中被网络设备转发（路由）。IPV4报头封装所需的三个重要的参数就是源IP地址、目的IP地址和协议号。由于上层用的是TCP协议，TCP协议对应的协议号为6，所以在Protocol部分为6；源IP地址为自身的IP地址192.168.1.1，目的IP地址为WebServer的IP地址192.168.2.1。封装好三层报头将数据段封装为数据包后，交给下一层，数据链路层。</p>
<h4 id="数据链路层："><a href="#数据链路层：" class="headerlink" title="数据链路层："></a>数据链路层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e5955e8b.png" alt="53a14e5955e8b"></p>
<p><img src="/2020/04/02/9-communication-process/1920px-Ethernet_Type_II_Frame_format.svg.png" alt="1920px-Ethernet_Type_II_Frame_format.svg"></p>
<p>上层数据到数据链路层后，需要封装以太网2的报头，使得之前的IP数据包能够在链路上被传输，因为TCP/IP在二层采用的是这种封装格式，以太网2报头中三个需要获知的重要参数为源MAC地址、目的MAC地址和以类型，源MAC地址为PC自身的MAC地址，目的MAC地址呢？PC知道，数据的目的地是192.168.2.1这个IP，而本机IP是192.168.1.1/24，显然，目的地与自己并不在同一个网段，因此需要借助自己的网关，让网关来帮助自己将数据包转发出去。那么首先我得把数据转发到网关吧？因此目的MAC地址填写的就是网关192.168.1.254对应的MAC地址。但是初始情况下，PC可能并没有192.168.1.254的MAC，所以，它会发送一个ARP广播去请求192.168.1.254的MAC，R1的GE0/0/0口会收到这个ARP请求并且回送ARP响应。如此一来PC就知道了网关的MAC，它将网关MAC 0018-0011-0001填写在以太网数据帧头部的目的MAC中。另外，以太网数据帧头的类型字段写上0x0800这个值，表示我这个数据帧头后面封装的是一个IP包。由于三层采用的封装为IPV4，所以EtherType中类型字段的值为0x0800，表示我这个数据帧头后面封装的是一个IP包。数据链路层封装好本层报头以后，将数据传给下一层，物理层。</p>
<h4 id="物理层："><a href="#物理层：" class="headerlink" title="物理层："></a>物理层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e6820ab9.png" alt="53a14e6820ab9"></p>
<p>物理层收到上层的数据帧后，将数据帧转换为物理层能识别的电磁信号，也就是bit流，从物理上来说，最终数据帧在物理层变成了一堆的0101，然后通过物理介质传输给网关，路由器R1。</p>
<h3 id="R1处理过程"><a href="#R1处理过程" class="headerlink" title="R1处理过程"></a>R1处理过程</h3><h4 id="物理层第一次："><a href="#物理层第一次：" class="headerlink" title="物理层第一次："></a>物理层第一次：</h4><p>R1收到物理介质传输的数据后，在物理层将电磁信号还原成数据帧，然后交给数据链路层。</p>
<h4 id="数据链路层第一次："><a href="#数据链路层第一次：" class="headerlink" title="数据链路层第一次："></a>数据链路层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e73c02b5.png" alt="53a14e73c02b5"></p>
<p>R1收到物理层发来的数据帧，先查看数据帧的CRC Checksum部分，看数据帧在传输过程中是否有损坏：</p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611145704.jpg" alt="微信图片编辑_20200611145704"></p>
<p>确定数据帧无损坏以后，开始对二层进行解封装，看看数据帧中目的MAC地址和收到这个数据帧的GE0/0/0口的MAC是否相同，如果相同说明这个数据是发给自己的，然后讲数据交给上层继处理。在这个例子中，两者相同，于是查看数据帧头部的Ether Type字段，发现类型为0X0800，表示上层网络层用的是IPV4协议封装，这个字段是用来告诉上层，这个数据的三层用的是IPV4封装方式，以便上层解封装的时候使用正确的方式解封装，提高数据处理效率。接着它将以太网帧头剥去或者说解封装完，然后交给上层IP协议继续处理。</p>
<h4 id="网络层：-1"><a href="#网络层：-1" class="headerlink" title="网络层："></a>网络层：</h4><p><img src="/2020/04/02/9-communication-process/53a14e7e58f26.png" alt="53a14e7e58f26"></p>
<p>网络层收到数据后，继续对IP报头进行解封装，校验一下在传输过程中IP报头部分是否损坏：</p>
<p><img src="/2020/04/02/9-communication-process/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200611150749.jpg" alt="微信图片编辑_20200611150749"></p>
<p>如果没有损坏就继续看目标IP地址部分，发现目的IP地址不是本机，网关R1根据目的IP地址，按照最长匹配原则查询是否有对应路由条目，查询后发现应将该数据从GE0/0/1端口发出。于是它不在继续拆IP报头看里面的其他字段也不会剥离IP头部了，而是把原封不动包含IP报头的IP数据包交给下层以太网协议去处理。</p>
<h4 id="数据链路层第二次："><a href="#数据链路层第二次：" class="headerlink" title="数据链路层第二次："></a>数据链路层第二次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e8bef0b7.png" alt="53a14e8bef0b7"></p>
<p>数据链路层收到上层发来的数据后，因为该数据是要从GE0/0/1口发送给R2的GE0/0/0口，所以以太网2封装的源MAC地址是R1的GE0/0/1口的MAC地址，目的MAC地址是R2的GE0/0/0接口的MAC地址，如果ARP缓存中没有R2的GE0/0/0接口MAC地址（在初始情况下是这样），则需要用ARP协议进行获取，如果有该ARP缓存则直接使用；由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给物理层转换成电磁信号发送给R2。</p>
<h3 id="R2处理过程："><a href="#R2处理过程：" class="headerlink" title="R2处理过程："></a>R2处理过程：</h3><h4 id="数据链路层第一次：-1"><a href="#数据链路层第一次：-1" class="headerlink" title="数据链路层第一次："></a>数据链路层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14e978d982.png" alt="53a14e978d982"></p>
<p>R2的物理层将收到的电磁信号恢复成数据帧后交给数据链路层，数据链路层对二层报头进行解封装，发现目的MAC地址和自己的F0/0接口的MAC地址相同，所以这个数据是发给自己的，于是将该数据交给上层的网络层继续处理。</p>
<h4 id="网络层第一次："><a href="#网络层第一次：" class="headerlink" title="网络层第一次："></a>网络层第一次：</h4><p><img src="/2020/04/02/9-communication-process/53a14ea4e02bc.png" alt="53a14ea4e02bc"></p>
<p>网络层收到下层的数据后继续解封装，发现目的IP地址不是自己的，然后根据目的IP地址，按照最长匹配原则查询是否有对应路由条目，查询后发现应将该数据从GE0/0/1端口发出。在网络层将三层按原报头重新打包好然后发给数据链路层。</p>
<h4 id="数据链路层第二次：-1"><a href="#数据链路层第二次：-1" class="headerlink" title="数据链路层第二次："></a>数据链路层第二次：</h4><p><img src="/2020/04/02/9-communication-process/53a14eb0487d8.png" alt="53a14eb0487d8"></p>
<p>数据链路层收到上层发来的数据后，因为该数据是要从GE0/0/1口发送给WebServer，所以以太网2封装的源MAC地址是R2的GE0/0/1口的MAC地址，目的MAC地址是WebServer的MAC地址（ARP方式获得MAC地址），由于上层采用IPV4封装，所以EtherType依旧是0X0800。然后发送给数据链路层转换成电磁信号发送给WebServer。物理层将数据帧转换为物理层能识别的电磁信号然后通过物理介质传输给最终目的设备，WebServer，数据传输结束。</p>
<p><a href="https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996">https://community.cisco.com/t5/networking-blogs/what-happens-when-router-receives-packet/ba-p/3105996</a></p>
<h3 id="Server处理过程"><a href="#Server处理过程" class="headerlink" title="Server处理过程"></a>Server处理过程</h3><p>Server首先是将101010这些比特流还原成帧，然后做校验看看帧头是否损坏，如果没有，则查看数据帧的目的MAC，结果发现就是自己的MAC，于是查看类型字段，发现是0x0800，于是知道这里头装的是一个IP包，于是将帧头剥去，将内层的IP数据包交给上层协议IP去处理。IP收到这个数据包之后，首先依然是查看IP包头是否损坏，如果没有，则查看目的IP地址，发现目的IP地址是192.168.2.1正是自己的网卡IP，于是它知道，这个IP包是发给自己的，因此继续查看IP包头中的协议字段，发现协议字段填写的是6这个值，原来这个IP包头后面封装的是一个TCP的数据，因此将IP包头剥去，将里头的TCP数据交给上层的TCP协议去处理。而TCP在处理这个数据的时候，查看TCP头部的目的端口号，发现目的端口号是80，而本地的TCP80端口是开放的，开放给HTTP应用了，接着它将TCP头部剥去，交给HTTP应用，好了终于从PC发送出来的HTTP应用数据，到达了目的地 –Server的HTTP应用的手中。</p>
<h2 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h2><p><img src="/2020/04/02/9-communication-process/Snipaste_2020-05-13_10-49-06.jpg" alt="Snipaste_2020-05-13_10-49-06"></p>
<p>两台路由器，R1的G0/0接口IP地址为192.168.12.1，R2的G0/1接口IP地址为192.12.2，R1和R2之间能够相互ping通，当R1ping一个不存在的IP地址时，比如192.168.12.3，请问链路上是否有ping包？</p>
<p>答案：没有，因为要封装ping包也就是ICMP，需要源目的IP以及源目地MAC地址，在ping12.3这个不存在的地址时，源目地IP地址已经有了，源MAC地址为自身的MAC地址所以也是有的，但目的MAC地址是靠ARP获得的，但当R1发出ARP请求以后，是获取不到MAC地址的，因为这个IP地址没有设备，也就没法告诉R1它的MAC地址，所以ping包无法封装，所以网络上没有ping包。</p>
<h2 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h2><p><a href="https://forum.huawei.com/enterprise/zh/thread-272107.html">利用TCP/IP模型理解数据通信过程</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>4、基础知识</title>
    <url>/2019/11/18/basic-knowledge/</url>
    <content><![CDATA[<h2 id="一、位（bit）与字节（byte）"><a href="#一、位（bit）与字节（byte）" class="headerlink" title="一、位（bit）与字节（byte）"></a>一、位（bit）与字节（byte）</h2><h3 id="（一）位（bit）"><a href="#（一）位（bit）" class="headerlink" title="（一）位（bit）"></a>（一）位（bit）</h3><p>来自英文bit，音译为“比特”，表示一个二进制位（0或者1）。位是计算机内部数据储存的最小单位，11010100是一个8位二进制数。一个二进制位只可以表示0和1两种状态（21）；两个二进制位可以表示00、01、10、11四种（22）状态。</p>
<h3 id="（二）字节（byte）"><a href="#（二）字节（byte）" class="headerlink" title="（二）字节（byte）"></a>（二）字节（byte）</h3><p>字节来自英文Byte，音译为“拜特”，习惯上用大写的“B”表示。字节是计算机中数据处理的基本单位。计算机中以字节为单位存储和解释信息，规定一个字节（Byte）由连续八个二进制位（bit）构成，即1个字节等于8个比特（1Byte=8bit）。八位二进制数最小为00000000，最大为11111111；通常1个字节可以存入一个ASCII码，2个字节可以存放一个汉字国标码。</p>
 <span id="more"></span>  

<h3 id="（三）位与字节关系举例"><a href="#（三）位与字节关系举例" class="headerlink" title="（三）位与字节关系举例"></a>（三）位与字节关系举例</h3><p>生活中办理的宽带的带宽，比如100M宽带其实是100Mbit/s，换算成Byte/s约等于11MByte/s左右。</p>
<p>计算方法：100Mbit/s*1000&lt;换算成K&gt;*1000&lt;换算成bit&gt;除以8除以1024&lt;换算成K&gt;除以1024&lt;换算成M&gt;  ≈  11MByte/s</p>
<p>1Kbit=1000bit ； 1Mbit=1000Kbit  ;  1Gbit=1000Mbit 1Kbyte=1024Byte  ;  1Mbyte=1024Kbyte  ;  1Gbyte=1024Mbyte</p>
<p><img src="/2019/11/18/basic-knowledge/p.jpg" alt="p"></p>
<p><img src="/2019/11/18/basic-knowledge/QQ%E6%88%AA%E5%9B%BE20191118190909.jpg" alt="QQ截图20191118190909"></p>
<h2 id="二、进制换算"><a href="#二、进制换算" class="headerlink" title="二、进制换算"></a><a href="https://www.cnblogs.com/gaizai/p/4233780.html">二、进制换算</a></h2><h3 id="各进制之间转换总体图"><a href="#各进制之间转换总体图" class="headerlink" title="各进制之间转换总体图"></a>各进制之间转换总体图</h3><p> <img src="/2019/11/18/basic-knowledge/191445561883615.png" alt="wpsC01D.tmp"> </p>
<h3 id="一-（二、八、十六进制）-→-（十进制）"><a href="#一-（二、八、十六进制）-→-（十进制）" class="headerlink" title="(一) （二、八、十六进制） → （十进制）"></a><strong>(一) （二、八、十六进制） → （十进制）</strong></h3><h4 id="1、二进制-→-十进制"><a href="#1、二进制-→-十进制" class="headerlink" title="1、二进制 → 十进制"></a><strong>1、二进制 → 十进制</strong></h4><p>　　方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>例：将二进制的(101011)B转换为十进制的步骤如下：</p>
<p>1. 第0位 1 x 2^0 = 1；</p>
<p>2. 第1位 1 x 2^1 = 2；</p>
<p>3. 第2位 0 x 2^2 = 0；</p>
<p>4. 第3位 1 x 2^3 = 8；</p>
<p>5. 第4位 0 x 2^4 = 0；</p>
<p>6. 第5位 1 x 2^5 = 32；</p>
<p>7. 读数，把结果值相加，1+2+0+8+0+32=43，即(101011)B=(43)D。</p>
<h4 id="2、八进制-→-十进制"><a href="#2、八进制-→-十进制" class="headerlink" title="2、八进制 → 十进制"></a><strong>2、八进制 → 十进制</strong></h4><p>　　方法：八进制数从低位到高位（即从右往左）计算，第0位的权值是8的0次方，第1位的权值是8的1次方，第2位的权值是8的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>　　八进制就是逢8进1，八进制数采用 0～7这八数来表达一个数。</p>
<p>　　例：将八进制的(53)O转换为十进制的步骤如下：</p>
<p>1. 第0位 3 x 8^0 = 3；</p>
<p>2. 第1位 5 x 8^1 = 40；</p>
<p>3. 读数，把结果值相加，3+40=43，即(53)O=(43)D。</p>
<h4 id="3、十六进制-→-十进制"><a href="#3、十六进制-→-十进制" class="headerlink" title="3、十六进制 → 十进制"></a><strong>3、十六进制 → 十进制</strong></h4><p>　　方法：十六进制数从低位到高位（即从右往左）计算，第0位的权值是16的0次方，第1位的权值是16的1次方，第2位的权值是16的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p>　　十六进制就是逢16进1，十六进制的16个数为0123456789ABCDEF。</p>
<p>　　例：将十六进制的(2B)H转换为十进制的步骤如下：</p>
<p>1. 第0位 B x 16^0 = 11；</p>
<p>2. 第1位 2 x 16^1 = 32；</p>
<p>3. 读数，把结果值相加，11+32=43，即(2B)H=(43)D。</p>
<h3 id="二-（十进制）-→-（二、八、十六进制）"><a href="#二-（十进制）-→-（二、八、十六进制）" class="headerlink" title="(二) （十进制） → （二、八、十六进制）"></a><strong>(二) （十进制） → （二、八、十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191445595475175.png"><img src="/2019/11/18/basic-knowledge/191446004698089.png" alt="wpsC01F.tmp"></a></p>
<p>（Figure3：十进制转换为其它进制）</p>
<h4 id="1、十进制-→-二进制"><a href="#1、十进制-→-二进制" class="headerlink" title="1、十进制 → 二进制"></a><strong>1、十进制 → 二进制</strong></h4><p>　　方法：除2取余法，即每次将整数部分除以2，余数为该位权上的数，而商继续除以2，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数读起，一直到最前面的一个余数。 </p>
<p>　　例：将十进制的(43)D转换为二进制的步骤如下：</p>
<p>1. 将商43除以2，商21余数为1；</p>
<p>2. 将商21除以2，商10余数为1；</p>
<p>3. 将商10除以2，商5余数为0；</p>
<p>4. 将商5除以2，商2余数为1；</p>
<p>5. 将商2除以2，商1余数为0； </p>
<p>6. 将商1除以2，商0余数为1； </p>
<p>7. 读数，因为最后一位是经过多次除以2才得到的，因此它是最高位，读数字从最后的余数向前读，101011，即(43)D=(101011)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446012199718.png"><img src="/2019/11/18/basic-knowledge/191446019539875.png" alt="wpsC02F.tmp"></a></p>
<p>（Figure4：图解十进制 → 二进制）</p>
<h4 id="2、十进制-→-八进制"><a href="#2、十进制-→-八进制" class="headerlink" title="2、十进制 → 八进制"></a><strong>2、十进制 → 八进制</strong></h4><p>　　方法1：除8取余法，即每次将整数部分除以8，余数为该位权上的数，而商继续除以8，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p>
<p>　　例：将十进制的(796)D转换为八进制的步骤如下：</p>
<p>1. 将商796除以8，商99余数为4；</p>
<p>2. 将商99除以8，商12余数为3；</p>
<p>3. 将商12除以8，商1余数为4；</p>
<p>4. 将商1除以8，商0余数为1；</p>
<p>5. 读数，因为最后一位是经过多次除以8才得到的，因此它是最高位，读数字从最后的余数向前读，1434，即(796)D=(1434)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446027976234.png"><img src="/2019/11/18/basic-knowledge/191446033751877.png" alt="wpsC030.tmp"></a></p>
<p>（Figure5：图解十进制 → 八进制）</p>
<p>　　方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成八进制；</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446044383535.png"><img src="/2019/11/18/basic-knowledge/191446059386793.png" alt="wpsC031.tmp"></a></p>
<p>（Figure6：图解十进制 → 八进制）</p>
<h4 id="3、十进制-→-十六进制"><a href="#3、十进制-→-十六进制" class="headerlink" title="3、十进制 → 十六进制"></a><strong>3、十进制 → 十六进制</strong></h4><p>　　方法1：除16取余法，即每次将整数部分除以16，余数为该位权上的数，而商继续除以16，余数又为上一个位权上的数，这个步骤一直持续下去，直到商为0为止，最后读数时候，从最后一个余数起，一直到最前面的一个余数。</p>
<p>　　例：将十进制的(796)D转换为十六进制的步骤如下：</p>
<p>1. 将商796除以16，商49余数为12，对应十六进制的C；</p>
<p>2. 将商49除以16，商3余数为1；</p>
<p>3. 将商3除以16，商0余数为3；</p>
<p>4. 读数，因为最后一位是经过多次除以16才得到的，因此它是最高位，读数字从最后的余数向前读，31C，即(796)D=(31C)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446073607794.png"><img src="/2019/11/18/basic-knowledge/191446083759737.png" alt="wpsC042.tmp"></a></p>
<p>（Figure7：图解十进制 → 十六进制）</p>
<p>　　方法2：使用间接法，先将十进制转换成二进制，然后将二进制又转换成十六进制；</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446096567695.png"><img src="/2019/11/18/basic-knowledge/191446107502896.png" alt="wpsC043.tmp"></a></p>
<p>（Figure8：图解十进制 → 十六进制）</p>
<h3 id="三-（二进制）-↔-（八、十六进制）"><a href="#三-（二进制）-↔-（八、十六进制）" class="headerlink" title="(三) （二进制） ↔ （八、十六进制）"></a><strong>(三) （二进制） ↔ （八、十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191446117669540.png"><img src="/2019/11/18/basic-knowledge/191446126101198.png" alt="wpsC044.tmp"></a></p>
<p>（Figure9：二进制转换为其它进制）</p>
<h4 id="1、二进制-→-八进制"><a href="#1、二进制-→-八进制" class="headerlink" title="1、二进制 → 八进制"></a><strong>1、二进制 → 八进制</strong></h4><p>　　方法：取三合一法，即从二进制的小数点为分界点，向左（向右）每三位取成一位，接着将这三位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的八进制数。如果向左（向右）取三位后，取到最高（最低）位时候，如果无法凑足三位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足三位。</p>
<p>　　例：将二进制的(11010111.0100111)B转换为八进制的步骤如下：</p>
<p>1. 小数点前111 = 7；</p>
<p>2. 010 = 2；</p>
<p>3. 11补全为011，011 = 3；</p>
<p>4. 小数点后010 = 2；</p>
<p>5. 011 = 3；</p>
<p>6. 1补全为100，100 = 4；</p>
<p>7. 读数，读数从高位到低位，即(11010111.0100111)B=(327.234)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446138756684.png"><img src="/2019/11/18/basic-knowledge/191446144855271.png" alt="wpsC054.tmp"></a></p>
<p>（Figure10：图解二进制 → 八进制）</p>
<p>二进制与八进制编码对应表：</p>
<p><img src="/2019/11/18/basic-knowledge/QQ%E6%88%AA%E5%9B%BE20191118191227.jpg" alt="QQ截图20191118191227"></p>
<h4 id="2、八进制-→-二进制"><a href="#2、八进制-→-二进制" class="headerlink" title="2、八进制 → 二进制"></a><strong>2、八进制 → 二进制</strong></h4><p>　　方法：取一分三法，即将一位八进制数分解成三位二进制数，用三位二进制按权相加去凑这位八进制数，小数点位置照旧。</p>
<p>　　例：将八进制的(327)O转换为二进制的步骤如下：</p>
<p>1. 3 = 011；</p>
<p>2. 2 = 010；</p>
<p>3. 7 = 111；</p>
<p>4. 读数，读数从高位到低位，011010111，即(327)O=(11010111)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446152665143.png"><img src="/2019/11/18/basic-knowledge/191446161888058.png" alt="wpsC055.tmp"></a></p>
<p>（Figure11：图解八进制 → 二进制）</p>
<h4 id="3、二进制-→-十六进制"><a href="#3、二进制-→-十六进制" class="headerlink" title="3、二进制 → 十六进制"></a><strong>3、二进制 → 十六进制</strong></h4><p>　　方法：取四合一法，即从二进制的小数点为分界点，向左（向右）每四位取成一位，接着将这四位二进制按权相加，然后，按顺序进行排列，小数点的位置不变，得到的数字就是我们所求的十六进制数。如果向左（向右）取四位后，取到最高（最低）位时候，如果无法凑足四位，可以在小数点最左边（最右边），即整数的最高位（最低位）添0，凑足四位。</p>
<p>　　例：将二进制的(11010111)B转换为十六进制的步骤如下：</p>
<p>1. 0111 = 7；</p>
<p>2. 1101 = D；</p>
<p>3. 读数，读数从高位到低位，即(11010111)B=(D7)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446167506929.png"><img src="/2019/11/18/basic-knowledge/191446173913759.png" alt="wpsC056.tmp"></a></p>
<p>（Figure12：图解二进制 → 十六进制）</p>
<h4 id="4、十六进制-→-二进制"><a href="#4、十六进制-→-二进制" class="headerlink" title="4、十六进制 → 二进制"></a><strong>4、十六进制 → 二进制</strong></h4><p>　　方法：取一分四法，即将一位十六进制数分解成四位二进制数，用四位二进制按权相加去凑这位十六进制数，小数点位置照旧。</p>
<p>　　例：将十六进制的(D7)H转换为二进制的步骤如下：</p>
<p>1. D = 1101；</p>
<p>2. 7 = 0111；</p>
<p>3. 读数，读数从高位到低位，即(D7)H=(11010111)B。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446183444917.png"><img src="/2019/11/18/basic-knowledge/191446194223347.png" alt="wpsC057.tmp"></a></p>
<p>（Figure13：图解十六进制 → 二进制）</p>
<h3 id="四-（八进制）-↔-（十六进制）"><a href="#四-（八进制）-↔-（十六进制）" class="headerlink" title="(四) （八进制） ↔ （十六进制）"></a><strong>(四) （八进制） ↔ （十六进制）</strong></h3><p><a href="https://images0.cnblogs.com/blog/48305/201501/191446207353847.png"><img src="/2019/11/18/basic-knowledge/191446216102748.png" alt="wpsC058.tmp"></a></p>
<p>（Figure14：八进制与十六进制之间的转换）</p>
<h4 id="1、八进制-→-十六进制"><a href="#1、八进制-→-十六进制" class="headerlink" title="1、八进制 → 十六进制"></a><strong>1、八进制 → 十六进制</strong></h4><p>　　方法：将八进制转换为二进制，然后再将二进制转换为十六进制，小数点位置不变。</p>
<p>　　例：将八进制的(327)O转换为十六进制的步骤如下：</p>
<p>1. 3 = 011；</p>
<p>2. 2 = 010；</p>
<p>3. 7 = 111；</p>
<p>4. 0111 = 7；</p>
<p>5. 1101 = D；</p>
<p>6. 读数，读数从高位到低位，D7，即(327)O=(D7)H。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446224386634.png"><img src="/2019/11/18/basic-knowledge/191446233756320.png" alt="wpsC069.tmp"></a></p>
<p>（Figure15：图解八进制 → 十六进制）</p>
<h4 id="2、十六进制-→-八进制"><a href="#2、十六进制-→-八进制" class="headerlink" title="2、十六进制 → 八进制"></a><strong>2、十六进制 → 八进制</strong></h4><p>　　方法：将十六进制转换为二进制，然后再将二进制转换为八进制，小数点位置不变。</p>
<p>　　例：将十六进制的(D7)H转换为八进制的步骤如下：</p>
<p>1. 7 = 0111；</p>
<p>2. D = 1101；</p>
<p>3. 0111 = 7；</p>
<p>4. 010 = 2；</p>
<p>5. 011 = 3；</p>
<p>6. 读数，读数从高位到低位，327，即(D7)H=(327)O。</p>
<p><a href="https://images0.cnblogs.com/blog/48305/201501/191446245008763.png"><img src="/2019/11/18/basic-knowledge/191446253919136.png" alt="wpsC06A.tmp"></a></p>
<p>（Figure16：图解十六进制 → 八进制）</p>
<p>此文从 <a href="https://www.cnblogs.com/gaizai/p/4233780.html">https://www.cnblogs.com/gaizai/p/4233780.html</a> 搬运，感谢原作者~</p>
<h2 id="三、带宽、网速、流量"><a href="#三、带宽、网速、流量" class="headerlink" title="三、带宽、网速、流量"></a>三、带宽、网速、流量</h2><p>通常情况下：我们说的带宽10M 20M ；现在网速：200KB/s ； 使用了8M的流量等，那么带宽、网速、流量之间有什么关系，他们分别代表什么呢？</p>
<p>带宽的统计单位是：比特/秒（bps）：10M=10Mbps；</p>
<p>网速是数据传输的速度，单位是：字节/秒（B/s KB/s MB/s）：1MB/s=1024KB/s ；1KB/s=1024B/s</p>
<p>流量是用户上网发送和接收的数据量总和，单位是：字节（Byte）；</p>
<p>网速和带宽是既有区别又有联系的。<br>宽带理论最大速度512k=512kbps=512k bits/s=64k bytes/s，1M=1024kbps=1024k bits/s=128k bytes/s，如此类推。。。。<br>即512Kb=64Kb/s.1M=128Kb/s,2M=256Kb/s(这是理论最大下载速度）</p>
<p>但实际上能达到的“最大”下载速度是1M的100Kb/s、2兆的200kb/s，3M的300。。。。<br>另外还有个标准（电信部门给的）：<br>· 512k用户的到达测速网站的速度大于 40KByte/s,即320Kbps时是属于正常的；<br>· 1M用户的到达测速网站的速度大于 80KByte/s,即640Kbps时是属于正常的；<br>· 2M以上用户的到达测速网站的速度大于 160KByte/s,即1280Kbps时是属于正常的；<br>· 3M以上用户的到达测速网站的速度大于 240KByte/s,即1920Kbps时是属于正常的；</p>
<p>比特是信息的最小单位：1字节=8比特（1B=8bit或者1B=8b）；1字节/秒=8比特/秒（1B/s=8bps）</p>
<p>1 Byte = 8 bits<br>1 Kb = 1024 bits<br>1 KB = 1024 bytes<br>1 Mb = 1024 Kb<br>1 MB = 1024 KB</p>
<p>　在这里要注意的是传输单位的写法上，B 和 b 分别代表 Bytes 和 bits，两者的定义是不同的，千万不要混淆了。否则差距可是8倍阿。</p>
<p>　所以各种宽带的极限下载值也可以轻易的计算出来。</p>
<p>1 M =112 KB/s<br>2 M =225 KB/s<br>8 M =901 KB/s<br>10 M =1126 KB/s</p>
<p>　Mbps实际上是一个带宽单位，而非速度单位，在“Mbps”单位中的“b”是指“Bit（位）”。而真正的速度单位应为MB/s，其中的“B”是指“Byte（字节）”。因为数据是按字节传输的，而并非按位。</p>
<p>　就因这两个大、小写不同的“B”和“b”，使得这两个单位不仅不能等同，而且相差甚远。当然它们之间也存在着较大关联的，那就是1MB/s=8Mbps，可以这么理解，那就是端口带宽是端口的理论最大传输速度，实际中的速度要远小于带宽值（通常为60~80%之间）。</p>
<p>1比特（1b or 1位）是信息技术中的最小存储单位，1位代表一个“1”或者“0”；</p>
<p>1B（1字节）是比较小的存储单位：1个英文字母占1个字节；一个汉字占2个字节；</p>
<p>他们之间的换算：10M带宽=1.25MB/s网速：1M带宽=0.125MB/s=128KB/s</p>
<p>10Mbps=10<em>1024Kbps=10</em>1024<em>1024bps=10</em>1024*1024/8 Byte/s=10/8 MB/s=1.25 MB/s</p>
<h2 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h2><p><a href="https://zhuanlan.zhihu.com/p/50401281">浅谈带宽、网速和流量之间的关系</a></p>
<p><a href="https://www.cnblogs.com/gaizai/p/4233780.html">二、八、十、十六进制转换（图解篇）</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>5、OSI七层模型</title>
    <url>/2019/11/18/OSI-7/</url>
    <content><![CDATA[<h2 id="一、定义"><a href="#一、定义" class="headerlink" title="一、定义"></a>一、定义</h2><p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong>（OSI model），一种概念模型，由国际标准化组织提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。定义于ISO/IEC 7498-1。</p>
<h2 id="二、OSI模型解决什么问题"><a href="#二、OSI模型解决什么问题" class="headerlink" title="二、OSI模型解决什么问题"></a>二、OSI模型解决什么问题</h2> <span id="more"></span>  

<p>伴随技术喷发，网络设备和网络软件行业兴起了几家巨头，包括思科、微软、Novell、IBM、惠普、苹果以及其它几家公司。<strong>每家都有自己的线缆和端口类型，允许各自的商业性协议。</strong>此时，如你从一家买路由器、另一家买交换机，又从别家买服务器，就会<strong>出现兼容性问题</strong>。</p>
<p>有一些处理这些问题的通容办法，比如<strong>在网络上部署网关来转换不同的协议</strong>，这会导致<strong>性能上的瓶颈</strong>（比如网络慢速部分）并会令到<strong>故障排除十分困难和费时</strong>。最终，厂商们不得不达成一个在各自产品上都能工作的通用标准，一套叫做 TCP/IP 的免费协议包。最后，那些未能采行 TCP/IP 的厂商失去市场份额，走向破产。</p>
<p><strong>ISO 创建出 OSI 模型，以助力于各厂商就通用标准达成一致，实现厂商之间的兼容。</strong>此模型包括了将总多网络功能分解为一套逻辑分层，或通俗地称为层的东西。各层只需完成其特定的一些功能，比如说你的公司专注于防火墙，那么这些防火墙将自然地与其它厂商的设备一起工作。</p>
<p><strong>此模型的优势在于每件设备设计用来出色完成一个角色，而非不充分地完成多个角色。</strong>客户可以根据其解决方案选出最好的设备，而不用死栓在一家厂商那里。同时<strong>故障排除也变得更为容易</strong>，因为确定的出错可被追踪到具体的某层。</p>
<p>OSI 模型将所有网络功能划分为七个不同的层。该层次化模型从第七层一路去往第一层。那些离用户更近、更为复杂的功能，在顶部，一直到处于底层的网络线缆规格。</p>
<h2 id="三、总览"><a href="#三、总览" class="headerlink" title="三、总览"></a>三、总览</h2><p><strong>OSI模型类似于生产车间中的流水线或单位中的部门</strong>，OSI参考模型中的一层就相当于流水线上的一道工序或单位中的一个部门，他们<strong>既相互关联又彼此独立，下层为上层提供传输服务，不关心上层传输的内容，需要标识上层所使用的协议或应用；而上层也不关心下层传输的手段，只期望能将信息最终发到通信对端的相应层次上。</strong>就好像流水线上负责装轮子的工人只会安心装自己的车轮而不会管生产底盘工人如何工作，上一个人将需要生产的产品（也就是网络中的数据）交给他，他只需要装上轮子（在通信过程中就是完成本层协议规定的动作，例如为数据打上本层的报头）然后将产品交给下一个人进行继续生产。</p>
<p>OSI七层模型的<strong>最大优点是将服务、接口和协议这三个概念明确地区分开来</strong>：服务说明某一层为上一层提供一些什么功能，接口说明上一层如何使用下层的服务，而协议涉及如何实现本层的服务；这样各层之间具有很强的独立性，互连网络中各实体采用什么样的协议是没有限制的，只要向上提供相同的服务并且不改变相邻层的接口就可以了。OSI 参考模型分为7层，<strong>高3层定义了端用户如何进行互相通信；底部4层定义了数据是如何端到端的传输。</strong>最高3层，也称之为上层(upper layer)，它们不关心网络的具体情况，这些工作是又下4层来完成。</p>
<p><img src="/2019/11/18/OSI-7/v2-854e3df8ea850c977c30cb1deb1f64db_hd.jpg" alt="v2-854e3df8ea850c977c30cb1deb1f64db_hd"></p>
<p><img src="/2019/11/18/OSI-7/osi5.png" alt="osi5"></p>
<h2 id="四、OSI模型的不足"><a href="#四、OSI模型的不足" class="headerlink" title="四、OSI模型的不足"></a>四、OSI模型的不足</h2><p>OSI模型所存在的问题是模型与协议自身的缺陷。OSI参考模型将“服务”与“协议”的定义相结合，使得参考模型变得格外复杂，实现起来更加困难，而且整体上对安全方面考虑的不够。会话层在大多数应用中很少用到，表示层几乎是空的。在数据链路层与网络层有很多子层插入，每个子层都有不同的功能。所以实际生活中我们用的绝大多数网络协议都是依照后面的TCP/IP协议制定的，只有少部分协议，比如数据中心中使用的IS-IS（Intermediate System to Intermediate System，中间系统到中间系统）是用OSI七层模型的。</p>
<h2 id="五、相关概念"><a href="#五、相关概念" class="headerlink" title="五、相关概念"></a>五、相关概念</h2><p><strong>本章节的概念比较难以理解一些，刚开始学的话建议对这些概念的定义有所了解就行，结合后边TCP/IP模型那章中的“用TCP/IP模型分析数据传输过程”部分，再回头看这些概念，会更好理解一些，因为联系实际能更方便对概念进行理解和掌握。</strong></p>
<h3 id="（一）协议号，端口号"><a href="#（一）协议号，端口号" class="headerlink" title="（一）协议号，端口号"></a>（一）协议号，端口号</h3><p>协议号是三层概念，存在于IP头部协议号字段(常见的例如：6=TCP，17=UDP)；<br>端口号是四层概念，存在于TCP或UDP源/目端口号字段(常见的例如：TCP80=HTTP, UDP53=DNS)</p>
<p>说白了都是“区分上层”用的，就是用来识别同一台计算机中进行通信的不同应用程序。但是所处的层次不一样。一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p><img src="/2019/11/18/OSI-7/1e487b21-906d-41ae-8894-d02f1037cf25.jpg" alt="1e487b21-906d-41ae-8894-d02f1037cf25"></p>
<h3 id="（二）协议的定义及作用"><a href="#（二）协议的定义及作用" class="headerlink" title="（二）协议的定义及作用"></a>（二）协议的定义及作用</h3><p>什么是协议（protocol）？ </p>
<p>是指通信双方对数据传送控制的一种约定。约定中包括对数据格式，同步方式，传送速度，传送步骤，检纠错方式以及控制字符定义等问题做出统一规定，通信双方必须共同遵守，它也叫做链路控制规程。</p>
<p><strong>通俗的来讲，协议是一种双方都明白或者必须遵守的事先约定</strong>，比如说长城上放狼烟，是因为人们已经预先设定好狼烟这个物理信号代表了“敌人入侵”这一抽象信号。这样一个“狼烟=敌人入侵”就是一个简单的协议。协议可以更复杂，比如摩尔斯码(Morse Code)，使用短信号和长信号的组合，来代表不同的英文字母。当然，通信的双方必须遵从同样的协议才能够完成通信，比如你这里的协议规定的是“长城上放狼烟代表敌人入侵”，而你通信对端的协议规定是“长城上放狼烟代表打开城门”，那就出大事儿了，这样是没法交流的，所以通信双方必须遵从相同的协议才能通信。</p>
<p>网络协议其实也是按照人的思维方式在工作，但是网络设备不会像人一样思考，所以我们当初给它设计各种协议的时候就要尽可能地为它想到这些协议所要应对的场景。</p>
<blockquote>
<p>a protocol is formally defined as a set of rules governing communication between entities at the same layer. </p>
</blockquote>
<h3 id="（三）X层设备"><a href="#（三）X层设备" class="headerlink" title="（三）X层设备"></a>（三）X层设备</h3><p>经常会听到三层交换机、二层交换机以及路由器是三层设备这种叫法。</p>
<p>工作在三层（网络层）的设备，例如路由器，指的是这台设备同时具备1-3层的功能，也就是可以支持物理层、数据链路层和网络层的所有协议；如果是一台二层（数据链路层）设备，比如二层交换机，指的是这台二层交换机同时具备1-2层的功能，也就是可以支持物理层和数据链路层的所有协议。</p>
<p>二层设备以三层设备的区别是看能不能识别三层的东西，能不能完整的运行三层协议，比如IP地址、路由等三层的东西。能识别能完整支持的就为三层设备。三层设备常用于多网段，隔离广播域。</p>
<p>还有一个概念叫四层交换机，它是一种功能，它决定传输不仅仅依据MAC地址(第二层网桥)或源/目标IP地址(第三层路由),而且依据TCP/UDP(第四层) 应用端口号。第四层交换功能就象是虚IP，指向物理服务器，也就是LVS功能。  LVS 是 Linux Virtual Server 的简写，意即 Linux 虚拟服务器，是一个开源的<a href="https://cloud.tencent.com/product/clb?from=10680">负载均衡</a>流量调度器。LVS 集群采用 IP 负载均衡技术和基于内容请求分发技术，将用户请求按照一定策略分发到后端的 Server 上，从而将一组服务器构成一个高性能的、高可用的虚拟服务器。 具体可参照<a href="https://www.cnblogs.com/zengkefu/p/5587687.html">LVS图解</a>这篇文章。</p>
<h3 id="（四）上三层，下四层"><a href="#（四）上三层，下四层" class="headerlink" title="（四）上三层，下四层"></a>（四）上三层，下四层</h3><p>下四层：物理层、链路层、网络层、传输层都是运行协议数据等保证网络通畅；接着的上面三层：会话层、表示层、应用层都是用来控制会话等。 </p>
<h3 id="（五）TCP-IP模型和OSI模型"><a href="#（五）TCP-IP模型和OSI模型" class="headerlink" title="（五）TCP\IP模型和OSI模型"></a>（五）TCP\IP模型和OSI模型</h3><p><img src="/2019/11/18/OSI-7/OSI-VS-TCPIP.jpg" alt="OSI-VS-TCPIP"></p>
<p>OSI七层模型是 ISO（国际标准化组织）制定的，为了方便学习把层级分的比较多，这七层涵盖很多分类过细导致协议太复杂实现较困难，厂家自己搞出了另一套通信协议，叫做TCP/IP，只有四层实现起来也较为方便简单，所以目前使用的几乎都是TCP/IP协议栈，现在的互联网也是基于TCP/IP的，所以在学习网络知识的时候，都是参照OSI模型的，但在使用的时候，都是使用TCP/IP模型。</p>
<p>关于两个模型具体的区别、联系，请看 <a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/">https://renyuan431.github.io/2019/11/23/6-tcp-ip/</a> 中相关部分</p>
<h3 id="（六）全双工、半双工"><a href="#（六）全双工、半双工" class="headerlink" title="（六）全双工、半双工"></a>（六）全双工、半双工</h3><p><strong>全双工</strong>（Full Duplex）是通讯传输的一个术语。 通信允许数据在两个方向上同时传输，它在能力上相当于两个单工通信方式的结合。 <strong>全双工</strong>指可以同时（瞬时）进行信号的双向传输（A→B且B→A）。 指A→B的同时B→A，是瞬时同步的。 类似于我们现在的打电话，电话两边的人可以同时说话（两端同时可以发送接收数据）。</p>
<p><strong>半双工</strong>(Half Duplex)数据传输指数据可以在一个信号载体的两个方向上传输，但是不能同时传输。 例如，在一个局域网上使用具有<strong>半双工</strong>传输的技术，一个工作站可以在线上发送数据，然后立即在线上接收数据，这些数据来自数据刚刚传输的方向。 类似于我们现在的对讲机，只有一端可以说话，在一段说话时对端只能听不能说。</p>
<h3 id="（七）冲突域、广播域"><a href="#（七）冲突域、广播域" class="headerlink" title="（七）冲突域、广播域"></a>（七）冲突域、广播域</h3><p>冲突域：可以理解称为<strong>物理划分</strong>，冲突域是连接在同一导线上的所有工作站的集合，或者说是同一物理网段上所有节点的集合或以太网上竞争同一带宽的节点集合。这个域代表了冲突在其中发生并传播的区域，这个区域可以被认为是共享段。冲突域中所有节点都链接到同一个被交换机和学习型网桥划分的相互连接的中继器集合。冲突域一般来说小于或者包含在广播域中。 一些处在数据链路层的设备能够划分冲突域，但是广播域只能由像路由器或者网络层交换机这样的网络层的设备来进行划分。</p>
<p>广播域：广播域是计算机网络的一个<strong>逻辑划分</strong>。广播域中的任意一个节点可以在数据链路层通过广播的方式到达任意一个节点。广播域可以被部署在同一个局域网或者被桥接到其他的局域网。</p>
<p><strong>冲突域是发送一个单播会影响的范围，广播域是发送一个广播会影响的范围。</strong> 二层设备（例如二层交换机）可以分割冲突域，交换机的每个接口都是一个单独的冲突域；三层设备（例如路由器）可以分割广播域，路由器的每个接口都i是一个单独的广播域，一些靠广播才能工作的协议，例如ARP、DHCP协议，到路由器接口就被隔绝了，需要进行适当的中继配置才能跨广播域起到效果。</p>
<h3 id="（八）网关"><a href="#（八）网关" class="headerlink" title="（八）网关"></a>（八）网关</h3><p>网关(Gateway)又称网间连接器、协议转换器。网关在传输层上以实现网络互连，是最复杂的网络互连设备，仅用于两个高层协议不同的网络互连。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。举个现实生活中的例子方便理解，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络（192.168.10.0/24）向另一个网络（192.168.20.0/24）发送信息，也必须经过一道“关口”，这道关口就是网关，具体来说，如果要跨网段传输数据时，要先把数据发给本网段的网关，由该网关把本网段的信息发给其他网段的网关，然后再由其他网段的网关发给目的设备。</p>
<h3 id="（九）泛洪"><a href="#（九）泛洪" class="headerlink" title="（九）泛洪"></a>（九）泛洪</h3><p>交换机将数据从所有的端口（除了接收到此帧的端口）发送出去，通常称为泛洪。如果配置了VLAN，泛洪也只在属于该VLAN ID的端口上泛洪。</p>
<h2 id="六、各层介绍"><a href="#六、各层介绍" class="headerlink" title="六、各层介绍"></a>六、各层介绍</h2><h3 id="（第七层）应用层（Application）"><a href="#（第七层）应用层（Application）" class="headerlink" title="（第七层）应用层（Application）"></a>（第七层）应用层（Application）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175324-1574502824777.png" alt="微信截图_20191123175324"></p>
<p>应用层是最接近终端用户的OSI层，这就意味着OSI应用层与用户之间是通过应用软件直接相互作用的。注意，<strong>应用层并非由计算机上运行的实际应用软件组成，而是由向应用程序提供访问网络资源的API（Application Program Interface，应用程序接口）组成</strong>，这类应用软件程序超出了OSI模型的范畴。应用层的功能一般包括标识通信伙伴、定义资源的可用性和同步通信。因为可能丢失通信伙伴，应用层必须为传输数据的应用子程序定义通信伙伴的标识和可用性。定义资源可用性时，应用层为了请求通信而必须判定是否有足够的网络资源。在同步通信中，所有应用程序之间的通信都需要应用层的协同操作。 </p>
<p>就是应用软件使用的协议，如邮箱使用的POP3，SMTP、远程登录使用的Telnet、获取IP地址的DHCP、域名解析的DNS、网页浏览的http协议等；这部分协议主要是规定应用软件如何去进行通信的。</p>
<p>http(80)、https（443）、 dns(53)、ftp(20/21)、smtp(25)、pop3(110)、telnet(23)</p>
<h3 id="（第六层）表示层（Presentation）"><a href="#（第六层）表示层（Presentation）" class="headerlink" title="（第六层）表示层（Presentation）"></a>（第六层）表示层（Presentation）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175412.png" alt="微信截图_20191123175412"></p>
<p>表示层提供多种功能用于应用层数据编码和转化，以确保以一个系统应用层发送的信息可以被另一个系统应用层识别。表示层的编码和转化模式包括公用数据表示格式、性能转化表示格式、公用数据压缩模式和公用数据加密模式。 </p>
<p>决定数据的展现（编码）形式，如同一部电影可以采样、量化、编码为RMVB、AVI，一张图片能够是JPEG、BMP、PNG等。</p>
<h3 id="（第五层）会话层（Session）"><a href="#（第五层）会话层（Session）" class="headerlink" title="（第五层）会话层（Session）"></a>（第五层）会话层（Session）</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175603.png" alt="微信截图_20191123175603"></p>
<p>为两端通信实体建立、管理及中断连接（会话），中间有认证鉴权以及检查点记录（供会话意外中断的时候可以继续，类似断点续传）,并提供3种不同的方式来组织它们之间的通信：单工、半双工、全双工 。</p>
<h3 id="（第四层）传输层（Transport）-lt-数据段-gt"><a href="#（第四层）传输层（Transport）-lt-数据段-gt" class="headerlink" title="（第四层）传输层（Transport）&lt;数据段&gt;"></a>（第四层）传输层（Transport）&lt;数据段&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175629.png" alt="微信截图_20191123175629"></p>
<p>将一个数据/文件斩件分成很多小段，标记顺序以被对端接收后可以按顺序重组数据，另外标记该应用程序使用的端口号及提供QOS（不同的应用程序使用不同计算机的端口号，同样的应用程序需要使用一样的端口号才能正常通信） 。传输层的协议有TCP、UDP。</p>
<h3 id="（第三层）网络层-Network-lt-数据包-gt"><a href="#（第三层）网络层-Network-lt-数据包-gt" class="headerlink" title="（第三层）网络层(Network)&lt;数据包&gt;"></a>（第三层）网络层(Network)&lt;数据包&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175655.png" alt="微信截图_20191123175655"></p>
<p>OSI参考模型规定网络层的主要功能有以下三点： </p>
<p>1．路径选择与中继。在点-点连接的通信子网中，信息从源结点出发，要经过若干个中继结点的存储转发后，才能到达目的结点。通信子网中的路径是指从源结点到目的结点之间的一条通路，它可以表示为从源结点到目的结点之间的相邻结点及其链路的有序集合。一般在两个结点之间都会有多条路径选择。路径选择是指在通信子网中，源结点和中间结点为将报文分组传送到目的结点而对其后继结点的选择，这是网络层所要完成的主要功能之一。 </p>
<p>2．流量控制。网络中多个层次都存在流量控制问题，网络层的流量控制则对进入分组交换网的通信量加以一定的控制，以防因通信量过大造成通信子网性能下降。 </p>
<p>3．网络连接建立与管理。在面向连接服务中，网络连接是传输实体之间传送数据的逻辑的、贯穿通信子网的端—端通信通道。</p>
<p>路由选路，选择本次通信使用的协议（http、ftp等），指定路由策略及访问控制策略（ospf、eigrp、BGP等协议），使用协议号标识上层应用 ，<strong>（IP地址在这一层，路由器以及三层交换机属于三层设备）</strong> 网络层的协议有IPV4、IPV6、OSPF等协议。</p>
<h3 id="（第二层）数据链路层-Data-Link-Layer-lt-数据帧-gt"><a href="#（第二层）数据链路层-Data-Link-Layer-lt-数据帧-gt" class="headerlink" title="（第二层）数据链路层(Data Link Layer)&lt;数据帧&gt;"></a>（第二层）数据链路层(Data Link Layer)&lt;数据帧&gt;</h3><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175720.png" alt="微信截图_20191123175720"></p>
<p>实际的物理链路是不可靠的，总会出现错误，<strong>数据链路层的作用就是通过一定的手段（将数据分成帧，以数据帧为单位进行传输）将有差错的物理链路转化成对上层来说没有错误的数据链路。</strong>它的特征参数包括：物理地址、网络拓朴结构、错误警告机制、所传数据帧的排序和流控等。其中物理地址是相对网络层地址而言的，它代表了数据链路层的节点标识技术。</p>
<p>根据端口与MAC地址，做分组（VLAN）隔离、端口安全、访问控制。（<strong>MAC地址在这一层，二层交换机属于二层设备</strong>）处理VLAN内的数据帧转发，跨VLAN间的访问，需要上升到网络层。 数据链路层有FCS（帧检验字段）用于检测数据的完整性。数据链路层的协议有ARP、PPPOE等。</p>
<h4 id="两个子层"><a href="#两个子层" class="headerlink" title="两个子层"></a>两个子层</h4><h5 id="LLC子层："><a href="#LLC子层：" class="headerlink" title="LLC子层："></a>LLC子层：</h5><p>负责识别Network layer 协议然后封装(encapsulate)数据.LLC 头部信息告诉Data Link layer 如何处理接受到的帧,LLC 也提供流控制和控制比特的编号 。</p>
<h5 id="MAC子层："><a href="#MAC子层：" class="headerlink" title="MAC子层："></a>MAC子层：</h5><p>这层定义了物理地址和拓扑结构,错误检测,流控制等.共享带宽,CSMA/CD先到先服务原则(FCFS) 。</p>
<p>物理地址通常为MAC地址：</p>
<p>MAC地址是烧录在Network Interface Card(网卡,NIC)里的MAC地址,也叫硬件地址,是由48比特长,16进制的数字组成。 </p>
<p>0 -24位 由厂家自己分配。</p>
<p>25-47位 组织唯一标志符(organizationally unique identifier,OUI).OUI是由IEEE分配给每个组织.组织按高到低的顺序分配1个唯一的全局地址给每个网卡以保证不会有重复的编号。</p>
<p>第47位 individual/Group(I/G)位,当I/G位为0的时候,我们可以设想这个地址是MAC地址的实际地址可以出现在MAC头部信息;当I/G位为1的时候,我们可以设想它为广播或多播。</p>
<p>第46位 G/L位,也叫U/L位.当这个位为0的时候代表它是由IEEE分配的全局地址;当这个位为1的时候,代表本地管理地址（例如在DECnet当中）。</p>
<p>CSMA/CD载波监听多路访问/冲突检测(carrier scnse multiple access collision detect)：设备准备发送数据以前先检查载波信首的介质访问机制。当一个节点想在网络中发送数据时，它首先检查线路上是否有其他主机的信号在传送：如果有，说明其他主机在发送数据，自己则利用退避算法等一会再试图发送；如果线路上没有其他主机的信号，自己就将数据发送出去，同时，不停的监听线路，以确信其他主机没有发送数据，如果检测到有其他信号，自己就发送一个JAM阻塞信号，通知网段上的其他节点停止发送数据，这时，其他节点也必须采用退避算法等一会再试图发送。</p>
<h3 id="（第一层）物理层-Physical-Layer-lt-比特-gt"><a href="#（第一层）物理层-Physical-Layer-lt-比特-gt" class="headerlink" title="（第一层）物理层(Physical Layer)&lt;比特&gt;"></a>（第一层）物理层(Physical Layer)&lt;比特&gt;</h3><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164057.png" alt="微信截图_20191123164057" style="zoom:50%;">

<img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164152.png" alt="微信截图_20191123164152" style="zoom: 50%;">

<img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123164159.png" alt="微信截图_20191123164159" style="zoom:50%;">



<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>物理层定义了通讯网络之间物理链路的电气或机械特性，以及激活、维护和关闭这条链路的各项操作。物理层特征参数包括：电压、数据传输率、最大传输距离、物理连接媒体等。</p>
<p>物理层将数据最终编码为用0、1标识的比特流，然后传输。（例如将QQ头像的图片，变为一串01100111100这样的数字来表示）。 <strong>物理层的作用就是通过物理手段把电脑连接起来，它主要规定了网络的一些电气特性，作用是负责传送0和1的电信号。物理层的协议有蓝牙（802.15）等。</strong></p>
<h4 id="2、介质"><a href="#2、介质" class="headerlink" title="2、介质"></a>2、介质</h4><p>同轴电缆、双绞线（非屏蔽双绞线、屏蔽双绞线），更多具体说明请看 <a href="https://renyuan431.github.io/2019/11/16/lan-and-fiber/">https://renyuan431.github.io/2019/11/16/lan-and-fiber/</a> </p>
<h4 id="3、设备"><a href="#3、设备" class="headerlink" title="3、设备"></a>3、设备</h4><p>物理层典型的设备有集线器（hub）、中继器（reperter）.中继器可以放大信号，延长网线传输距离。一般网线理论传输距离为100米，实际工作中不建议在超过70米的地方使用，丢包会很严重，传输质量无法保障；集线器相当于一个多端口的中继器，也能起到信号放大的作用，但集线器在半双工模式下工作，同一时间只能有一个方向的数据可以传输，发送的时候不能接收，接收的时候不能发送，所以集线器的所有接口都属于同一个冲突域。集线器的工作过程是接收到一个端口发来的数据后，将数据直接转发到除接收到这个数据的端口以外的所有端口上，工作效率比较低下，集线器已经被淘汰。</p>
<h2 id="七、封装、解封装"><a href="#七、封装、解封装" class="headerlink" title="七、封装、解封装"></a>七、封装、解封装</h2><h3 id="（一）封装"><a href="#（一）封装" class="headerlink" title="（一）封装"></a>（一）封装</h3><h4 id="1、定义-1"><a href="#1、定义-1" class="headerlink" title="1、定义"></a>1、定义</h4><p>将数据变为比特流的过程中，在参考模型的每一层需要添加上特定的协议报头动作。</p>
<h4 id="2、动作"><a href="#2、动作" class="headerlink" title="2、动作"></a>2、动作</h4><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175033.png" alt="微信截图_20191123175033"></p>
<p>从高层往低层依次封装，在每一层使用特定的协议，对数据进行处理，在数据前添加特定的协议报头。L代表layer，表示第几层，H表示header，表示报头，第七层的报头在DATA（数据）的前面，表示数据在第七层（应用层）的时候前边加上了该层的报头。再到下一层（第六层，表示层）时前面又加上了第六层的报头，以此类推，到了第一层物理层的时候，打上了各层报头的数据被转换成0101的电信号发送给其他设备。</p>
<p>大概流程可以理解为：在传输层将数据分段，并加入TCP头，在网络层加入IP地址，在数据链路层分别加入LLC头和MAC头，最后转换成电信号在物理层传输。 </p>
<h4 id="3、封装原则"><a href="#3、封装原则" class="headerlink" title="3、封装原则"></a>3、封装原则</h4><p>（1）每一层在上一层数据前添加协议报头</p>
<p>注：进行封装的时候是添加的“协议报头”，目前三层封装协议主要是IP协议，二层协议主要是以太网2协议，不代表只有这两个协议才能对二、三层进行封装。四层主要有TCP\UDP两个协议组成，所以在进行四层封装的时候添加的主要是这两个协议的报头。</p>
<p>（2）添加完协议报头的整体，就是该层的PDU</p>
<p>（3）每一层的PDU对于下一层来说就是上层数据（每一层的上层数据就是上层的PDU）。</p>
<h4 id="4、封装的必要参数"><a href="#4、封装的必要参数" class="headerlink" title="4、封装的必要参数"></a>4、封装的必要参数</h4><p>传输层：源端口号     目标端口号</p>
<p>网络层：源IP地址     目标IP地址</p>
<p>数据链路层：源MAC地址   目标MAC地址</p>
<h3 id="（二）解封装"><a href="#（二）解封装" class="headerlink" title="（二）解封装"></a>（二）解封装</h3><h4 id="1、定义-2"><a href="#1、定义-2" class="headerlink" title="1、定义"></a>1、定义</h4><p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123175058.png" alt="微信截图_20191123175058"></p>
<p>封装的逆过程，数据从比特流还原为数据的过程</p>
<h4 id="2、动作-1"><a href="#2、动作-1" class="headerlink" title="2、动作"></a>2、动作</h4><p>从底层往高层依次解封装，每解封装一层，会将该层的协议报头去掉</p>
<h4 id="3、解封装原则"><a href="#3、解封装原则" class="headerlink" title="3、解封装原则"></a>3、解封装原则</h4><p>（1）必须从底层往高层解封装</p>
<p>（2）解封装时，<strong>只有协议报头合理，才可以解封装</strong>，打个比方，你收到一个包裹，上面有你的名字还有你的家庭住址和电话才是你的，你才能拆开叫做合理。举例说明，<strong>如果拆二层封装，必须目的MAC地址为自己接收这个帧的MAC地址才可以进行二层解封装，如果拆三层封装，必须目的IP地址为自己接收这个数据包的IP地址才可以进行三层解封装。</strong></p>
<p>（3）解封装一旦停止，数据就会被丢弃</p>
<p>（4）解封装由接收者触发，数据必须经过解封装才可以被接收</p>
<h3 id="（三）PDU"><a href="#（三）PDU" class="headerlink" title="（三）PDU"></a>（三）PDU</h3><p><strong>PUD</strong>即协议数据单元（英语：Protocol Data Unit，缩写为_PDU_）。PDU包含来自上层的信息，以及当前层的实体附加的信息。 协议数据单元(Protocol Data Unit )物理层的 PDU是数据位（bit），数据链路层的 PDU是数据帧（frame），网络层的PDU是数据包（packet），传输层的 PDU是数据段（segment），其他更高层次的PDU是报文（message）。</p>
<h2 id="八、通信流程说明"><a href="#八、通信流程说明" class="headerlink" title="八、通信流程说明"></a>八、通信流程说明</h2><p>![o_0D_2V8B_`V86P43E6OKYDVV](OSI-7/o_0D_2V8B_%60V86P43E6OKYDVV.gif)</p>
<p><img src="/2019/11/18/OSI-7/osiencap.png" alt="osiencap"></p>
<p><img src="/2019/11/18/OSI-7/Y6OBY.gif" alt="Y6OBY"></p>
<p>从高层往低层依次封装，在每一层使用特定的协议，对数据进行处理，在数据前添加特定的协议报头。L代表layer，表示第几层，H表示header，表示报头，第七层的报头在DATA（数据）的前面，表示数据在第七层（应用层）的时候前边加上了该层的报头。再到下一层（第六层，表示层）时前面又加上了第六层的报头，以此类推，到了第一层物理层的时候，打上了各层报头的数据被转换成0101的电信号发送给其他设备。其他设备接到电信号后，由物理层将电信号转换成数据，然后发送到上层的数据链路层，拆二层报头识别后交给上一层，网络层继续拆封装并识别，以此类推直到应用层拆除所有层的报头后识别数据。</p>
<h3 id="（一）A——B通信说明（按OSI七层模型）"><a href="#（一）A——B通信说明（按OSI七层模型）" class="headerlink" title="（一）A——B通信说明（按OSI七层模型）"></a>（一）A——B通信说明（按OSI七层模型）</h3><p>两主机通信的过程，从发送者（以下简称A）到接收者（以下简称B），属于从7层（应用层）-&gt;1层（物理层）封装，然后传输到远端，再从1层（物理层）-&gt;7层（应用层）解封装的过程。</p>
<p>2个主机之间的通信，对于2台主机来说，肯定是都需要跨越7层的，而平常说的只需要去到2层或者3层，其实是对于中间系统而言的，就是说中间的交换机、路由器而言。</p>
<p>1、 当A打开了QQ这个软件，相当就到达<strong>应用层</strong>了；因为软件会根据你的操作调动机器底层的硬件工作了。  </p>
<p>2、 当A往QQ这个软件的聊天窗口里面输入信息，发出后，QQ会将这个信息保存在本地聊天记录文件MSGEX.db（一般就保存在QQ目录下以你的QQ号码为文件夹里）。以某种格式编码/保存某种信息，这可以理解为<strong>表示层</strong>了。  </p>
<p>3、 当A打开与B的聊天窗口，输入信息，按下“输入”按钮，用户的操作就完结了，剩下都是机器自己的操作了。实际传输之前QQ会先建立A与B的会话连接，才真正开始传输信息/数据（你可以理解借传输文件理解：你发送文件给对方，要等待对方按下接收，才算建立了会话，然后才开始传输。）这算<strong>会话层</strong>了。  </p>
<p>4、 会话建立后，会将A发的信息斩件，如A发送“你吃了饭没有”？<strong>传输层</strong>将这句话斩成“你”“吃”“了”“饭”“没”“有”6个数据段，标记号使用的端口号，然后准备发出去。  </p>
<p>5、 接上一层，信息还未发出去，这时候在<strong>网络层</strong>做路由选路，可以理解为，从A家出去，可以分别经“联通”“电信”“移动”3个网络中的一个再到B家。</p>
<p>网络层根据路由协议负责选路（根据链路质量、带宽、开销等方法论）。假设最后选了2条，可能就A-&gt;联通-&gt;B发送“你”“吃”“了”3个数据段，A-&gt;电信-&gt;B发送“饭”“没”“有”3个数据段。</p>
<p>选路后，<strong>这一层要标记IP包头，包头主要内容是源IP地址，目的IP地址，使用什么协议</strong>。其中源、目的IP相当于你寄信的时候的收发的地址与邮政编码，标记出发送者与接收者。而协议相当于这封信到底用什么语言书写。（只有保证2端使用同种语言，才能确保通信起来，否则你用英文写信给大妈，大妈怎么看得懂呢？）  </p>
<p>6、 然后再到<strong>数据链路层</strong>，数据链路层主要是负责同一个子网内的通信的。例如A、B连接在同一台二层交换机，就属于同一个子网，那么数据帧的通信室是不需要通过网络层的（即三层交换机或者路由器），直接在这台二层交换机就过去了。<strong>这一层打的是MAC地址的帧头，对于上述通信过程来说，就是为数据帧打上A的机器的MAC与A的网关的MAC</strong>。这一层的工作就完成了。  </p>
<p>7、 到<strong>物理层</strong>了，经过上述斩件、打完各层标签后的6个数据帧，物理层将他们翻译为N段0、1表示的比特流，然后通过光纤、铜缆进行传输。  </p>
<p>8、 当比特流传输到了远端，接着B的机器按照上述的1~7的步骤反方向运行一次即可（即由物理层到应用层）。就是一层层读取标签，传输给标签标记着的相应对象，然后摘除标签，再读取上一层标签，直到最后B的应用程序能够读到A往应用程序输入的数据为止。</p>
<h3 id="（二）A——B通信说明（按实际）"><a href="#（二）A——B通信说明（按实际）" class="headerlink" title="（二）A——B通信说明（按实际）"></a>（二）A——B通信说明（按实际）</h3><h4 id="1、总体原则"><a href="#1、总体原则" class="headerlink" title="1、总体原则"></a>1、总体原则</h4><p><img src="/2019/11/18/OSI-7/Snipaste_2019-12-10_16-36-13.jpg" alt="Snipaste_2019-12-10_16-36-13"></p>
<h4 id="2、局域网（LAN）通信步骤"><a href="#2、局域网（LAN）通信步骤" class="headerlink" title="2、局域网（LAN）通信步骤"></a>2、局域网（LAN）通信步骤</h4><p><img src="/2019/11/18/OSI-7/switch.jpg" alt="switch"></p>
<ul>
<li><p>交换机如果刚刚加电启动，它的MAC地址缓存为空，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址，根据OSI七层模型，我们知道，下四层每一层需要封装本层的报头，三层网络层封装的时候需要源目的IP地址，二层数据链路层封装的时候需要原目的MAC地址，这里PC1只知道PC3的IP地址和自己的IP地址，所以三层需要封装的参数已经知道了，但在开始通信的时候，二层封装的目的MAC地址还不知道，所以需要获得MAC地址才能完成二层数据链路层的封装，PC1会使用ARP（Address Resolution Protocol，缩写：<strong>ARP</strong>）这个协议去获取目的MAC地址用来完成二层封装。</p>
</li>
<li><p>假设PC1已经知道C的MAC地址（ARP获得目的MAC地址的过程在后边讨论）而Switch的MAC地址表项为空，PC1将数据封装好发送给Switch，Switch从接口1接收到PC1发过来的数据后，首先对数据进行解封装，将0101的比特流还原成数据，然后对二层进行解封装，知道了该数据帧的源、目的MAC地址，然后添加这个数据帧的源MAC地址，既PC1的MAC地址（AAAAAAAAAA）和对应的端口G0/1添加到自己的MAC地址表中方便以后再进行数据传输时使用，然后从自己的MAC地址表中去查找这个数据帧目的地PC3（CCCCCCCCCC）的MAC地址，但是此时由于MAC地址表项为空所以找不到对应的MAC地址，这时Switch将这个数据封装上二层帧头，从除了收到这个数据的G0/1以外的其他接口（G0/2、G0/3、G0/0）泛洪出去；</p>
</li>
<li><p>PC2和PC4都接收到了这个数据帧，这两台设备对数据帧进行解封装后查看该数据帧的目的MAC地址，发现目的MAC地址与自己的网卡MAC地址不相同，PC2和PC4丢弃这个数据帧；</p>
</li>
<li><p>在上一步中PC3也同时收到了这个数据帧，PC3对数据进行解封装后，检查目的MAC地址的时候发现，与本机相同，PC3接收这个数据包，并回发数据包对PC1进行确认，PC3封装一个源地址为自己MAC地址，目的地址是A的MAC地址，源IP为自己IP，目的IP为PC1的IP地址的数据发送给Switch；</p>
</li>
<li><p>Switch接收到这个数据，它首先添加PC3的MAC和对应的接口G0/3到自己的MAC地址表中，然后查询源MA地址表时候发现PC1的MAC地址在MAC地址表项中可以查到，此MAC地址对应端口为G0/1，Switch将这个数据帧发给接口G0/1的PC1；</p>
</li>
<li><p>PC1收到PC3发回的确认，通信成功；</p>
</li>
<li><p>通过这种形式，Switch学习到的MAC地址以及所在接口。如下：</p>
</li>
</ul>
<p><img src="/2019/11/18/OSI-7/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191124185137.jpg" alt="微信截图_20191124185137"></p>
<p>通过不停的通信，最终Switch能够获得所有端口对应的MAC地址，但需注意，MAC地址表项的老化时间为300秒，如果超过老化时间，表项会被删除，Switch需重新泛洪以获取目的MAC地址对应的表项。思科交换机查看MAC地址表的命令为：<strong>show mac-address</strong> </p>
<h4 id="3、广域网（WAN）通信步骤"><a href="#3、广域网（WAN）通信步骤" class="headerlink" title="3、广域网（WAN）通信步骤"></a>3、广域网（WAN）通信步骤</h4><p><img src="/2019/11/18/OSI-7/newL3-PC1-PC2.png" alt="newL3-PC1-PC2"></p>
<p>假设交换机如果刚刚加电启动，它的MAC地址缓存为空，两台PC的网关分别为路由器的G0/0和G0/1，此时路由器Router有去往PC1（192.168.10.1）和PC2（192.168.20.1）的路由，此时假设PC1要发送数据给PC3，假设这里是PC1要ping PC3的IP地址，PC1首先判断通信对象PC2的IP是否为同一网段地址，此时PC2为不同网段，所以数据要先发给自身的网关（192.168.10.254），所以数据的源MAC地址为PC1的MAC地址，目的MAC地址为网关（192.168.10.254）对应的MAC地址，源IP地址为自身IP地址（192.168.10.1），目的IP地址为PC2的IP地址（192.168.20.1），抓包的结果如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1.jpg" alt="PC1"></p>
<p>PC1的G0/0接口的MAC地址如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1-1.jpg" alt="PC1-1"></p>
<p>网关，Router的G0/0接口MAC地址如下：</p>
<p><img src="/2019/11/18/OSI-7/PC1-2.jpg" alt="PC1-2"></p>
<p>路由器接到数据以后，首先对数据进行解封装，将0101的比特流还原成数据，然后对二层进行解封装，查看二层的目的MAC地址和接收端口G0/0的MAC地址是否一致，确定两者一致后继续对三层解封装查看目的IP地址，网关根据目的IP按照最长匹配原则查询是否有对应路由条目，在这里路由器是有10.0网段和20.0网段的路由的：</p>
<p><img src="/2019/11/18/OSI-7/route.jpg" alt="route"></p>
<p>查询路由表发现192.168.20.0网段直连G0/1接口，需要讲数据从G0/1发出，此时三层的源、目的IP地址封装是不变的，二层封装的MAC地址发生变化，源MAC地址为发出接口的G0/1的MAC地址，目的地址为PC2的G0/0接口MAC地址：</p>
<p><img src="/2019/11/18/OSI-7/PC2-2.jpg" alt="PC2-2"></p>
<p><img src="/2019/11/18/OSI-7/PC2-3.jpg" alt="PC2-3"></p>
<p><img src="/2019/11/18/OSI-7/PC2-4.jpg" alt="PC2-4"></p>
<p><img src="/2019/11/18/OSI-7/PC2.jpg" alt="PC2"></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>1、学习方法</title>
    <url>/2019/11/16/how-to-learn-network-knowledge/</url>
    <content><![CDATA[<h1 id="学习网络知识的四个阶段"><a href="#学习网络知识的四个阶段" class="headerlink" title="学习网络知识的四个阶段"></a>学习网络知识的四个阶段</h1><p>（一）掌握协议的概念。这个协议的概念是什么，是在什么地方应用的，例如什么是路由，什么是交换。</p>
<p>（二）掌握如何使用。例如OSPF、EIGRP在现网中如何配置，如何查看，如何使用。</p>
<p>（三）掌握协议是如何工作的。协议的标准是什么，工作的机制是什么，例如EIGRP的DUAL算法是如何规定且工作的，OSPF的SPF算法是如何规定且工作的。</p>
<p>（四）掌握协议底层的工作机制和报文。例如OSPF协议中，两个路由器之间建立邻居的过程，反应在底层是什么样的，也就是报文是如何传输的，报文的格式是什么，每个报文中重要字段有什么，这些字段的含义是什么。</p>
<p>以上总结出自红茶三杯CCNP课程的路由选择原理。</p>
 <span id="more"></span>  

<p>对于计算机网络初学者来说，知道“为什么这么做”比“知道怎么做”更重要，虽然经历知道“为什么这么做？”的过程很痛苦，但一旦过了这个阶段，“知道怎么做”也就水到渠成了。但是对于初学者来说，真没必要那么深入地学习网络协议的细节，你只需要理解常见协议（例如HTTP、FTP、DHCP、DNS、ARP等常见协议）的工作过程，你理解了这些协议，理解其他的协议就是依葫芦画瓢，虽然计算机网络很讲究知识的积累，但如果你一开始把太多的精力放在了解细节上就会陷进只见树木不进森林的境地。</p>
<p>例如，数据包的结构，浏览一下各字段的作用就可以了，能记住就记住，记不住也没关系，你只需要先重点理解IP头部里的目的地址、源地址和TCP头部里的目的端口号、源端口号，这些比较简单且重要的字段的含义就行了，至于其他用的比较少的字段的含义以及每个位置为1或者0的含义这种相对难一些的概念，建议等对网络有一定的了解以后再进行学习；TCP/IP和OSI两个模型，只要先大概知道为什么要建立参考模型、每一层大概的作用及常见协议即可，我当时在入门的时候希望能把基础砸瓷实一些但事与愿违，在这两个章节纠结了很久，结果既没有弄明白每个细节，又耽误了学习进程，差点“从入门到放弃”。当然我的笔记中试图尽可能多的涵盖一些知识点，会将每一个字段的定义都写上，请参照每一篇笔记的新人学习建议进行选择性学习。</p>
<p><strong>强烈建议听懂一个知识点以后总结一份自己的笔记，因为很多东西听懂的和自己能总结完全不是一个层次，笔记是一个对知识消化并进一步总结归纳的过程，比简单的听懂视频看懂书籍要高了一个档次，虽然耗时更长，但对知识会有更深层次的理解并且记得更牢固。过一段时间回看自己的笔记，会发现自己相对之前有哪些提高。</strong></p>
<h1 id="学习一定要打好基础循序渐进"><a href="#学习一定要打好基础循序渐进" class="headerlink" title="学习一定要打好基础循序渐进"></a>学习一定要打好基础循序渐进</h1><p>这段像是一堆废话，但打好基础的过程是非常痛苦且无聊，因为一开始可能你根本看不懂这段在说什么，比如OSI七层模型每层的功能以及TCP\IP模型的报头格式这种纯理论的东西，在它所在的章节很难联系实际去理解掌握，一开始看起来很云里雾里的感觉，不像后面学了路由或者交换的知识以后马上可以在模拟器上验证，会有成就感，理论知识真的很枯燥乏味，但真心应该把这些东西掌握了再看后面，如果没有完全掌握也没关系，至少对这些理论知识的名词和概念大概有个印象，对一些重点的概念，比如报头中重要的字段，知道定义，哪怕是死记硬背下来不真正明白含义，后面等学到相关的章节或知识的时候，可能就能一通百通了，如果没真正明白也不要气馁，再翻回头对基础知识进行复习，周而复始总会真正掌握的。举个例子就是如果对二进制、十进制的换算不明白的话，会很难真正理解IP地址还有子网划分中的一些东西。</p>
<h1 id="遇到问题如何找寻答案"><a href="#遇到问题如何找寻答案" class="headerlink" title="遇到问题如何找寻答案"></a>遇到问题如何找寻答案</h1><p>如果周围有懂技术的朋友，请教他们是最快捷最直接的解决办法，但还是更建议通过搜索引擎、官方文档或做实验寻找答案，因为人的大脑可能记错答案但官方文档一般来说是不会出问题的，国内技术类网站都是中文，可以解决常见的一些疑问，但如果有比较冷门一些的问题，可能国内的中文网站已经很难找到解答，这时候思科的官方文档和官方社区是最好的求助对象，尤其是思科的官方论坛，经常有思科的技术大佬过去回答问题，是提升自我非常好的学习渠道，老外对技术细节的讨论十分到位，基本可以解决大部分疑惑，善用英文进行搜索能对学习起到很大的帮助。搜索引擎尽量别用百度，搜索的效率相对低一些，容易浪费时间。</p>
<h1 id="抓包有什么用？"><a href="#抓包有什么用？" class="headerlink" title="抓包有什么用？"></a>抓包有什么用？</h1><p>有一些故障的现象并不明显，并不是看配置就能那么轻易的找到问题的答案，需要去抓包分析，分析包的行为能帮助你给出一个排错的大概方向。一般来说 TCP用的比较多，IP头看分片，TOS字段比较多。TCP的话主要看TCP的一些机制和算法。</p>
<h1 id="如何下载学习资料"><a href="#如何下载学习资料" class="headerlink" title="如何下载学习资料"></a>如何下载学习资料</h1><p>推荐两个论坛，<a href="http://bbs.hh010.com/">鸿鹄论坛</a>以及<a href="http://bbs.vlan5.com/">攻城狮论坛</a>。鸿鹄论坛上的考试题库更新比较快，包含版本比较新，也有一些学习资料；攻城狮论坛上的学习资料比较丰富，基本上所有需要的资料在攻城狮论坛都能下载到。</p>
<h1 id="厂商的认证是否有必要考？"><a href="#厂商的认证是否有必要考？" class="headerlink" title="厂商的认证是否有必要考？"></a>厂商的认证是否有必要考？</h1><p>谈一下我浅薄的看法，还是比较建议考取厂商认证，一方面厂商认证的课程是由专业人士设计的，相对于在工作中遇到什么学什么这种学习方式，进行认证课程的学习能够在整体上比较牢固的搭建起你对网络的知识构架体系；另一方面认证也是一个敲门砖，让用人单位能更好的了解你的技术水平，为之后的面试打下基础。但拿到证书并不代表着拿到高薪offer，当上CTO，赢取白富美，走上人生巅峰，光有个认证而没有与之相匹配的技术能力是不行的，因为工作中遇到的问题不像考试有相应的答案，必须靠自己的技术去解决，所以应该将备考的过程视为提高自己技术水平的过程，在这个过程中加深对技术的理解和掌握，而且如果进入面试以后面试官发现你名不副实，花大价钱考下来的证书就显得一点用没有还会让用人单位觉得你名不副实，直接pass你。</p>
<h1 id="关于笔记的一些说明"><a href="#关于笔记的一些说明" class="headerlink" title="关于笔记的一些说明"></a>关于笔记的一些说明</h1><h2 id="关于笔记中的比喻"><a href="#关于笔记中的比喻" class="headerlink" title="关于笔记中的比喻"></a>关于笔记中的比喻</h2><p>这种用类比来解释问题往往就会面临『十个类比九个错』的尴尬局面，如果别人用类比回答你的为什么，你需要仔细想一想它的类比里究竟哪里有漏洞；类比带来的解释往往只能有片面的相似性，我们永远也无法找到绝对正确的类比，它只在我们想要通俗易懂地展示事物的特性时才能发挥较大的作用。——出自《为什么 TCP 建立连接需要三次握手》</p>
<p>我认为上面这段文字非常精髓的把在技术中使用比喻的优缺点都说到了，用比喻的话能够更快的让不懂这个技术的人较快的大概明白这个东西某一方面的特性或作用，但几乎所有比喻都不是完美的呈现事务本来面貌的，毕竟用生活中的东西和技术上的知识本来就属于两个差别比较大的不同范畴，不可能找到完全一样的事务做出完美的比喻，比喻后几乎一定会产生一定程度上的误导，笔记中既有严禁定义又使用了比喻是希望能更快的使读者对技术某一方面有更快更直观的理解，但希望看过比喻大概了解了一个技术后一定要去看该部分中更为严谨的描述，以便能够真正确切的掌握一个技术而不是仅仅对技术有个模糊且有一定偏差的印象，这不仅是对自己负责，也是今后靠技术吃饭拿到一定薪酬的保证。</p>
<h2 id="关于不同技术的出现"><a href="#关于不同技术的出现" class="headerlink" title="关于不同技术的出现"></a>关于不同技术的出现</h2><p>网络学习中比较让人头疼的一个情况就是，网络技术百花齐放般层出不穷，究其原因，新技术的出现一定是为了解决现网中遇到的实际问题或情况，而旧的技术往往不能解决或不能很好解决这些实际需要，才会开发新技术，比如后面的动态路由协议部分中，现网中有不同的动态路由协议在使用，比如BGP、OSPF等，在一般情况下OSPF协议能满足大多数企业网络的需要，但由于OSPF协议算法的限制，无法承载大批量路由条目，所以在运营商这种路由条目繁多的环境中，会使用IS - IS路由协议，但该协议也无法承载运营商之间超大规模交互路由条目的任务，这时候BGP协议粉墨登场，解决这种情况下的实际需要。所以建议在学技术时不仅要知其然，也要知其所以然，也就是不仅要知道这项技术如何使用，也要明白这项技术是为何而生，使用场景是什么，和其他协议相比有什么不同的特点。</p>
<h2 id="关于笔记中的英文"><a href="#关于笔记中的英文" class="headerlink" title="关于笔记中的英文"></a>关于笔记中的英文</h2><p>笔记中引用了一些英文的文章，在解释一些术语的时候也尽量中英文都写，主要是因为权威的RFC文档通常采用英文撰写，多了解一些专业词汇的英文是个只赚不赔的事，毕竟不可能所有疑问都有人能请教，当没法向别人请教网上又没有相应的中文资料时，查询RFC或用英文搜索是个不错的选择，多一种语言能力也能在找工作时多一个加分项。</p>
<h1 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h1><p><a href="https://www.zhihu.com/question/51074319">TCP/IP 协议到底在讲什么</a></p>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手</a></p>
<img src="/2019/11/16/how-to-learn-network-knowledge/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20201012200720.jpg" alt="微信图片_20201012200720" style="zoom: 25%;">]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>3、网线和光纤</title>
    <url>/2019/11/16/lan-and-fiber/</url>
    <content><![CDATA[<h2 id="一、网线"><a href="#一、网线" class="headerlink" title="一、网线"></a>一、网线</h2><h3 id="（一）网线简介"><a href="#（一）网线简介" class="headerlink" title="（一）网线简介"></a>（一）网线简介</h3><p><strong>双绞线</strong>（twisted pair，TP）是一种综合布线工程中最常用的传输介质，是由两根具有绝缘保护层的铜导线组成的。 把两根绝缘的铜导线按一定密度互相绞在一起，每一根导线在传输中辐射出来的电波会被另一根线上发出的电波抵消，有效降低信号干扰的程度。</p>
<img src="/2019/11/16/lan-and-fiber/UTP_cable.jpg" alt="UTP_cable" style="zoom: 67%;">

 <span id="more"></span>  



<h3 id="（二）网线分类"><a href="#（二）网线分类" class="headerlink" title="（二）网线分类"></a>（二）网线分类</h3><p>双绞线分2类，屏蔽双绞线（STP）与非屏蔽双绞线(UTP)。最大传输距离为100米，但工程中不建议使用超过75米，否则会误码率比较高导致数据传输质量下降。</p>
<h4 id="屏蔽双绞线："><a href="#屏蔽双绞线：" class="headerlink" title="屏蔽双绞线："></a>屏蔽双绞线：</h4><p>由四组两条一对地互相缠绕并包装在绝缘管套中的铜线所组成，四对不同颜色的传输线互相缠绕，每对相同颜色的线传递著来回两方向的电脉冲，这样的设计是<strong>利用了电磁感应相互抵销的原理来屏蔽电磁干扰</strong>。双绞线外的金属网（通常是铜质或铝箔）可以进一步屏蔽传输线，使之较不受外部电磁场干扰。价格相对较高，在高要求场合应用。</p>
<h4 id="非屏蔽双绞线："><a href="#非屏蔽双绞线：" class="headerlink" title="非屏蔽双绞线："></a>非屏蔽双绞线：</h4><p>构造和屏蔽双绞线相同，不过外部没有金属网包裹，价格更低、直径更小、重量更轻、易安装、易弯曲，但抗干扰性相对弱一些，在大多数环境中使用广泛。</p>
<p>一般常见的都是非屏蔽双绞线（UTP），它由四对细铜线组成，每对铜线都绞合一起，每根铜线都外裹带色的塑料绝缘层。然后整体包有一层塑料外套，使用RJ-45接头，网线原则上数字越大，版本越新，带宽也越高，价格也会相应会提高。</p>
<p><img src="/2019/11/16/lan-and-fiber/Cat5e%20cat6%20ca6a%20cat7%20Premium%20Wires-1573891144157.jpg" alt="âcat 5e cat 6âçå¾çæç´¢ç»æ"></p>
<p>CAT-1/2/3/4<br>1/2/3/4类双绞线，目前已淘汰<br>CAT-5<br>5类双绞线，可用于100M以太网传输<br>CAT-5e/6<br>超5类/6类双绞线，可用于1,000M以太网传输<br>CAT-6A<br>超6类双绞线，可用于10,000M以太网传输<br>CAT-7<br>7类双绞线，可用于更高标准（大于等于10,000M）以太网传输，必须为屏蔽线</p>
<h3 id="（三）直通线与交叉线"><a href="#（三）直通线与交叉线" class="headerlink" title="（三）直通线与交叉线"></a>（三）直通线与交叉线</h3><p>直通线：两头都是568B标准， 两端线序相同，用于不同设备之间互连，比如电脑和路由器。</p>
<p>交叉线：一头是568A，而另一头是568B， 两端线序不同，用来同种设备之间互连，比如电脑与电脑。</p>
<p><strong>现网设备接口都支持自适应功能，可以自动翻转线序，不管是直通线还是交叉线可以随意使用，目前使用的基本都是直通线。但在认证考试中要注意。</strong></p>
<h3 id="（三）水晶头的线序排列"><a href="#（三）水晶头的线序排列" class="headerlink" title="（三）水晶头的线序排列"></a>（三）水晶头的线序排列</h3><p><img src="/2019/11/16/lan-and-fiber/568B.jpg" alt="568B"></p>
<p><strong>网线中的1、2、3、6四根线的通断决定了这跟网线是否能正常工作</strong></p>
<h3 id="（四）网线制作步骤"><a href="#（四）网线制作步骤" class="headerlink" title="（四）网线制作步骤"></a>（四）网线制作步骤</h3><p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173154.png" alt="微信截图_20191123173154"></p>
<p>1、用双绞线网线钳把五类双绞线的一端剪齐（最好先剪一段符合布线长度要求的网线），然后把剪齐的一端插入到网线钳用于剥线的缺口中。注意网线不能弯，直插进去，直到顶住网线钳后面的挡位，稍微握紧压线钳慢慢旋转一圈（无需担心会损坏网络里面芯线的包皮，因为剥线的两刀之间留有一定距离，这距离通常就是里面4对芯线的直径），让刀口划开双绞线的保护胶皮，拔下胶皮。</p>
<p>2、剥除外包皮即可见到双绞线的4对8条芯线，并且可以看到每对的颜色都不同。每对缠绕的两根芯线是由一种染有相应颜色的芯线加上一条只染有少许相应颜色的白色相间芯线组成。</p>
<p>先把4对芯线一字并排排列，然后再把每对芯线分开，并按从左到右：白橙、橙、白绿、蓝、白蓝、绿、白棕、棕的顺序排列（这种排列称为568B排序）。然后用网线钳垂直于芯线排列方向剪齐。</p>
<p>3、左手水平握住水晶头，然后把剪齐、并列排列的8条芯线对准水晶头开口并排插入水晶头中，注意一定要使各条芯线都插到水晶头的底部，不能弯曲。确认所有芯线都插到水晶头底部后，即可将插入网线的水晶头直接放入网线钳压线缺口中。水晶头放好后即可压下网线钳手柄，一定要使劲，使水晶头的插针都能插入到网线芯线之中，与之接触良好。</p>
<p>4、用测线仪检测网线连通性，看网线是否制作成功。</p>
<p>至此，这个RJ-45头就压接好了。按照相同的方法、同样的排线顺序制作双绞线的另一端水晶头，要注意的是芯线排列顺序一定要与另一端的顺序完全一样，这样整条网线的制作就算完成了。</p>
<h2 id="二、光纤"><a href="#二、光纤" class="headerlink" title="二、光纤"></a>二、光纤</h2><h3 id="（一）光纤简介"><a href="#（一）光纤简介" class="headerlink" title="（一）光纤简介"></a>（一）光纤简介</h3><p>光导纤维，简称光纤，是一种由玻璃或塑料制成的纤维，利用光在这些纤维中以全内反射原理传输的光传导工具。微细的光纤封装在塑料护套中，使得它能够弯曲而不至于断裂。通常光纤的一端的发射装置使用发光二极管或一束激光将光脉冲传送至光纤中，光纤的另一端的接收装置使用光敏元件检测脉冲。包含光纤的线缆称为光缆。</p>
<p><strong>光纤是一种比较脆弱的传输介质，使用中切忌拉扯、挤压，会造成光纤永久性的损坏。</strong></p>
<p><img src="/2019/11/16/lan-and-fiber/fiber-1573891431396.jpg" alt="fiber"></p>
<h3 id="（二）光纤分类"><a href="#（二）光纤分类" class="headerlink" title="（二）光纤分类"></a>（二）光纤分类</h3><p>支持的多种传播路径或横向模式的光纤被称为多模光纤(MMF)，而支持单一模式的被称为单模光纤（SMF）。单模光纤采用固体激光器做光源，多模光纤则采用发光二极管做光源。</p>
<p><img src="/2019/11/16/lan-and-fiber/f_23ea6035fa6826458ab1312d34a56574.jpg" alt="âå¤æ¨¡åçº¤ åæ¨¡åçº¤âçå¾çæç´¢ç»æ"></p>
<h3 id="（三）单模、多模的区别"><a href="#（三）单模、多模的区别" class="headerlink" title="（三）单模、多模的区别"></a>（三）单模、多模的区别</h3><p>多模光纤的芯线粗、传输距离短、整体传输性差，传输距离相对单模来说较短（最长约2KM），但是成本相对低廉，一般用于建筑物内部或地理位置相邻的环境下，多模光纤跳线大多数橙色的。单模光纤的纤芯相应较细，传输距离远（最长约100KM）、但成本较高，单模光纤条线大多数黄色的。</p>
<p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173535.png" alt="微信截图_20191123173535"></p>
<h3 id="（四）常见光纤使用场景"><a href="#（四）常见光纤使用场景" class="headerlink" title="（四）常见光纤使用场景"></a>（四）常见光纤使用场景</h3><p>机房中常见的光纤使用场景是将接入层交换机与上层的汇聚层连接起来，或汇聚层、核心层设备之间相互连接。</p>
<p><img src="/2019/11/16/lan-and-fiber/SFPGESST.E.jpg" alt="âswitch cisco fiberâçå¾çæç´¢ç»æ"></p>
<p>接入交换机的光纤模块</p>
<img src="/2019/11/16/lan-and-fiber/fiber-optic-cable-connect-to-ethernet-switch-mount-rack-85811589.jpg" alt="âswitch connect with fiberâçå¾çæç´¢ç»æ" style="zoom: 50%;">

<p>用光纤连接网络设备</p>
<h3 id="（五）光纤接头连接器"><a href="#（五）光纤接头连接器" class="headerlink" title="（五）光纤接头连接器"></a>（五）光纤接头连接器</h3><p>“/”前面部分表示尾纤的连接器型号：<br>“SC”接头是标准方型接头，采用工程塑料，具有耐高温，不容易氧化优点。传输设备侧光接口一般用SC接头<br>“LC”接头与SC接头形状相似，较SC接头小一些。<br>“FC”接头是金属接头，一般在ODF侧采用，金属接头的可插拔次数比塑料要多。</p>
<p>“/”后面表明光纤接头截面工艺，即研磨方式：<br>“PC” 微球面研磨抛光，在电信运营商的设备中应用得最为广泛，其接头截面是平的，。<br>“UPC”的衰耗比“PC”要小，一般用于有特殊需求的设备，一些国外厂家ODF架内部跳纤用的就是FC/UPC，主要是为提高ODF设备自身的指标。<br>“APC”呈8度角并做微球面研磨抛光，可改善电视信号的质量。</p>
<p><img src="/2019/11/16/lan-and-fiber/8c89a5e925a216b29e3501.png"></p>
<p><img src="/2019/11/16/lan-and-fiber/fiber-classification.jpg" alt="fiber-classification"></p>
<h4 id="1、ST接口（常用于光纤配线架-）"><a href="#1、ST接口（常用于光纤配线架-）" class="headerlink" title="1、ST接口（常用于光纤配线架 ）"></a>1、ST接口（<em>常用于光纤配线架</em> ）</h4><p>ST(AT&amp;T版权所有)，也许是多模网络(例如大部分建筑物内或园区网络内)中最常见的连接设备。它具有一个卡口固定架，和一个2.5毫米长圆柱体的陶瓷(常见)或者聚合物卡套以容载整条光纤。</p>
<p>ST的英文全称有时记做”Stab &amp; Twist”，很形象的描述，首先插入，然后拧紧！</p>
 <img src="/2019/11/16/lan-and-fiber/0012175_10m-singlemode-simplex-fiber-optic-patch-cable-9125-st-to-st.jpeg" alt="“ST fiber”的图片搜索结果" style="zoom: 33%;"> 

<p><img src="/2019/11/16/lan-and-fiber/16154597.jpg" alt="16154597"></p>
<h4 id="2、SC接口（常用于交换机-）"><a href="#2、SC接口（常用于交换机-）" class="headerlink" title="2、SC接口（常用于交换机 ）"></a>2、SC接口（<em>常用于交换机</em> ）</h4><p>SC同样具有2.5毫米卡套，不同于ST/FC，它是一种插拔式的设备，因为性能优异而被广泛使用。它是TIA-568-A标准化的连接器，但初期由于价格昂贵(ST价格的两倍)而没有被广泛使用。</p>
<p>材质为塑料，推拉式连接，接口可以卡在光模块上，常用于交换机。</p>
<p>SC的英文全称有时记做”Square Connector”, 因为SC的外形总是方状的。</p>
 <img src="/2019/11/16/lan-and-fiber/0012051_2m-singlemode-duplex-fiber-optic-patch-cable-9125-lc-to-sc.jpeg" alt="“SC fiber”的图片搜索结果" style="zoom: 33%;"> 

<h4 id="3、LC接口（用于路由器上连接SFP光模块-）"><a href="#3、LC接口（用于路由器上连接SFP光模块-）" class="headerlink" title="3、LC接口（用于路由器上连接SFP光模块 ）"></a>3、LC接口（用于路由器上连接SFP光模块 ）</h4><p>材质为塑料，用于连接SFP光模块，接口可以卡在光模块上。</p>
<p> <img src="/2019/11/16/lan-and-fiber/lc-fiber-optic-connector-500x500.png" alt="“LC fiber”的图片搜索结果"> </p>
<h4 id="4、光模块"><a href="#4、光模块" class="headerlink" title="4、光模块"></a>4、光模块</h4><p>光模块的作用就是光电转换，发送端把电信号转换成光信号，通过光纤传送后，接收端再把光信号转换成电信号。</p>
<img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123173804.png" alt="微信截图_20191123173804" style="zoom:67%;">

<p>短波模块-单模光纤-短波模块：不可行！因为短波模块的发光口大于单模光纤的纤芯直径，部分光信号无法进入光纤 </p>
<p>长波模块-多模光纤-长波模块：一般可行，因为长波模块的发光口小于多模光纤的纤芯直径，所有光信号能够进入光纤。但传输距离受多模光纤限制，只有几百米，甚至连不通的情况！ </p>
<p>长波模块-多模光纤-短波模块：不可行！两端波长必须相同！</p>
<h3 id="（六）光纤打环测试"><a href="#（六）光纤打环测试" class="headerlink" title="（六）光纤打环测试"></a>（六）光纤打环测试</h3><p>可以把光纤弯曲到一定的程度（一般光纤的弯曲度都是有规定的，国家规定光缆的最小弯曲半径是静态10倍缆径，动态20倍缆径）。然后用光功率计（如果已经做上连接头的话）或者OTDR（光时域反射仪）来测试光缆的衰减。正常情况下是光纤的衰减值越小，证明光纤越好。如果是光缆，那就还得看一下光缆的外径和所使用的纺伦，一般是外径越粗越好，纺伦越是细腻光亮越好。<br>单多模光纤都可以使用以上方法测试。</p>
<p>在没有光功率计的时候，用一根光纤将光模块的TX侧和RX侧连接起来，对光模块进行自环测试（长距离光模块必须通过光衰器件互连），如果接口指示灯常亮，接口可以Up，说明本侧的接口和光模块正常；否则说明接口或者光模块可能存在问题，建议更换正常的光模块或者接口测试。</p>
<h3 id="（七）光模块安装与移除"><a href="#（七）光模块安装与移除" class="headerlink" title="（七）光模块安装与移除"></a>（七）光模块安装与移除</h3><h4 id="1、光模块的安装"><a href="#1、光模块的安装" class="headerlink" title="1、光模块的安装"></a>1、光模块的安装</h4><p><img src="/2019/11/16/lan-and-fiber/imgDownload.png" alt="imgDownload"></p>
<p>安装前，要仔细检查光模块的金手指是否明亮齐整，是否干净，拉杆是否完好。</p>
<p>安装时，要仔细辨别光纤口的方向，不要插反。插入光纤跳线时能够听到轻微的听到“啪”的声音或感到轻微震动。 </p>
<p>安装后，要确定光模块的拉杆固定好，光模块的安装到位，不会轻易拔出。</p>
<h4 id="2、光模块的移除"><a href="#2、光模块的移除" class="headerlink" title="2、光模块的移除"></a>2、光模块的移除</h4><p><img src="/2019/11/16/lan-and-fiber/A1117-SFP_remove.jpg" alt="A1117-SFP_remove"></p>
<h4 id="3、注意事项"><a href="#3、注意事项" class="headerlink" title="3、注意事项"></a>3、注意事项</h4><p><strong><span style="color:red">永远不要让光纤尾部正对你的眼睛，永远不要向光纤里面看，不要直接或使用仪器看光纤尾部。激光是不可见的，但可能会对人眼造成永久伤害</span></strong> </p>
<h3 id="（八）光纤配线架"><a href="#（八）光纤配线架" class="headerlink" title="（八）光纤配线架"></a>（八）光纤配线架</h3><img src="/2019/11/16/lan-and-fiber/timg.jpg" alt="timg" style="zoom:67%;">

<p><img src="/2019/11/16/lan-and-fiber/timg%20(1).jpg" alt="timg (1)"></p>
<h4 id="1、定义"><a href="#1、定义" class="headerlink" title="1、定义"></a>1、定义</h4><p>光纤配线架用于光缆终端光纤熔接、光连接器的调节、多余尾纤的存储及光缆保护等功能 。</p>
<h4 id="2、使用连接示意图"><a href="#2、使用连接示意图" class="headerlink" title="2、使用连接示意图"></a>2、使用连接示意图</h4><p><img src="/2019/11/16/lan-and-fiber/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20191123174708.png" alt="微信截图_20191123174708"></p>
<h3 id="（八）参考文章"><a href="#（八）参考文章" class="headerlink" title="（八）参考文章"></a>（八）参考文章</h3><h4 id="1、教你如何认识各种光纤接口类型"><a href="#1、教你如何认识各种光纤接口类型" class="headerlink" title="1、教你如何认识各种光纤接口类型"></a><a href="http://blog.51cto.com/68240021/1980520">1、教你如何认识各种光纤接口类型</a></h4>]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>6、tcp/ip参考模型</title>
    <url>/2019/11/23/6-tcp-ip/</url>
    <content><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><img src="/2019/11/23/6-tcp-ip/TCP-IP%E6%A8%A1%E5%9E%8B%20(2)%20(1).jpg" alt="TCP-IP模型 (2) (1)" style="zoom: 67%;">

 <span id="more"></span>  

<p><img src="/2019/11/23/6-tcp-ip/tcpipprotocols.png" alt="tcpipprotocols"></p>
<p>互联网协议套件（英语：Internet Protocol Suite，缩写IPS）是一个网络通信模型，以及一整个网络传输协议家族，为网际网络的基础通信架构。它常被通称为TCP/IP协议族（英语：TCP/IP Protocol Suite，或TCP/IP Protocols），简称TCP/IP。因为该协议家族的两个核心协议：TCP（传输控制协议）和IP（网际协议），为该家族中最早通过的标准。由于在网络通讯协议普遍采用分层的结构，当多个层次的协议共同工作时，类似计算机科学中的堆栈，因此又被称为TCP/IP协议栈（英语：TCP/IP Protocol Stack）。这些协议最早发源于美国国防部（缩写为DoD）的ARPA网&lt;高级研究计划局网络（英语：Advanced Research Projects Agency Network），通称阿帕网（英语：ARPANET）是美国国防高级研究计划局开发的世界上第一个运营的数据包交换网络，是全球互联网的鼻祖。&gt;项目，因此也被称作DoD模型（DoD Model）。这个协议族由互联网工程任务组负责维护。</p>
<p>TCP/IP提供了点对点链接的机制，将数据应该如何封装、定址、传输、路由以及在目的地如何接收，都加以标准化。它将软件通信过程抽象化为四个抽象层，采取协议堆栈的方式，分别实现出不同通信协议。协议族下的各种协议，依其功能不同，被分别归属到这四个层次结构之中，常被视为是简化的七层OSI模型。</p>
<h2 id="TCP-IP和OSI模型对比"><a href="#TCP-IP和OSI模型对比" class="headerlink" title="TCP/IP和OSI模型对比"></a>TCP/IP和OSI模型对比</h2><p><img src="/2019/11/23/6-tcp-ip/999804-20170926194048637-1078586652.png" alt="999804-20170926194048637-1078586652"></p>
<ol>
<li><p>OSI引入了服务、接口、协议、分层的概念，TCP/IP借鉴了OSI的这些概念建立TCP/IP模型。</p>
</li>
<li><p>OSI先有模型，后有协议，先有标准，后进行实践；而TCP/IP则相反，先有协议和应用再提出了模型，且是参照的OSI模型。</p>
</li>
<li><p>OSI是一种理论下的模型，而TCP/IP已被广泛使用，比如现在我们每天都在用的互联网就是用的TCP/IP协议。</p>
</li>
<li><p>OSI 参考模型注重“通信协议必要的功能是什么”，而 TCP/IP 则更强调“在计算机上实现协议应该开发哪种程序”。</p>
</li>
</ol>
<p><strong>简单来说，OSI参考模型和TCP/IP参考模型，其实都是每一层加上本层的报头然后发给其他层这么一个工作模式，不过分层方式有所不同，现在的互联网用的都是TCP/IP，因为OSI分层太多，有些层没必要，比如表示层、会话层，在TCP/IP模型中应用层都搞定了。</strong></p>
<h2 id="TCP-IP相关概念"><a href="#TCP-IP相关概念" class="headerlink" title="TCP\IP相关概念"></a>TCP\IP相关概念</h2><h3 id="TCP-IP-的具体含义"><a href="#TCP-IP-的具体含义" class="headerlink" title="TCP/IP 的具体含义"></a>TCP/IP 的具体含义</h3><p>TCP/IP（Transmission Control Protocol/Internet Protocol，传输控制协议/网际协议）是指能够在多个不同网络间实现信息传输的协议簇。TCP/IP协议不仅仅指的是TCP 和IP两个协议，而是指一个由FTP、SMTP、TCP、UDP、IP等协议构成的协议簇， 只是因为在TCP/IP协议中TCP协议和IP协议最具代表性，所以被称为TCP/IP协议。</p>
<p>互联网进行通信时，需要相应的网络协议，TCP/IP 原本就是为使用互联网而开发制定的协议族。因此，互联网的协议就是 TCP/IP，TCP/IP 就是互联网的协议。</p>
<p><img src="/2019/11/23/6-tcp-ip/tcpip.jpg" alt="tcpip"></p>
<h3 id="数据的格式"><a href="#数据的格式" class="headerlink" title="数据的格式"></a>数据的格式</h3><p>一般而言，数据包含报文头部（报头、header）、数据（Data、载荷、Payload）、报文尾部（Footer、Trailer）。</p>
<p><strong>报文头部</strong>：在实际数据部分之前的信息，一般包含少量的控制信息，这些控制信息用于传达有关报文所包含的数据以及如何使用这些数据的信息。例如四层的数据段（Segment）的TCP报头中包含了源目地端口号（用来定位数据交给上层的哪个程序处理）等信息；三层的数据包（Packet）的IP报头中包含了源目地IP地址（用来在互联网上找到通信双方的位置）等信息。</p>
<p><strong>数据</strong>：真正需要传递的数据，一般也叫做载荷。有些消息承载了各种各样的数据，有些消息并没有承载任何数据，这种没有承载任何数据的消息是用作控制在和沟通目的的，比如TCP的三次握手和四次分手的过程中的消息是没有承载任何数据的。</p>
<p><strong>报文尾部</strong>：哪些在数据后面的信息，报文头部的信息和报文尾部的信息没有真正的区别，他们都包含了特定的控制信息。只在某些情况下使用报文尾部，特别是在字段中的数据是基于要传输的数据的值来计算的情况下。</p>
<p>看完上面你可能会有疑问，为什么要区别出来报文头部和报文尾部呢？两者看上去功能完全相同，为什么不合二为一，非要分个头尾不同的部分？是因为有些类型的控制信息（例如FCS，详见<a href="https://renyuan431.github.io/2019/11/23/6-tcp-ip/#%E4%BB%A5%E5%A4%AA%E7%BD%912%E5%B8%A7%E5%A4%B4%E5%88%86%E6%9E%90">二层部分</a>）是利用数据本身的值来计算的。在某些情况下，在发送数据有效载荷的同时进行这种计算，然后在有效载荷后以页脚的形式传输结果，这样做更有效率。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-01_16-54-42.jpg" alt="Snipaste_2020-05-01_16-54-42"></p>
<h3 id="数据段、数据包、数据帧、比特、PDU"><a href="#数据段、数据包、数据帧、比特、PDU" class="headerlink" title="数据段、数据包、数据帧、比特、PDU"></a>数据段、数据包、数据帧、比特、PDU</h3><p><img src="/2019/11/23/6-tcp-ip/featured-4.jpg" alt="featured-4"></p>
<p><img src="/2019/11/23/6-tcp-ip/tcp_pdus.png" alt="tcp_pdus"></p>
<p>协议数据单元PDU（Protocol Data Unit）是指对等层次之间传递的数据单位。</p>
<ul>
<li>数据链路层的PDU叫做Frame（帧）</li>
<li>网络层的PDU叫做Packet（数据包）</li>
<li>传输层TCP的PDU叫做Segment（数据段），UDP的PDU叫做Datagram。（数据报）</li>
<li>物理层传输的PDU叫Bit(比特)</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-13_14-10-29.jpg" alt="Snipaste_2019-12-13_14-10-29"></p>
<p>为什么每层的PDU要有不同的命名呢？</p>
<blockquote>
<p>In some cases, the different terms can be very useful, because the name used to refer to a particular message can tell you something about what the message contains, as you will see shortly. In particular, different message names are usually associated with protocols and technologies operating at specific layers of the OSI Reference Model. Thus, the use of these different names can help clarify discussions that involve multiple protocols operating at different layers. </p>
</blockquote>
<p>因为在某些情况下，不同的术语可能非常有用，因为用来指代一个特定报文的名称可以告诉你一些关于该报文包含的内容，特别是，不同的报文名称通常与在OSI参考模型的特定层中运行的协议和技术有关。因此，使用这些不同的名称可以帮助澄清涉及在不同层操作的多个协议的讨论。举个例子就是，如果严谨的使用这些术语，一说数据帧，我们就能知道这是封装到二层，数据链路层，的数据，报头中封装的是数据链路层的报头，源、目的MAC地址。但如果不严格使用这些属于就可能传达混淆的信息，当然有些人混用以上这几个术语，有些人则逻辑严谨的使用，必须在与他人交流或学习网络知识的时候注意这些。</p>
<h3 id="什么是TCP的连接"><a href="#什么是TCP的连接" class="headerlink" title="什么是TCP的连接"></a>什么是TCP的连接</h3><blockquote>
<p>The reliability and flow control mechanisms described above requirethat TCPs initialize and maintain certain status information foreach data stream.  The combination of this information, including sockets, sequence numbers, and window sizes, is called a connection.</p>
</blockquote>
<p>上面提到的TCP的可靠和流量控制机制，需要TCP为每个信息流数据初始化并维持特定的状态信息。包括sockets、序列号和窗口大小在内的这些信息的集合，叫做连接。</p>
<h3 id="面向连接协议与无连接协议"><a href="#面向连接协议与无连接协议" class="headerlink" title="面向连接协议与无连接协议"></a>面向连接协议与无连接协议</h3><p>面向连接（Connection-Oriented）：是指发送数据之前必须在两端建立逻辑连接（logical connection）。通常建立连接的方式是通过遵循一系列规则来完成的，这些规则指定了应如何发起，协商，管理以及最终终止连接的方式。 通常，一台设备首先发送打开连接的请求，而另一台则响应。 设备传递控制信息，以确定是否以及如何建立连接。 如果成功，则在设备之间发送数据。 完成后，连接断开。TCP建立逻辑连接的方法是“三次握手”，这样能建立可靠的连接。</p>
<p>无连接（Connection-less）：是指发送数据之前不在两端建立连接。即使对端主机关机或不存在，数据包还是会被发送出去。反之，对于一台主机来说，它会何时从哪里收到数据也是不得而知的。通常应该进行网络监控，让主机只接收发给自己的数据包。若没有做好准备很有可能会错过一些该收的包。因此，在面向无连接的方式下可能会有很多冗余的通信。</p>
<h3 id="可靠传输与不可靠传输"><a href="#可靠传输与不可靠传输" class="headerlink" title="可靠传输与不可靠传输"></a>可靠传输与不可靠传输</h3><blockquote>
<p>Thus, to support these applications, something has to be done to <strong>guarantee</strong> that the data sent by one end of the application is delivered <strong>correctly</strong> and <strong>completely</strong> to the other end of the application. If a protocol provides such a guaranteed data delivery service, it is said to provide reliable data transfer.</p>
</blockquote>
<p>分组可能会在网络中丢失、损坏，应用层可能对网络通信有所要求，不允许出现这种差错，<strong>必须保证接收方的应用收到了完整且正确的数据，这种服务就是可靠数据传输服务。</strong>如果一个协议可以确保发送端发送了怎样的数据，那么接收端就必然能接收到怎样的数据，那么就可以说这个协议提供了可靠数据传输服务，这个协议是可靠（Reliable）的，反之则是不可靠（Unreliable）的。</p>
<h3 id="端口号、协议号以及通信如何识别"><a href="#端口号、协议号以及通信如何识别" class="headerlink" title="端口号、协议号以及通信如何识别"></a>端口号、协议号以及通信如何识别</h3><p>数据链路和 IP 中的地址，分别指的是 MAC 地址和 IP 地址。前者用来识别同一链路中不同的计算机，后者用来识别 TCP/IP 网络中互连的主机和路由器。在传输层也有这种类似于地址的概念，那就是端口号，端口号用来识别同一台计算机中进行通信的不同应用程序。因此，它也被称为程序地址；在网络层的类似概念就是协议号。</p>
<p>类比到相对熟悉的概念就是流水线上，比如造车的时候先有底盘，然后装传动轴，再装轮胎，不同的车型用的轮胎和轴承不同，底盘生产出来以后就得告诉下一步组装传动轴的，这个底盘要装什么类型的传动轴，传动轴工序完毕以后要告诉装轮胎的，我这个传动轴要配什么轮胎，否则下一步不知道如何处理上一步给过来的零件，数据传输中，这个告诉下一步要如何处理的功能就是由端口号、协议号实现的。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145437.jpg" alt="微信图片编辑_20200113145437"></p>
<p>协议号（Protocol）是三层概念，存在于IP头部协议号字段，解封装时，如果上一层是TCP就将IP包首部之后的部分传给TCP处理；如果是UDP则将IP包首部后面的部分传给UDP处理(常见的例如：6=TCP，17=UDP)；</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113145310.jpg" alt="微信图片编辑_20200113145310"></p>
<p>端口号是四层概念，存在于TCP或UDP源/目端口号字段，用以识别发送主机跟接收主机上的应用，解封装时会根据端口号的不同，传给由端口号识别的应用程序。常见的例如：TCP80=HTTP, UDP53=DNS，如果目的端口号是80，就交给上层的HTTP协议去处理，如果目的端口号是53就交给DNS协议去处理。</p>
<p>说白了都是“区分上层”用的，就是用来识别同一台计算机中进行通信的不同应用程序。但是所处的层次不一样。一台计算机上同时可以运行多个程序。传输层协议正是利用这些端口号识别本机中正在进行通信的应用程序，并准确地将数据传输。</p>
<p>之所以有如此多的端口号是因为通信并不是由端口号一个字段决定的，识别一个通信是由五元组（<strong>源IP地址、目标IP地址、源端口号、目标端口和协议号</strong>）一起决定的。源IP地址决定了通信起源设备，目标IP地址决定了通信目的设备，但仅有源、目的IP地址不能识别一个通信，因为一台设备可以同时运行多个程序，下面举个接收端的例子来说明：</p>
<p>设备收到了一个数据后，先通过把物理层的电磁信号还原成二层的数据帧，然后看二层数据帧帧头的目的MAC地址和自己所接收端口的MAC地址是否相一致，如果一致就继续解封装到三层，查看目的IP地址是否是自己的，如果是自己的IP地址，再看协议号中的字段规定使用的是TCP还是UDP协议，然后将这个数据交给相应的四层（应用层）协议去处理，应用层处理以后，怎么知道把该数据交给上层（应用层）的哪个程序去处理呢？这就要通过端口号了，如果端口号是80，说明这是一个http协议，交给http处理，如果有多个http进程，则可以根据通信的五元组中其他不同的部分加以区分，其他的协议以此类推。</p>
<p><img src="/2019/11/23/6-tcp-ip/1e487b21-906d-41ae-8894-d02f1037cf25-1577770747233.jpg" alt="1e487b21-906d-41ae-8894-d02f1037cf25"></p>
<p><img src="/2019/11/23/6-tcp-ip/c9daa-20190821100721-bd5df.jpeg" alt="c9daa-20190821100721-bd5df"></p>
<p><img src="/2019/11/23/6-tcp-ip/3d251-20190821100721-c0e40.jpeg" alt="3d251-20190821100721-c0e40"></p>
<ul>
<li>① 和② 的通信是在两台计算机上进行的。它们五元组中的源、目的IP（源IP为192.168.4.22，目标地址为192.168.4.20），协议号（TCP6）以及目标端口号（80）均相同。这里可以根据五元组的源端口号加以区分。</li>
<li>③ 和 ① 的目标端口号和源端口号完全相同，但它们各自的源 IP 地址不同。</li>
<li>此外，当 IP 地址和端口号全都一样时，我们还可以通过协议号来区分（TCP 和 UDP）。</li>
</ul>
<h3 id="MTU、Default-media-MTU、Default-IP-MTU、Protocol-MTU"><a href="#MTU、Default-media-MTU、Default-IP-MTU、Protocol-MTU" class="headerlink" title="MTU、Default media MTU、Default IP MTU、Protocol MTU"></a>MTU、Default media MTU、Default IP MTU、Protocol MTU</h3><p>MTU是最大传输单元的英文简写（<strong>M</strong>aximum <strong>T</strong>ransmission <strong>U</strong>nit）</p>
<blockquote>
<p>the maximum transmission unit (MTU) is the size of the largest protocol data unit (PDU) that can be communicated in a single network layer transaction</p>
</blockquote>
<p>最大传输单元（MTU）是可以在单个网络层事务中通信的最大协议数据单元（PDU）的大小，简单来说也就是 <strong>TCP 数据段能够携带的数据上限</strong>。MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，更小的 MTU 意味着更低的网络延迟。每一个物理设备都有自己的 MTU，<strong>两个主机之间的 MTU 依赖于底层的网络能力，它由整个链路上 MTU 最小的物理设备决定</strong>。</p>
<p>Default media MTU是Juniper的叫法，个人觉得Juniper的命名方式比较清楚，所以以下均采用Juniper的方式。Default IP MTU和Default media MTU（MTU）不是同一个概念。Juniper有个计算公式：</p>
<p>Default media MTU = Default IP MTU + encapsulation overhead</p>
<p>encapsulation overhead 在现网中就是 Ethernet header，因为二层的协议用的都是以太网2封装技术，以太网头部（14字节）但<strong>不包括尾部的FCS校验部分</strong>（4字节），所以：</p>
<p>Default media MTU = 1500 （Default IP MTU） + 14（encapsulation overhead，6字节的目的MAC＋6字节的源MAC＋2字节的帧类型） =1514字节。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200129143940.jpg" alt="微信图片编辑_20200129143940"></p>
<p>Default IP MTU=TCP header + IP header + TCP segment length（也就是图中的Data部分） </p>
<p>Default IP MTU（1500字节）= TCP header（20字节） + IP header（20字节） + TCP segment length（1460字节）</p>
<p>注1：TCP MSS 、Payload、 DATA 以及 TCP segment length其实是同一个东西</p>
<p>注2：抓包软件抓到的是去掉前导同步码、帧开始分界符、CRC校验之外的数据，其最大值是6＋6＋2＋1500＝1514，这个在Juniper这就是Default media MTU</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200129144404.jpg" alt="微信图片编辑_20200129144404"></p>
<p>如果IP层有&lt;=1500 byte 需要发送，只需要一个IP包就可以完成发送任务；如果IP层有&gt; 1500 byte 数据需要发送，需要分片才能完成发送，这些分片有一个共同点，即IP Header ID相同。但如果分片的话，会导致网络传输效率降低，所以要尽量避免分片。</p>
<blockquote>
<p>Why we ‘ve both of Interface MTU and IP MTU?</p>
<p>IP MTU will only affect IP packets while MTU will affect all ethernet frames. It gives you a bit more granularity to only set the MTU for IP packets.</p>
</blockquote>
<p>为什么同时需要Default IP MTU和Default media MTU这两个概念呢？</p>
<p>因为IP MTU仅仅影响IP包，Default media MTU将影响所有以太网帧，这样区分概念可以为网络提供更高的颗粒度，比如可以仅仅设置IP MTU而不影响以太网帧。</p>
<p>当然，上面这个解答是在二层用以太网封装的情况下，如果用PPP或其他方式的话，上文中的Default media MTU影响的就不是所有以太网了。</p>
<h3 id="最大分段大小（MSS）"><a href="#最大分段大小（MSS）" class="headerlink" title="最大分段大小（MSS）"></a>最大分段大小（MSS）</h3><p>“最大分段大小”（英语：<strong>M</strong>aximum <strong>S</strong>egment <strong>S</strong>ize）。TCP提交给IP层最大分段大小，不包含TCP Header和 TCP Option，只包含TCP Payload ，注意，<strong>UDP是没有MSS这个概念的</strong>。MSS是TCP用来限制application层最大的发送字节数，是tcp能发送的分组的最大长度。MSS是系统默认的，就是系统TCP/IP栈所能允许的最大包。<strong>在建立连接的三次握手时，这个MSS值经过双方协商后已经被确定了</strong>，这个值并不是客观的值，而是由tcp/ip的实现确定的，<strong>TCP在传送大量数据时，是以MSS的大小将数据进行分割发送。进行重发时也是以MSS为单位。</strong>下图中，左右两边的MSS都是1460。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_13-48-20.jpg" alt="Snipaste_2020-01-26_13-48-20" style="zoom:150%;">

<p>如果两边的MSS值不同，则MSS会使用较小值。通信双方最终的MSS一般情况下 = 双方较小IP MTU - 40。这个40是由20字节的IP Header和20字节的TCP Header构成的，但如果IP Header和TCP Header的大小有变化，比如下图中的MSS就是1448位：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-02_15-17-34.jpg" alt="Snipaste_2020-04-02_15-17-34"></p>
<p>如果Default IP MTU  = 1500 byte，则 MSS = 1500- 20(IP Header) -20 (TCP Header) = 1460 byte，如果application 有2000 byte发送，需要两个segment才可以完成发送，第一个TCP segment = 1460，第二个TCP segment = 540。</p>
<p><img src="/2019/11/23/6-tcp-ip/tcp_pdus-1580019861990.png" alt="tcp_pdus"></p>
<p><img src="/2019/11/23/6-tcp-ip/MTU-image-1.png" alt="MTU-image-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/2843224-029d06502bd58f0e.webp" alt="2843224-029d06502bd58f0e"></p>
<h3 id="TCP-segment-length"><a href="#TCP-segment-length" class="headerlink" title="TCP segment length"></a>TCP segment length</h3><p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_17-04-26.jpg" alt="Snipaste_2020-01-26_17-04-26"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-26_17-06-18.jpg" alt="Snipaste_2020-01-26_17-06-18"></p>
<p>这个TCP segment length就是上图的DATA部分，TCP MSS 、Payload、 DATA 以及 TCP segment length其实是同一个东西，也就是应用层交给传输层的数据。</p>
<h3 id="TCP分段与IP分片"><a href="#TCP分段与IP分片" class="headerlink" title="TCP分段与IP分片"></a>TCP分段与IP分片</h3><p>有<a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">一篇文章</a>把这两个概念讲的非常好，如果想深入了解请自行访问链接进行查看。</p>
<p>TCP分段的原因是因为TCP报文段的大小受到MSS的限制，当TCP报文段的长度大于MSS时，就要在TCP层面进行分段，MSS 是操作系统内核层面的限制，为的是保证传输的性能；IP分片的原因是IP数据包的大小受到MTU的限制，当所需转发的IP数据报的大于MTU时，就需要在IP层面进行分片，IP层面分片是因为物理设备的限制。这两个分片有点类似于，一辆车上只能装4个人，如果有6个人想坐车就只能坐两辆车分开走，但这个比喻只是方便理解但非常的不准确。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-08_12-07-28.jpg" alt="Snipaste_2020-04-08_12-07-28"></p>
<p>但由于一直有MSS&lt;=MTU，很明显，分段后的每一段TCP报文段再加上IP首部后的长度不可能超过MTU，因此也就不需要在网络层进行IP分片了。因此TCP报文段很少会发生IP分片的情况。</p>
<p>再来看UDP数据报，由于UDP数据报不会自己进行分段，因此当长度超过了MTU时，会在网络层进行IP分片。同样，ICMP（在网络层中）同样会出现IP分片情况。</p>
<p><strong>总结：UDP不会分段，就由IP来分。TCP会分段，当然就不用IP来分了！</strong></p>
<h4 id="TCP分段分析"><a href="#TCP分段分析" class="headerlink" title="TCP分段分析"></a>TCP分段分析</h4><p>TCP报文段的每个分段中都有TCP首部，到了端点后根据TCP首部的信息在传输层进行重组。IP数据报分片后，只有到达目的地后才进行重组，而不是向其他网络协议，在下一站就要进行重组。</p>
<p>当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_15-59-26.jpg" alt="Snipaste_2020-03-12_15-59-26"></p>
<h4 id="IP数据分片分析"><a href="#IP数据分片分析" class="headerlink" title="IP数据分片分析"></a>IP数据分片分析</h4><p>前面说过，IP分片的原因是IP数据包的大小受到MTU的限制，当所需转发的IP数据报的大于MTU时，就需要在IP层面进行分片。</p>
<p>在分析IP数据分片时，有三个IP报头中的字段需要格外注意：</p>
<blockquote>
<ul>
<li>Identification - this value identifies a group of fragments. It’s what tells the reassembling device which fragments make up the original packet.</li>
<li>Fragment offset - once all the fragments have been received, they need to be put back in the correct order. This field tells the reassembling device where in the original packet to place the data from each fragment (after stripping the L2&amp;L3 headers).<br>the value for the first fragment will be 0</li>
<li>Flags - MF bit - More Fragments means that there are additional packets coming in after this one.<br>it is set (1) in all but the last fragment (0)</li>
</ul>
</blockquote>
<p>Identification（标识符），这个字段标识该数据为同一组分片的数据，用来告诉重组数据的设备哪些数据分片可以用来重组称为原始数据。</p>
<p>Fragment offset（分段序号），当所有分段数据都被接收后，需要将这些数据根据正确的顺序重组起来，这个字段告诉重组的设备这些分段数据正确的重组顺序。第一个分段数据的Fragment offset值为0。</p>
<p>Flags（标记）-MF位（more fragments），当该位为1时表示后面还有更多的分片数据，当最后一个分片数据的MF位为0，表示没有更多的分片数据了。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404205116.png" alt="微信截图_20200404205116"></p>
<p>先总体来看看这个抓包，这个抓包工有14个数据，前7个是ping包，也就是红框中的这些，后7个是replay这个ping包的，是蓝色框中的部分。</p>
<blockquote>
<p>The most important information is in the last entry (<code>#7</code> for the request and <code>#14</code> for the reply). It shows a combination of the contents (and size) of the last fragment to arrive (<code>134</code> bytes), but it also shows the reassembled packet in all its glory (<code>8980</code> bytes).</p>
<p>They key to that is noticing the tab that appears at the bottom which says <code>Reassembled IPv4 (8980 bytes)</code>.</p>
</blockquote>
<p>最重要的信息是在最后的两行中，对于ping包就是第七个数据，对于回复包就是第十四个数据，这两行显示的是最后一个整合了前面所有分片数据信息和大小，也是前面所有分片的整合。</p>
<p>关键是要看到标签按键上的“组合起来是8980位”这个，表示7个数据的ipv4部分加起来是8980位。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-05_16-51-01.jpg" alt="Snipaste_2020-04-05_16-51-01"></p>
<blockquote>
<p>To make matters worse, the IP header shown inside the reassembled packet is the one from the last fragment (notice Fragment offset is <code>8880</code> and MF is <code>0</code>). On the flip side, it does tell you that the packet has been reassembled from 7 fragments and it gives you the sizes and links to the fragments themselves. Convenient.</p>
</blockquote>
<p>让事情变得更糟糕的是，只有分片最后的那片数据带有UDP或ICMP首部，在这个例子中，只有第七和第十四片带有ICMP头部，因为Flag位上的MF位（More Fragments）为0，也就是说没有更多分片了，这两个是他们分片中的最后一个分片了，所以可以把所有分片整合起来了。在7和14上可以看到所有的分片大小以及这些分片的链接。</p>
<p>有些书上写的是只有第一个分片包含UDP或ICMP首部，但通过抓包以及询问原厂工程师，我觉得应该是最后一个分片带有UDP和ICMP首部，因为只有在7和14这两个上才有其他分片的信息以及Flag位中的MF位为0（表示没有更多分片）。在自己的结果和书上查到的资料有差异时，不要简单的就怀疑自己的结果有问题，要多方查证，通过做实验和抓包去证实真正的结果如何。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404194723.png" alt="微信截图_20200404194723"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404194744.png" alt="微信截图_20200404194744"></p>
<p>最后一点，对IP分片的数据报来说，即使只丢失一片数据也要重新传整个数据报（既然有重传，说明运输层使用的是具有重传功能的协议，如TCP协议）。这是因为IP层本身没有超时重传机制——由更高层（比如TCP）来负责超时和重传。当来自TCP报文段的某一段（在IP数据报的某一片中）丢失后，TCP在超时后会重发整个TCP报文段，该报文段对应于一份IP数据报（可能有多个IP分片），没有办法只重传数据报中的一个数据分片。</p>
<h3 id="FCS和CRC"><a href="#FCS和CRC" class="headerlink" title="FCS和CRC"></a>FCS和CRC</h3><p>定义：</p>
<blockquote>
<p>FCS - Frame Check Sequence is the process of using an algorithm or many algorithms to check frames</p>
<p>CRC - Cyclical Redunancy Check is a checksum type. It uses a specific algorithm (found below) for checking computation or transmission integrity.</p>
</blockquote>
<p>用简单的话来说，FCS是用算法校验数据的过程，而CRC是FCS这个校验过程可以采用的一种校验的方式，以太网用的就是CRC这种校验方式，所以在以太网里可以暂且把两者看成是同一个东西，但从概念上来讲，要知道二者是不同的。</p>
<h2 id="各层功能"><a href="#各层功能" class="headerlink" title="各层功能"></a>各层功能</h2><h3 id="应用层（Network-Access-Layer）"><a href="#应用层（Network-Access-Layer）" class="headerlink" title="应用层（Network Access Layer）"></a>应用层（Network Access Layer）</h3><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200118145723.png" alt="微信图片_20200118145723"></p>
<p>图中的DATA部分可以理解为由应用层产生的，应用层向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录，常见用的软件所使用的很多协议都在这一层。应用层包含了所有的高层协议：</p>
<ul>
<li>HTTP 80                  超文本传输协议，提供浏览网页服务 </li>
<li>Telnet 23                  远程登陆协议，提供远程管理服务</li>
<li>FTP 20、21             文件传输协议，提供互联网文件资源共享服务</li>
<li>SMTP 25                  简单邮件传输协议，提供互联网电子邮件服务</li>
<li>POP3 110                邮局协议，提供互联网电子邮件服务</li>
<li>TFTP 69 (UDP)        简单文件传输协议，提供简单的文件传输服务 </li>
<li>DNS  53（UDP）    域名解析协议，提供网址和IP地址相互映射服务</li>
</ul>
<p>关于DNS举个现实中的例子，我们在设备上ping百度网址的时候，其实ping的并不是百度 <a href="http://www.baidu.com/">www.baidu.com</a> 的网址而是ping的61.135.169.125这个IP地址，因为在网络上只有IP地址才是设备的唯一标识，必须通过IP地址数据才能通信，但相比一长串的IP地址，还是网址这个贴近人类记忆习惯的东西比较好记，但机器无法识别这些人类熟悉的网址，所以有了DNS这个映射协议，将网址和IP地址对应起来，当用户输入主机名（域名）时，DNS会自动检索那个注册了主机名和IP地址的数据库，并迅速定位对应的IP地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-09_13-54-41-1583733928827.jpg" alt="Snipaste_2020-03-09_13-54-41"></p>
<h3 id="传输层（Transport-Layer）"><a href="#传输层（Transport-Layer）" class="headerlink" title="传输层（Transport Layer）"></a>传输层（Transport Layer）</h3><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118145922.jpg" alt="微信图片编辑_20200118145922"></p>
<p>传输层位于应用层和网络接口层之间，负责在主机之间提供逻辑连接，通常提供如下功能：</p>
<p>流量控制：通过窗口技术</p>
<p>可靠连接：通过序列号和确认号</p>
<p>会话多路复用：通过端口号和IP地址</p>
<p>分段：通过使用数据段的协议数据单元（PDU）</p>
<p>在TCP/IP协议族中，有两个互不相同的传输协议：TCP（传输控制协议）和UDP（用户数据报协议）。图中的TCP协议（也可能是UDP协议）+端口号（Port Number）+应用层的DATA可以理解为整个传输层封装后产生的，在数据由应用层传递给传输层后，TCP提供将应用层发来的数据顺利发送至对端的可靠传输。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118151853.jpg" alt="微信图片编辑_20200118151853"></p>
<p>为了实现TCP的这一功能，需要在应用层数据的前端附加一个TCP首部。TCP首部中包括源端口号和目标端口号（用以识别发送主机跟接收主机上的应用）、序号（用以发送的包中哪部分是数据）以及校验和（Check Sum，用来检验数据的读取是否正常进行的方法。） （用以判断数据是否被损坏）。随后将附加了TCP首部的包再发送给IP。</p>
<p><img src="/2019/11/23/6-tcp-ip/TCPUDP.jpg" alt="TCPUDP"></p>
<p>TCP 就可以在自己这一层，把用户发送的数据，预先分成多个大小限制在 MTU 里的 TCP 包。每个 TCP 的分片包，都完整了包含了 TCP 头信息，方便在接收方重组。</p>
<h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><p>TCP（Transmission Control Protocol，传输控制协议）为两台主机提供高可靠性的数据通信，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由IETF的RFC793定义。TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构，你可以把它想象成排水管中的水流。</p>
<h5 id="TCP的特点："><a href="#TCP的特点：" class="headerlink" title="TCP的特点："></a>TCP的特点：</h5><p>1、面向连接：是指发送数据之前必须在两端建立连接。TCP建立连接的方法是“三次握手”，这样能建立可靠的连接，所以说TCP是面向连接的协议。建立连接，是为数据的可靠传输打下了基础。</p>
<p>面向连接，是指发送数据之前必须在两端建立连接。TCP建立连接的方法是“三次握手”，这样能建立可靠的连接，所以说TCP是面向连接的协议。</p>
<p>2、可靠传输：TCP协议可以确保发送端发送了怎样的数据，那么接收端就必然能接收到怎样的数据，因为TCP协议中规定了：①如何处理丢失或重复等差错情况。②如何初始化一个数据流传输 ③如何协商结束数据流传输 ④流量控制和拥塞控制机制。</p>
<ul>
<li><p>①如何处理丢失或重复等差错情况：靠的是TCP的序列号（Sequence Number）以及确认应答号（Acknowledgement Number、ACK）。TCP在发送数据的时候，为每个字节编号（也就是序列号），接收端收到数据之后，经过校验无误，发回确认应答号，确认应答号为接收端等待接受的写一个字节的序号。并且它会缓存到达的乱序数据，统一排序之后传递给上层。这样就解决了丢包，重复和乱序的问题。</p>
</li>
<li><p>②如何初始化一个数据流传输：TCP的三次握手进行了规定。</p>
</li>
<li><p>③如何协商结束数据流传输：TCP的四次分手进行了规定。</p>
</li>
<li><p>④流量控制和拥塞控制机制：TCP的窗口字段、序列号、确认应答号、Tail drop（尾帧丢弃）和RED（Random early detection）等提供了这些功能。</p>
</li>
</ul>
<p>3、支持流控</p>
<p>TCP连接的每一方都有固定大小的缓冲空间。TCP的接收端只允许另一端发送接收端缓冲区所能接纳的数据。这将防止较快主机致使较慢主机的缓冲区溢出。具体见下文的窗口大小部分。</p>
<p>4、窗口机制</p>
<p>见下方的窗口机制部分。</p>
<h5 id="TCP报头格式"><a href="#TCP报头格式" class="headerlink" title="TCP报头格式"></a>TCP报头格式</h5><p>每个分层中，都会对所发送的数据附加一个首部，在这个首部中包含了该层必要的信息，如发送的目标地址以及协议相关信息。通常，为协议提供的信息为包首部，所要发送的内容为数据。在下一层的角度看，从上一层收到的包全部都被认为是本层的数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-31_13-24-32.jpg" alt="Snipaste_2019-12-31_13-24-32"></p>
<p>一个 TCP Header 一般有 20 个字节，如果启用了options，header的长度可以达到 60 个字节。图中每一行是 4 个 bytes，32 个 bits。</p>
<img src="/2019/11/23/6-tcp-ip/01e54adf-35dc-4628-8de3-044c64437a37.jpg" alt="01e54adf-35dc-4628-8de3-044c64437a37" style="zoom:67%;">

<p><img src="/2019/11/23/6-tcp-ip/3-slide3.jpg" alt="3-slide3"></p>
<h6 id="源端口号（Source-Port）"><a href="#源端口号（Source-Port）" class="headerlink" title="源端口号（Source Port）"></a>源端口号（Source Port）</h6><p><strong>表示发送端端口号</strong>，字段长16位。</p>
<h6 id="目标端口号（Destination-Port）"><a href="#目标端口号（Destination-Port）" class="headerlink" title="目标端口号（Destination Port）"></a>目标端口号（Destination Port）</h6><p><strong>表示接收端端口号</strong>，字段长度16位。</p>
<p>源和目标端口号长度均为16位，即允许一个主机有2的16次方，也就是65535个不同端口，其中：</p>
<p>0——1023为分配给系统的端口号，属于知名端口，不可以乱用，常见的有HTTP的80端口，FTP的21端口以及TELNET的23端口。</p>
<p>1024——49151为登记端口号，第三方可以使用。</p>
<p><strong>应用客户端使用的源端口号一般为系统中未使用的且大于1023的数字。</strong></p>
<h6 id="序列号（Sequence-Number）"><a href="#序列号（Sequence-Number）" class="headerlink" title="序列号（Sequence Number）"></a>序列号（Sequence Number）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160155.jpg" alt="微信图片编辑_20200118160155"></p>
<p>字段长32位。<strong>序列号（有时也叫序号）是指发送数据的位置</strong>。每发送一次数据，就累加一次该数据字节数的大小。接收方可以通过检查收到的数据分组的序号发现哪些分组没有收到、哪些分组冗余了。发送ACK/NAK反馈时也可以指定Seq表示需要重传哪些分组或者继续往下发送哪些分组。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_15-20-26.jpg" alt="Snipaste_2020-03-12_15-20-26"></p>
<p>一个TCP流是有无数个0和1构成，这些0和1以8个bit为单位，可以分割成一个个的byte，TCP是可靠传输协议，每一个byte都是有标号的，因为我们需要追踪每个byte是否被成功传输了，每个byte的标号就是我们这里的sequence number。有了数据包对应的序列号，我们就可以：</p>
<ul>
<li><strong>接收方可以通过序列号对重复的数据包进行去重；</strong></li>
<li><strong>发送方会在对应数据包未被 ACK 时进行重复发送；</strong></li>
<li><strong>接收方可以根据数据包的序列号对它们进行重新排序；</strong></li>
</ul>
<p><strong>序列号不会从0或1开始，而是在建立连接时由计算机生成的随机数作为其初始值，通过SYN包传给接收端主机。然后再将每转发过去的字节数累加到初始值上表示数据的位置。此外，在建立连接和断开连接时发送的SYN包和FIN包虽然并不携带数据，但是也会作为一个字节增加对应的序列号。</strong></p>
<blockquote>
<p> A TCP header which only consists of the ACK will not increment the SEQ/ACK</p>
</blockquote>
<p><strong><span style="color:red">一个只包含ACK的TCP报头不会增加序列号和ACK号的数字，也就是说，一个纯ACK确认数据是不会增加序列号和ACK号的数字</span></strong> </p>
<h6 id="确认应答号（Acknowledgement-Number、ACK）"><a href="#确认应答号（Acknowledgement-Number、ACK）" class="headerlink" title="确认应答号（Acknowledgement Number、ACK）"></a>确认应答号（Acknowledgement Number、ACK）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160230.jpg" alt="微信图片编辑_20200118160230"></p>
<p>确认应答号字段长度32位。是指表示<strong>期望收到对方下一个报文段的序号值</strong>。实际上，它是指已收到确认应答号减1为止的数据。当发送端收到确认应答号后，用来确认这个位置以前所有数据都被正常接收，否则将会从新连接发送，这也<strong>是TCP是可靠传输的原因，因为有“序列号—确认应答号”这么一个确认机制，可以知道数据是否发送完整。</strong>例如下图中，主机A向主机B发送了长度为725的数据，主机B在回复的数据中将应答号设置为726，表示前725个数据都正常接收，下次请发送序列号从726开始的数据。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-15_17-04-48.jpg" alt="Snipaste_2019-12-15_17-04-48" style="zoom:150%;">

<p>必须要注意的是，<strong>TCP的ACK表达的意思一方面是期望收到对方下一个报文段的序列号，另一方面也是确认当前数据段前面的全部数据段已经被接收和处理</strong>，如果说对方发送了5个数据段，数据段1-5，如果后四段成功接收，但第一段未接收的话，接收者是不会发送ACK序列号为6的，因为如果发送了ACK=6就是说明1-5全部接收成功，但事实上数据段1并没有接收到所以是不会发送ACK为6的数据的，由于发送方没有收到 ACK，<strong>所有数据段</strong>对应的计时器就会超时并重新传输数据。在丢包较为严重的网络下，这种重传机制会造成大量的带宽浪费。</p>
<p>如何解决上面说的这种其中某一个数据段没收到就要重传所有数据段的问题呢？要用到快速重传（Fast Retransmit/Fast Recovery），大概意思是当接收方收到乱序的数据段时，不会等待重传计时器到时再重传，而是会立刻发送两个连续的 ACK 触发发送方的重传，这里就不展开了，详见RFC2581中的<a href="https://tools.ietf.org/html/rfc2581#page-6">3.2 Fast Retransmit/Fast Recovery</a>。</p>
<blockquote>
<p>The sequence number is always valid. The acknowledgement number is only valid when the ACK flag is one. The only time the ACK flag is not set, that is, the only time there is not a valid acknowledgement number in the TCP header, is during the first packet of connection set-up.</p>
</blockquote>
<p><strong>序列号始终存在。确认编号仅在ACK标志为1时存在。</strong> 唯一未设置ACK标志的时间，即TCP头中没有有效确认号的唯一时间是在连接建立的第一个数据包期间。</p>
<blockquote>
<p>if ACK flag is 1 , Acknowledgment number is considered by application; if ACK flag is 0, Acknowledgment Number is not considered</p>
</blockquote>
<p>如果控制位中的ACK置位为1，则应用程序考虑确认号；如果ACK为0，则不考虑确认编号。关于控制位中的ACK置位问题，请参照后面的控制位部分。</p>
<blockquote>
<p>The ACK flag is used to acknowledge past data, but the acknowledgement number is used to say what is expected in the future. Those are two completely different functions.</p>
<p>when a host sees the ACK flag, it knows that all data up to the acknowledgement number has been acknowledged, but the acknowledgement number, itself, is telling the host what the destination is expecting next.</p>
</blockquote>
<p>注意ACK置位和ACK 序号的区别，ACK位是在TCP报头控制位里的其中一位，而ACK序号是前面的ACK确认应答号，两者功能是完全不同的，ACK置位为1的时候，表示这个数据是确认之前发送的数据，对端会明白这个数据是用来确认的，确认的是ACK确认应答号之前的那些数字，比如ACK确认应答号是1000，而ACK确认应答号是用来告诉对端下一次发送数据的序列号是多少，所以下次发送数据从1000开始。这两个字段是搭配起来用的。</p>
<h6 id="——关于序列号和确认应答号的相关说明——"><a href="#——关于序列号和确认应答号的相关说明——" class="headerlink" title="——关于序列号和确认应答号的相关说明——"></a><strong>——关于序列号和确认应答号的相关说明——</strong></h6><p>序列号和确认号组合起来使用，<strong>可以提高可靠性。</strong></p>
<blockquote>
<p>When a host initiates a TCP session, its initial sequence number is effectively random; it may be any value between 0 and 4,294,967,295, inclusive. However, protocol analyzers like Wireshark will typically display <em>relative</em> sequence and acknowledgement numbers in place of the actual values. These numbers are relative to the initial sequence number of that stream. This is handy, as it is much easier to keep track of relatively small, predictable numbers rather than the actual numbers sent on the wire.</p>
</blockquote>
<p>主机启动TCP会话时，<strong>其初始序列号实际上是随机的； 它可以是0到4,294,967,295（含）之间的任何值。</strong>因为序列号的大小是32位，2的32次方是4294967296。但是，像Wireshark这样的<strong>抓包分析软件通常会显示相对序列和确认号来代替实际值</strong>。 这些数字是相对于该流的初始序列号。这很方便，因为跟踪相对较小的可预测数字比在线上发送的实际数字要容易得多。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-15_16-52-20.jpg" alt="Snipaste_2019-12-15_16-52-20" style="zoom: 150%;">

<p>当TCP连接已经建立时，主机A向主机B发送了9个字节的数据后，主机B在回包中用确认号（Acknowledgemt Number）10来回复，这个10就是期望收到对方下一个报文段的序号值，所以对方在下一次发送中发送的12个字节，编号是从10开始的，也就是编号为10-21的数据。</p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2019-12-31_16-08-44.jpg" alt="Snipaste_2019-12-31_16-08-44" style="zoom:150%;">

<p>从抓包中能更直观的看出来“期望收到对方下一个报文段的序号值”这个概念：主机2（174.143.213.184）发送了长度为1448的数据给主机1（192.168.1.2），主机1在回复的数据中所带的ACK值是1449，所以下一次主机2发送的数据的序列号从1449开始，长度为1448的数据。</p>
<p><strong>通过序列号和确认应答号，TCP 能够识别是否已经接收数据，又能够判断是否需要接收，从而实现可靠传输。</strong></p>
<h6 id="数据偏移（Data-Offset）"><a href="#数据偏移（Data-Offset）" class="headerlink" title="数据偏移（Data Offset）"></a>数据偏移（Data Offset）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160306.jpg" alt="微信图片编辑_20200118160306"></p>
<p>该字段表示TCP所传输的数据部分应该从TCP包的哪个位开始计算，当然也可以把它看作<strong>TCP首部的长度</strong>（Specifies the size of the TCP header in 32-bit words.）。该字段长4位，单位为4字节（即4X8=32位）。不包括选项字段的话，TCP的首部为20字节长，因此数据偏移字段可以设置为5。反之，如果该字段的值为5，那说明从TCP包的最一开始到20字节为止都是TCP首部，余下的部分为TCP数据。</p>
<h6 id="保留（Reserved）"><a href="#保留（Reserved）" class="headerlink" title="保留（Reserved）"></a>保留（Reserved）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160356.jpg" alt="微信图片编辑_20200118160356"></p>
<p>该字段主要是为了以后扩展时使用，其长度为4位。一般设置为0，但即使收到的包在该字段不为0，此包也不会被丢弃（保留字段的第4位（如图中的第7位）用于实验目的，相当于NS（Nonce Sum）标志位。） 。</p>
<h6 id="控制位（Control-Flag）"><a href="#控制位（Control-Flag）" class="headerlink" title="控制位（Control Flag）"></a>控制位（Control Flag）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160431.jpg" alt="微信图片编辑_20200118160431"></p>
<p>字段长为8位，每一位从左至右分别为CWR、ECE、URG、ACK、PSH、RST、SYN、FIN。这些控制标志也叫做控制位。当它们对应位上的值为1时，具体含义如下：</p>
<p><img src="/2019/11/23/6-tcp-ip/6976ea88-152b-4bc4-b602-dde1d632cd14.jpg" alt="6976ea88-152b-4bc4-b602-dde1d632cd14"></p>
<p>CWR（Congestion Window Reduced）<br>CWR标志与后面的ECE标志都用于IP首部的ECN字段。ECE标志为1时，则通知对方已将拥塞窗口缩小。</p>
<p>ECE（ECN-Echo）<br>ECE标志表示ECN-Echo。置为1会通知通信对方，从对方到这边的网络有拥塞。在收到数据包的IP首部中ECN为1时将TCP首部中的ECE设置为1。</p>
<p>URG（Urgent Flag）<br>该位为1时，表示包中有需要紧急处理的数据。在目前的协议中很少用到，这个字段的功能需要配合后面的“紧急指针（<em>Urgent Pointer</em>）”一起使用，</p>
<p>ACK（Acknowledgement Flag）<br>该位为1时，确认应答的字段变为有效，ACK字段用于确认成功接收数据包。</p>
<p>PSH（Push Flag）<br>该位为1时，表示需要将受到的数据立刻传给上层应用协议。PSH为0时，则不需要立即传而是先进行缓存。</p>
<p>RST（Reset Flag）<br>该位为1时表示TCP连接中出现异常必须强制断开连接。例如，一个没有被使用的端口即使发来连接请求，也无法进行通信。此时就可以返回一个RST设置为1的包。此外，程序宕掉或切断电源等原因导致主机重启的情况下，由于所有的连接信息将全部被初始化，所以原有的TCP通信也将不能继续进行。这种情况下，如果通信对方发送一个设置为1的RST包，就会使通信强制断开连接。</p>
<p>SYN（Synchronize Flag）<br>用于建立连接。SYN为1表示希望建立连接，并在其序列号的字段进行序列号初始值的设定（Synchronize本身有同步的意思。也就意味着建立连接的双方，序列号和确认应答号要保持同步） 。</p>
<p>FIN（Fin Flag）<br>该位为1时，表示今后不会再有数据发送，希望断开连接。当通信结束希望断开连接时，通信双方的主机之间就可以相互交换FIN位置为1的TCP段。每个主机又对对方的FIN包进行确认应答以后就可以断开连接。不过，主机收到FIN设置为1的TCP段以后不必马上回复一个FIN包，而是可以等到缓冲区中的所有数据都因已成功发送而被自动删除之后再发。</p>
<h6 id="窗口大小（Window-Size）"><a href="#窗口大小（Window-Size）" class="headerlink" title="窗口大小（Window Size）"></a>窗口大小（Window Size）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160548.jpg" alt="微信图片编辑_20200118160548"></p>
<p>该字段长为16位。用于通知从相同TCP首部的确认应答号所指位置开始能够接收的数据大小（8位字节）。TCP不允许发送超过此处所示大小的数据，换句话说就是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>。于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来。不过，如果窗口为0，则表示可以发送窗口探测，以了解最新的窗口大小。但这个数据必须是1个字节。</p>
<h6 id="校验和（Checksum）"><a href="#校验和（Checksum）" class="headerlink" title="校验和（Checksum）"></a>校验和（Checksum）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160621.jpg" alt="微信图片编辑_20200118160621"></p>
<p>该字段长为16位。由发送端填充，接收端对 TCP 报文段执行 CRC 算法，以检验 TCP 报文段在传输过程中是否损坏，<strong>会校验包括IP头部、TCP头部和TCP数据在内的整个序列，确保IP地址、端口号和其他相关信息正确</strong>，如果损坏接收方会丢弃该TCP片段。<strong>检验范围包括首部和数据两部分，这也是 TCP 可靠传输的一个重要保障。</strong></p>
<h6 id="紧急指针（Urgent-Pointer）"><a href="#紧急指针（Urgent-Pointer）" class="headerlink" title="紧急指针（Urgent Pointer）"></a>紧急指针（Urgent Pointer）</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160652-1579334838087.jpg" alt="微信图片编辑_20200118160652"></p>
<p>该字段长为16位。仅在 URG = 1 时才有意义，<strong>它指出本报文段中的紧急数据的字节数</strong>。当 URG = 1 时，发送方 TCP 就把紧急数据插入到本报文段数据的<strong>最前面</strong>，而在紧急数据后面的数据仍是普通数据。因此，紧急指针指出了紧急数据的末尾在报文段中的位置。</p>
<h5 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h5><h6 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h6><p>因为想确保彼此告诉对方的东西都被准确无误的听到了，类比到现实生活中就是打电话，你给别人打电话，不可能电话一接通你就啪啦啪啦地说一大通，万一对方接通电话后因为有事还没来得及倾听呢？这不太符合正常人类的交流习惯。一般是电话接通后，双方一般会有个交互的过程，一般是你说一声“你好”，然后对方也回复一声“你好”，双方通过各自一句“你好”明确对方的注意力都放在了电话沟通上，然后你们双方就可以开始交流了，这才是正常的人类交流方式，这个过程体现在计算机网络里就是网络协议！我们通过TCP协议在两台电脑建立网络连接之前要先发数据包进行沟通，沟通后再建立连接，然后才是信息的传输，这个机器沟通的过程和人打电话沟通的过程类似，但因为机器始终是机器，没有人那么智能，必须用一系列机制来确保“双方的注意力都放在了电话沟通上”，在TCP建立连接的过程中，这个机制就是三次握手，这三次握手中的Seq、ACK以及控制字段彼此呼应，完成了建立沟通的过程。</p>
<p>当然，上面这部分完全是为了方便理解所做的比喻，但真实情况和上面的例子还是有一些差别的，如果有兴趣请自行查阅<a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">这篇文章</a>，后面我也会结合文章和自己的体会整理一篇单独的笔记，在这里摘要其中一些部分进行说明。</p>
<p>在<a href="https://tools.ietf.org/html/rfc793">RFC793 - Transmission Control Protocol</a> 的文档中，清楚的定义了TCP使用三次握手的重要原因——为了阻止历史的重复链接初始化造成的混乱问题，防止使用TCP协议通信的双方建立了错误的连接。</p>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
<p>当然，也有另一个原因就是让通信的双方确定初始序列号。</p>
<p>三次握手建立TCP连接的成本相当高，不仅需要额外增加1.5RTT的网络延迟，还要增加222字节的额外开销，以太网数据帧头是3*14=42字节，IP数据帧头占据3 * 20 = 60字节，TCP数据占据3 * 40 =120字节，加起来一共是222字节。所以在弱网环境下，通过三次握手建立TCP连接会加剧TCP的性能问题。</p>
<p><img src="/2019/11/23/6-tcp-ip/2020-01-02-15779393353427-tcp-three-way-handshake-overhead.png" alt="2020-01-02-15779393353427-tcp-three-way-handshake-overhead"></p>
<p><img src="/2019/11/23/6-tcp-ip/2020-01-02-15779393353419-basic-3-way-handshake.png" alt="2020-01-02-15779393353419-basic-3-way-handshake"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200217174753.jpg" alt="微信图片编辑_20200217174753"></p>
<img src="/2019/11/23/6-tcp-ip/TCP-handshake.jpg" alt="TCP-handshake" style="zoom:150%;">

<h6 id="第一次握手："><a href="#第一次握手：" class="headerlink" title="第一次握手："></a>第一次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118162239.jpg" alt="微信图片编辑_20200118162239"></p>
<p>客户端将标志位SYN置为1，表示我要和对方建立TCP连接，现在开始三次握手，并随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-51-08.jpg" alt="Snipaste_2020-01-08_17-51-08" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-04_17-56-06.jpg" alt="Snipaste_2020-01-04_17-56-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134334.jpg" alt="微信图片编辑_20200113134334"></p>
<p>开始三次握手的设备1（IP地址为192.168.1.2）会将TCP控制位（Control Flag）中的SYN位置为1，表示希望建立TCP连接；序列号（Sequence Number）置为J，在这J为0，因为这是设备1发送的第一个TCP数据（这个0是相对序列号，解释见上边序列号部分或下段说明），并将该数据包发送给对端的设备2（IP地址为174.143.213.184），客户端进入SYN_SENT状态，等待对端确认。会话的每一端都以（相对）序列号零开始。同样，确认数也为零，因为还没有对话的互补面需要确认。</p>
<p>必须注意的是，主机启动TCP会话时，<strong>其初始序列号实际上是随机的； 它可以是0到4,294,967,295（含）之间的任何值。</strong> 但是，像Wireshark这样的<strong>抓包分析软件通常会显示相对序列和确认号来代替实际值</strong>。 这些数字是相对于该流的初始序列号。 这很方便，因为跟踪相对较小的可预测数字比在线上发送的实际数字要容易得多。</p>
<h6 id="第二次握手："><a href="#第二次握手：" class="headerlink" title="第二次握手："></a>第二次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200130170823.jpg" alt="微信图片编辑_20200130170823"></p>
<p>服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，SYN置位为1表示我也要建立连接，ACK置位为1表示这个是确认收到了对方之前的回复；ack=J+1，表示这个带ack的值是回应之前Seq值为J的数据的，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-52-06.jpg" alt="Snipaste_2020-01-08_17-52-06" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-04_18-03-45.jpg" alt="Snipaste_2020-01-04_18-03-45"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134532.jpg" alt="微信图片编辑_20200113134532"></p>
<p>设备2（IP地址为174.143.213.184）收到数据包后解封装发现TCP的控制位中SYN置1，说明设备1（IP地址为192.168.1.2）请求建立连接，于是将自己TCP的控制位中的SYN和ACK都置为1，SYN置位为1表示我也要建立连接，ACK置位为1表示这个是确认收到了对方之前的回复；ACK为设备1的序列号J+1，第一次握手的J=0，所以这里的ACK为1，表示我确认的是之前序列号为0的那个数据；随机产生一个序列号K，这个K在这也是0（相对序列号），因为这是设备2第一次和设备1通信，然后将该数据包发送给设备1并进入SYN_RCVD状态。</p>
<h6 id="第三次握手："><a href="#第三次握手：" class="headerlink" title="第三次握手："></a>第三次握手：</h6><ul>
<li>理论分析：</li>
</ul>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200130171052.jpg" alt="微信图片编辑_20200130171052"></p>
<p>客户端收到确认后，检查ack是否为J+1（回应之前Seq值为J的数据），ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<ul>
<li>实际抓包过程举例：</li>
</ul>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-52-53.jpg" alt="Snipaste_2020-01-08_17-52-53" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_18-58-43.jpg" alt="Snipaste_2020-01-05_18-58-43"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200113134609.jpg" alt="微信图片编辑_20200113134609"></p>
<p>设备1（IP地址为192.168.1.2）收到确认后，检查ack是否为J+1，之前J=0，所以检查ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，前面的K=0，并将该数据包发送给设备2（IP地址为174.143.213.184），设备2检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，两个设备均进入了ESTABLISHED状态，完成三次握手，随后客户端与服务器端之间可以开始传输数据了。</p>
<h5 id="TCP三次握手的漏洞："><a href="#TCP三次握手的漏洞：" class="headerlink" title="TCP三次握手的漏洞："></a>TCP三次握手的漏洞：</h5><p><strong>漏洞：SYN洪泛攻击</strong></p>
<p><strong>定义：</strong></p>
<p>通过网络服务所在的端口发送大量伪造原地址的攻击报文，发送到服务端，造成服务端上的半开连接队列被占满，从而阻止其他用户进行访问。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-04_12-47-46.jpg" alt="Snipaste_2020-05-04_12-47-46"></p>
<p><strong>原理：</strong></p>
<p>当开放了一个TCP端口后，该端口就处于Listening状态，不停地监视发到该端口的SYN报文，一旦接收到Client发来的SYN报文，就需要为该请求分配一个TCB（Transmission Control Block），通常一个TCB至少需要280个字节，在某些操作系统中TCB甚至需要1300个字节，并返回一个SYNACK报文，立即转为SYN-RECEIVED即半开连接状态，而某些操作系统在SOCKT的实现上最多可开启512个半开连接（如Linux2.4.20 内核）。</p>
<p>如果恶意的向某个服务器端口发送大量的SYN包(第一次握手)，而服务端的响应(第二次握手)的报文将永远发送不到真实的客户端，服务端在等待客户端的第三次握手(永远都不会有的)，则可以使服务器打开大量的半开连接，分配TCB，从而消耗大量的服务器资源，同时也使得正常的连接请求无法被相应。而攻击发起方的资源消耗相比较可忽略不计。</p>
<p><strong>解决方案：</strong></p>
<p>无效连接监控释放：</p>
<p>不停的<strong>监视系统的半开连接和不活动连接，当达到一定阈值时拆除这些连接，从而释放系统资源。</strong>这种方法对于所有的连接一视同仁，而且由于SYN Flood造成的半开连接数量很大，正常连接请求也被淹没在其中被这种方式误释放掉。</p>
<p>延缓TCB分配方法：</p>
<p>1、SYN Cache技术</p>
<p>这种技术是在收到SYN数据报文时不急于去分配TCB，而是先回应一个SYN ACK报文，并在一个专用HASH表（Cache）中保存这种半开连接信息，直到收到正确的回应ACK报文再分配TCB。</p>
<p>2、SYN Cookie技术：</p>
<p>Syn Cookie技术则完全不使用任何存储资源，这种方法比较巧妙，它使用一种特殊的算法生成Sequence Number，这种算法考虑到了对方的IP、端口、己方IP、端口的固定信息，以及对方无法知道而己方比较固定的一些信息，如MSS、时间等，在收到对方的ACK报文后，重新计算一遍，看其是否与对方回应报文中的（SequenceNumber-1）相同，从而决定是否分配TCB资源。</p>
<p>防火墙：</p>
<p>很多<strong>防火墙中都提供一种SYN代理的功能，其主要原理是对试图穿越的SYN请求进行验证后才放行。</strong></p>
<h5 id="TCP的四次分手"><a href="#TCP的四次分手" class="headerlink" title="TCP的四次分手"></a>TCP的四次分手</h5><p><img src="/2019/11/23/6-tcp-ip/2020-03-10-15838517142219-tcp-closing-connection.png" alt="2020-03-10-15838517142219-tcp-closing-connection"></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP-88-1.jpg" alt="TCP-88-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200218152246.jpg" alt="微信图片编辑_20200218152246"></p>
<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_17-07-53.jpg" alt="Snipaste_2020-01-05_17-07-53" style="zoom:150%;">

<img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_15-49-17.jpg" alt="Snipaste_2020-02-18_15-49-17" style="zoom:150%;">

<p>建立起TCP连接的设备两端均可以发起中断连接。</p>
<h6 id="第一次分手："><a href="#第一次分手：" class="headerlink" title="第一次分手："></a>第一次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/Users/32759/Downloads/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121145129.jpg" alt="微信图片编辑_20200121145129"></p>
<p>理论步骤：客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。意思是说”我客户端没有数据要发给你了”，但是如果你服务器端还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-05_17-14-40.jpg" alt="Snipaste_2020-01-05_17-14-40"></p>
<p>实际例子分析：设备1（IP地址为10.0.2.15）发送一个序列号（sequence number，此处为相对序列号）为106，确认应答号（Acknowledgement number）为321，这个321是用来确认之前对端发给该设备的，相对FIN与ACK均置为1的数据给设备2（IP地址为176.32.99.41），表示我这段要结束数据传送并进入FIN_WAIT_1状态。意思是说”我没有数据要发给你了”，但是如果你还有数据没有发送完成，则不必急着关闭连接，可以继续发送数据。</p>
<p>上一个数据包的Next sequence number是321，所以这个回送数据中的ACK为321，表示成功接收了320个数据，可以从序列号321开始发送，上一个数据包的抓包如下：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_14-53-26.jpg" alt="Snipaste_2020-01-21_14-53-26"></p>
<h6 id="第二次分手："><a href="#第二次分手：" class="headerlink" title="第二次分手："></a>第二次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121145617.jpg" alt="微信图片编辑_20200121145617"></p>
<p>理论步骤：服务器端收到FIN后，先发送ack=M+1，告诉客户端，你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_14-57-58.jpg" alt="Snipaste_2020-01-21_14-57-58"></p>
<p>实际例子分析：设备2（IP地址为176.32.99.41）收到FIN后，先发送ack=M+1，这里的M为106，所以本数据包中的ACK为107，此序列号确认了设备1（IP地址为10.0.2.15）发送的序列号（sequence number，此处为相对序列号）为106的数据，告诉了设备1你的请求我收到了，但是我还没准备好，请继续你等我的消息。这个时候客户端就进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。</p>
<p><span style="color:red">必须注意的是，这个ACK是个纯ACK，因为只有ACK置位为1了，TCP Segment Len：0，也就是没有DATA部分，没有其他的东西在里头，说明这个数据是个<strong>纯ACK</strong>，而一个只包含ACK的TCP报头不会增加序列号和ACK号的数字，所以后面第三次分手时数据的seq和ACK数字和第二次是一样的。</span></p>
<h6 id="第三次分手："><a href="#第三次分手：" class="headerlink" title="第三次分手："></a>第三次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121150048.jpg" alt="微信图片编辑_20200121150048"></p>
<p>理论步骤：当服务器端确定数据已发送完成，则向客户端发送FIN=N报文，告诉客户端，好了，我这边数据发完了，准备好关闭连接了。<strong>这里其实ACK位也是置位为1的，然后ACK值也是M+1，表示确认的是之前FIN=M那个第一次分手</strong>。服务器端进入LAST_ACK状态。</p>
<p>实际例子分析：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_15-30-30.jpg" alt="Snipaste_2020-01-21_15-30-30"></p>
<p>设备2（IP地址为176.32.99.41）向设备1发送FIN位置为1的报文，告诉设备1（IP地址为10.0.2.15），我这边的数据已经发送完毕，准备好关闭连接了。服务器端进入LAST_ACK状态。<strong>这里的ACK值也是上一次分手时发送给设备1的ACK值，为107，因为第二次回复的ACK是一个纯ACK，里面没有数据，TCP Segment Len=0，也就是这个里面的DATA部分为0，是一个纯ACK数据，所以这里ACK位也置为1。</strong></p>
<p><strong>关于TCP Segment Len</strong></p>
<blockquote>
<p>The TCP payload size is calculated by taking the “Total Length” from the IP header (ip.len) and then substract the “IP header length” (ip.hdr_len) and the “TCP header length” (tcp.hdr_len).</p>
</blockquote>
<p>通过从IP报头（ip.len）中获取“总长度”，然后减去“ IP报头长度”（ip.hdr_len）和“ TCP报头长度”（tcp.hdr_len），可以计算出TCP有效负载大小。tcp payload是0 说明要么是三次握手，四次关闭，要么是纯ack。</p>
<h6 id="第四次分手："><a href="#第四次分手：" class="headerlink" title="第四次分手："></a>第四次分手：</h6><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200121154015.jpg" alt="微信图片编辑_20200121154015"></p>
<p>理论步骤：客户端收到FIN=N报文后，就知道可以关闭连接了，但是他还是不相信网络，怕服务器端不知道要关闭，所以发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。客户端等待了2MSL（Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. ）后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次分手。</p>
<p>实际例子分析：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-21_15-41-40.jpg" alt="Snipaste_2020-01-21_15-41-40"></p>
<p>实际例子分析：</p>
<p>设备1（IP地址为10.0.2.15）向设备2（IP地址为176.32.99.41）发送了一个相对序列号为107，相对确认号为322，ACK置位为1的数据，表示用来确认之前对方所发送序列号为321的数据，进入TIME_WAIT状态，如果等待了2MSL（Maximum segment lifetime is the time a TCP segment can exist in the internetwork system. ）后依然没有收到回复，则证明服务器端已正常关闭，那好，我客户端也可以关闭连接了。最终完成了四次分手。</p>
<p>上面是一方主动关闭，另一方被动关闭的情况，实际中还会出现同时发起主动关闭的情况。</p>
<blockquote>
<p>It is also possible to terminate the connection by a 3-way handshake, when host A sends a FIN and host B replies with a FIN &amp; ACK (merely combines 2 steps into one) and host A replies with an ACK</p>
<p><a href="https://en.wikipedia.org/wiki/Andrew_S._Tanenbaum">Tanenbaum, Andrew S.</a> (2003-03-17). <a href="https://archive.org/details/computernetworks00tane_2"><em>Computer Networks</em></a> (Fourth ed.). Prentice Hall. <a href="https://en.wikipedia.org/wiki/International_Standard_Book_Number">ISBN</a> <a href="https://en.wikipedia.org/wiki/Special:BookSources/978-0-13-066102-9">978-0-13-066102-9</a>.</p>
</blockquote>
<p>TCP连接的关闭也可以通过3次分手实现，当主机A发送FIN置位为1的数据时，主机B回复一个FIN和ACK位均置位为1的数据，相当于把中间的两步整合为一步，最后主机A回复一个ACK结束TCP连接，比如下图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_17-07-05.jpg" alt="Snipaste_2020-02-18_17-07-05"></p>
<h5 id="为什么TCP实放需要四次分手"><a href="#为什么TCP实放需要四次分手" class="headerlink" title="为什么TCP实放需要四次分手"></a>为什么TCP实放需要四次分手</h5><p>为了保证双方都能通知对方“需要释放连接”，即在释放连接后都无法接收或发送消息给对方</p>
<ul>
<li>需要明确的是：TCP是全双工模式，这意味着是双向都可以发送、接收的</li>
<li>释放连接的定义是：双方都无法接收或发送消息给对方，是双向的</li>
<li>当主机1发出“释放连接请求”（FIN报文段）时，只是表示主机1已经没有数据要发送 / 数据已经全部发送完毕；但是，这个时候主机1还是可以接受来自主机2的数据。</li>
<li>当主机2返回“确认释放连接”信息（ACK报文段）时，表示它已经知道主机1没有数据发送了 但此时主机2还是可以发送数据给主机1</li>
<li>当主机2也发送了FIN报文段时，即告诉主机1我也没有数据要发送了 此时，主机1和2已经无法进行通信：主机1无法发送数据给主机2，主机2也无法发送数据给主机1，此时，TCP的连接才算释放。</li>
</ul>
<h5 id="为什么-TCP-协议有-TIME-WAIT-状态"><a href="#为什么-TCP-协议有-TIME-WAIT-状态" class="headerlink" title="为什么 TCP 协议有 TIME_WAIT 状态"></a><a href="https://draveness.me/whys-the-design-tcp-time-wait/">为什么 TCP 协议有 TIME_WAIT 状态</a></h5><p>？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<h5 id="TCP的流量控制——窗口滑动机制"><a href="#TCP的流量控制——窗口滑动机制" class="headerlink" title="TCP的流量控制——窗口滑动机制"></a>TCP的流量控制——窗口滑动机制</h5><h6 id="窗口"><a href="#窗口" class="headerlink" title="窗口"></a>窗口</h6><p>TCP 用“序列号（Sequence Number）”和“确认应答号（Acknowledge Number）”确保数据可靠传输，但如果每发送一个数据都要等对端发送ACK确认后才能发送下一个数据的话，显然效率是很低的，而且包的往返时间越长通信性能就越低，为解决这个问题，TCP引入了窗口这个概念。不再是一个数据段确认一次，而是以更大的单位进行确认，这么做的好处是转发时间将会被大幅地缩短。也就是说，发送端主机，在发送了一个数据段以后不必要一直等待确认应答，而是继续发送其他的数据段。接收方的硬件性能有限，不可能在同一时间处理完这些数据，所以接收方利用接收缓存（Buffer）去暂时存储那些还没来得及处理的数据。但接收这些未经确认的数据是有大小限制的，这个限制的大小称作窗口大小，也就是TCP报头中的16位字段“Window Size”，这个字段用来告诉发送端，接收端还有多少缓存可以用，发送端会根据缓存的大小来调整发送的数据量。<strong>换句话说，窗口大小就是指无需等待确认应答而可以继续发送数据的最大值。</strong>但是这个数值并不是对方一次发送数据的值，因为发送数据的值收到带宽等多方面因素的影响。</p>
<p>窗口的作用：</p>
<p><strong>1.确保数据不丢失</strong>：如果发送的数据丢失了可以重新发。</p>
<p><strong>2.控制发送速度</strong>：控制发送速度，以免接收方的缓存不够大导致溢出，同时控制流量也可以避免网络拥塞。</p>
<img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200118160548-1580447316189.jpg" alt="微信图片编辑_20200118160548" style="zoom:80%;">

<blockquote>
<p>Suppose we have two hosts, A and B, that form a TCP connection. At the start of the connection, both hosts allocate 32 KB of buffer space for incoming data, so the initial window size for each is 32,768.</p>
</blockquote>
<p>假设有两台主机用TCP协议连接，在TCP建立连接之初，两端都为接收数据设置了32K的缓存空间，所以这个初始的TCP 窗口大小是32678K（32X1024）。<strong>主机的buffer缓存，是由操作系统决定的。路由器交换机的buffer就是硬件内存</strong>。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_13-20-31.jpg" alt="Snipaste_2020-01-31_13-20-31"></p>
<blockquote>
<p>Host A needs to send data to host B. It can tell from host B’s advertised window size that it can transmit up to 32,768 bytes of data (in intervals of the maximum segment size, or MSS) before it must pause and wait for an acknowledgment. Assuming an MSS of 1460 bytes, host A can transmit 22 segments before exhausting host B’s receive window.</p>
</blockquote>
<p>假设两边的MSS协商为1460位，主机A在主机B的接收缓存满之前，可发送22个数据段，1460X22=32120，小于窗口最大值32768。</p>
<blockquote>
<p>When acknowledging receipt of the data sent by host A, host B can adjust its window size. For example, if the upper-layer application has only processed half of the buffer, host B would lower its window size to 16 KB. If the buffer was still entirely full, host B would set its window size to zero, indicating that it cannot yet accept more data.</p>
</blockquote>
<p>确认收到主机A发送的数据后，主机B可以调整其窗口大小。 例如，如果上层应用程序仅处理了一半的缓冲区，则主机B会将其窗口大小减小到16 KB。 如果缓冲区仍然完全满，主机B会将其窗口大小设置为零，表明它还不能接收更多数据。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_13-50-39.jpg" alt="Snipaste_2020-01-31_13-50-39"></p>
<blockquote>
<p>On a LAN with high bandwidth and extremely low delay, windows are rarely stressed as there are typically very few segments in transit between two endpoints at any given time. On a high-bandwidth, high-delay network, however, an interesting phenomenon occurs: it is possible to max out the receive window of the destination host before receiving an acknowledgment.</p>
</blockquote>
<p>在具有高带宽和极低延迟的局域网也就是LAN上，TCP的窗口很少受到压力，因为在一定时间在两个端点之间传输的段通常很少。 但是，在高带宽，高延迟的网络上，会出现一个有趣的现象：主机A发送的数据有可能在主机A接收到确认之前就沾满了主机B的缓存。</p>
<blockquote>
<p>As an example, let’s assume a TCP connection is established between two hosts connected by a dedicated 10 Mbps path with a one-way delay of 80ms. Both hosts advertise the maximum window size of 65,535 bytes (the maximum value of a 16-bit unsigned integer). We can calculate the potential amount of data in transit in one direction at one point in time as <strong>bandwidth * delay</strong>: 10,000,000 bps divided by 8 bits per byte, multiplied by 0.08 seconds equals 100,000 bytes. In other words, if host A begins transmitting to host B continuously, it will have sent 100,000 bytes before host B receives the first byte transmitted. However, because our maximum receive window is only 65,535 bytes, host A must stop transmitting once this number has been reached and wait for an acknowledgment from host B. (For the sake of simplicity, our example calculations do not factor in overhead from TCP and lower-layer headers.) This delay wastes potential throughput, unnecessarily inflating the time it takes to reliably transfer data across the network. TCP window scaling was created to address this problem.</p>
</blockquote>
<p>举例来说，让我们假设两台主机A、B之间用延迟80ms，带宽为10M的专线物理连接，他们之间用TCP建立连接，两边都有最大值为65535的TCP窗口（因为TCP报头中window size是16位，2的16次方就是65535），我们能够通过 “ 带宽 * 延迟 ” 的公式计算出某一时间点在一个方向上传输的潜在数据量：</p>
<p>10Mbps连接的带宽：也就是10,000,000 bps，除以8，将单位由bps换算成Bps，换算成Byte是因为byte（字节）一般做容量，bit（比特、位）一般用作速率（1B=8b、1B/s=8b/s或1Bps=8bps），然后乘以延迟0.08s（1ms = 0.001s，80ms=0.08s），等于100,000bytes。</p>
<p>也就是说在主机B收到第一个数据前，主机A会发送100，000字节的数据。但是因为我们接收的TCP最大窗口值为65535字节，所以主机A发送了65535字节的数据后必须停下来等待主机B发送ACK表示数据成功接收，因为 “window size” 这个字段的含义就是<strong>接收端告诉发送端自己还有多少缓冲区可以接收数据</strong>，发送端会按照这个值去发送数据，等对端确认接收了再继续发送余下的数据。（为了简单起见，我们这个例子的计算不考虑TCP报头以及其他报头的开销）。这种延迟浪费了潜在的吞吐量，不必要地增加了跨网络可靠传输数据所需的时间，将最大窗口限制在65535对所谓的“大而胖的网络”（那些有大带宽延迟产品）的性能有显著的损害。TCP窗口缩放就是为了解决这个问题而产生的。</p>
<h6 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h6><blockquote>
<p>Window scaling was introduced in RFC 1072 and refined in <a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a>. Essentially, window scaling simply extends the 16-bit window field to 32 bits in length. Of course, the engineers could not simply insert an extra 16 bits into the TCP header, which would have rendered it completely incompatible with existing implementations. The solution was to define a TCP option to specify a count by which the TCP header field should be <a href="http://en.wikipedia.org/wiki/Bitwise_operation#Logical_shift">bitwise shifted</a> to produce a larger value.</p>
</blockquote>
<p>滑动窗口由RFC 1072 引入，并在RFC 1323 中进行了改进。本质上，只是简单的将“window size”这个参数从16位的窗口字段扩展为32位。当然，工程师们不是简单的将新增加的16位插入TCP报头，如果简单的将新增加的16位字段插入报头中，TCP的新报头和之前的报头将不同，导致无法互相兼容。解决办法是在TCP的opinion字段中定义一个数值，TCP报头中的“window size”字段按opinion的该数值移位以产生较大的值。</p>
<blockquote>
<p>A count of one shifts the binary value of the field to left by one bit, doubling it. A count of two shifts the value two places to the left, quadrupling it. A count of seven (as shown in the example above) multiplies the value by 128. In this manner, we can multiply the 16-bit header field along an exponential scale to achieve more than sufficiently high values. Of course, this causes us to lose granularity as we scale (we can only increase or decrease the window size in intervals of 2n where <em>n</em> is our scale), but that isn’t much of a concern when dealing with such large windows.</p>
</blockquote>
<p>当值为1时，会将“window size”字段的二进制值向左移一位，也就是将“window size”的值加倍。 当值为2时，将值向左移动两位，也就是将“window size”的值扩大4倍。 一个7的计数（如下面的示例所示）将该值乘以128。以这种方式，我们可以将16位opinion的字段沿指数范围相乘，以获得更多的足够高的值。 当然，这会导致我们在缩放时失去粒度（我们只能以2的n次方为间隔增加或减小窗口大小，其中_n_是我们的缩放比例），但是在处理如此大的窗口时，这并不是什么大问题。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-02_20-51-06.jpg" alt="Snipaste_2020-02-02_20-51-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-02_20-34-36.jpg" alt="Snipaste_2020-02-02_20-34-36"></p>
<blockquote>
<p>The window scaling option may be sent only once during a connection by each host, in its SYN packet. The window size can be dynamically adjusted by modifying the value of the window field in the TCP header, but the scale multiplier remains static for the duration of the TCP connection. Scaling is only in effect if both ends include the option; if only one end of the connection supports window scaling, it will not be enabled in either direction. The maximum valid scale value is 14 (section 2.3 of <a href="http://tools.ietf.org/html/rfc1323">RFC 1323</a> provides some background on this caveat for those interested).</p>
</blockquote>
<p>在TCP三次握手建立连接期间，窗口缩放选项只在其SYN数据包中发送一次。 可以通过修改TCP标头中的窗口字段的值来动态调整窗口大小，但是比例乘数在TCP连接期间保持不变。 仅当两端都包含该选项时，缩放才有效； 如果仅连接的一端支持窗口缩放，则两端都不会启用该参数。 最大有效比例值是14（有进一步研究兴趣的请查阅RFC 1323的2.3节）。</p>
<blockquote>
<p>Revisiting our earlier example, we can observe how window scaling allows us to make much more efficient use of long fat networks. To calculate our ideal window, we double the end-to-end delay to find the round trip time, and multiple it by the available bandwidth: 2 * 0.08 seconds * 10,000,000 bps / 8 = 200,000 bytes. To support a window of this size, host B could set its window size to 3,125 with a scale value of 6 (3,125 left shifted by 6 equals 200,000). Fortunately, these calculations are all handled automatically by modern TCP/IP stack implementations.</p>
</blockquote>
<p>回头看我们之前举的例子，我们可以看到，滑动窗口是如何让我们能更有效的利用“长且胖”（long fat networks）网络的。为了计算我们所需要的理想窗口大小，我们将“端到端延迟”加倍，就能得到“往返时间”（RTT），将这个往返时间（RTT）乘以现有的带宽：2 X 0.08s X 10,000,000 bps / 8 = 200,000 bytes。为了能支持200,000 bytes大小的理想window size，主机B将它的window size 设置成3125（小于window size最大值的65535），然后将缩放比例值（也就是window scale）设置为6,（3125 X 2的6次方等于200,000），幸运的是，这些计算都自动的被近代的TCP\IP协议栈所处理好了。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-28_15-46-40.jpg" alt="Snipaste_2020-03-28_15-46-40"></p>
<p><strong>关于“长且胖”的网络和RTT</strong></p>
<blockquote>
<p>The term, long fat network (<strong>LFN</strong>), which are “<strong>long</strong>” in terms of distance and network delay and “<strong>fat</strong>” in terms of link bandwidth.</p>
</blockquote>
<p>“长且胖”网络是从英文：<strong>L</strong>ong <strong>F</strong>at <strong>N</strong>etwork翻译过来的，简称LFN，“Long”表示传输距离，“Fat”表示链路带宽。</p>
<p>RTT表示来回通信延迟（Round-trip delay time），在通信（Communication）、电脑网络（Computer network）领域中，意指：在双方通信中，发讯方的信号（Signal）传播（Propagation）到收讯方的时间（意即：传播延迟（Propagation delay）），加上收讯方回传消息到发讯方的时间（如果没有造成双向传播速率差异的因素，此时间与发讯方将信号传播到收讯方的时间一样久）</p>
<p><strong>关于 “ 带宽 * 延迟 ” 的公式</strong></p>
<p>在文章中，一共有两个“ 带宽 * 延迟 ” ，一开始是由带宽乘以单向通信延迟，后面是由带宽乘以来回通信延迟（RTT）。</p>
<p>前面的带宽乘以单向通信延迟，是为说明65535作为window size 过小，已经影响了TCP传输效率。这里可以把主机A和主机B的通信想象成两台主机通过一根管子（网络）连接，我们要计算它的体积，通过其“宽度”（它的带宽，这更像它的横截面积，以比特每秒为单位）乘以“长度”（单向延迟，以秒为单位），得出来的值<strong>等同在任何特定时间该网络线路上的最大数据量——已发送但尚未确认的数据。</strong>因为这个计算出来的值是100,000 bytes，远远大于65,535 bytes这个window size的值，没有最大限度的利用网络带宽，最理想的状态是当A发送第1个字节到达B的时候，A刚好停止发送数据，等待ACK，所以后面要加入window scale这个参数把window size扩大到32位、4294967296，更好的利用网络。</p>
<p>后面由带宽乘以来回通信延迟（RTT）这个公式，就是带宽时延乘积（英语：bandwidth-delay product，简写为BDP；或称带宽延时乘积、带宽延时积等），网络速率越高、延迟越大的情况下，计算出来的BDP越大，在这种情况下，TCP的性能难以发挥。</p>
<p>滑动窗口的工作机制演示：</p>
<p><img src="/2019/11/23/6-tcp-ip/gifhome_448x336_13s.gif" alt="gifhome_448x336_13s"></p>
<h5 id="TCP的重传机制"><a href="#TCP的重传机制" class="headerlink" title="TCP的重传机制"></a>TCP的重传机制</h5><blockquote>
<p>When the TCP transmits a segment containing data, it puts a copy on a retransmission queue and starts a timer; when the acknowledgment for that data is received, the segment is deleted from the queue. If the acknowledgment is not received before the timer runs out, the segment is retransmitted.</p>
</blockquote>
<p>当TCP传输包含数据的段时，它将该数据段的副本放在重传队列上并启动计时器。如果在计时器计时结束之前，收到该数据的ACK，则将该数据段的副本从重传队列中删除，然后继续移动窗口，发送接下来的TCP片段。 如果在计时器用尽之前未收到确认，则重新发送该段。这个计时等待的时间叫做重新发送超时时间(<strong>RTO</strong>, retransmission timeout)。</p>
<p>注意，如果是发送端的数据到达了接收端，但接收端的ACK包没到发送端的情况下，也还是会重传数据。</p>
<p>数据被重发之后若还是收不到确认应答，则进行再次发送。此时，等待确认应答的时间将会以2倍、4倍的指数函数延长。此外，数据也不会被无限、反复地重发。<strong>达到一定重发次数之后，如果仍没有任何确认应答返回，就会判断为网络或对端主机发生了异常，强制关闭连接。并且通知应用通信异常强行终止。</strong></p>
<p>除了上面的RTO，还有一个名词叫RTT，<strong>RTT</strong>，Round-trip delay time，来回通信延迟，就是在双方通信中，发讯方的信号传播到收讯方的时间，加上收讯方回传消息到发讯方的时间，要注意两者的区别。</p>
<p>需要注意的是，网络是一直波动的, RTT 是一直变化的, RTO 的值基于上次 RTT 往返时间动态计算出来的而不是一成不变的。</p>
<p><img src="/2019/11/23/6-tcp-ip/RTT.png" alt="RTT"></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP-RTO-Retransmission-Timeout-Diagram.jpg" alt="TCP-RTO-Retransmission-Timeout-Diagram"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-10_15-38-54.jpg" alt="Snipaste_2020-02-10_15-38-54"></p>
<p>例如上图中，client没收到server发送的segment2 ，所以会一直发送ACK2用来请求seq为2的数据，请注意，这里client收到了其他的比如segment 5，但client是不会发送ACK6的，因为它没收到seq2的数据，并且TCP ACK 的语义是<strong>当前数据段前的全部数据段都已经被接收和处理</strong>，所以接收方无法发送 ACK 消息，由于发送方没有收到 ACK，<strong>所有数据段</strong>对应的计时器就会超时并重新传输数据。</p>
<p>server一直收到ACK=2的数据，说明client只确认收到了seq=1的数据，所以在计时完成（RTO），认为client没收到数据以后，server从seq=2的数据重新开始发送。</p>
<h5 id="TCP的慢启动"><a href="#TCP的慢启动" class="headerlink" title="TCP的慢启动"></a>TCP的慢启动</h5><p>定义和作用：</p>
<blockquote>
<p>TCP slow start is an algorithm which balances the speed of a network connection. Slow start gradually increases the amount of data transmitted until it finds the network’s maximum carrying capacity.</p>
</blockquote>
<p>TCP慢启动是一种用来平衡网络连接速度的算法，慢启动渐渐增加传输的数量直到发现网络最大负载能力为止。</p>
<blockquote>
<p>Slow start prevents a network from becoming congested by regulating the amount of data that’s sent over it. It negotiates the connection between a sender and receiver by defining the amount of data that can be transmitted with each packet, and slowly increases the amount of data until the network’s capacity is reached. This ensures that as much data is transmitted as possible without clogging the network.</p>
</blockquote>
<p>慢速启动可以通过调节网络上发送的数据量来防止网络拥塞。 它通过定义每个数据包可以传输的数据量来协商发送方和接收方之间的连接，并缓慢增加数据量，直到达到网络容量为止。 这样可以确保在不阻塞网络的情况下传输尽可能多的数据。</p>
<p>工作机制：</p>
<p><strong>慢启动</strong>（Slow-start）是用于结合其他阶段算法，来避免发送过多数据到网络中而导致网络拥塞，算法在<a href="https://zh.wikipedia.org/wiki/RFC">RFC</a> <a href="https://tools.ietf.org/html/rfc5681">5681</a>中定义。慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小。</p>
<p>慢启动初始启动时设置拥塞窗口值（cwnd）为1、2、4或10个MSS。拥塞窗口在每接收到一个ACK时增加，每个RTT（<strong>RTT</strong>，Round-trip delay time，来回通信延迟，就是在双方通信中，发讯方的信号传播到收讯方的时间，加上收讯方回传消息到发讯方的时间）内成倍增加，当然实际上并不完全是指数增长，因为接收方会延迟发送确认，通常是每接收两个分段则发送一次确认包。发送速率随着慢启动的进行而增加，直到遇到出现丢失、达到慢启动阈值（ssthresh）、或者接收方的接收窗口进行限制。如果数据发生丢失（发送端发现有个ACK一直没来，一直重传然后超过重传次数的threshold，就认为丢包了），则TCP推断网络出现了拥塞，会试图采取措施来降低网络负载。这些是靠具体使用的TCP拥塞算法来进行测量判断。当达到慢启动阈值（ssthresh）时，慢启动算法就会转换为线性增长的阶段，算法控制每个RTT内拥塞窗口只增加1个分段量。虽然称为“慢启动”，但实际上比拥塞控制阶段的窗口增加更为激进。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-31_16-01-52.jpg" alt="Snipaste_2020-01-31_16-01-52"></p>
<p>关于CWND、slow start与congestion avoidance 之间的切换</p>
<p><a href="https://packetlife.net/blog/2011/jul/5/tcp-slow-start/">TCP Slow Start</a></p>
<p><a href="https://packetbomb.com/understanding-throughput-and-tcp-windows/">Understanding Throughput and TCP Windows</a></p>
<p><a href="https://indigoo.com/petersblog/?p=215">SCTP Congestion Control</a></p>
<p><img src="/2019/11/23/6-tcp-ip/ss-ca.png" alt="ss-ca"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-24_17-01-25.jpg" alt="Snipaste_2020-02-24_17-01-25"></p>
<p><img src="/2019/11/23/6-tcp-ip/cwnd-rwnd.png" alt="cwnd-rwnd"></p>
<h5 id="TCP拥塞的出现"><a href="#TCP拥塞的出现" class="headerlink" title="TCP拥塞的出现"></a>TCP拥塞的出现</h5><p>当接口必须传输超出其处理能力的更多数据时，就会发生拥塞。传统的体现是当它的队列将达到限制，尾部的帧会被丢掉，也就是把缓存之外收到的数据丢弃掉，表示我的缓存已经满了，没法处理再多的数据了。当然这么做肯定有很多弊端，所以出现了拥塞避免机制，具体的见下文。</p>
<h5 id="TCP拥塞避免"><a href="#TCP拥塞避免" class="headerlink" title="TCP拥塞避免"></a>TCP拥塞避免</h5><p>传统的做法是，如果接收方的缓存满了，就把尾部的帧丢弃，也就是丢弃了缓存外的数据，用来表示我的缓存已经满了，没法处理再多的数据了。发送方通过接收方的ACK发现，发送给对方1000个数据，可能只确认了200个，而且window size字段数字很小，说明接收方缓存已经满了，我得少发数据，因为发送了也处理不过来，等不拥塞了再多发数据。因为网络上用TCP的肯定不止一个程序，众多用TCP的程序发现拥塞以后是这么一个“传输——拥塞——丢尾部帧——等待不拥塞——传输”，大家同时这么干，这个过程就是TCP的全局同步（<a href="https://en.wikipedia.org/wiki/TCP_global_synchronization">TCP global synchronization</a>），这样对网络利用效率就很低，因为大家一股脑的在同一时间传输，再一起等待不拥塞，如果这时候再有UDP这种不管是否拥塞都传输的，就会造成TCP饥饿（tcp starvation），所以有了RED ( <strong>Random early detection</strong> ) 这个技术，大概就是说不丢尾部帧了，而是随机丢一些队列里的帧（这个随机是基于队列中的数据包数量和数据包的TOS标记），<strong>因为丢的不是同一时刻的数据包，所以不会造成TCP上面那些同步的情况，</strong>因为造成TCP全局同步需要在同一时间传输，同一时间等待，而因为RED的丢包是随机丢的，并不是同一时刻的包，所以不会造成TCP全局同步。但问题是还是需要丢包，会某些应用造成性能损伤，因为TCP的重传和慢启动机制，这时候ECN就横空出世，大概过程是一开始通过ECN字段为ECT（0），也就是这两位置10，来协商ECN这个字段，两边都支持协商好以后，当队列快要满的时候，网络设备给数据包mark CE bit（ECN=11），然后接收端看到数据包ECN=11 就知道路上有拥塞了，然后下一个TCP返回的报文就TCP  flag ECE（ecn echo）=1，告诉发送端：我这检测到拥塞了，你慢点发，然后发送端收到这个TCP包之后，看到ECE=1，就调小发送速率，并且CWR=1，相当于ECE的确认。<strong>具体实现过程请参照后面IP报头部分的“服务类型”章节。</strong>为了改善RED的这个问题，衍生出来了其他的RED，比如最常用的WRED，是给数据设置优先级，每个优先级丢包的概率不同，优先级低的数据被丢的概率高，优先级高的数据被丢的概率低；除了最常用的WRED还有ARED，RRED等其他方式，就不展开说了，因为使用率不高我也没看，不会说什么，囧~</p>
<p>TCP全局同步的示意图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-29_15-59-48.jpg" alt="Snipaste_2020-02-29_15-59-48"></p>
<p>加入RED之后的TCP拥塞避免示意图：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-29_17-20-26.jpg" alt="Snipaste_2020-02-29_17-20-26"></p>
<h5 id="TCP快速重传（Fast-Retransmit-Fast-Recovery）"><a href="#TCP快速重传（Fast-Retransmit-Fast-Recovery）" class="headerlink" title="TCP快速重传（Fast Retransmit/Fast Recovery）"></a>TCP快速重传（Fast Retransmit/Fast Recovery）</h5><blockquote>
<p>The TCP sender SHOULD use the “fast retransmit” algorithm to detect and repair loss, based on incoming duplicate ACKs.  The fastretransmit algorithm uses the arrival of 3 duplicate ACKs (4 identical ACKs without the arrival of any other intervening packets) as an indication that a segment has been lost.  After receiving 3duplicate ACKs, TCP performs a retransmission of what appears to be the missing segment, without waiting for the retransmission timer toexpire.</p>
</blockquote>
<p>TCP的发送方应该基于收到的重复ACK数据，利用快速重传算法检测并修复丢失的数据。快速重传算法使用3个重复ACK数据的到来（也就是4个相同且中间没有其他数据ACK干预的ACK，为什么这里是4个相同的ACK，而前面是3个重复的ACK呢，是因为第一个ACK不是重复的，后面3个一样的才是重复的）作为丢包的标志。收到3个重复的ACK包后，TCP不用等待重传计时器超时，立刻对丢失的数据段进行重传。</p>
<blockquote>
<p>After the fast retransmit algorithm sends what appears to be the missing segment, the “fast recovery” algorithm governs the transmission of new data until a non-duplicate ACK arrives.  The reason for not performing slow start is that the receipt of the duplicate ACKs not only indicates that a segment has been lost, but also that segments are most likely leaving the network (although a massive segment duplication by the network can invalidate this conclusion).  In other words, since the receiver can only generate a duplicate ACK when a segment has arrived, that segment has left the network and is in the receiver’s buffer, so we know it is no longer consuming network resources.  Furthermore, since the ACK “clock” is preserved, the TCP sender can continue to transmit new segments (although transmission must continue using a reduced cwnd)</p>
</blockquote>
<p>当快速重传算法发送了看似丢失的数据段后，“快速恢复”算法控制着新数据的传输，直到收到不重复的ACK为止。之所以不用慢启动是因为在这种情况下，重复的ACK不仅代表着数据段丢失，而且同时代表着这些数据段很可能离开了网络（尽管网络进行的大量段复制可能会使此结论无效），换句话说，因为接收方只能在数据段到达时产生重复的ACK，那个数据段已经不在网络上传输而是在接收方的缓存中了，所以并不消耗网络资源。此外，由于ACK的“时钟”被保留，所以TCP的发送方可以持续发送新的数据段（尽管网络必须使用缩小的CWND来传输）。</p>
<p>RFC中还有一个快速重传的步骤，因为快速重传已经被SACK（Selective Acknowledgments）所取代（The algorithm outlined in this document, heavily based on the algorithm detailed in [FF96], is aconservative replacement of the fast recovery algorithm –rfc3517），所以在这就不摘录翻译剩下的部分了。</p>
<h5 id="TCP-SACK"><a href="#TCP-SACK" class="headerlink" title="TCP SACK"></a><a href="https://packetlife.net/blog/2010/jun/17/tcp-selective-acknowledgments-sack/">TCP SACK</a></h5><p>在TCP传输过程中，没有快速重传的情况下，如果一个传输数据被分成5个数据段发送，当其中一个数据段丢失时，假设数据段2丢失了其他数据段都收到了，接收者会发送一个ACK=2的数据告诉发送端，我只收到了数据段1，但无法告诉发送端我收到了数据段3-5，并且接收端也不能发送一个ACK=6或者其他不是2的数据，因为如果发送了ACK=6表示希望发送端下发送Sequence=6的数据，ACK表示的是希望下一个收到的报文段的序列号，接收端并没有收到数据段2所以不能发送除了ACK=2的其他的ACK信息，但此时接收端只需要数据段2就行了，其他的数据段重新传输完全是浪费网络资源并降低传输效率，所以SACK（Selective Acknowledgment）出现了，SACK可以告诉发送端哪些数据段我收到了，哪些我没有收到。SACK的能力也需要两端在TCP建立连接时进行协商，在两边都支持的情况下才能使用。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-22_16-21-38.jpg" alt="Snipaste_2020-04-22_16-21-38"></p>
<p><strong>理论步骤分析：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/TCP_SACK.png" alt="TCP_SACK"></p>
<blockquote>
<p>Step 1</p>
<p>Response segment #2 is lost.</p>
<p>Step 2</p>
<p>The client realizes it is missing a segment between segments #1 and #3. It sends a duplicate acknowledgment for segment #1, and attaches a SACK option indicating that it has received segment #3.</p>
<p>Step 3</p>
<p>The client receives segment #4 and sends another duplicate acknowledgment for segment #1, but this time expands the SACK option to show that it has received segments #3 through #4.</p>
<p>Step 4</p>
<p>The server receives the client’s duplicate ACK for segment #1 and SACK for segment #3 (both in the same TCP packet). From this, the server deduces that the client is missing segment #2, so segment #2 is retransmitted. The next SACK received by the server indicates that the client has also received segment #4 successfully, so no more segments need to be transmitted.</p>
<p>Step 5</p>
<p>The client receives segment #2 and sends an acknowledgment to indicate that it has received all data up to an including segment #4.</p>
</blockquote>
<p>步骤1：服务器发往接收端的Segment 2丢失。</p>
<p>步骤2：服务器继续发送数据段3被接收端成功接收。接收端通过查看序列号发现，数据段1和3之间丢失了数据段2，接收端发送重复ACK去确认Sequence=1的数据段成功收到并且在opinion中附加了SACK字段表示它收到了数据段3。</p>
<p>步骤3：接收端收到了服务器发送来的数据段4，并且接收端又发送了一个ACK确认数据段1成功接收，但这次扩展的opinion选项字段中的信息表示接收端收到了数据段3和4。</p>
<p>步骤4：服务器端收到了接收端发送的确认数据段1收到重复ACK，这个数据中的SACK字段还表明接收端除了收到数据段1以外还收到了数据段3。至此，服务器端已经可以推测出来接收端并未受到数据段2，因此重新发送数据段2。接收到后一个SACK后发现接收端也收到了数据段4，因此没有其他需要重新传送的数据段了。</p>
<p>步骤5：接收端收到了重新发送的数据段2并且发送了确认收到数据段1-4的ACK信息。</p>
<p><strong>抓包分析：</strong></p>
<p><a href="/download/TCP_SACK.cap"> 点击下载抓包文件 </a></p>
<p>TCP在三次握手的前两个数据交互的时候就已经决定了这个TCP连接是否支持SACK属性，SACK在opinion字段中。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-22_16-21-38-1587612395091.jpg" alt="Snipaste_2020-04-22_16-21-38"></p>
<p>从第28个抓包中我们可以看到，这个ACK期待的下一个收到的序列号是17737：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-48-43.jpg" alt="Snipaste_2020-04-23_11-48-43"></p>
<p>从第三十个抓包中我们可以看到，这个数据包是乱序的，因为前面收到的ACK表明下一个期待的数据序列号应为17377，而第三十个抓包中的序列号是18825，和之前ACK期待的不一样，所以是个乱序包。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-53-18.jpg" alt="Snipaste_2020-04-23_11-53-18"></p>
<p>当收到乱序包以后，接收端用抓包31发送了重复的ACK，这个包中的opinion字段中有SACK部分，用来告诉发送端数据包30我收到了。当然这个SACK字段不可能简单的标明哪个数据段我收到了，而是标识出那些在数据包的确认号之外的数据的左右两边。从ACK17377到left edge18825之间的是没收到的，只传序列号17377-18825之间的数据段即可，而left edge18825到right edge20273这部分也是收到的，不用重新进行传递。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_11-57-12.jpg" alt="Snipaste_2020-04-23_11-57-12"></p>
<p>除了抓包31这个ACK以外，在抓包33、35、37也发送了同样的重复ACK，duplicate ACK，告诉发送端序列号17377-18825我没收到，于是发送端在抓包38的时候重新发送了序列号17377-18825的这些数据：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_14-23-29.jpg" alt="Snipaste_2020-04-23_14-23-29"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-23_14-22-27.jpg" alt="Snipaste_2020-04-23_14-22-27"></p>
<p>如果在TCP传输过程中，丢了好几个包，比如收到了序列号为0-500，900-1100和1300-2000的数据段，这时候SACK能否告诉发送端中间丢了好几段数据呢？当然可以，中间可以分几段来表示丢失的不同部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">                  +--------+--------+</span><br><span class="line">                  | Kind=5 | Length |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Left Edge of 1st Block       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Right Edge of 1st Block      |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|                                   |</span><br><span class="line">/            . . .                  /</span><br><span class="line">|                                   |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Left Edge of nth Block       |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line">|      Right Edge of nth Block      |</span><br><span class="line">+--------+--------+--------+--------+</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">TCP ACK - 501 (in TCP header, not in SACK Option)</span><br><span class="line">TCP SACK - 1st block Left Edge  - 900</span><br><span class="line">TCP SACK - 1st block Right Edge - 1100</span><br><span class="line">TCP SACK - 2nd block Left Edge  - 1300</span><br><span class="line">TCP SACK - 2nd block Right Edge - 2000</span><br></pre></td></tr></table></figure>

<h5 id="TCP协议存在的问题及解决"><a href="#TCP协议存在的问题及解决" class="headerlink" title="TCP协议存在的问题及解决"></a>TCP协议存在的问题及解决</h5><p><strong>TCP性能上存在的问题：</strong></p>
<p>TCP 选择了充分利用带宽，为流量而设计，期望在尽可能短的时间内传输更多的数据，但这种设计会存在一些负面因素，例如TCP超时计算是RTOx2，这样连续丢三次包就变成RTOx8了，十分恐怖；例如TCP丢包时会全部重传从丢的那个包开始以后的数据；例如TCP为了充分利用带宽，延迟发送ACK（NODELAY都没用），这样超时计算会算出较大 RTT时间，延长了丢包时的判断过程；弱网环境是丢包率较高的特殊场景，TCP 在类似场景中的表现很差，当 RTT 为 30ms 时，一旦丢包率达到了 2%，TCP 的吞吐量就会下降 89.9%7，从下面的表中我们可以看出丢包对 TCP 的吞吐量极其显著的影响：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-04-20_16-13-53.jpg" alt="Snipaste_2020-04-20_16-13-53"></p>
<p>影响TCP性能的三个原因：</p>
<ul>
<li>TCP 的拥塞控制算法会在丢包时主动降低吞吐量；</li>
<li>TCP 的三次握手增加了数据传输的延迟和额外开销；</li>
<li>TCP 的累计应答机制导致了数据段的传输；</li>
</ul>
<p>上边的这三个原因中，<strong>拥塞控制算法是导致 TCP 在弱网环境下有着较差表现的首要原因</strong>，三次握手和累计应答两者的影响依次递减，但是也加剧了 TCP 的性能问题。</p>
<p><strong>目前解决的方法：</strong></p>
<ol>
<li>使用 UDP 构建性能更加优异、更灵活的传输协议，例如：QUIC 等；</li>
<li>通过不同的手段优化 TCP 协议的性能，例如：选择性 ACK（Selective ACK, SACK），TCP 快开启（TCP Fast Open, TFO）</li>
</ol>
<p>既然TCP的拥塞算法是导致网络表现较差的首要原因，我们就需要改进这个算法，其中一种算法就是基于不丢包的拥塞算法，CDG（CAIA-Delay Gradient），该算法以 <strong>延迟</strong> 作为判断依据，延迟增大说明拥塞, 数据开始在路由器的缓冲中积累. 降低发送 <strong>窗口</strong>。然而 CDG 算法与基于丢包的算法不兼容, 只有全球的设备都换上 CDG，但这是不可能的，目前市面上的设备不可能一下子都切换到 CDG，因此 Google 就不开心了，Google 的科学家们开发了一种过渡算法来解决这个问题，这个算法的名字就是 <code>BBR（Bottleneck Bandwidth and RTT）</code>，它是一种全新的 <strong>拥塞控制算法</strong>，BBR 同 CDG 一致的思想是不以丢包作为拥塞控制信号，但是和 CDG 不同的是，BBR 能和 cubic 和 reno 共存。</p>
<p>BBR 由 Google 开发，供 Linux 内核的 TCP 协议栈使用，有了 BBR 算法，Linux 服务器可以显著提高吞吐量并减少连接延迟，简单来说 BBR 能加速网络传输速度。此外，部署 BBR 也很容易，因为该算法只需要发送方，而不需要网络或接收方的支持。</p>
<p><img src="/2019/11/23/6-tcp-ip/165a3f47af98be83.gif" alt="165a3f47af98be83"></p>
<h4 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h4><p><img src="/2019/11/23/6-tcp-ip/unnamed.png" alt="unnamed"></p>
<p><img src="/2019/11/23/6-tcp-ip/wireshark5-1.png" alt="wireshark5-1"></p>
<p><img src="/2019/11/23/6-tcp-ip/con_026a.gif" alt="con_026a"></p>
<h5 id="UDP的特点："><a href="#UDP的特点：" class="headerlink" title="UDP的特点："></a>UDP的特点：</h5><p>UDP是一种无连接的、不可靠的、面向报文、没有拥塞控制的协议。</p>
<p><strong>无连接的</strong>：和TCP要建立连接不同，UDP传输数据不需要建立连接，就像写信，在信封写上收信人名称、地址就可以交给邮局发送了，至于能不能送到，就要看邮局的送信能力和送信过程的困难程度了。</p>
<p><strong>不可靠的</strong>：因为UDP发出去的数据包发出去就不管了，不管它会不会到达，即使到达不了也不会像TCP那样重传，因为UDP报头很精简，不像TCP报头中有序列号、确认号以及重传机制，能知道哪些数据发送到哪些没法送到，也不会重传那些没发送到的数据，所以很可能会出现丢包现象，使传输的数据出错。</p>
<p><strong>面向报文</strong>：数据报文，就相当于一个数据包，应用层交给UDP多大的数据包，UDP就照样发送，不会像TCP那样拆分。</p>
<p><strong>没有拥塞控制</strong>：拥塞，是指到达通信子网中某一部分的分组数量过多，使得该部分网络来不及处理，以致引起这部分乃至整个网络性能下降的现象，严重时甚至会导致网络通信业务陷入停顿，即出现死锁现象，就像交通堵塞一样。TCP建立连接后如果发送的数据因为信道质量的原因不能到达目的地，它会不断重发，有可能导致越来越塞，所以需要一个复杂的原理来控制拥塞。而UDP就没有这个烦恼，发出去就不管了。</p>
<h5 id="UDP的应用场景："><a href="#UDP的应用场景：" class="headerlink" title="UDP的应用场景："></a>UDP的应用场景：</h5><p>UDP通常用于对时间敏感的通信，在这种情况下，偶尔丢弃数据包比等待数据流更好。 语音和视频流量使用此协议发送，因为它们既对时间敏感，又被设计成可处理一定程度的丢失。 例如，许多基于Internet的电话服务使用的VOIP（基于IP的语音）通过UDP运行，在线游戏也通常使用UDP。 同样，由于DNS和NTP服务器都需要快速高效，因此它们通过UDP运行。</p>
<h5 id="UDP报头"><a href="#UDP报头" class="headerlink" title="UDP报头"></a>UDP报头</h5><p><img src="/2019/11/23/6-tcp-ip/th.jpg" alt="th"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-18_20-44-36.jpg" alt="Snipaste_2020-02-18_20-44-36"></p>
<p>（1）源端口：源端口长度为16位，用于标识源端口号，在需要对方回信时选用，不需要时可全用0。</p>
<p>（2）目的端口：目的端口号长度为16位，用于标识目的地数据包的端口。</p>
<p>（3）长度：UDP用户数据报的长度，其最小值是8（仅有首部）。</p>
<p>（4）校验和：校验UDP用户数据报在传输中是否有错，有错就丢弃。</p>
<h5 id="UDP常见协议："><a href="#UDP常见协议：" class="headerlink" title="UDP常见协议："></a>UDP常见协议：</h5><p>Multimedia applications, DNS, BOOTP, DHCP, TFTP, SNMP, RIP</p>
<h4 id="TCP-VS-UDP"><a href="#TCP-VS-UDP" class="headerlink" title="TCP VS UDP"></a>TCP VS UDP</h4><p>TCP用于在传输层有必要实现可靠传输的情况。由于它是面向有连接并具备顺序控制、重发控制等机制的，所以它可以为应用提供可靠传输。例如浏览网页的HTTP服务</p>
<p>UDP主要用于那些对高速传输和实时性有较高要求的通信或广播通信。我们举一个通过IP电话进行通话的例子。如果使用TCP，数据在传送途中如果丢失会被重发，但这样无法流畅地传输通话人的声音，会导致无法进行正常交流。而采用UDP，它不会进行重发处理。从而也就不会有声音大幅度延迟到达的问题。即使有部分数据丢失，也只是会影响某一小部分的通话</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-25_17-17-29.jpg" alt="Snipaste_2020-02-25_17-17-29"></p>
<h3 id="网络层（Internet-Layer）"><a href="#网络层（Internet-Layer）" class="headerlink" title="网络层（Internet Layer）"></a>网络层（Internet Layer）</h3><h4 id="网络层总览"><a href="#网络层总览" class="headerlink" title="网络层总览"></a>网络层总览</h4><p>TCP/IP的心脏是互联网层。这一层主要由IP（Internet Protocol）、ICMP（Internet Control Message Protocol）等协议组成。IP协议是一个面向无连接的协议，也就是在发送数据包之前不需要与目标地址之间建立连接，上层如果到需要发送给IP的数据，该数据会立即被压缩成IP包发送出去。</p>
<h5 id="为什么IP是无连接协议"><a href="#为什么IP是无连接协议" class="headerlink" title="为什么IP是无连接协议"></a>为什么IP是无连接协议</h5><p>主要有两点原因：一是为了简化，二是为了提速。面向连接比起面向无连接处理相对复杂。甚至管理每个连接本身就是一个相当繁琐的事情。此外，每次通信之前都要事先建立连接，又会降低处理速度。需要有连接时，可以委托上一层（比如TCP）提供此项服务。因此，IP为了实现简单化与高速化采用面向无连接的方式。</p>
<h5 id="如何提高可靠性"><a href="#如何提高可靠性" class="headerlink" title="如何提高可靠性"></a>如何提高可靠性</h5><p>IP提供尽力服务（Best Effort），意指“为了把数据包发送到最终目标地址，尽最大努力。”然而，它并不做“最终收到与否的验证”。IP数据包在途中可能会发生丢包、错位以及数据量翻倍等问题。如果发送端的数据未能真正发送到对端目标主机会造成严重的问题。例如，发送一封电子邮件，如果邮件内容中很重要的一部分丢失，会让收件方无法及时获取信息。</p>
<p>因此提高通信的可靠性很重要。<strong>TCP就提供这种功能。</strong>如果说IP只负责将数据发给目标主机，那么TCP则负责保证对端主机确实接收到数据。</p>
<p>那么，有人可能会提出疑问：为什么不让IP具有可靠传输的功能，从而把这两种协议合并到一起呢？</p>
<p>这其中的缘由就在于，<strong>如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。</strong>相比之下，按照网络分层，<strong>明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现。</strong></p>
<p>网络通信中如果能进行有效分层，就可以明确TCP与IP各自协议的最终目的，也有利于后续对这些协议进行扩展和性能上的优化。分层也简化了每个协议的具体实现。互联网能够发展到今天，与网络通信的分层密不可分。</p>
<h4 id="IPv4议报头"><a href="#IPv4议报头" class="headerlink" title="IPv4议报头"></a>IPv4议报头</h4><img src="/2019/11/23/6-tcp-ip/ip-v4-datagram-header.png" alt="ip-v4-datagram-header" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-01-08_17-05-12.jpg" alt="Snipaste_2020-01-08_17-05-12"></p>
<p><img src="/2019/11/23/6-tcp-ip/IP%20packet.png" alt="IP packet"></p>
<p><img src="/2019/11/23/6-tcp-ip/2-slide2.jpg" alt="2-slide2"></p>
<h5 id="版本号（Version）："><a href="#版本号（Version）：" class="headerlink" title="版本号（Version）："></a>版本号（Version）：</h5><p>长度4比特。标识目前采用的IP协议的版本号。一般的值为0100（IPv4），IPv6的值（0110），除此之外的版本号现网中已经几乎绝迹了。</p>
<p>如果不知道为什么0100对应IPV4，0110对应IPV6，请看<a href="https://renyuan431.github.io/2019/11/18/basic-knowledge/">4、基础知识</a>中关于2进制转换的部分，这里简单的说一下计算方法。</p>
<p>二进制转换成十进制的方法：二进制数从低位到高位（即从右往左）计算，第0位的权值是2的0次方，第1位的权值是2的1次方，第2位的权值是2的2次方，依次递增下去，把最后的结果相加的值就是十进制的值了。</p>
<p><strong>2进制的0100换算成10进制就是4，代表IPV4</strong></p>
<p>1. 第0位 0 x 2^0 = 0；</p>
<p>2. 第1位 0 x 2^1 = 0；</p>
<p>3. 第2位 1 x 2^2 = 4；</p>
<p>4. 第3位 0 x 2^3 = 0；</p>
<p>所以2进制的0100换算成10进制是：0+0+4+0=4</p>
<p><strong>2进制的0110换算成10进制就是6，代表IPV6。</strong></p>
<p>1. 第0位 0 x 2^0 = 0；</p>
<p>2. 第1位 1 x 2^1 = 2；</p>
<p>3. 第2位 1 x 2^2 = 4；</p>
<p>4. 第3位 0 x 2^3 = 0；</p>
<p>所以2进制的0110换算成10进制是：0+2+4+0=6</p>
<h5 id="IP包头长度（Header-Length）："><a href="#IP包头长度（Header-Length）：" class="headerlink" title="IP包头长度（Header Length）："></a>IP包头长度（Header Length）：</h5><p>长度4比特。这个字段的作用是为了描述IP包头的长度，因为在IP包头中有变长的可选部分。IP包头最小长度为20字节，由于变长的可选部分最大长度可能会变成60字节。</p>
<h5 id="服务类型（Type-of-Service、TOS）："><a href="#服务类型（Type-of-Service、TOS）：" class="headerlink" title="服务类型（Type of Service、TOS）："></a>服务类型（Type of Service、TOS）：</h5><p>长度8比特，通知沿途路由器包含在数据报中的数据的重要性，从而设置数据报的优先级，只有当<strong>网络设备能够支持</strong>（能够识别IP首部中的ToS字段）识别ToS字段时，这给字段设置才有意义。否则都是空谈。这个字段虽然在TCP\IP协议栈中被定义了，但一直以来基本没怎么使用过，在近些年被重新定义为<strong>Differentiated Services</strong>，这个字段又被划分为两部分，DSCP（differentiated services codepoint）和ECN（Explicit Congestion Notification）。</p>
<p><img src="/2019/11/23/6-tcp-ip/differentiated%20services-1578811260461.jpg" alt="differentiated services"></p>
<blockquote>
<p>Differentiated services or DiffServ is a computer networking architecture that specifies a simple and scalable mechanism for classifying and managing network traffic and providing quality of service (QoS) on modern IP networks. DiffServ can, for example, be used to provide low-latency to critical network traffic such as voice or streaming media while providing simple best-effort service to non-critical services such as web traffic or file transfers.</p>
<p>DiffServ uses a 6-bit differentiated services code point (DSCP) in the 8-bit differentiated services field (DS field) in the IP header for packet classification purposes. The DS field replaces the outdated IPv4 TOS field.</p>
<p>Explicit Congestion Notification (ECN), is used by some routers to signal support for Explicit Congestion Notification and, when it is supported, the bits can be used to signal congestion (ECN = 11)</p>
</blockquote>
<p>区分服务或DiffServ是一种计算机网络体系结构，它指定了一种简单且可扩展的机制，用于对网络流量进行分类和管理，并在现代IP网络上提供服务质量（QoS）。 例如，DiffServ可用于为关键网络流量（例如语音或流媒体）提供低延迟，同时为非关键服务（例如Web流量或文件传输）提供简单的尽力而为服务。</p>
<blockquote>
<p>The definition of ToS was changed entirely in RFC 2474, and it is now called Differentiated Service (DS). On the eight fields, the upper six bit contain value called Differentiated Services Code Point (DSCP). The last two bits are used for Explicit Congestion Notification and it is defined in RFC 3168.</p>
</blockquote>
<p>ToS的定义在RFC 2474中完全更改，现在称为差异化服务（DS）。 在8个字段上，高6位包含称为差分服务代码点（DSCP）的值。 后两位用于显式拥塞通知，它在RFC 3168中定义。区分服务代码点（DSCP）是一种分类和管理网络流量并在现代第3层IP网络中提供服务质量（QoS）的方法。</p>
<p>DiffServ使用了IP报头里8位差异服务字段（DS字段）中的6位差异服务代码点（DSCP）进行数据包分类。DS字段替换了过时的IPv4 TOS字段。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-09_13-12-48.jpg" alt="Snipaste_2020-02-09_13-12-48"></p>
<p>一些路由器使用显式拥塞通知（ECN）来表示对显式拥塞通知的支持，这是一个2个比特的字段，置00时，表示设备不支持ECN字段，当两边都置为ECT的时候，表示两端设备均支持ECN字段，可以协商这个能力。ECT（1）和ECT（0）均表示支持这个能力，但一般用ECT（0）。置位为11（CE）的时候，表示网络中出现拥塞。</p>
<p>一开始是没有ECN这个字段的，传统的做法是，如果接收方的缓存满了，就把尾部的帧丢弃，也就是丢弃了缓存外的数据，用来表示我的缓存已经满了，没法处理再多的数据了。发送方通过接收方的ACK发现，发送给对方1000个数据，可能只确认了200个，而且window size字段数字很小，说明接收方缓存已经满了，我得少发数据，因为发送了也处理不过来，等不拥塞了再多发数据。因为网络上用TCP的肯定不止一个程序，众多用TCP的程序发现拥塞以后是这么一个“传输——拥塞——丢尾部帧——等待不拥塞——传输”，大家同时这么干，这个过程就是TCP的全局同步（<a href="https://en.wikipedia.org/wiki/TCP_global_synchronization">TCP global synchronization</a>），这样对网络利用效率就很低，因为大家一股脑的在同一时间传输，再一起等待不拥塞，如果这时候再有UDP这种不管是否拥塞都传输的，就会造成TCP饥饿（tcp starvation），所以有了RED ( <strong>Random early detection</strong> ) 这个技术，大概就是说不丢尾部帧了，而是随机丢一些队列里的帧，<strong>因为丢的不是同一时刻的数据包，所以不会造成TCP上面那些同步的情况，</strong>因为造成TCP全局同步需要在同一时间传输，同一时间等待，而因为RED的丢包是随机丢的，并不是同一时刻的包，所以不会造成TCP全局同步。但问题是还是需要丢包，会某些应用造成性能损伤，因为TCP的重传和慢启动机制，这时候ECN就横空出世，大概过程是一开始通过ECN字段为ECT（0），也就是这两位置10，来协商ECN这个字段，两边都支持协商好以后，当队列快要满的时候，网络设备给数据包mark CE bit（ECN=11），然后接收端看到数据包ECN=11 就知道路上有拥塞了，然后下一个TCP返回的报文就TCP  flag ECE（ecn echo）=1，告诉发送端：我这检测到拥塞了，你慢点发，然后发送端收到这个TCP包之后，看到ECE=1，就调小发送速率，并且CWR=1，相当于ECE的确认。更具体的协商工作机制如下：</p>
<p>TCP initiation and process for ECN：</p>
<ol>
<li>Host A sends a SYNC packet with ECE and CWR set in TCP options field. ECN bit set to 00 in IP header.</li>
<li>Host B responds with a SYNC+ACK packet with ECE set in TCP options field. ECN bit set to 00 in IP header.</li>
<li>After TCP establishes with ECN capable, data start to be transmitted with ECT set(ECN=01/10,same meaning) </li>
<li>The middle device must enable support ECN on respective queue to enable ECN feature.</li>
<li>If a middle device detects that the WRED drop probability is greater than 0 in a ECN enabled queue, which means congestion experiencing in this queue. Device will remark the packet with CE(Congestion Experienced, ECN=II), and downstream device must remain it unchanged.</li>
<li>The receiver gets a packet with CE set, it responds in next ACK with ECE flag set in TCP header</li>
<li>When sender gets the ACK packet with ECE flag set, it reduces the sending rate and reply with CWR flag set in next packet to ack the ECE set packet.</li>
<li>When the receiver receives the CWR flag, the receiver stops setting the ECE bit in replies to the sender.</li>
</ol>
<p>TCP 三次握手时ECN的过程：</p>
<p>1、主机A在TCP三次握手发送第一次SYN时，除了将SYN位置1以外，还将TCP报头里的控制位中的ECE和CWR两个位也置为1；将IP报头中的ECN位设置为00：</p>
<img src="/2019/11/23/6-tcp-ip/%E4%B8%8B%E8%BD%BD.png" alt="下载" style="zoom:150%;">

<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200212184752.jpg" alt="微信图片编辑_20200212184752"></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200212185545.jpg" alt="微信图片编辑_20200212185545"></p>
<p>2、主机B发送数据相应主机A的TCP三次握手，将TCP报头中控制位里的SYN和ACK两位置为1，将IP报头中ECN两位也置为00。<br>3、当TCP建立完具有ECN能力的连接后，所传输的数据的IP报头中的ECN位将设置为01或10（表示的含义一样），这两个ECT置为本质上是在IP数据包中的ECN field中放置了一个随机数（<strong>The use of two ECT codepoints essentially gives a one-bit ECN noncein packet headers, and routers necessarily “erase” the nonce whenthey set the CE codepoint</strong>）。<br>4、主机AB之间的中间网络设备，必须在相应的队列上启用支持ECN才能启用ECN功能。<br>5、如果中间设备在启用ECN的队列中检测到WRED丢弃概率大于0，则表示此队列中出现拥塞。 设备将使用CE（表示经历拥塞，ECN = 11）标记该数据包，下游设备必须保持其不变。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20200328154414.png" alt="微信图片_20200328154414"></p>
<p>6.接收方获得一个带有CE设置的数据包，它在下一个ACK中响应，并在TCP报头中设置了ECE标志<br>7.当发送方收到设置了ECE标志的ACK数据包时，它将降低发送速率并在下一个数据包中设置CWR标志进行答复，以确认ECE设置数据包。<br>8.当接收方收到CWR标志时，接收方停止设置ECE位，以回复发送方。</p>
<p><strong>关于ECT的说明：</strong></p>
<blockquote>
<p>The use of two ECT codepoints essentially gives a one-bit ECN noncein packet headers, and routers necessarily “erase” the nonce whenthey set the CE codepoint [SCWA99].  For example, routers that erasedthe CE codepoint would face additional difficulty in reconstructingthe original nonce, and thus repeated erasure of the CE codepoint would be more likely to be detected by the end-nodes.  The ECN nonce also can address the problem of misbehaving transport receivers lying to the transport sender about whether or not the CE codepoint was setin a packet.</p>
</blockquote>
<p>这两个ECT置为本质上是在IP数据包中的ECN field中放置了一个随机数，当路由器将ECN field置为位CE（也就是置位11的时候），会将ECT置位抹去（其实也就是将ECT的10换为CE的11用来表示有拥塞了）。举例来说，如果路由器将CE字段抹去会面临难以恢复ECT置位中的那个随机数的情况（因为抹掉CE置位的路由器也不知道ECT置位的随机数是多少，它收到的只是个CE置位，所以就没法复原那个随机数，所以后面的路由器就会知道这个数据有问题因为没有ECT的随机数或者随机数有问题和之前的不同。这里说的这个抹去CE&lt;11&gt;的动作其实是错误的，因为CE表示有拥塞，不能简单的把这个抹去而不进行相应的动作），并且重复的抹去CE置位会让后面的路由器更容易发现这个问题。ECN随机数还可以解决不管是否在分组中设置CE码点的情况下，传输层接收者欺骗传输层发送者的问题。我理解是说是加上了ECT以后，因为多了一个随机数，如果上游设备对TCP层进行了擅自改变，能够检测出来。</p>
<h5 id="IP包总长（Total-Length）："><a href="#IP包总长（Total-Length）：" class="headerlink" title="IP包总长（Total Length）："></a>IP包总长（Total Length）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112151420.jpg" alt="微信图片编辑_20200112151420"></p>
<p>长度16比特。总长度是一个16比特字段，以字节为单位指定包的总长度，包括报头。IP包最大长度65535字节。</p>
<h5 id="标识符（Identifier）"><a href="#标识符（Identifier）" class="headerlink" title="标识符（Identifier）:"></a>标识符（Identifier）:</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112151451.jpg" alt="微信图片编辑_20200112151451"></p>
<p>长度16比特。该字段和Flags和Fragment Offest字段联合使用，对大的上层数据包进行分段（fragment）操作。当数据包的大小超过接口的<strong>最大传输单元</strong>（英语：<strong>M</strong>aximum <strong>T</strong>ransmission <strong>U</strong>nit，缩写<strong>MTU</strong>）时，必须将该数据包分割成较小的数据包，然后，路由器在“标识符（Identifier）”字段中用相同的数字标记每个片段，以便接收设备可以识别这些被分割的数据包，并将它们整合到一起。</p>
<h5 id="标记（Flags）："><a href="#标记（Flags）：" class="headerlink" title="标记（Flags）："></a>标记（Flags）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112152850.jpg" alt="微信图片编辑_20200112152850"></p>
<img src="/2019/11/23/6-tcp-ip/img9.png" alt="img9" style="zoom:150%;">

<p>长度3比特。该字段第一位不使用。第二位是DF位，DF位设为1时表明路由器不能对该上层数据包分段。如果一个上层数据包无法在不分段的情况下进行转发（例如数据包大小超过MTU但不允许分片），则路由器会丢弃该上层数据包并返回一个错误信息。第三位是MF位，当路由器对一个上层数据包分段，会将最后一个分段之外的所有MF位都设置为1，以便接收设备明白要继续等待分段，直到遇到MF = 0的分段为止。假设一个数据包被分为10段，当其中的分段5的数据在传输中丢失的话，整个所有的分段，也就是10个分段的数据都必须要重新传输。这种情况有可能会增加网络拥塞。</p>
<h5 id="分段序号（Fragment-Offset）："><a href="#分段序号（Fragment-Offset）：" class="headerlink" title="分段序号（Fragment Offset）："></a>分段序号（Fragment Offset）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112152954.jpg" alt="微信图片编辑_20200112152954"></p>
<p>长度13比特。该字段对包含分段的上层数据包的IP包赋予序号。由于IP包在网络上传送的时候不一定能按顺序到达，这个字段保证了目标路由器在接收到IP包之后能够按照发送的顺序准确还原分段的上层数据包。</p>
<h5 id="生存时间（Time-to-Live、TTL）："><a href="#生存时间（Time-to-Live、TTL）：" class="headerlink" title="生存时间（Time to Live、TTL）："></a>生存时间（Time to Live、TTL）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153031.jpg" alt="微信图片编辑_20200112153031"></p>
<p>长度8比特。当IP包进行传送时，先会对该字段赋予某个特定的值。当IP包经过每一个沿途的路由器的时候，每 个沿途的路由器会将IP包的TTL值减少1。如果TTL减少为0，则该IP包会被丢弃。这个字段可以防止由于故障而导致IP包在网络中不停被转发。TTL虽然中文翻译成生存时间，但实际来看其实是一个经过多少路由器的跳数计算，一般情况下建议TTL设置成为64，当然更小的TTL值（例如32或15）也能见到。</p>
<h5 id="协议（Protocol）："><a href="#协议（Protocol）：" class="headerlink" title="协议（Protocol）："></a>协议（Protocol）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153100.jpg" alt="微信图片编辑_20200112153100"></p>
<p>长度8比特。IP头中的协议号用来说明IP报文中承载的是哪种协议（一般是传输层协议，比如6 TCP，17 UDP；但也可能是网络层协议，比如1 ICMP；也可能是应用层协议，比如89 OSPF）。</p>
<p>一些知名协议号：</p>
<p><img src="/2019/11/23/6-tcp-ip/wellKnowProto1.JPG" alt="wellKnowProto1"></p>
<h5 id="头部校验和（Header-Checksum）："><a href="#头部校验和（Header-Checksum）：" class="headerlink" title="头部校验和（Header Checksum）："></a>头部校验和（Header Checksum）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153137.jpg" alt="微信图片编辑_20200112153137"></p>
<p>长度16位，由于IP包头是变长的，所以提供一个头部校验值来保证IP包头中信息的正确性。这个校验和不包括所封装数据，因为UDP、TCP和ICMP这些有自己的校验和去检测信息正确与否。该字段包含一个16位的补码校验和，由数据包的初始发送设备计算得出。</p>
<h5 id="起源和目标地址（Source-and-Destination-Addresses）："><a href="#起源和目标地址（Source-and-Destination-Addresses）：" class="headerlink" title="起源和目标地址（Source and Destination Addresses）："></a>起源和目标地址（Source and Destination Addresses）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153206.jpg" alt="微信图片编辑_20200112153206"></p>
<p>这两个地段都是32比特。标识了这个IP包的起源和目标地址。</p>
<h5 id="可选项（Options）："><a href="#可选项（Options）：" class="headerlink" title="可选项（Options）："></a>可选项（Options）：</h5><p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200112153233.jpg" alt="微信图片编辑_20200112153233"></p>
<p>这是一个可变长的字段。该字段由起源设备根据需要改写。可选项目包含以下内容：<br>松散源路由（Loose source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，但是允许在相继的两个IP地址之间跳过多个路由器。<br>严格源路由（Strict source routing）：给出一连串路由器接口的IP地址。IP包必须沿着这些IP地址传送，如果下一跳不在IP地址表中则表示发生错误。<br>路由记录（Record route）：当IP包离开每个路由器的时候记录路由器的出站接口的IP地址。<br>时间戳（Timestamps）：当IP包离开每个路由器的时候记录时间。</p>
<p>这几个参数由于有安全方面的问题，所以几乎不再使用。比如互联网上有人截获报文，就可以知道拓扑，截获大量报文，甚至可以推算全网的拓扑、IP以及接口，比较危险。</p>
<p>比如关于Loose Source and Record Route (LSRR)，<a href="https://tools.ietf.org/html/rfc6274#section-3.13.2">RCF6274</a>上3.13.2.3.的描述是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The LSRR option has well-known security implications.  Among other</span><br><span class="line">   things, the option can be used to:</span><br><span class="line"></span><br><span class="line">   o  Bypass firewall rules</span><br><span class="line"></span><br><span class="line">   o  Reach otherwise unreachable Internet systems</span><br><span class="line"></span><br><span class="line">   o  Establish TCP connections in a stealthy way</span><br><span class="line"></span><br><span class="line">   o  Learn about the topology of a network</span><br><span class="line"></span><br><span class="line">   o  Perform bandwidth-exhaustion attacks</span><br></pre></td></tr></table></figure>

<h4 id="IPv4地址"><a href="#IPv4地址" class="headerlink" title="IPv4地址"></a>IPv4地址</h4><h5 id="定义及格式"><a href="#定义及格式" class="headerlink" title="定义及格式"></a>定义及格式</h5><p>IPv4地址（以下简称IP地址）是为了确切地标识Internet中的主机和路由器，TCP/IP建立了一套编址方案，为每台主机和路由器分配一个全网唯一的地址。这个地址的名字就叫IP地址。（相当于国家为了知道谁是谁为每个人都分配了一个身份证号码一样），IP地址是一个<strong>逻辑地址</strong>，可以规划改变的。和现实中家里或公司的地址类似，现实中的地址绝大多数是唯一的，是为了让使用一个地址的人收到快递，现实中，一个身份证号（一个地址）对应一个人，网络中，一个IP地址对应一个设备或接口；互联网中的IP地址除极个别情况外也是唯一的，是为了让使用一个虚拟IP地址的人收到数据。IP地址的长度为32位，也就是IP报头中的源和目的IP地址所占的空间，也就是2的32位，32个1和0，例如00001011110000100011111101100100，但这个方式只有机器可以明白，因为机器只能识别0101这种二进制的数字，人类很难理解，于是把32位的IP地址分成4组，这样每个IP地址段中数字不太大方便人类记忆，每个八位组都可以用0到255之间的十进制数表示，然后将2进制换算成10进制，也就是点分十进制，比如上面的地址可以写成：00001011.11000010.00111111.01100100，换算成10进制是：11.194.63.100。这个换算的方式只说一下第一段如何换算，其他的以此类推：</p>
<p>00001011：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_11-18-30.jpg" alt="Snipaste_2020-02-26_11-18-30"></p>
<p>8+2+1=11，所以第一段00001011这个二进制数字换算成10进制数字为11。</p>
<p>以此类推，如果要将11000000换算成10进制：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_14-22-10.jpg" alt="Snipaste_2020-02-26_14-22-10"></p>
<p><img src="/2019/11/23/6-tcp-ip/fea3fac8ba890854dbfdde34926e04ac.png" alt="fea3fac8ba890854dbfdde34926e04ac"></p>
<p>我们需要记住上图的2的幂的结果，不需要死记硬背，这个是有技巧的，从上图来看，很容易发现，由于是2的幂，所有相邻的幂的前后都是相差2倍，所以只要知道其中一个幂值，就知道相邻的幂的值。</p>
<p><strong>但要注意，点分十进制这个写法只是为了方便人类理解记忆IP地址，而网络设备只能看懂32位的0101组合的数字。IP地址由网络位和主机位构成。</strong>网络位的概念基本可以等同于代表一个网段的网络号，网络位用于确定某一特定的网络，主机位用于确定该网络中某一特定的主机，它在这个特定的网络中的编号是多少。<strong>同一网段内的计算机网络部分相同，主机部分不同同时重复出现。</strong>初看这段可能一开始接触会觉得不知所云，这个命名规则用收件地址来类比会比较易懂一些：</p>
<p>比如要从广州寄个快递给北京市海淀区复兴路26号复兴小区7号楼1单元109的李磊收，快递员拿到这个快递以后，只需要看最开头的“北京市海淀区”就够了，他不需要管后面那一长串详细的小区名门牌号之类的因为那些信息等快递到了北京才要去管，快递不到北京知道那些东西毫无意义，他只需要知道地址最开头的大地址“北京市海淀区”，然后把这个快递交给发往北京的线路，发送到北京海淀的集散中心，由北京海淀的集散中心再去关心后边的具体的门牌地址之类的具体信息进行分拣投送。网络位起到的作用和收货地址里“北京市海淀区”这个大范围的作用类似，网络位（网络号/网段）定义了一个大的IP地址范围，网络位对应使用同一个网络号的主机范围，一个网络号（网段）可能包含N个IP地址（具体有几个地址要结合子网掩码计算得出），只要是发往这个网络号包含主机的数据，都可以直接发往通往这个网络号的设备，网络号和网络位的概念基本一致，就是网络位+主机位为0；主机位则是在这个特定的网络中的某一台特定的设备或接口，和地址后面具体的门牌号和收件人功能类似，属于在特定的网络号的范围内，精确定位用的。比如一个四合院里面可能住了很多人，但四合院的门牌号可能都是北京市西城区西直门大街西直门胡同1号院，但如果地址只写这个1号院，谁知道这封信是给院子里哪个人的呢，所以必须在这个1号院的地址后边加上收件人，这个“北京市西城区西直门大街西直门胡同1号院”代表了所有住这个院子里的人的一个大范围的地址，相当于网络号（网络位）的作用，确定一个大的地址范围（IP地址所属的大的范围也就是IP地址所属的网段），所有属于这个网段的每一个IP地址都是这个网络号的一部分，而收件人：张三、李四、王二麻子，相当于主机位。也可以用身份证号码的命名模式类比来理解网络位和主机位：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-10_17-43-57.jpg" alt="Snipaste_2020-03-10_17-43-57"></p>
<p>至于一个网段里有多少主机位，要看具体情况，比如192.168.1.0/24这个网段所能容纳的主机IP地址数，是从192.168.1.0 — 192.168.1.255这么多，但由于192.168.1.0是本网段的网络号所以不能使用，而192.168.1.255是本网段的广播地址，也不能作为普通IP地址使用，最后IP地址的数字是从192.168.1.1 — 192.168.1.254，一共是253个IP地址，把最后的主机位写成二进制，会明白这个意思：</p>
<p>192.168.1.0换算成二进制：</p>
<p>​           192       .           168        .            1           .           0</p>
<p>1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0</p>
<p>由于最后一个8位组都是主机位，所以第一个IP地址是00000001，将00000001换算成2进制，补全网络位以后，这个IP地址就是192.168.1.1；在这个基础上加1，主机位为00000002，由于这个是二进制，也就是逢二进一，所以加1以后主机位应为，00000010，第二个IP地址就是192.168.1.2；在前面的基础上加1 , 主机位为00000011，换算成2进制并补全网络位以后，IP地址为192.168.1.3。以此类推可以得出该网段包含的所有IP地址，因为1个8位组最大的数值就是8个1，也就是：11111111，所以一个8位组换算成10进制最大不会超过255。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-07_16-49-22.jpg" alt="Snipaste_2020-03-07_16-49-22"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-26_14-21-06.jpg" alt="Snipaste_2020-02-26_14-21-06"></p>
<h5 id="IP地址的类别："><a href="#IP地址的类别：" class="headerlink" title="IP地址的类别："></a>IP地址的类别：</h5><p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-02-27_20-35-06.jpg" alt="Snipaste_2020-02-27_20-35-06"></p>
<p><img src="/2019/11/23/6-tcp-ip/d8edafebca5bbbf1d5bb35cef4156026.png" alt="d8edafebca5bbbf1d5bb35cef4156026"></p>
<p>网络位部分决定了设备位于网络的哪个网段中，主机位部分标识了一个网段中的特定设备。</p>
<p>IP地址共分5个类别：A、B、C、D、E</p>
<p>A：左起第1位必须是0，其他随意变换（1~126）。第一个八位组为网络位，它第一位必须是0其他位数没有要求，其他三个八位组为主机位。A类网络默认子网掩码为255.0.0.0，也可写作/8。</p>
<p>第1位必须是0，说明第1个八位组中的第一个数字是固定的，其他7个数字可以任意变化，也就是从00000000，00000001,00000010,00000011….. ~ 01111111，将前面的二进制换算成十进制，就是从1 ~ 127，但由于全0地址被保留，因为0.0.0.0表示所有IP地址，常用于定义默认路由，而127.*的这个整个网段常被用作loopback网络接口的默认地址，用于测试本机的TCP\IP协议是否正常（能ping通这个地址说明本机的TCP\IP协议工作正常），按惯例通常设置为 127.0.0.1。这个地址在其他计算机上不能访问，就算你想访问，访问的也是自己，因为每台带有TCP/IP协议栈的设备基本上都有 localhost/127.0.0.1。所以A类地址的网络位只是从1~126，因为0和127都有特殊的用途和意义，所以可用的A类网络有126个（1.0.0.0；2.0.0.0…126.0.0.0），A类网络最大主机数量是256×256×256-2=166777214（减去1个主机位为0的网络地址和1个广播地址），也就是从1.0.0.0 ~ 126.255.255.255。</p>
<p>B：左起第1、2位必须是10（128 ~ 191）第一和第二个八位组为网络位，第一个八位组的第一位和第二位必须是0、1，其他位数没有要求，其他两个八位组为主机位。B类网络默认子网掩码为255.255.0.0，也可写作/16。</p>
<p>第1、2位必须是10，说明第1个八位组中的第1、2位数字是固定的，其他6个数字可以任意变化，也就是从10000000 ~ 10111111，将前面的二进制换算成十进制，就是从128 ~ 191，所以IP地址的范围是从128.0.0.0 ~ 191.255.255.255。可用的B类网络有16382个，每个网络最大主机数量256×256-2=65534。</p>
<p>C：左起第1、2、3位必须是110（192 ~ 223），前三个八位组为网络位，最后一个八位组为主机位。C类网络默认子网掩码为255.255.255.0，也可写作/24。</p>
<p>第1、2、3位必须是110，说明第1个八位组中的第1、2、3位数字是固定的，其他5个数字可以任意变化，也就是从11000000 ~ 11011111，将前面的二进制换算成十进制，就是从192 ~ 223，所以IP地址的范围是从192.0.0.0 ~ 223.255.255.255。C类网络最大主机数量256-2=254。</p>
<p>D：左起第1、2、3、4位必须是1110（224 ~ 239），不分网络地址和主机地址。</p>
<p>第1、2、3、4位必须是1110，说明第1个八位组中的第1、2、3、4位数字是固定的，其他5个数字可以任意变化，也就是从11100000 ~ 11101111，将前面的二进制换算成十进制，就是从224 ~ 239，所以IP地址的范围是从224.0.0.0 ~ 239.255.255.255。D 类地址没有主机标识，常用于组播（多播）。</p>
<p>E：左起第1、2、3、4、5位必须是11110（240 ~ 255）E类地址用于实验和将来使用。不分网络地址和主机地址。</p>
<p><strong>在分配 IP 地址时关于主机标识有一点需要注意。即要用比特位表示主机地址时，不可以全部为 0 或全部为 1。因为全部为 0 只有在表示对应的网络地址或 IP 地址不可以获知的情况下才使用。而全部为 1 的主机通常作为广播地址。因此，在分配过程中，应该去掉这两种情况。这也是为什么 C 类地址每个网段最多只能有 254（ 28 - 2 = 254）个主机地址的原因。</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/6187e6bd1d31364a8bda03f376b30351.png" alt="6187e6bd1d31364a8bda03f376b30351"></p>
<p><img src="/2019/11/23/6-tcp-ip/e664d181be8697229b52f2af236afae7.png" alt="e664d181be8697229b52f2af236afae7"></p>
<h5 id="关于IP地址的基本概念"><a href="#关于IP地址的基本概念" class="headerlink" title="关于IP地址的基本概念"></a>关于IP地址的基本概念</h5><h6 id="•单播（Unicast）："><a href="#•单播（Unicast）：" class="headerlink" title="•单播（Unicast）："></a>•<strong>单播（Unicast）：</strong></h6><p>主机之间一对一的通讯模式，网络中的交换机和路由器对数据只进行转发不进行复制，单播过程类似于我们现实生活中一对一的打电话。如果10个客户机需要相同的数据，则服务器需要逐一传送，重复10次相同的工作。但由于其能够针对每个客户的及时响应，所以现在的网页浏览全部都是采用单播模式，具体的说就是IP单播协议。网络中的路由器和交换机根据其目标地址选择传输路径，将IP单播数据传送到其指定的目的地。</p>
<h6 id="•广播（Broadcast）："><a href="#•广播（Broadcast）：" class="headerlink" title="•广播（Broadcast）："></a>•<strong>广播（Broadcast）：</strong></h6><p>主机之间一对所有的通讯模式，网络对其中每一台主机发出的信号都进行无条件复制并转发，所有主机都可以接收到所有信息（不管你是否需要），由于其不用路径选择，所以其网络成本可以很低廉。类似我们的校园广播，校园广播一开启播放，校园里的所有人都能听到，但是不是所有人都对广播内容感兴趣，有些人选择倾听，有些人选择忽略。但不管你是倾听还是忽略，广播的声音都会传到你的耳边。例如，校园广播一条失物招领通知，你根本没丢东西，所以这个广播内容与你无关，但是广播的声音还是会传到你的耳边。对比广场舞音乐，对于跳广场舞的大妈大婶来说，这就是音乐，对于想睡觉的您来说，这就是噪音。在数据网络中也允许广播的存在，但其被限制在二层交换机的局域网范围内，禁止广播数据穿过路由器，防止广播数据影响大面积的主机。</p>
<h6 id="•组播（Multicast）："><a href="#•组播（Multicast）：" class="headerlink" title="•组播（Multicast）："></a>•<strong>组播（Multicast）：</strong></h6><p>主机之间一对多（一组ip地址）的通讯模式，加入了同一个组的主机可以接受到此组内的所有数据，网络中的交换机和路由器只向有需求者复制并转发其所需数据。主机可以向路由器请求加入或退出某个组，网络中的路由器和交换机有选择的复制并传输数据，即只将组内数据传输给那些加入组的主机。这样既能一次将数据传输给多个有需要（加入组）的主机，又能保证不影响其他不需要（未加入组）的主机的其他通讯，有点类似于我们常用的微信群，只有加入了特定的微信群才能收到特定群发送的消息，也可以随时退出微信群，这样就无法收到相关微信群的消息了。IP地址中的D类就是组播用的地址，大概意思就是想接收特定组播地址的设备去监听该组播地址，就能收到相应的组播消息。</p>
<h6 id="•网络地址、网络号、网络位："><a href="#•网络地址、网络号、网络位：" class="headerlink" title="•网络地址、网络号、网络位："></a>•<strong>网络地址、网络号、网络位：</strong></h6><p>指代网络的地址，又叫网络号。标识网络上的一个物理网络地址，位于相同的物理网络上的所有主机（包括网关）共享一个相同的网络号，其主机地址的网络部分相同。这样的地址模式便于对大量地址进行分级管理，可以极大的减少路由表的规模，使得网络容纳大量主机成为可能。比如说，如果没有网络号，去往192.168.10.2、192.168.10.3、192.168.10.4将数据从E0口发送出去这个路由，在路由表中就要生成三个条目，而如果用网络号记录则只需要记录一条192.168.10.0的条目即可，能大大节约网络设备的条目数量。</p>
<p><strong>当一个IP地址的主机位全为0的时候得出的地址就是网络号。</strong>如果两个IP地址的网络号相同说明这两个IP地址在逻辑上处于同一个网络，在同一网段，通信的时候只需要二层设备就可以通信了；如果他们的三层地址不在同一个网段，所以必须要三层设备才能互相通信。</p>
<h6 id="•广播地址："><a href="#•广播地址：" class="headerlink" title="•广播地址："></a>•<strong>广播地址：</strong></h6><p>用于向网络中的所有主机发送数据的特殊地址。广播地址使用该网络范围内的最大地址。即主机部分的各比特位全部为1的地址。如下图中，192.168.1.255是192.168.1.0这个网络号代表的网段的广播地址，如果向192.168.1.255这个广播地址发送数据，整个192.168.1.0网段包括的IP地址都能收到这个消息。</p>
<p><strong>当一个IP地址的主机位全为1的时候得出的地址就是该网段的广播地址。</strong></p>
<h6 id="•主机地址："><a href="#•主机地址：" class="headerlink" title="•主机地址："></a>•<strong>主机地址：</strong></h6><p>分配给网络中终端设备的地址，例如：192.168.1.5。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-01_21-35-35.jpg" alt="Snipaste_2020-03-01_21-35-35"></p>
<h6 id="公网IP地址"><a href="#公网IP地址" class="headerlink" title="公网IP地址"></a>公网IP地址</h6><p>公有地址分配和管理由Inter NIC（Internet Network Information Center 因特网信息中心）负责。各级ISP使用的公网地址都需要向Inter NIC提出申请，有Inter NIC统一发放，这样就能确保地址块不冲突。有公网IP地址的话可以直接用这个地址访问互联网上的其他资源。</p>
<h6 id="私网IP地址"><a href="#私网IP地址" class="headerlink" title="私网IP地址"></a>私网IP地址</h6><p>创建IP寻址方案的人也创建了私网IP地址。这些地址可以被用于私有网络，在Internet没有这些IP地址，Internet上的路由器也没有到私有网络的路由表。</p>
<p>私有地址类似于“10号楼1单元808”，这个在本小区的内部可以正常使用，但出了本小区以外，很多小区都有10号楼1单元808这个地址，就没法正确的定位设备也就没法使用了。私有地址的使用仅限于局域网内部使用，无法在公网上获得路由，一般内部网络都是用私有地址，因为IPV4地址资源有限，如果使用私有地址的设备想访问互联网则使用NAT\PAT技术将私有地址转换成公有地址即可。</p>
<ul>
<li>A类：10.0.0.0 255.0.0.0，保留了1个A类网络。</li>
<li>B类：172.16.0.0 255.255.0.0～172.31.0.0 255.255.0.0，保留了16个B类网络。</li>
<li>C类：192.168.0.0 255.255.255.0～192.168.255.0 255.255.255.0，保留了256个C类网络。</li>
</ul>
<p>PS：私网地址访问Internet需要做NAT或PAT网络地址转换，目前我们常用的家用路由器，都是给家里分配一个私有地址网段，所有设备使用这个网段在内网进行通信，如果要访问互联网上的资源，需要将私有地址进行转换，转换成公有地址才可以。</p>
<p><img src="/2019/11/23/6-tcp-ip/b00638fef79863c0e1958bb912a52d7d.png" alt="b00638fef79863c0e1958bb912a52d7d"></p>
<h6 id="子网掩码："><a href="#子网掩码：" class="headerlink" title="子网掩码："></a>子网掩码：</h6><p>因为越来越多的用户接入互联网，原有的IP地址不够分的，比如一个A类地址中包含的IP地址过多，一般大公司用不了那么多，但按原有的IP地址规定又不好分开，<strong>所以加入了子网掩码，和IP地址结合使用，用于描述一个IP地址中的网络部分及主机部分，用来确定目标IP是否在“逻辑上”与本计算机在同一个网络内。</strong>为什么要确定两个IP地址在逻辑上是否在同一个网络呢？是因为如果两个IP在同一个网络内，也就是在同一个网段内，也就是他们的三层地址在同一个大的范围内，所以通信的时候只需要二层设备就可以通信了；如果他们的三层地址不在同一个大的范围内，必须要三层设备才能互相通信。</p>
<p><img src="/2019/11/23/6-tcp-ip/b740e271ede6cd9fa7d6be4f2bec061b.png" alt="b740e271ede6cd9fa7d6be4f2bec061b"></p>
<p>A、B、C类网络都有默认的子网掩码(default subnet mask).A 类IP 地址的默认子网掩码为255.0.0.0;B 类的为255.255.0.0;C 类的为255.255.255.0 ，但子网掩码也可以改变，也就是让网络位和主机位之间相互借位，已达到更好划分网络利用IP地址的目的，例如VLSM和超网，这两个概念在后面章节有详细的介绍。</p>
<p>如果子网掩码是24/的时候，就是说子网掩码为24位，前24位为网络位，后8位为主机位，也就是24个二进制的1：11111111.11111111.11111111.00000000，换算成10进制就是255.255.255.255.0</p>
<p><strong>如何如何计算出两个IP地址是否逻辑上在同一个网络（在同一网段）呢？</strong>也就是用32位的IP地址和32位的子网掩码，一位对一位的进行与运算，得出的就是所在网段。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-01_22-17-44.jpg" alt="Snipaste_2020-03-01_22-17-44"></p>
<h5 id="IP地址与子网掩码的与运算："><a href="#IP地址与子网掩码的与运算：" class="headerlink" title="IP地址与子网掩码的与运算："></a>IP地址与子网掩码的与运算：</h5><p>与运算的整体规则为：0&amp;0=0; 0&amp;1=0; 1&amp;0=0; 1&amp;1=1。即：两位同时为“1”，结果才为“1”，否则为0，举个例子：4&amp;6</p>
<p>4的二进制：0 1 0 0</p>
<p>6的二进制：0 1 1 0</p>
<p>得出结论：  0 1 0 0</p>
<p>所以得出结论，4&amp;6=4</p>
<p><img src="/2019/11/23/6-tcp-ip/v2-c6bc0d2fb99795fb273e1c976dff903c_r.jpg" alt="v2-c6bc0d2fb99795fb273e1c976dff903c_r"></p>
<p>IP地址与子网掩码的运算步骤为：</p>
<p>1、把IP地址和子网掩码变成二进制</p>
<p>2、将二进制的IP地址与子网掩码进行每一位对应的与运算</p>
<p>3、将运算后的结果换算为十进制得到网络地址也就是网络号</p>
<p>4、网络号不变，主机位全为0得出的即为该网段的网络号，主机位全为1得出的即为该网段的广播地址。</p>
<p>比如IP地址为192.168.1.129和192.168.1.5这两个C类网络地址，在子网掩码为255.255.255.0和255.255.255.128的时候是不同的。</p>
<p>当子网掩码为255.255.255.0的时候，掩码为/24位，因为一个8位组全为1的时候，1111111，换算成十进制以后是255，三个255，也就是3X8=24，掩码为24位，换算成二进制就是11111111.11111111.11111111.11111111。</p>
<p>192.168.1.5/24的网络号计算：</p>
<p>IP地址：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 1 0 1</p>
<p>子网掩码：         1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 0 0 0 0 0 0 0 0</p>
<p>网络号：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p>所以192.168.1.5这个IP当它的掩码为/24的时候，网络号为192.168.1.0，广播地址为192.168.1.255。</p>
<p>192.168.1.129/24的网络号计算以此类推：</p>
<p>IP地址：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 1</p>
<p>子网掩码：         1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 0 0 0 0 0 0 0 0</p>
<p>网络号：             1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p>所以192.168.1.129这个IP当它的掩码为/24的时候，网络号为192.168.1.0，和192.168.1.5的网络号相同，在同一个网段，当然二者的广播地址也是相同的，因为在同一网段。</p>
<p>下面来看看当这两个IP地址的子网掩码为255.255.255.128（也就是掩码为/25，前三个8位组均为255的时候一共是24位，所以第四个8位组的第一位也为1的时候&lt;10000000=128&gt;，正好是25个1，也就是/25位，）他们的网络号分别为多少。</p>
<p>192.168.1.5/25的网络号计算：</p>
<p>IP地址：                                  1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 1 0 1</p>
<p>子网掩码：                              1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 0 0 0 0 0 0 0</p>
<p>网络号：                                  1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 0 0 0 0 0 0 0  = 192.168.1.0</p>
<p>广播地址：                               1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 0 1 1 1 1 1 1 1 = 192.168.1.127</p>
<p>所以192.168.1.5这个IP当它的掩码为/25的时候，网络号为192.168.1.0，<strong>广播地址为192.168.1.127，广播地址这里要注意一下，因为子网掩码是25/位的，也就是说网络位有25位，IP地址一共32位，32-25=7，所以主机位是后7位，所以该网段的广播地址为192.168.1.127，并不是192.168.1.255。</strong></p>
<p>192.168.1.129/25的网络号计算：</p>
<p>IP地址：                          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 1</p>
<p>子网掩码：                      1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 1 1 1 1 1 1 1 . 1 0 0 0 0 0 0 0</p>
<p>网络号：                          1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 0 0 0 0 0 0 0  =192.168.1.128</p>
<p>广播地址：                      1 1 0 0 0 0 0 0 . 1 0 1 0 1 0 0 0 . 0 0 0 0 0 0 0 1 . 1 1 1 1 1 1 1 1 = 192.168.1.255</p>
<p><strong>所以192.168.1.129这个IP当它的掩码为/24的时候，网络号为192.168.1.128，和192.168.1.5的网络号不同，说明他们属于不同的网段，相互通信的时候需要三层设备。</strong></p>
<h5 id="子网划分"><a href="#子网划分" class="headerlink" title="子网划分"></a>子网划分</h5><h6 id="子网划分的定义"><a href="#子网划分的定义" class="headerlink" title="子网划分的定义"></a>子网划分的定义</h6><p>可以自由的加减子网掩码长度，也就是不限制于A/B/C类默认的掩码长度，A类地址不必须使用8/位的掩码，也可以用诸如：10/位掩码或者7/位掩码。</p>
<h6 id="子网划分的原因"><a href="#子网划分的原因" class="headerlink" title="子网划分的原因"></a>子网划分的原因</h6><p>子网就是把一个大网划分为几个小网，而如果按照默认的A\B\C类默认使用的话，比如一个B类地址，默认掩码为255.255.0.0，意味着这个地址空间里有2的16次方个IP，并且该网络号只能用于一个广播域，造成了IP地址的极大浪费，如果一个广播域中的PC数量过于庞大，网络可能被广播报文消耗大量资源。把一个大网络划分成几个不同的小网络以后，他们之间的网络号和广播地址各不相同，可以尽可能多的使用IP地址避免浪费，一个网段中的主机数量相对少一些的话，广播报文消耗的资源也会少很多，使得网络更有层次性。</p>
<p>为了解决IPv4的不足，提高网络划分的灵活性，诞生了两种非常重要的技术，那就是<strong>VLSM（可变长子网掩码）</strong>和<strong>CIDR（无类别域间路由）</strong>，把传统标准的IPv4有类网络演变成一个更为高效，更为实用的无类网络。</p>
<p>VLSM用于IPv4子网的划分，也就是把一个大的网络划分成多个小的子网；而CIDR则用于IPv4子网的聚合，当然主要是指路由方面的聚合，也就是路由汇总。通过CIDR可以把多个小的子网路由条目汇总成一个大网络的路由条目，以减少路由器中路由条目的数量，提高路由效率。</p>
<h6 id="子网划分的方法"><a href="#子网划分的方法" class="headerlink" title="子网划分的方法"></a>子网划分的方法</h6><p>子网划分的总体思路是借用现有网段的主机位的最左边某几位作为子网位，划分出多个子网：</p>
<p>①、把原来有类网络IPv4地址中的“网络ID”部分向“主机ID”部分借位</p>
<p>②、把一部分原来属于“主机ID”部分的位变成“网络ID”的一部分（通常称之为“子网ID”）。</p>
<p>③、原来的“网络ID”+“子网ID”=新“网络ID”。“子网ID”的长度决定了可以划分子网的数量。</p>
<p>网络ID等同于网络位，主机ID等同于主机位，翻译方式不同。</p>
<p><img src="/2019/11/23/6-tcp-ip/afdf9cfdadeda8e3fce05fd4857b1947.png" alt="afdf9cfdadeda8e3fce05fd4857b1947"></p>
<p>具体的划分步骤参见：<a href="https://renyuan431.github.io/2020/02/19/8-subnet/">子网划分</a></p>
<h5 id="网关"><a href="#网关" class="headerlink" title="网关"></a>网关</h5><h6 id="网关的定义"><a href="#网关的定义" class="headerlink" title="网关的定义"></a>网关的定义</h6><p>网关实质上是一个网络通向其他网络（其他网段）的IP地址，比如有网络A和网络B，网络A的IP地址范围为“192.168.1.1  ~  192.168.1.254”，子网掩码为255.255.255.0；网络B的IP地址范围为“192.168.2.1  ~  192.168.2.254”，子网掩码为255.255.255.0。在没有路由器的情况下，两个网络之间是不能进行TCP/IP通信的，即使是两个网络连接在同一台交换机（或集线器）上，TCP/IP协议也会根据子网掩码（255.255.255.0）判定两个网络中的主机处在不同的网络里。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目标主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程也是如此 所以说，只有设置好网关的IP地址，TCP/IP协议才能实现不同网络之间的相互通信。那么这个IP地址是哪台机器的IP地址呢？网关的IP地址是具有路由功能的设备的IP地址，具有路由功能的设备有路由器、启用了路由协议的服务器（实质上相当于一台路由器）、代理服务器（也相当于一台路由器）。</p>
<p>举一个生活中的例子方便理解网关的概念和用途，大家都知道，从一个房间走到另一个房间，必然要经过一扇门。同样，从一个网络向另一个网络发送信息，也就是不同的网段不同的网络号之间相互发送信息，也必须经过一道“关口”，这道关口就是网关。顾名思义，网关(Gateway)就是一个网络连接到另一个网络的“关口”。没有这个“关口”，不同网段之间的通信就无法进行，就相当于去别的国家没法过人家海关，就没法入境。</p>
<h6 id="网关的作用及工作流程的通俗解释"><a href="#网关的作用及工作流程的通俗解释" class="headerlink" title="网关的作用及工作流程的通俗解释"></a>网关的作用及工作流程的通俗解释</h6><p>假设你的名字叫小不点，你住在一个大院子里，你的邻居有很多小伙伴，在门口传达室还有个看大门的李大爷，李大爷就是你的网关。当你想跟院子里的某个小伙伴玩，只要你在院子里大喊一声他的名字，他听到了就会回应你，并且跑出来跟你玩。</p>
<p>但是你不被允许走出大门，你想与外界发生的一切联系，都必须由门口的李大爷（网关）用电话帮助你联系。假如你想找你的同学小明聊天，小明家住在很远的另外一个院子里，他家的院子里也有一个看门的王大爷（小明的网关）。但是你不知道小明家的电话号码，不过你的班主任老师有一份你们班全体同学的名单和电话号码对照表，你的老师就是你的DNS服务器。于是你在家里拨通了门口李大爷的电话，有了下面的对话：</p>
<p>小不点：李大爷，我想找班主任查一下小明的电话号码行吗？</p>
<p>李大爷：好，你等着。（接着李大爷给你的班主任挂了一个电话，问清楚了小明的电话）问到了，他家的号码是211.99.99.99</p>
<p>小不点：太好了！李大爷，我想找小明，你再帮我联系一下小明吧。</p>
<p>李大爷：没问题。（接着李大爷向电话局发出了请求接通小明家电话的请求，最后一关当然是被转接到了小明家那个院子的王大爷那里，然后王大爷把电话给转到小明家）</p>
<p>就这样你和小明取得了联系。</p>
<p>在网络中，同网段之间的设备要进行通信（和同一个大院里的其他小朋友联系）是不需要经过网关（看门的X大爷）的，不同网段之间的设备要进行通信，就必须经过网关（你家大院看大门的X大爷），帮你把你要发送的信息传送给目的IP所在网段的网关（对方大院看门的X大爷），因为只有对方的网关才能在收到发往该网段的数据时，完成之后的通信步骤，具体的通信步骤以及网关所扮演的角色，请参后文“用TCP/IP模型分析数据传输过程”部分。</p>
<h5 id="默认网关"><a href="#默认网关" class="headerlink" title="默认网关"></a>默认网关</h5><p>如果搞清了什么是网关，默认网关也就好理解了。就好像一个房间可以有多扇门一样，一台主机可以有多个网关。默认网关的意思是一台主机如果找不到可用的网关，就把数据包发给默认指定的网关，由这个网关来处理数据包。现在主机使用的网关，一般指的是默认网关。</p>
<p>？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p>
<h5 id="网络层协议"><a href="#网络层协议" class="headerlink" title="网络层协议"></a>网络层协议</h5><h6 id="ICMP（ping、Traceroute）"><a href="#ICMP（ping、Traceroute）" class="headerlink" title="ICMP（ping、Traceroute）"></a>ICMP（ping、Traceroute）</h6><p><strong>用途</strong>：</p>
<p>ICMP由设备（如路由器）用于与数据包的源进行通信，以解决传输问题，例如，如果数据未发送到目的设备，则ICMP可能将此信息报告给主机，并提供详细信息，以帮助识别传输错误。比较常用的是两种工具，Ping和Traceroute。</p>
<p><img src="/2019/11/23/6-tcp-ip/icmp-header-how.jpg" alt="icmp-header-how"></p>
<p><img src="/2019/11/23/6-tcp-ip/icmp-header-fields.jpg" alt="icmp-header-fields"></p>
<p>ICMP报头跟在IPV4报头后面，ICMP在IPV4报头中的协议号为1，所有的ICMP包都有8字节的报头部分和可变长度的数据部分，8字节的报头中，前4字节为固定格式，后4字节取决于ICMP数据包的类型/代码。</p>
<p>Type和Code两个字段，结合使用，在不同的字段下表示不同的含义，Type字段常用的为：</p>
<ul>
<li>Echo Reply (0)：表示对于ping包的回复，和Type8结合使用</li>
<li>Echo Request (8)：表示ping包的请求，和Type0结合使用</li>
<li>Destination Unreachable (3)：表示目标设备不可达</li>
<li>Time Exceeded (11)：表示ICMP等待超时</li>
</ul>
<p>下面来看看常见的ICMP的抓包：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-44-45.jpg" alt="Snipaste_2020-03-22_15-44-45"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-45-21.jpg" alt="Snipaste_2020-03-22_15-45-21"></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_15-46-19.jpg" alt="Snipaste_2020-03-22_15-46-19"></p>
<p>更多的关于Type和Code表示的含义有兴趣可以查看下表</p>
<p><img src="/2019/11/23/6-tcp-ip/Users/32759/Downloads/%E4%B8%8B%E8%BD%BD%20(1).png" alt="下载 (6-tcp-ip/%E4%B8%8B%E8%BD%BD%20(1).png)"></p>
<p><strong>Ping</strong>（ Echo Request and Reply—Types 8 and 0）</p>
<p>Ping是一种非常实用的程序，它使用ICMP消息来报告有关网络连接和主机与目标计算机之间的数据中继速度的信息。大概工作原理就是模拟双向通信过程来检测链路是否畅通，常用命令就是Ping x.x.x.x，一般会返回以下几种信息：</p>
<ul>
<li><p>! ! ! ! !            每一个感叹号代表收到一次回复，表示链路畅通</p>
</li>
<li><p>. . . . .            每一个省略号表示网络在等待答复时超时，表示链路不通</p>
</li>
<li><p>U U U U U    每一个U表示收到目标不可达的错误</p>
</li>
<li><p>Q Q Q Q Q   收到Q表示目的设备太忙无法回复</p>
</li>
</ul>
<p>ping包出去时，在Type中的字段是8，ping包的回复，在Type中字段是0。</p>
<p><strong>Traceroute</strong></p>
<p>traceroute命令可用于识别数据包到达其目标所使用的路径。 它标识从源主机到目标主机的路径中的所有路由器，在排除网络故障时很有用。 这个命令可以帮助网络管理员确定数据传输到哪台设备时发生了丢失，以便对该设备进行进一步的检查以确定问题原因。该命令利用IP头部的TTL字段，TTL字段在每经过一个设备时减少1，当TTL为0时（实际上，TTL来没有被减小到0，因为将其减小到0的路由器在TTL变成0之前会产生错误）数据包会被丢弃然后返回一个ICMP信息告诉源设备该情况，Traceroute命令就是利用TTL超时报错的特性来探测网络路径中的每一个设备节点。</p>
<p>Traceroute工作过程：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-22_16-09-58.jpg" alt="Snipaste_2020-03-22_16-09-58"></p>
<p>当设备A发送Traceroute到设备D时，A发出的数据的TTL从1开始并且持续增加，第一次发出的数据TTL=1，第二次发出的TTL=2，以此类推。当TTL=1的第一个数据到达设备B时，B发现TTL=1，再将这个TTL-1的话就为0了，会出现错误，从而丢弃该数据并返回一个ICMP超时的信息给设备A；设备A发送第二个数据，将TTL设置为2，经过设备B到达设备C后，设备C发现设备B发过来的数据TTL=1，再将这个TTL-1的话就为0了，会出现错误，从而丢弃该数据返回一个ICMP超时的信息，后面以此类推直到到达最终的设备D，从而将设备A——设备D之间的设备都搞清了。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-07-16.jpg" alt="Snipaste_2020-03-19_19-07-16"></p>
<p>上图是一个Traceroute成功的例子，Traceroute会把从源到目的设备的每一跳设备的信息显示出来。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-09-59.jpg" alt="Snipaste_2020-03-19_19-09-59"></p>
<p>上图是一个Traceroute失败的例子，表示数据包到10.0.0.1以后就无法再传输下去，表示极有可能是在该设备上出了问题。</p>
<p>Traceroute一般会返回如下的信息：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-19_19-18-15.jpg" alt="Snipaste_2020-03-19_19-18-15"></p>
<p><strong>ping包抓包：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200319203904.jpg" alt="微信图片编辑_20200319203904"></p>
<h3 id="数据链路层（DataLink-Layer）"><a href="#数据链路层（DataLink-Layer）" class="headerlink" title="数据链路层（DataLink Layer）"></a>数据链路层（DataLink Layer）</h3><h4 id="二层封装格式简析"><a href="#二层封装格式简析" class="headerlink" title="二层封装格式简析"></a>二层封装格式简析</h4><p>二层封装格式，能见到的有四种，分别是TCP/IP协议使用、目前基本大一统的Ethernet II，IEEE的IEEE 802.3、802.2 LLC、802.2 SNAP，常见的封装结构为IEEE 802.3和Ethernet II帧（以太网2），之所以有两种帧封装格式，是因为有OSI七层以及TCP/IP两种模型定义了两种不同的分装格式，他们的差别主要是在帧头封装部分，具体的区别有兴趣的自行搜索。之前商定的结果是控制层面的用802.3格式封装，转发层面的用以太网2封装，但目前基本上是以太网一统天下，所以在这就不介绍802.3的相关东西了。至于什么是控制层面、转发层面，后面会有专门的章节进行阐述。除了以上的知识，还有一些扩展的信息在思科论坛的<a href="https://community.cisco.com/t5/switching/ether-frames-802-3-naming-conventions/td-p/2076323">这个帖子</a>以及<a href="https://community.cisco.com/t5/switching/ethernet-802-3-vs-ethernet-ii-frame/td-p/2718996">这个帖子</a>里，如果有兴趣可以看看，这里贴一段我觉得总结的比较好的话：</p>
<blockquote>
<p>if you are going to look at an IPv4 or IPv6 communication, it will be practically always encapsulated into Ethernet II frames because those are the most efficient in terms of overhead. 802.3 + LLC frames are used nowadays mostly for older protocols authored by IEEE itself, such as STP/RSTP/MSTP. SNAP frames are often used for vendor-proprietary Layer2 protocols - Cisco uses it for CDP, DTP, VTP and PAgP, to name a few.</p>
</blockquote>
<p>如果你观察IPV6或者IPV4的通信，它们实际上都是用以太网2进行封装的，因为从开销方面来说这是最有效率的封装方式。如今，802.3+LLC子层的帧格式绝大部分时候是出现在IEEE编写的较老的协议上，比如STP/RSTP/MSTP等协议。SNAP帧格式经常出现在厂家私有的二层协议中，比如思科用在CDP, DTP, VTP 和 PAgP等协议上。</p>
<h4 id="为什么Ethernet-2-使用的更加广泛"><a href="#为什么Ethernet-2-使用的更加广泛" class="headerlink" title="为什么Ethernet 2 使用的更加广泛"></a>为什么Ethernet 2 使用的更加广泛</h4><blockquote>
<p>To run TCP/IP over IEEE 802.3, the SNAP format has to be used. That requires 8 bytes of the data field to identify the kind of data the frame is carrying: three bytes for the Logical Link Control, three bytes for the SNAP header, and two bytes for the Protocol Type field. That means the data field shrinks from the standard range of 46 to 1500 bytes down to a range of 38 to 1492. This is the reason most network managers stay with Ethernet II.</p>
</blockquote>
<p>在TCP/IP协议上运行IEEE802.3的封装时，必须使用SNAP格式，它需要8字节的数据字段用来标识帧所携带的数据的类型。这8个字节由，3个字节的逻辑子层控制、3字节的SNAP报头、2个字节的协议类型字段组成。这意味着能携带的数据部分将从46到1500字节，缩小到38到1492字节。<strong>数据部分缩小是绝大多数网络使用以太网2封装的原因。</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/u7vjq.jpg" alt="u7vjq"></p>
<h4 id="以太网2帧头分析"><a href="#以太网2帧头分析" class="headerlink" title="以太网2帧头分析"></a>以太网2帧头分析</h4><p><img src="/2019/11/23/6-tcp-ip/1920px-Ethernet_Type_II_Frame_format.svg.png" alt="1920px-Ethernet_Type_II_Frame_format.svg"></p>
<p><img src="/2019/11/23/6-tcp-ip/1-slide11.jpg" alt="1-slide11"></p>
<p>源目的MAC地址两个字段并不复杂就不多说了。</p>
<p>EtherType：这个字段标识由帧数据封装的上层协议，以便接收端能根据不同的上层协议用不同的协议进行处理，提高数据处理的效率。 例如，EtherType值0x0800表示该帧包含IPv4数据包。同样，以太类型0x0806表示ARP帧，0x86DD表示IPv6帧，0x8100表示存在IEEE 802.1Q标签，具体可以参考下表：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-23_15-06-24.jpg" alt="Snipaste_2020-03-23_15-06-24"></p>
<p>最后的CRC checksum，4字节，是表示Cyclical Redundancy Check (CRC)，最后这个部分是让接收端在收到数据的时候检查收到的帧是否正确无误。如果帧校验和错，就丢弃此帧。如果校验和正确，再去判断帧的目的硬件地址是否符合自己的接收条件，<strong>看帧校验和是二层解封装后的第一步</strong>。多说两句，这个部分从严格意义上来说应该叫“FCS - Frame Check Sequence”，FCS是用算法校验数据的过程，而CRC是FCS这个校验过程可以采用的一种校验的方式，以太网用的就是CRC这种校验方式，所以在以太网里可以暂且把两者看成是同一个东西，但从概念上来讲，要知道二者是不同的。</p>
<h4 id="MAC地址"><a href="#MAC地址" class="headerlink" title="MAC地址"></a>MAC地址</h4><p>所有的计算机和终端设备都需要通过网络适配器连接到局域网中，每一个适配器都有唯一的链路层地址，也被叫做 LAN 地址或者 MAC 地址，MAC 地址被设计成了扁平结构，它们不会随着所处网络的不同而发生改变。</p>
<p>MAC地址是烧录在Network Interface Card(网卡,NIC)里的MAC地址，所以也叫硬件地址，可以用两种不同的格式表示，分别是48位的 EUI-48 和 64 位的 EUI-64，IPV4网络中的MAC地址是EUI-48，EUI-64 主要用于 IPv6 协议。EUI-48长度为48比特，由16进制的数字组成。MAC地址是物理地址，一般情况下出厂时候就烧录到网卡中，也有一些特定的方式可以对其进行更改，但一般不推荐这么做。</p>
<p><img src="/2019/11/23/6-tcp-ip/How-To-Find-Or-View-MAC-Address-In-Windows-10-1.png" alt="How-To-Find-Or-View-MAC-Address-In-Windows-10-1"></p>
<p>其中，0 — 24位由厂家自己分配；25 — 47位是组织唯一标志符(organizationally unique identifier,OUI)。OUI是由IEEE分配给每个组织，再由组织按高到低的顺序分配1个唯一的全局地址给每个网卡以保证不会有重复的编号。第47位是individual/Group(I/G)位，当I/G位为0的时候，我们可以设想这个地址是MAC地址的实际地址可以出现在MAC头部信息；当I/G位为1的时候,我们可以设想它为广播或多播。第46位是G/L位，也叫U/L位。当这个位为0的时候代表它是由IEEE分配的全局地址；当这个位为1的时候,代表本地管理地址 (例如在DECnet当中) 。<strong>当MAC地址为全F的时候，代表该数据是个广播。</strong>和IP地址全球统一的点分十进制记录方式不同，MAC地址有一些厂家采取自己规定的方式进行记录：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-12_16-26-52.jpg" alt="Snipaste_2020-05-12_16-26-52"></p>
<p>MAC地址由IEEE负责分配，厂家在生产网卡时也需要向IEEE购买MAC地址，这种由机构分发 MAC 地址段并由设备商保证地址唯一的方式就是为了保证全世界所有硬件的网络地址唯一，但是在实际操作中，全球唯一是无法保证的而且我们也并不需要地址的全球唯一，这主要因为以下两个原因：</p>
<ul>
<li>在不同操作系统上，我们都可以通过软件直接修改网卡的 MAC 地址；</li>
<li>只需要保证一个局域网内的 MAC 地址不重复，网络就可以正常工作；</li>
</ul>
<h4 id="MAC地址和IP地址"><a href="#MAC地址和IP地址" class="headerlink" title="MAC地址和IP地址"></a>MAC地址和IP地址</h4><p>MAC地址和IP地址除了处于层级不同（IP地址在三层，MAC地址在二层），地址的位数不同（MAC地址12位，IP地址32位），MAC地址通常无法改变IP地址可以更改，IP地址是逻辑地址MAC地址是物理地址，这几个比较显著比较好理解的区别以外，还有一个最为关键且显著的差别，也就是他们使用功能以及范围上的区别：IP地址是用于在全球互联网上通信时标识一台设备的，而MAC地址是用于在特定本地网络中标识一台设备的，通信的过程也是先根据IP地址将数据发送到IP地址所在的特定本地网络中，然后根据MAC地址在本地网络中再把数据发送给该设备。关于两者的区别，这里举两个例子，一个是身份证号码和姓名，另一个是寄快递的地址。</p>
<p>姓名和MAC地址类似，在一个小区或者一个村里，不管你是叫张三李四王二麻子，一说名字大家都知道这个是你，因为一个村或一个小区人不多，大家也都相互认识，重名的不多，用名字来标识一个人基本是够用的也是很精确的；但当出去旅游或办事时，范围已经扩大到了全国，这时候叫同名同姓的可能性极高，再只用名字作为标识显然是不够的，这时候就需要一个全国唯一的东西，身份证号码，来标识一个人，IP地址类似于身份证号码。</p>
<p>下面再说说寄快递，比如一个地址“北京市西城区玉桃园小区3号楼2门808”这个地址，前面的“北京市西城区玉桃园小区”是在全国这个大范围里定位快递应送到哪个小区，功能类似于IP地址，在全球互联网内定位数据应发送到哪个网段（小区）中，而后面的“3号楼2门808”是在特定的小区内精准定位，功能类似于MAC地址，在数据发送到特定网段（玉桃园小区）后，在该网段（该小区）内的定位由MAC地址完成，因为全国有很多小区，很多小区都有“3号楼2门808”，光靠后面的无法将货物送达，货物必须到了特定小区后，后面的楼号以及门牌号才能发挥作用。</p>
<p>当然上面这两个比喻只是为了方便理解他们作用范围的区别，而不是对两者完全精确的比喻，请批判的阅读这个比喻后，重新看关于MAC地址和IP地址的准确定义，才能真正明白二者的作用。</p>
<h4 id="数据链路层协议："><a href="#数据链路层协议：" class="headerlink" title="数据链路层协议："></a>数据链路层协议：</h4><h6 id="ARP（Address-Resolution-Protocol-）"><a href="#ARP（Address-Resolution-Protocol-）" class="headerlink" title="ARP（Address Resolution Protocol ）"></a>ARP（Address Resolution Protocol ）</h6><p><strong>作用：</strong></p>
<p>– 将IPv4 地址解析为MAC 地址</p>
<p>– 维护IP与MAC映射关系的缓存</p>
<p>ARP是为了促进IP和以太网之间的动态地址解析而开发的，现在也可以在其他第二层技术上使用。 它通过允许IP设备在本地网络上发送广播来工作，并且它请求来自同一本地网络上另一设备的带有硬件地址的响应。</p>
<p><strong>ARP协议解决现网中的什么问题？</strong></p>
<p>在前面的笔记中也提到过，识别、传输一个数据通信是靠：源IP地址、目的IP地址、协议、源端口地址、目的端口地址，这5个元素，其中源、目的IP地址以及协议是封装在三层的ipv4报头中的，源、目的端口是封装在二层的以太网2报头中的，必须有这几个东西，数据才能封装成帧然后转换成0101的电信号通过网线传给另一端的设备，但一般情况下，网工测试线路是否通畅采用的是ping这个工具，比如你的地址是192.168.1.2，想看看到192.168.1.3是否通畅，你都是直接输入“ping 192.168.1.3”，然后系统就会告诉你连通性，但这时候通信必须的五元组里，你只有源、目的IP地址，协议（ping是ICMP协议中的一部分）以及源MAC地址这四个元组，目的MAC地址是不知道的，如何获取目的MAC地址完成二层帧封装呢？这就需要用到ARP协议，英文翻译成中文就是地址解析协议，地址解析是将网络层地址（IP地址）解析为数据链路层地址（MAC地址）的过程。</p>
<p><strong>必须注意的是，这里的ARP地址解析协议只用于解析Internet协议（IPv4）版本4中的单播地址</strong>，而IPv4下的组播地址使用直接映射方法，而IPv6使用新的邻居发现（ND）协议代替ARP，IPV4组播和IPV6中的部分会在后面的笔记中涉及到。</p>
<p>有两种关联IP和以太网地址的基本方法：直接映射或动态解析。但是，以太网地址长48位，而IP地址只有32位，这立即排除了直接映射的可能。</p>
<p>顺便提一句，ARP协议是出现时间比较早而且还在大范围使用的协议之一，RFC编号是826，发布于1982年。</p>
<p><strong>ARP协议分类</strong></p>
<p>1、静态映射。用命令添加静态的IP地址和MAC地址之间的映射条目，功能类似于大厦1层的索引牌。用静态映射的相对少一些。</p>
<p><img src="/2019/11/23/6-tcp-ip/sign.jpg" alt="sign"></p>
<p>2、动态解析。主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。动态映射的应用场景比较多。功能类似于你去小红家找妹纸玩，但只知道她在哪个楼住，但不知道具体楼层门牌号，然后在楼下大喊“小红你在哪~”，她听到你喊她以后出来告诉你她具体的楼层和门牌号，比如“我在地下十八层住，大爷来玩啊”这种。</p>
<p><strong>ARP表缓存查询命令</strong></p>
<p>windows：arp - a</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200512173718.jpg" alt="微信图片编辑_20200512173718"></p>
<p>Cisco IOS：show arp</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-26_16-54-39.jpg" alt="Snipaste_2020-05-26_16-54-39"></p>
<p>表中的**Age(min)**表示自从该ARP条目进入ARP表中以来的时间，当设备第一次收到该ARP时在ARP表项中输入该条目并启动该计时器，ARP的过期时间Nexus和普通交换机过期时间不同：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-06-15_10-12-53.jpg" alt="Snipaste_2020-06-15_10-12-53"></p>
<p>表中的<strong>ARPA</strong>是一种以太网默认的封装格式：</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-05-26_17-08-59.jpg" alt="Snipaste_2020-05-26_17-08-59"></p>
<p><strong>ARP封装格式</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/ARP+Packet+Format+Same+format+for+request+and+reply..jpg" alt="ARP+Packet+Format+Same+format+for+request+and+reply."></p>
<p><img src="/2019/11/23/6-tcp-ip/2015-10-18_00-33-22.png" alt="2015-10-18_00-33-22"></p>
<p><strong>Hardware type</strong> ：该字段表示网络链接协议类型。例如常用的TCP/IP中以太网表示为1，换算成16进制就是0X0001。</p>
<p><strong>Protocol type</strong>：该字段表示ARP请求所针对的互联网络协议。对于IPv4，其值为0x0800。</p>
<p><strong>Hardware address length</strong>：硬件地址（MAC地址）的长度（八位字节）。以太网地址长度为6。</p>
<p><strong>Protocol address length</strong>：互联网络地址（IP地址）的长度（八位字节）。互联协议在PTYPE中指定。示例：IPv4地址长度为4。</p>
<p><strong>Operation code</strong>：ARP request，也就是ARP请求时该字段为1，当为ARP reply，也就是ARP回复时该字段为2。</p>
<p>**Sender protocol address (SPA)**：Internetwork address of the sender，也就是发送设备的IP地址</p>
<p>**Target protocol address (TPA)**：Internetwork address of the intended receiver，也就是目标设备的IP地址。</p>
<p>在图中有<strong>两组MAC地址</strong>，要明白他们各自代表的是什么含义并且区分开，可以简单理解为一组是以太网2协议中的通信用MAC地址，另一组是arp协议中的请求用MAC地址：</p>
<ol>
<li>从左边起算的，在ARP前边的destination address 和 source address， source address表示的是这整个的数据帧的发送者的源MAC地址，destination address表示的是整个数据帧接收者的MAC地址，这个是以太网报头中的通信用的MAC地址，这组MAC地址的目的是把ARP请求信息送到接收端。</li>
<li>而ARP段中的source hardware address根据该数据是ARP请求还是ARP回复所表示的含义不同，在ARP请求中，此字段用于指示发送请求的主机的地址。在ARP答复中，此字段用于指示请求正在寻找的主机的地址。Target hardware address含义也是有区别的，在ARP请求中，此字段为空，因为并不知道目标MAC地址才要使用ARP协议。在ARP答复中，此字段用于指示发起ARP请求的主机的地址。ARP中的这组MAC地址是为了完成请求目的MAC地址的功能的。</li>
</ol>
<p><strong>工作过程：</strong></p>
<blockquote>
<p>ARP is a relatively simple request-and-reply protocol. The source device broadcasts an ARP Request that’s looking for a particular device based on the device’s IP address. That device responds with its hardware address in an ARP Reply message.</p>
</blockquote>
<p>ARP是一个相对来说比较简单的“请求——回应”的协议，源设备广播它的ARP请求，这个ARP请求基于目标设备的IP地址，那个有ARP请求中同样IP地址的设备将用ARP回复来告知源设备它的MAC地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-12_13-58-43.jpg" alt="Snipaste_2020-03-12_13-58-43"></p>
<blockquote>
<ol>
<li>Source Device Checks Cache The source device will first check its cache to determine if it already has a resolution of the destination device. If so, it can skip to step 9. </li>
<li>Source Device Generates ARP Request Message The source device generates an ARP Request message. It puts its own data link layer address as the Sender Hardware Address and its own IP address as the Sender Protocol Address. It fills in the IP address of the destination as the Target Protocol Address. (It must leave the Target Hardware Address blank, since that it is what it is trying to determine!) </li>
<li>Source Device Broadcasts ARP Request Message The source broadcasts the ARP Request message on the local network.</li>
<li>Local Devices Process ARP Request Message The message is received by each device on the local network. It is processed, with each device looking for a match on the Target Protocol Address. Those that do not match will drop the message and take no further action. </li>
<li>Destination Device Generates ARP Reply Message The one device whose IP address matches the contents of the Target Protocol Address of the message will generate an ARP Reply message. It takes the Sender Hardware Address and Sender Protocol Address fields from the ARP Request message and uses these as the values for the Target Hardware Address and Target Protocol Address of the reply. It then fills in its own layer 2 address as the Sender Hardware Address and its IP address as the Sender Protocol Address. Other fields are filled in, as explained in the description of the ARP message format in the following sec-tion. </li>
<li>Destination Device Updates ARP Cache If the source needs to send an IP dat-agram to the destination now, it makes sense that the destination will probably need to send a response to the source at some point soon. (After all, most com-munication on a network is bidirectional.) Next, as an optimization, the desti-nation device will add an entry to its own ARP cache that contains the hardware and IP addresses of the source that sent the ARP Request. This saves the desti-nation from needing to do an unnecessary resolution cycle later on.</li>
<li>Destination Device Sends ARP Reply Message The destination device sends the ARP Reply message. This reply is, however, sent unicast to the source device, because there is no need to broadcast it. </li>
<li>Source Device Processes ARP Reply Message The source device processes the reply from the destination. It stores the Sender Hardware Address as the layer 2 address of the destination and uses that address for sending its IP datagram. </li>
<li>Source Device Updates ARP Cache The source device uses the Sender Proto-col Address and Sender Hardware Address to update its ARP cache for use in the future when transmitting to this device.<br>KEY CONCEPT ARP is a relatively simple request-and-reply protocol. The source device broadcasts an ARP Request that’s looking for a particular device based on the device’s IP address. That device responds with its hardware address in an ARP Reply message.</li>
</ol>
</blockquote>
<p>源设备，也就是要发送数据的设备为设备A</p>
<p>目标设备，也就是要接收数据的设备为设备B</p>
<p>1、源设备A进行ARP缓存表查询。发送数据的源设备A在一开始将会对自己的ARP缓存表进行查询，看它是否有目标设备的“IP地址——MAC地址”的ARP解析结果，如果有该结果则直接跳到第九步。</p>
<p>2、源设备A生成ARP请求消息。当源设备A发现自身并没有对应的ARP缓存时，源设备生会成ARP请求信息，将本设备的源IP地址以及源MAC地址作为ARP请求信息的源IP地址以及源MAC地址，将目的设备B的IP地址作为目标IP地址。这个请求消息会将目标MAC地址设置为空因为A正在请求目标MAC地址。对比ARP报头格式我们可以知道，ARP封装的信息已经齐了，可以进行ARP报头的封装了。</p>
<p><img src="/2019/11/23/6-tcp-ip/arp-packet-format-1.jpg" alt="arp-packet-format-1"></p>
<p>“**Sender protocol address (SPA)<strong>”是Internetwork address of the sender，也就是发送设备的IP地址，“</strong>Target protocol address (TPA)**”是Internetwork address of the intended receiver，也就是目标设备的IP地址。</p>
<p>3、源设备A将ARP请求信息在本网段上进行广播。</p>
<p>4、本网段设备对ARP请求信息进行处理。本网段所有设备将收到源设备发送的ARP的请求信息，因为ARP请求信息是个“broadcasts”，也就是广播，它所传播的范围就是在本网段，每个收到该广播的设备都会核对自身的IP地址和ARP请求信息中的“目标”是否一致，如果不一致的话将丢弃该ARP请求信息也不会有下一步的处理了。如果所请求的arp目标在不同网段，则需要用到代理ARP，在这篇笔记中暂时不涉及到。</p>
<p>5、目标设备B生成ARP回复信息。那个IP地址和ARP请求信息中“目标IP地址”相同的设备，将生成一个ARP回复信息，这个回复信息将使用ARP请求信息中的源IP地址和源MAC地址，并将它们作为ARP回复信息中的目的IP地址和目的MAC地址。然后将自身的IP地址作为ARP回复信息中的源IP地址，将自己的MAC地址作为源MAC地址，然后封装好ARP报头。</p>
<p>6、目标设备B更新自身的ARP缓存表项。如果源设备A在得知目标设备B的MAC地址后要向目标设备发送数据，目标设备B之后回复数据的时候，也是需要源设备A的MAC地址的，毕竟大多数的通信都是双向的，所以作为一个优化步骤，目标设备B会将收到的ARP请求中的，源设备A的“IP地址——MAC地址”对应的ARP条目放入缓存中，以便于以后使用，因为缓存中有源设备A的ARP条目后，再通信的时候就不用进行ARP请求而可以直接使用了。</p>
<p>7、目标设备B发送APR回复消息。目标设备B发送ARP回复信息，这个ARP回复信息是基于单播的，因为已经知道源设备A的IP地址和MAC地址，无需用广播回复。</p>
<p>8、源设备A处理ARP回复消息。源设备处理A从目标设备B处收到的ARP回复消息，源设备A使用ARP中的发件人硬件地址（也就是ARP报头中的Target hardware address）作为发送给目标设备B的以太网报头中的目的MAC地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200319135836.jpg" alt="微信图片编辑_20200319135836"></p>
<p>9、源设备A更新ARP缓存。源设备A用目标设备的IP地址及MAC地址更新ARP表项，以便未来使用。</p>
<p><strong>示例分析：</strong></p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-08-38.jpg" alt="Snipaste_2020-03-15_14-08-38"></p>
<p>当PC想和1.1.1.254通信，通过上面ARP的9步我们知道，它先要查询本地的ARP表中是否有相关条目，这时在PC上是用arp -a这个命令在CMD中查询发现，PC并没有该条目所以要发送ARP请求来获知1.1.1.254的MAC地址。先看二层封装，由于ARP请求是一个广播，所以源MAC地址是自身的MAC地址，目的MAC地址则为全F，表示这是一个广播；然后看ARP报头封装，源MAC地址和源IP地址都是自身的地址不多说，目标MAC地址为全0，因为前面也说了，发送ARP请求就是为了获取ARP缓存，目标IP地址就是1.1.1.254。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-29-05.jpg" alt="Snipaste_2020-03-15_14-29-05"></p>
<p>当ARP请求到达交换机时，交换机会将该广播从除了接收接口以外的其他所有接口发送出去，每个收到该广播的设备都会核对自身的IP地址和ARP请求信息中的“目标”是否一致，如果不一致的话将丢弃该ARP请求信息也不会有下一步的处理。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-35-41.jpg" alt="Snipaste_2020-03-15_14-35-41"></p>
<p>当路由器收到该ARP请求时，将0101的电信号还原成帧，然后解二层封装，发现目标MAC地址为全F，也就是一个广播，因为广播是发送给全网段的，所以也就是发给自己的于是进一步解封装到ARP报头，发现Target IP和自身F0/0接口一致，于是对该请求进行处理。路由器将ARP请求信息中的源IP地址1.1.1.1，与源MAC地址00dd.f800.0001的对应条目放入本地ARP缓存中。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_14-39-09.jpg" alt="Snipaste_2020-03-15_14-39-09"></p>
<p>路由器生成回复ARP请求的单播数据，二层封装的源MAC地址为路由器F0/0的MAC地址，0000.000C.AAAA，目的MAC地址为PC的MAC地址00dd.f800.0001，PC的MAC地址是从PC的ARP报头中获得的，ARP报头封装的源MAC地址与源IP地址为F0/0口的相应地址，目标IP地址与目标MAC地址为PC的相应地址。</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-15-53.jpg" alt="Snipaste_2020-03-15_15-15-53"></p>
<p>ARP回复信息经交换机发送给PC后，PC对回复的信息还原成帧后查看目标MAC地址发现是发送给自己的，然后进一步对数据进行解封装，发现是arp 回复消息，然后将1.1.1.254与它的对应MAC地址条目放入arp缓存表，以后再向1.1.1.254发送数据的时候，就不用再通过arp请求MAC地址了。</p>
<p>ARP缓存在思科设备上的默认过期时间是1500秒，也就是25分钟，这个数字可以自行设置，设置范围为60 — 28800秒之间。</p>
<p>ARP抓包：</p>
<p>arp请求信息</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-22-21.jpg" alt="Snipaste_2020-03-15_15-22-21"></p>
<p>arp回复信息</p>
<p><img src="/2019/11/23/6-tcp-ip/Snipaste_2020-03-15_15-22-52.jpg" alt="Snipaste_2020-03-15_15-22-52"></p>
<h6 id="代理ARP（Proxy-ARP）"><a href="#代理ARP（Proxy-ARP）" class="headerlink" title="代理ARP（Proxy ARP）"></a>代理ARP（Proxy ARP）</h6><blockquote>
<p>Proxy ARP is a technique by which a proxy device on a given network answers the ARP queries for an IP address that is not on that network. The proxy is aware of the location of the traffic’s destination, and offers its own MAC address as the (ostensibly final) destination.</p>
</blockquote>
<p>代理ARP是一种技术，这种技术使得在特定网段上的代理设备回答不在该网段上的IP地址的ARP查询。代理设备知道如何前往数据的目的地址，并且将代理设备自身的MAC地址提供给ARP的查询者。</p>
<p>简单来说，当ARP请求目标跨网段时，网关设备收到此ARP请求，会用自己的MAC地址返回给请求者，这便是代理ARP（Proxy ARP）。代理ARP本质上来说是一个“善意的欺骗”，是一个“错位”的映射，实际网络中，代理ARP由网络中的网关设备来执行，包括路由器、多层交换机、无线路由器、防火墙等设备。并且，网关即便有代理ARP功能，也未必一定执行，还必须满足两个条件：<strong>①网关已经开启代理ARP功能；②网关有目标的路由信息。</strong>思科设备默认开启代理ARP功能，不用再手动进行开启，如果被关闭的话在接口上输入<strong>ip proxy-arp</strong>将接口的代理ARP打开。</p>
<h4 id="数据链路层在数据传输时的步骤："><a href="#数据链路层在数据传输时的步骤：" class="headerlink" title="数据链路层在数据传输时的步骤："></a>数据链路层在数据传输时的步骤：</h4><p>在发送端，数据链路层收到上层传过来的数据后，打上数据链路层的报头，然后发送给物理层。在接收端，数据链路层收到下层发过来的数据后，对二层报头进行解封装，首先查看二层的FCS部分校验是否正确，如果正确再查看报头中的目的MAC地址和本地的MAC地址是否相符，如果相符就根据二层报头中的EtherType将数据发给上层的相应协议继续处理，如果目的MAC地址和本机MAC地址不相符就将数据丢弃。</p>
<h3 id="物理层（Physical-Layer）"><a href="#物理层（Physical-Layer）" class="headerlink" title="物理层（Physical Layer）"></a>物理层（Physical Layer）</h3><blockquote>
<p>The physical layer contains the protocols relating to the physical medium on which TCP/IP will be communicating. Officially, the protocols of this layer fall within four categories that together describe all aspects of physical media: </p>
<p>Electrical/optical protocols describe signal characteristics such as voltage or photonic levels, bit timing, encoding, and signal shape. </p>
<p>Mechanical protocols are specifications such as the dimensions of a connector or the metallic makeup of a wire. </p>
<p>Functional protocols describe what something does. For example, “Request to Send” is the functional description of pin 4 of an EIA-232-D connector. </p>
<p>Procedural protocols describe how something is done. For example, a binary 1 is represented on an EIA-232-D lead as a voltage more negative than 3 volts.</p>
</blockquote>
<p>物理层包含那些和物理传输介质相关的协议，定义了电压、数据传输率、最大传输距离等参数，官方规定了四类属性来描述物理层的各个方面：</p>
<p>电气/光学协议描述了信号特征，例如电压或光子电平，位时序，编码和信号形状。</p>
<p>机械协议是规范，例如连接器的尺寸或电线的金属外观。</p>
<p>功能协议描述了某些功能。 例如，“请求发送”是EIA-232-D连接器的引脚4的功能描述。</p>
<p>过程协议描述了如何完成某件事。 例如，二进制文件1在EIA-232-D引线上表示为比3伏更负的电压。</p>
<p>简单来说，<strong>物理层在传输中完成的动作就是在发送端将二层数字帧转换成电磁脉冲</strong>，在不同的传输介质中，转换的结果不同，如果是在光纤中传输，也就是将0101的数字信号转换为光信号然后传输，如果是在铜缆中就是转换成高低电平然后传输，在接收端完成的动作就是将电磁信号还原成帧然后交给上层处理。</p>
<p>工作在物理层的设备有：中继器，常规集线器和收发器。</p>
<p><img src="/2019/11/23/6-tcp-ip/%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20200404175346.png" alt="微信截图_20200404175346"></p>
<h1 id="引用文章："><a href="#引用文章：" class="headerlink" title="引用文章："></a>引用文章：</h1><p><a href="https://blog.csdn.net/hanzhen7541/article/details/79072036">TCP和UDP协议的特点和区别详解</a></p>
<p><a href="https://www.zhihu.com/question/39324847">怎么有效理解可靠数据传输</a>？</p>
<p><a href="http://docs.52im.net/extend/docs/book/tcpip/vol1/17/">第17章 TCP：传输控制协议</a></p>
<p><a href="https://www.jianshu.com/p/9f3e879a4c9c#comments">一篇文章带你熟悉 TCP/IP 协议（网络协议篇二）</a></p>
<p><a href="https://packetlife.net/blog/2010/jun/7/understanding-tcp-sequence-acknowledgment-numbers/">Understanding TCP Sequence and Acknowledgment Numbers</a></p>
<p><a href="https://www.cnblogs.com/xuekai-to-sharp/p/3506982.html">IP包头</a></p>
<p>Routing TCP/IP, Volume I</p>
<p>数据通信与联网技术</p>
<p>图解TCPIP</p>
<p><a href="https://www.cnblogs.com/cyjaysun/p/4415439.html">协议号与端口号详解</a></p>
<p><a href="https://www.cnblogs.com/straybirds/p/5319604.html">ip地址的组成（网络位+主机位）</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/32361762">IP地址、子网掩码和网络号的计算</a></p>
<p><a href="https://juejin.im/post/5e187698f265da3e3c4ced87">网络架构系列1–TCP/IP详解</a></p>
<p><a href="https://www.jianshu.com/p/c4fcecc2fd2e">SYN-Flood攻击解决办法？</a></p>
<p><a href="https://blog.csdn.net/nie19940803/article/details/76647834">SYN Flood攻击及防御方法</a></p>
<p><a href="https://v.youku.com/v_show/id_XNDg1NDUyMDUy.html">TCP sliding window</a></p>
<p><a href="https://blog.csdn.net/wdscq1234/article/details/52444277">TCP-IP详解：滑动窗口（Sliding Window）</a></p>
<p><a href="https://blog.csdn.net/guizaijianchic/article/details/77524825">MTU，窗口大小和mss的区别</a></p>
<p><a href="https://www.juniper.net/documentation/en_US/junos/topics/concept/interfaces-media-mtu.html">Media MTU Overview</a></p>
<p><a href="https://packetlife.net/blog/2010/aug/4/tcp-windows-and-window-scaling/">TCP Windows and Window Scaling</a></p>
<p><a href="https://learningnetwork.cisco.com/message/553728#553728">TCP - Interface MTU VS. IP MTU</a></p>
<p><a href="https://networklessons.com/cisco/ccie-routing-switching-written/tcp-window-size-scaling">TCP Window Size Scaling</a></p>
<p><a href="https://python.freelycode.com/contribution/detail/948">你不知道什么是网络性能（一）</a></p>
<p><a href="https://medium.com/@retroviseur/long-fat-network-lfn-and-tcp-7df4654b7c21">Long Fat Network (LFN) and TCP</a></p>
<p><a href="https://blog.stackpath.com/tcp-slow-start/">What is TCP Slow Start?</a></p>
<p><a href="https://networkengineering.stackexchange.com/questions/59441/whats-the-use-of-an-acknowledgement-number-without-the-ack-flag-set">What’s the use of an acknowledgement number without the ACK flag set?</a></p>
<p><a href="https://www.zhihu.com/question/23940717">localhost、127.0.0.1 和 本机IP 三者的区别?</a></p>
<p><a href="https://www.jianshu.com/p/164ab8a6e6a9">单播、多播（组播）和广播的区别</a></p>
<p><a href="https://www.jannet.hk/zh-Hant/post/IP-Address-Version-4-IPv4/">IP Address Version 4 (IPv4) 網際網路協定位址</a></p>
<p><a href="https://www.zhihu.com/question/56895036">如何理解子网掩码</a>？</p>
<p><a href="https://www.zhihu.com/question/51074319">TCP/IP 协议到底在讲什么TCP/IP 协议到底在讲什么</a></p>
<p><a href="https://blog.51cto.com/vip2010/202899">网关(Gateway)–帮你深入理解什么是网关</a></p>
<p><a href="https://blog.51cto.com/mmanong/1945144">可变长度子网掩码（VLSM）在子网划分中的应用</a></p>
<p><a href="https://blog.51cto.com/6930123/2112403">IP地址和子网划分学习笔记之《IP地址详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2112748">IP地址和子网划分学习笔记之《子网掩码详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2113151">IP地址和子网划分学习笔记之《子网划分详解》</a></p>
<p><a href="https://blog.51cto.com/6930123/2115072">IP地址和子网划分学习笔记之《超网合并详解》</a></p>
<p><a href="https://www.hackingarticles.in/working-of-traceroute-using-wireshark/">Working of Traceroute using Wireshark</a></p>
<p><a href="https://www.globalknowledge.com/us-en/resources/resource-library/articles/what-is-the-difference-between-ethernet-ii-and-ieee-8023/">What is the Difference Between Ethernet II and IEEE 802.3</a></p>
<p><a href="https://www.jianshu.com/p/8d50e92a852c">计算机网络-笔记</a></p>
<p>TCP分段与IP<a href="https://www.jianshu.com/p/f9a5b07d99a2">分片</a></p>
<p><strong><a href="https://www.trueneutral.eu/2015/wireshark-frags-1.html">IP FRAGMENTATION IN WIRESHARK (1)</a></strong></p>
<p><a href="https://draveness.me/whys-the-design-tcp-three-way-handshake/">为什么 TCP 建立连接需要三次握手 · Why’s THE Design?</a></p>
<p><a href="https://draveness.me/whys-the-design-tcp-segment-ip-packet/">为什么 TCP/IP 协议会拆分数据</a></p>
<p><a href="https://draveness.me/whys-the-design-non-unique-mac-address/">为什么 Mac 地址不需要全球唯一</a></p>
<p><a href="https://blog.51cto.com/chenxinjie/1961255">图解ARP协议（四）代理ARP原理与实践（“善意的欺骗”）</a></p>
<p><a href="https://cordero.me/cisco-arp-and-mac-address-aging/">Cisco ARP and MAC Address Aging</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>7、为什么要建立TCP/IP通信模型</title>
    <url>/2020/02/19/layer-mind/</url>
    <content><![CDATA[<p>OSI七层和TCP\IP这两个模型，除了了解每层的功能、各字段的意义、封装解封装的过程以及每层的协议以外，还有一个重要但又容易被忽视的概念，就是建立分层的思维，之前的笔记中也提到过，OSI参考模型中的一层就相当于流水线上的一道工序或单位中的一个部门，他们既相互关联又彼此独立，下层为上层提供传输服务，不关心上层传输的内容，需要标识上层所使用的协议或应用；而上层也不关心下层传输的手段，只期望能将信息最终发到通信对端的相应层次上。之前一直觉得这个概念很好理解，也就没再关注这个，但在总结笔记的时候，才发现这个概念还是没有真正理解，可能这个概念要真正掌握并且固话还需要一次次的反复，每次当发现认知有问题的时候，会对此篇笔记进行更新。</p>
 <span id="more"></span>  

<h2 id="2020年"><a href="#2020年" class="headerlink" title="2020年"></a>2020年</h2><h3 id="2月17日事件"><a href="#2月17日事件" class="headerlink" title="2月17日事件"></a>2月17日事件</h3><p>起因是看到TCP的RFC文档的2.6 Reliable Communication里有这么一段话：</p>
<blockquote>
<p>An acknowledgment by TCP does not guarantee that the data has been delivered to the end user, but only that the receiving TCP has taken the responsibility to do so.</p>
</blockquote>
<p>一开始觉得这段话的意思是说，对一个数据进行ACK了也不能确保整个数据肯定传到“用户”（user）了，发送ACK的这个设备（也就是其他路由器或网络设备）需要完成接下来的步骤，因为可能收到这个数据并发送ACK的设备给丢弃了，例如它这没有路由表或者说它down了。但因为知道自己很渣，所以到思科论坛发了<a href="https://community.cisco.com/t5/routing/what-s-the-meaning-of-an-acknowledgment-by-tcp-does-not/m-p/4030767#M329627">求助帖</a>，想验证一下自己的想法是否正确，有个哥们回复我说，他认为：</p>
<blockquote>
<p>IMHO, it’s all about hierarchical model. The “user” is the “application process”. TCP is just one of the layers (transport, 4th). TCP is responsible for receiving/transmitted data only. Let’s imagine that TCP receives data. Then the data should travel to the end user (Application, 7th layer). But application may be overloaded and discards the data. In this situation the remote side received TCP-ACK, but on our side the user has not received the message.</p>
</blockquote>
<p>IMHO是in my humble opinion的缩写，翻译成中文就是“以我愚见”，人家真是谦虚啊，帮我解答疑惑还这么客气，真让我无地自容。</p>
<p>他的大概意思就是说，我不懂的那段文字其实说的是分层模型（潜台词就是说，哥们你没明白TCP\IP模型中这个分层的真正含义啊），RFC里的这个user指的并不是一个接收端，而指的是接收端TCP\IP模型（或OSI模型）应用层中的应用程序，因为模型中的每一层都是相互独立的，发给你ACK的是对端的TCP，而TCP在第四层也就是传输层，只能表示数据一直到对面的传输层都是正常的，而且对面的传输层也完整无误的收到了这个数据，也就是数据从发送端的传输层——网络层——数据链路层——物理层——接收端的物理层——传输层——网络层——传输层的这个过程都是没问题的，当然按道理来说，应用层确认收到数据以后，这个数据应该发送给了应用层，但是应用程序可能会过载，并丢弃数据。在这种情况下，会出现发送端已收到TCP-ACK，但在接收端，“user”也就是应用层的程序，尚未收到该消息。</p>
<p><img src="/2020/02/19/layer-mind/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91_20200219144709.jpg" alt="微信图片编辑_20200219144709"></p>
<p>后来经高人指点发现RFC文档上有这么一句话，更印证了上面那哥们的回答：</p>
<blockquote>
<p>This part of the RFC is about passing responsibility over to the operating system or whatever is the next stage of the process. It’s fundamentally concerned with the separation of layers.</p>
</blockquote>
<p>这段话说的是，RFC的这一部分是关于将责任转移到操作系统或过程的下一阶段。 从根本上讲，它与分层有关。所以说这段话还是在强调分层这个概念，当然我这种啃不下去RFC的人，是看不到这段话的。</p>
<p>后来到网上搜了一下，有一个人在另一个论坛提出了和我一样的问题，这个回答相对更严谨复杂一些，有兴趣的可以看一下：</p>
<p><a href="https://networkengineering.stackexchange.com/questions/55581/acknowledgment-by-tcp-does-not-guarantee-that-the-data-has-been-delivered">acknowledgment by TCP does not guarantee that the data has been delivered</a></p>
<h3 id="3月12日事件"><a href="#3月12日事件" class="headerlink" title="3月12日事件"></a>3月12日事件</h3><p>起因是因为感觉对RTO（retransmission timeout）还是理解的有问题，所以去网上看了<a href="https://www.extrahop.com/company/blog/2011/retransmission-timeouts-rtos-application-performance-degradation/">一篇文章</a>，发现文章里有这么一句话：TCP starts a retransmission timer when an outbound segment is handed down to IP。看完这句话，感觉又被教育了一次什么叫分层。</p>
<p>TCP是一个可靠的协议，里面的重传机制也是仅仅工作在本层的，和其他层没关系，之前看到一句话说：When the TCP transmits a segment containing data, it puts a copy on a retransmission queue and starts a timer，结合上面的那句话就是说，当TCP传输包含数据的段时，也就是说当TCP将数据段传送给下层的网络层时，它将该数据段的副本放在重传队列上并启动计时器。而并不是之前我所感觉的数据发出本设备时，计时器开始计时，而是当数据发出本层时计时器就开始计时了，因为TCP是传输层的协议，仅对自己传输层的东西负责和影响。</p>
<h2 id="关于分层概念的浅见"><a href="#关于分层概念的浅见" class="headerlink" title="关于分层概念的浅见"></a>关于分层概念的浅见</h2><p>最后再针对一张很好的图说两句自己对于分层概念以及模型的理解：</p>
<p>1、标准化</p>
<p>2、彼此独立</p>
<p>3、相互联系</p>
<p>4、便于实现</p>
<h3 id="便于网络通信的实现"><a href="#便于网络通信的实现" class="headerlink" title="便于网络通信的实现"></a>便于网络通信的实现</h3><p>为什么要弄出分层这么一个模型，个人感觉是因为整个网络数据的传输过程比较复杂，分层使得网络易于实现和维护，便于调试。类似于汽车上的流水线分工，一开始是一个工人生产一辆汽车，但随着汽车需求原来越大，汽车生产过程的越来越复杂，这种模式已经不适合大规模生产的要求了，首先是一个人很难掌握如此多的工序，其次是即使掌握了也不便于汽车的大规模生产，第三是由于一个人要做很多道工序，很难精通所有的工序，无法加快汽车生产速度也无法提高优化每一步的生产精度，无法提高产品质量。</p>
<p>网络传输也是同样的道理，一开始的时候协议是不分层的，实现所有的功能，但随着通信量的上升，如果要一种协议规定所有的功能和作用，那么该协议的具体实施和编程就会变得非常复杂，无法轻易实现。相比之下，按照网络分层，明确定义每层协议的作用和责任以后，针对每层具体的协议进行编程会更加有利于该协议的实现，使得网络易于实现和维护，便于调试。比如汽车生产中有些步骤是生产底盘，有些步骤是安装轮胎，有些步骤是安装外壳，但不同的车型（类似于实现用户需求的程序），需要的轮胎、外壳和底盘都不同（用不同的协议实现），当需要造轿车的时候（比如要实现浏览网页的功能），需要相对应的轿车底盘和轿车轮胎（应用层需要采用HTTP协议，传输层需要采用TCP协议）。</p>
<h3 id="标准化"><a href="#标准化" class="headerlink" title="标准化"></a>标准化</h3><p>生产设备的厂家以及每一层的协议，必须符合分层模型统一的标准才能相互兼容，完成通信的全步骤，如果其中一层出了问题或者改变，只需要在其中一层进行改变，不会影响其他层。这么说可能不太直观，依旧用汽车这货来举个贴近生活的例子方便理解，在网络通信中，如果没有统一的规则，自己按照自己的规则开发导致协议、设备相互不兼容，不仅无法通信，也无法形成今天全球互联网全互联的状态，类推到汽车行业就是，生产汽车零件的厂家有很多，比如轮胎有普利司通的，有马牌的也有韩泰的，品牌不同但必须按一个统一的规定去生产，比如轮胎的直径和宽度是多少才能用到轿车上，这样的话，当汽车中的某个零件损坏时，才能使用同规格的零件替换，因为生产的标准、使用的连接方式都相同。同理在分层模型中，网络层的协议也必须遵守一定的规则才能被通信协议使用，才能像汽车一样，如果轮胎坏了（类推到网络中就是其中某些层的某些协议或功能出了问题），只需要更换一个同型号的换轮胎即可上路飞驰，汽车的其他零件不受影响也不用变动（对相应出问题层级进行排错，出问题的特定层级排除错误通信即可恢复）。</p>
<h3 id="彼此独立又相互依靠"><a href="#彼此独立又相互依靠" class="headerlink" title="彼此独立又相互依靠"></a>彼此独立又相互依靠</h3><p>？？？？？？？？？？？？？？？</p>
<h3 id="上层依赖于下层，下层为上层提供服务"><a href="#上层依赖于下层，下层为上层提供服务" class="headerlink" title="上层依赖于下层，下层为上层提供服务"></a>上层依赖于下层，下层为上层提供服务</h3><p>？？？？？？？？？？？？？？</p>
<p>为什么要弄出分层这么一个模型，个人感觉是因为整个网络数据的传输过程比较复杂，分层使得网络易于实现和维护，便于调试。如果其中一层出了问题或者改变，只需要在其中一层进行改变，不会影响其他层。这么说可能不太直观，举个实际中的例子就是造汽车，一个人去造一整辆汽车显然无法适应现代汽车生产的需求，所以出现了汽车生产的流水线，这个流水线也就是将汽车生产的步骤分层成一个一个的步骤，每个步骤实现不同的工序用于实现不同的功能，网络分层也是一样的道理，要适应大规模数据传输必须将复杂的数据传输细分成实现不同功能的层次。比如汽车生产中有些步骤是生产底盘，有些步骤是安装轮胎，有些步骤是安装外壳，但不同的车型（类似于实现用户需求的程序），需要的轮胎、外壳和底盘都不同（用不同的协议实现），当需要造轿车的时候（比如要实现浏览网页的功能），需要相对应的轿车底盘和轿车轮胎（应用层需要采用HTTP协议，传输层需要采用TCP协议）。如果轮胎坏了（其中某些层的功能出了问题），只需要更换轮胎即可，汽车的其他零件不受影响（对相应出问题层级进行排错）。</p>
<p>当然仅仅分层也是不够的，还必须对每一层进行标准化，而生产设备的厂家以及每一层的协议，必须符合分层模型统一的标准才能相互兼容，完成通信的全步骤，否则如果没有统一的规则，自己按照自己的规则开发导致相互不兼容，不仅无法通信，也无法形成今天全球互联网全互联的状态。标准化就类似于生产汽车零件的厂家有很多，但必须按一个统一的规定去生产，比如轮胎的直径和宽度是多少才能用到轿车上，这样的话，当汽车中的某个零件损坏时，才能使用同规格的零件替换，因为生产的标准、使用的连接方式都相同。同理在分层模型中，网络层的协议也必须遵守一定的规则才能被通信协议使用。</p>
<p><img src="/2020/02/19/layer-mind/tcpipprotocols.png" alt="tcpipprotocols"></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>2、模拟器</title>
    <url>/2019/11/16/network-simulator/</url>
    <content><![CDATA[<h2 id="一、用什么模拟器"><a href="#一、用什么模拟器" class="headerlink" title="一、用什么模拟器"></a>一、用什么模拟器</h2><h3 id="（一）cisco-packet-tracer"><a href="#（一）cisco-packet-tracer" class="headerlink" title="（一）cisco packet tracer"></a>（一）cisco packet tracer</h3><p>cisco packet tracer 是思科出品的模拟器，界面、功能和使用都非常简单，对新手十分友好，基本上一学就会。不足是这个模拟器相对简单，一些命令无法运行，不过基本能满足NA阶段的学习。</p>
<h3 id="（二）EVE-NG"><a href="#（二）EVE-NG" class="headerlink" title="（二）EVE-NG"></a>（二）EVE-NG</h3><p>个人推荐使用EVE，因为EVE不仅可以模拟网络设备，也可以运行一切虚拟机，可以算得上是仿真虚拟环境，给用户最接近真实网络设备的体验；它是深度定制的Ubuntu操作系统，可以直接把它安装在x86架构的物理主机上。它也有ova版本，可以导入到VMware等虚拟机软件中运行。EVE-NG在交互模式上更加具有优势，与GNS3截然不同。GNS3更像是用户使用的软件，只有GNS3支持的 OS才能使用；而EVE-NG更像是CS模型，EVE-NG是服务端，用户端可以是支持http/https的任意OS。</p>
 <span id="more"></span>  

<h3 id="（三）GNS3"><a href="#（三）GNS3" class="headerlink" title="（三）GNS3"></a>（三）GNS3</h3><p>GNS3是一个于2008年发布的网络软件模拟器，它允许组合的虚拟和实际设备，用于模拟复杂的网络。 它使用Dynamips模拟软件来模拟Cisco IOS。GNS3在很多大型公司中也有广泛的应用，例如埃克森公司、沃尔玛、AT&amp;T和美国宇航局。功能上比cisco packet tracer 要丰富的多，但相对真机还是有一定差距且使用起来有一些比较麻烦的地方。</p>
<h3 id="（四）NetSim"><a href="#（四）NetSim" class="headerlink" title="（四）NetSim"></a>（四）NetSim</h3><p>该软件相比之前几个软件，对新手更加友好，有很多设计好的实验，针对每一步的配置均有讲解，但该软件是全英文版，而且是付费软件，由于使用人数不多破解版和使用说明并不好找。</p>
<h2 id="二、EVE-NG安装及设置"><a href="#二、EVE-NG安装及设置" class="headerlink" title="二、EVE-NG安装及设置"></a>二、EVE-NG安装及设置</h2><h3 id="（一）所需软件"><a href="#（一）所需软件" class="headerlink" title="（一）所需软件"></a>（一）所需软件</h3><p>EVE-NG的虚拟机文件、VMware-workstation、火狐浏览器、SecureCRT以及EVE-NG-Win-Client-Pack安装包。</p>
<h3 id="（二）安装步骤"><a href="#（二）安装步骤" class="headerlink" title="（二）安装步骤"></a>（二）安装步骤</h3><h4 id="1、下载软件"><a href="#1、下载软件" class="headerlink" title="1、下载软件"></a>1、下载软件</h4><p>推荐用14以上版本，14之前的版本有安全隐患，建议去VMware官网下载最新版进行安装，官网网址为：<a href="https://www.vmware.com/cn.html">https://www.vmware.com/cn.html</a></p>
<img src="/2019/11/16/network-simulator/image-20191117105947209.png" alt="image-20191117105947209" style="zoom: 67%;">

<h4 id="2、安装VMware-workstation"><a href="#2、安装VMware-workstation" class="headerlink" title="2、安装VMware-workstation"></a>2、安装VMware-workstation</h4><p> <img src="/2019/11/16/network-simulator/20181129090415536.png" alt="img"> </p>
<p> <img src="/2019/11/16/network-simulator/image-20191117110739400.png" alt="image-20191117110739400"> </p>
<p>一路next点下去即可，如果不愿意安装在C盘可自行选择空间大的分区，密钥可以自行搜索输入即可激活</p>
<h4 id="3、导入虚拟机文件"><a href="#3、导入虚拟机文件" class="headerlink" title="3、导入虚拟机文件"></a>3、导入虚拟机文件</h4><img src="/2019/11/16/network-simulator/image-20191117110934416.png" alt="image-20191117110934416" style="zoom:150%;">

<p>在bbs.vlan5.com或其他网站均有打包好镜像的整合版，不需要自行导入镜像，更推荐下载这种整合版，装好直接就能用。双击下载好的镜像.ova文件，将文件用Vmware Workstation打开并点击导入。</p>
<img src="/2019/11/16/network-simulator/image-20191117111918615.png" alt="image-20191117111918615" style="zoom:80%;">

<img src="/2019/11/16/network-simulator/image-20191117112009691.png" alt="image-20191117112009691" style="zoom:80%;">

<h4 id="4、安装安装EVE-NG-Win-Client-Pack"><a href="#4、安装安装EVE-NG-Win-Client-Pack" class="headerlink" title="4、安装安装EVE-NG-Win-Client-Pack"></a>4、安装安装EVE-NG-Win-Client-Pack</h4><p>一直下一步即可。</p>
<h4 id="5、设置虚拟机参数"><a href="#5、设置虚拟机参数" class="headerlink" title="5、设置虚拟机参数"></a>5、设置虚拟机参数</h4><p><img src="/2019/11/16/network-simulator/image-20191117112226743.png" alt="image-20191117112226743"></p>
<h5 id="EVE内存设置："><a href="#EVE内存设置：" class="headerlink" title="EVE内存设置："></a>EVE内存设置：</h5><p><img src="/2019/11/16/network-simulator/image-20191117112404527.png" alt="image-20191117112404527"></p>
<p>一般只用设置内存和处理器两个参数即可，运行EVE模拟器建议本机至少12G内存，然后分8G给EVE，16G内存则可以分10G内存给EVE。</p>
<h5 id="CPU设置："><a href="#CPU设置：" class="headerlink" title="CPU设置："></a>CPU设置：</h5><p><img src="/2019/11/16/network-simulator/image-20191117112640714.png" alt="image-20191117112640714"></p>
<p>除服务器工作站外的其他个人主机的处理器数量均为1，每个处理器的内核数量和型号有关，建议根据CPU型号自行搜索选择，虚拟化引擎中的第一项“虚拟化Intel VT-X”必须勾选否则无法运行模拟器。</p>
<h5 id="网络相关"><a href="#网络相关" class="headerlink" title="网络相关"></a>网络相关</h5><p>此方法适用于虚拟机启动后能够获取IP地址但在浏览器中输入IP地址无法访问，以及无法获取到IP地址</p>
<p><img src="/2019/11/16/network-simulator/lab-net.png" alt="lab-net"></p>
<h4 id="5、在BIOS中开启VT功能"><a href="#5、在BIOS中开启VT功能" class="headerlink" title="5、在BIOS中开启VT功能"></a>5、在BIOS中开启VT功能</h4><h5 id="进入计算机BIOS："><a href="#进入计算机BIOS：" class="headerlink" title="进入计算机BIOS："></a>进入计算机BIOS：</h5><p>参考以下按键，开机时按住对应的键进入BIOS：</p>
<p>组装机以主板分，华硕按F8、Intel按F12,其他品牌按ESC、F11或F12；</p>
<p>笔记本以品牌分，联想ThinkPad系列按F1,其他品牌按F2；</p>
<p>品牌台式机按品牌分， Dell按ESC，其他按F12；</p>
<p>如果仍然不能进入BIOS，找找电脑（主板）说明书或者参考BIOS设置怎么进入图解教程。</p>
<h5 id="开启VT功能"><a href="#开启VT功能" class="headerlink" title="开启VT功能"></a>开启VT功能</h5><p>部分较新主板已经采取了图形化界面，需点击“退出/高级模式”进入高级模式才能看到VT开启选项，华硕等主板的VT选项在“ Advanced高级——CPU Configuration处理器设置 ”中开启，技嘉等主板的VT选项在“ BIOS Features —— Intel Virtualization Technology英特尔虚拟化技术 ”中开启，通用Phoenix BIOS机型在“ Configuration—— Intel Virtual Technology”中开启。</p>
<h2 id="三、EVE-NG使用简略说明"><a href="#三、EVE-NG使用简略说明" class="headerlink" title="三、EVE-NG使用简略说明"></a>三、EVE-NG使用简略说明</h2><h3 id="（一）登陆"><a href="#（一）登陆" class="headerlink" title="（一）登陆"></a>（一）登陆</h3><p><img src="/2019/11/16/network-simulator/image-20191117114900537.png" alt="image-20191117114900537"></p>
<p>点击开启此虚拟机将EVE开启</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115458381.png" alt="image-20191117115458381"></p>
<p>开启后第一行的root、eve分别是虚拟机中登录的用户名密码，一般情况下用不到，第二行的IP地址为登录EVE模拟器的地址，将该地址输入火狐浏览器后进行登录。</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115652940.png" alt="image-20191117115652940"></p>
<p>默认登录用户名密码为：admin、eve</p>
<p><img src="/2019/11/16/network-simulator/image-20191117115844969.png" alt="image-20191117115844969"></p>
<p>登录后点击红框中的按键为新建模拟器</p>
<p><img src="/2019/11/16/network-simulator/image-20191117160634525.png" alt="image-20191117160634525"></p>
<p>更多的设置请查看 <a href="C:\Users\32759\Downloads\EVE-COOKBOOK-1.25-Chinese-20200122-v1.0.pdf">EVE-COOKBOOK-1.25-Chinese-20200122-v1.0.pdf</a> </p>
<h3 id="（二）新建实验拓扑及基本操作"><a href="#（二）新建实验拓扑及基本操作" class="headerlink" title="（二）新建实验拓扑及基本操作"></a>（二）新建实验拓扑及基本操作</h3><h4 id="1、添加设备及选择IOS"><a href="#1、添加设备及选择IOS" class="headerlink" title="1、添加设备及选择IOS"></a>1、添加设备及选择IOS</h4><p><img src="/2019/11/16/network-simulator/image-20191117161041649.png" alt="image-20191117161041649"></p>
<p>在空白处点击右键，出现常用菜单</p>
<p><img src="/2019/11/16/network-simulator/image-20191117162643074.png" alt="image-20191117162643074"></p>
<p>第一个是思科3725路由器的IOS，第二个是IOL，第三四个是VIOS，两者的区别，我找到一个老外的解释：</p>
<p> IOSv is a complete VM. IOU is IOS as a native linux process. IOSv will be more up to date with features but IOU is less resource hungry.  </p>
<p>大概意思是“VIOS是完整的Vmware文件。而IOU是作为本地Linux进程的IOS。VIOS有更多最新功能，但IOU的资源消耗较少。”</p>
<p>如果做实验的过程中确定配置方面没问题，则可能是用的IOS有问题，换个IOS也许就正常了，这种情况在做交换实验的时候遇到的多一些，有一次做三层交换机实验的时候无论如何也不同，换了个IOS但配置没做任何改变就通了。</p>
<p><img src="/2019/11/16/network-simulator/image-20191117165907022.png" alt="image-20191117165907022"></p>
<p>这里用IOL举例，选择IOL以后，有两个IOS可选，L2代表三层、二层交换机的IOS，L3代表路由器的IOS。</p>
<h4 id="2、连接设备"><a href="#2、连接设备" class="headerlink" title="2、连接设备"></a>2、连接设备</h4><p><img src="/2019/11/16/network-simulator/EVE-_-Topology.gif" alt="EVE-_-Topology"></p>
<p>连接设备的方式如GIF图所示，可以选择不同的接口连接，由于录屏软件的问题，下拉菜单并没有录制上。</p>
<h4 id="3、开启设备"><a href="#3、开启设备" class="headerlink" title="3、开启设备"></a>3、开启设备</h4><p>开启设备的方式有两种，选中设备后右键开机以及在左侧菜单中开启全部设备。具体步骤见gif动图。</p>
<p><img src="/2019/11/16/network-simulator/turn-on-and-off.gif" alt="turn-on-and-off"></p>
<h4 id="4、保存设置"><a href="#4、保存设置" class="headerlink" title="4、保存设置"></a>4、保存设置</h4><p>在设备上输入wr既可在关闭模拟器后保存已输入的配置，</p>
<h4 id="5、设置预配"><a href="#5、设置预配" class="headerlink" title="5、设置预配"></a>5、设置预配</h4><p>很多时候我们想把EVE所有的配置都清空，但是又想在清空时保存最基本的预配，比如IP地址，Hostname等等，以下为设置预配详细步骤： </p>
<p>（1）在设备中配置好想保存的基本预配命令后使用wr命令保存。</p>
<p>（2）选择菜单选项栏 More actions—Export all CFGs 注意右边消息窗口弹出config exported并且无错误，此导出步骤请重复2-3遍。此步骤为导出所有设备的配置。</p>
<p>（3）选择 More actions——Set nodes startup-cfg to exported 注意右边消息提示中无错误，并且完成，此操作请重复2-3遍。  此步骤为把步骤2中的导致的配置文件加载到设置的starup-cfg中.</p>
<p>（4） 当完成实验使用右键菜单中的“Wipe Selected”清除配置后，在启动设备时之前的预配信息将不会被清除。</p>
<p>（5）如关闭了虚拟机后想在下次启动EVE模拟器时直接用基本预配启动，则选择More actions——Set nodes startup-cfg to exported，而后选择Wipe all nodes，然后再开启设备。</p>
<h3 id="（三）命令行杂记"><a href="#（三）命令行杂记" class="headerlink" title="（三）命令行杂记"></a>（三）命令行杂记</h3><p>show run | section XXX</p>
<p>show run 是查看所有运行在内存里的配置，在show run 后接管道符“|”（在英文输入状态下，按shift + 回车上面的键，即可输入管道符）section后面接所需要看的命令抬头，比如可以接 ip route ，表示只查看静态路由的相关配置。</p>
<p>int range f0/0 - 2</p>
<p>range 命令可以同时进入多个接口，进行普遍性的操作配置</p>
<h3 id="（四）secure-CRT"><a href="#（四）secure-CRT" class="headerlink" title="（四）secure CRT"></a>（四）secure CRT</h3><p>Secure CRT比putty界面更友好一些，日常使用非常方便，不过CCIE考试的时候因为版权问题，一直使用免费的putty，如果想更贴近考场情况，还是建议使用putty。</p>
<h4 id="1、默认使用secure-CRT打开设备"><a href="#1、默认使用secure-CRT打开设备" class="headerlink" title="1、默认使用secure CRT打开设备"></a>1、默认使用secure CRT打开设备</h4><p>Firefox（火狐）：设置–应用，找到Telnet，右侧选“使用 SecureCRT Application 处理（默认）”，实现单个窗口多标签打开对话。</p>
<p>Chrome： 第一次点开设备的时候选择CRT时将“始终在关联的应用中打开这些类型的链接”点上以后打开就默认用CRT了，如果勾选错了想取消，找到文件“<strong>C:\Users\Whidy(你的用户名)\AppData\Local\Google\Chrome\User Data\Default\Preferences</strong>”搜索protocol_handler修改excluded_schemes内的相关应用为false就可以重新选择打开方式了。</p>
<h4 id="2、如何用SecureCRT标签打开不同设备"><a href="#2、如何用SecureCRT标签打开不同设备" class="headerlink" title="2、如何用SecureCRT标签打开不同设备"></a>2、如何用SecureCRT标签打开不同设备</h4><p>方法1：</p>
<p><img src="/2019/11/16/network-simulator/CRT%E6%89%93%E5%BC%80EVE%E7%9A%84%E8%AE%BE%E5%A4%87%E6%98%AF%E7%8B%AC%E7%AB%8B%E7%AA%97%E5%8F%A3-1573998925521.gif" alt="CRT打开EVE的设备是独立窗口"></p>
<p>方法2：</p>
<p>右键单击CRT左侧面板中的“Session”，选择New Session，单击下一步 </p>
<p> <img src="/2019/11/16/network-simulator/wKiom1hJUcLBOTWIAABRFpokUzM697.png-wh_500x0-wm_3-wmp_4-s_2022892654.png" alt="wKiom1hJUcLBOTWIAABRFpokUzM697.png-wh_50"> </p>
<img src="/2019/11/16/network-simulator/image-20191118183846505.png" alt="image-20191118183846505" style="zoom:150%;">

<p>IP地址为模拟器登录的IP地址，不同的设备所使用的端口不同，鼠标移到设备上会在浏览器左下角显示该设备的IP地址和端口，从端口32796开始将每个设备的参数配置到CRT中，以后使用的时候在左侧面板中点击连接该设备，配置好后以后可方便在相同窗口的不同标签中打开不同设备。</p>
<p>窗口切换快捷键：Ctrl+Tab</p>
<p>参考文章：</p>
<p><a href="https://www.sjzyj.vip/?p=96">EVE-NG 开机无法获取IP地址</a></p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
  <entry>
    <title>14、BGP</title>
    <url>/2020/10/11/14-BGP/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>学习BGP这部分知识的时候，一定不要将之前路由协议的经验或概念,套到BGP上，因为BGP和他们有非常大的区别，因为之前接触的RIP,OSPF,EIGRP等等路由协议都是IGP(Interior Gateway Protocol)也就是内部网关协议,而BGP是EGP(Exterior Gateway Protocol)也就是外部网关协议,内\外部网关协议从根本上有很多不同。</p>
<p>本笔记大部分引用自红茶三杯的BGP技术笔记，基于自己的理解进行了小幅度添加及修改。</p>
<h2 id="协议概述"><a href="#协议概述" class="headerlink" title="协议概述"></a>协议概述</h2><h3 id="存在意义"><a href="#存在意义" class="headerlink" title="存在意义"></a>存在意义</h3><h4 id="无需BGP的场景"><a href="#无需BGP的场景" class="headerlink" title="无需BGP的场景"></a>无需BGP的场景</h4><p>在常见的小型或需求不高的企业网中,BGP存在的意义不大,比如以下的三个场景.</p>
<p>场景1：</p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-00-24.png" alt="Snipaste_2020-10-13_16-00-24"></p>
<p>客户网络只有一台路由器的情况下,直接用默认路由指向运营商提供的公网IP地址A.B.C.D即可,IP route 0.0.0.0 0.0.0.0  A.B.C.D,网络内私网地址设备要访问互联网的话需要在出口路由器上做PAT\NAT,将私网地址转换成公网地址.所以这种情况下并不需要BGP就能满足用户需求.</p>
<p><strong>场景2:</strong></p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-13-08.png" alt="Snipaste_2020-10-13_16-13-08"></p>
<p>这种场景下,客户不只有一台路由器,还有几台服务器要接入互联网提供服务,这些服务器可能提供邮件或网页服务.这种情况下,需要用端口转发技术将正确的端口和这些服务器对应起来,因此这种情况下不需要用BGP也能够满足用户需求.</p>
<p><strong>场景3:</strong></p>
<p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-15-51.png" alt="Snipaste_2020-10-13_16-15-51"></p>
<p>如果在之前场景中加上冗余需求呢?由于用户的服务器对外提供服务,只有一台路由器连接到ISP运营商可能会出现单点故障,也就是说一旦这台对外提供网络的服务器挂掉,整网就瘫痪了,服务器也无法对外提供服务.所以这时需要一个冗余路由器一起提供互联网连接,即使有一台路由器出现故障,另一台路由器可以顺利接替,大体配置方式如下:</p>
<ul>
<li>为主路路线配置一条metric值较低的静态路由；</li>
<li>为备用路线配置一条metric值较高的静态路由；</li>
</ul>
<p>主用线路由于metric值低,所以优先走主用路线,当主用路线挂掉以后会启用备用路线,如果需要主备用路线实现负载均衡则将两条线路的metric配置成相同即可,每条线路的流量会大致为50%,这种情况下也无需BGP。</p>
<h4 id="需要BPG的场景"><a href="#需要BPG的场景" class="headerlink" title="需要BPG的场景"></a>需要BPG的场景</h4><p><img src="/2020/10/11/14-BGP/Snipaste_2020-10-13_16-54-57.png" alt="Snipaste_2020-10-13_16-54-57"></p>
<p>在上面的拓扑中,如果两条线路的负载均衡需求为80%和20%呢?显然这种场景下就必须BGP才能胜任了。</p>
<p>现在来看一个更复杂一点的场景,这种情况下,出口路由器需要连接两个不同的ISP运营商,以防在一个运营商挂掉的情况下,整网无法对外提供服务.但此时又遇到一个问题，由于我有两个ISP运营商提供服务，两个ISP都会给我属于他们的公网地址，如果我用了ISP1提供的地址，那么如果属于ISP1的这条链路出现问题，网络还是会断开连接，这时候我们就不能使用运营商所提供的公网地址了，而要使用我们自己从IANA（Internet Assigned Numbers Authority，互联网地址分配机构）申请到的地址，我们把从IANA申请到的地址告诉两家运营商，使用BGP和运营商进行连接并宣告申请到的地址进BGP协议。</p>
<p>除了上面的场景，其他使用BGP的理由主要如下：</p>
<ul>
<li><p>大量路由需要承载的情况，只有BGP能胜任，IGP能容纳的路由条目以千条为单位，但BGP是以万条为单位起算的，一两百万条BGP路由条目的路由器也不在少数；</p>
</li>
<li><p>支持MPLS/VPN的应用，传递客户VPN路由；</p>
</li>
<li><p>策略能力强，可以很好的实现路由策略与数据控制。</p>
</li>
</ul>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><h2 id="IGP-amp-EGP"><a href="#IGP-amp-EGP" class="headerlink" title="IGP&amp;EGP"></a>IGP&amp;EGP</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ul>
<li>IGP(Interior Gateway Protocol)</li>
</ul>
<p>IGP,内部网关协议,用来在Autonomous System内部的网关间交换路由信息.常见协议有OSPF,EIGRP,ISIS。</p>
<ul>
<li>EGP(Exterior Gateway Protocol)</li>
</ul>
<p>EGP,外部网关协议,用来在Autonomous System之间交换路由信息.目前在用的EGP协议只有BGP一个协议。</p>
<h3 id="AS是什么"><a href="#AS是什么" class="headerlink" title="AS是什么"></a>AS是什么</h3><blockquote>
<p>An autonomous system (AS) is a collection of connected Internet Protocol (IP) routing prefixes under the control of one or more network operators on behalf of a single administrative entity or domain that presents a common, clearly defined routing policy to the internet. ——<a href="https://en.wikipedia.org/wiki/Autonomous_system_(Internet)#:~:text=An%20autonomous%20system%20(AS)%20is,routing%20policy%20to%20the%20internet.">维基百科</a> </p>
</blockquote>
<p>维基的定义比较晦涩难懂,直译就是说,由一个或多个网络运营商代表单一行政实体或域控制下的连接的互联网协议(IP)路由前缀的集合，它向互联网提出一个共同的、明确定义的路由策略。</p>
<p><img src="/2020/10/11/14-BGP/routingas.png" alt="routingas"></p>
<p>上面这个图能更直观的表现出什么叫一个AS,简单的说就是配置在同一个AS号码（和EIGRP的AS不同）下,自己可管理的所有设备组成的一个较大的逻辑区域。一个AS中必须包含最少一台运行BGP的路由器。</p>
<h3 id="两者区别"><a href="#两者区别" class="headerlink" title="两者区别"></a>两者区别</h3><p><img src="/2020/10/11/14-BGP/0_gUtwQ4minoYExQwN.png" alt="0_gUtwQ4minoYExQwN"></p>
<p>IGP在AS内部发挥作用，它们的作用就是在AS内部为如何去往目的网段找到最短路径；EGP在AS之间发挥作用。为什么除了IGP以外还要搞出来一个BGP，简单理解就是因为IGP协议能够处理的路由条目不多，没法满足大批量路由的需要，比如有些路由器要处理一两百万条路由，一般的IGP没法胜任，路由条目在一万条左右就已经差不多了。</p>
<h2 id="AS号"><a href="#AS号" class="headerlink" title="AS号"></a>AS号</h2><p>最开始的时候，AS号长度为2字节，也就是16比特，它的范围是1-65535，和IP地址一样，AS号也有公有和私有之分，1-64511是公有AS号，由IANA规定并出售，64512-65535是私有AS号，可以随意使用。由于互联网持续扩大，原有的65535个AS号已经逐渐用完，所以在RFC4893中将2字节（16比特）的AS号扩展为4字节（32比特），共有4294967295个AS号，和原有的65535个AS号相比，有了很大的提升，扩展的AS号中，4,200,000,000–4,294,967,294是私有AS号。00–4,294,967,294</p>
<p>可以通过<a href="https://www.cidr-report.org/as2.0/">CIDR Report</a>查询AS号目前都被哪个运营商使用以及目前的前缀、邻居等信息。在使用AS号的时候必须使用由IANA所分配的AS号或私有AS号，胡乱使用其他机构的AS号可能导致互联网面临毁灭性的问题。</p>
<h2 id="Looking-Glass-Servers"><a href="#Looking-Glass-Servers" class="headerlink" title="Looking Glass Servers"></a>Looking Glass Servers</h2><blockquote>
<p>Looking Glass servers are computers on the Internet running one of a variety of publicly available Looking Glass software implementations. A Looking Glass server (or LG server) is accessed remotely for the purpose of viewing routing information. Essentially, the server acts as a limited, read-only portal to routers of whatever organization is running the LG server. ——维基百科</p>
</blockquote>
<p>Looking Glass 服务器是一些部署在互联网上安装了Looking Glass软件的计算机，Looking Glass软件能让你远程登陆，运行一些基本的命令并查看关于BGP的相关信息，可以在<a href="https://www.bgp4.as/looking-glasses">该页面</a>找到分布在全球的Looking Glass 服务器。</p>
<p><img src="/2020/10/11/14-BGP/1602594423151-6aca5b7f-0eed-4515-8cae-21dfe2bdd63e.jpeg" alt="img"></p>
<p>这个服务器的作用是什么呢？主要是用来方便排错。比如说运营商有很多那个边缘设备（可以简单的把边缘设备理解成在AS最边界的设备），跟别的运营商对接的peer邻居设备去收全球的路由表，有时候你会发现，你运行BGP的线路中突然有一个业务突然不通或某个网段好像突然不通了，但是为什么呢你也不知道，因为你不知道互联网上到这个网段的路径到底通不通，到底是那边的网络出了问题还是你这边的网络出了问题，这时候你可以用looking glass服务器去查他那个在互联网上他到底有没有问题，如果在他原本在互联网上就有问题的话，那就说明问题不在你这边，能够方便确定问题到底出在哪端。为什么你不知道到底是别人那边出了问题还是你这边出了问题呢？因为BGP是一个距离矢量协议，和之前的RIP有一些相通之处，都是基于传闻的协议，并不知道整个网络的情况。</p>
<h2 id="BGP-Peer-amp-Speaker"><a href="#BGP-Peer-amp-Speaker" class="headerlink" title="BGP Peer&amp;Speaker"></a>BGP Peer&amp;Speaker</h2><p>运行了BGP协议的路由器被称为BGP Speaker，这里可以将BGP协议理解为一种语言,当一个路由器运行BGP协议时,相当于它说了BGP这种语言,所以将运行BGP的路由器称作BGP Speaker;当一个BGP Speaker和另一个BGP Speaker建立了一条基于TCP的BGP连接后，称两者为BGP Peer，直译成中文就是BGP 对等体，说白了就是在BGP协议中换了一种称呼两者为邻居的方式，不说他们是邻居了，而说他们是对等体。</p>
<p><img src="/2020/10/11/14-BGP/1602668367683-94693172-45e5-4581-a194-61ecdd5db6f2.jpeg" alt="img"></p>
<h2 id="IBGP"><a href="#IBGP" class="headerlink" title="IBGP"></a>IBGP</h2><p>IBGP就是Internal BGP，翻译成中文就是内部BGP，用来连接内部对等体（Peer），在同一个自治系统（AS）内运行BGP的路由器之间，是IBGP Peer，也就是IBGP邻居，在配置IBGP邻居时，推荐用loopback地址建立邻居关系。建立IBGP邻居要满足以下几个条件：</p>
<ul>
<li>AS号相同</li>
<li>IBGP邻居之间建立TCP会话</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1602668402711-f7e43efa-9c09-4f65-adc3-cd2da23225ec.jpeg" alt="img"></p>
<h2 id="EBGP"><a href="#EBGP" class="headerlink" title="EBGP"></a>EBGP</h2><p>EBGP就是External BGP，翻译成中文就是外部BGP，用来连接外部，属于不同AS的路由器，不同的自治系统（AS）之间运行BGP的路由器之间，是EBGP Peer，也就是EBGP邻居，建立EBGP邻居时，推荐使用直连的IP地址建立邻居关系。建立EBGP邻居要满足以下几个条件：</p>
<ul>
<li><p>EBGP之间AS号不同</p>
</li>
<li><p>EBGP邻居之间建立TCP会话</p>
</li>
<li><p>Neighbor中指定的地址要可达</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1602668529012-d4fdef25-ea05-4b61-a430-f5d697e91f9a.jpeg" alt="img"></p>
<h2 id="NLRI"><a href="#NLRI" class="headerlink" title="NLRI"></a>NLRI</h2><p>NLRI的全称是Network Layer Reachability Information，直译成中文是网络层可达信息，简单来说是BGP的网络前缀，抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1603516028491-82b5fd06-3916-4f72-bd4e-77df1b4a60c1.jpeg" alt="img"></p>
<p>但问了个厂家的朋友说，NLRI其实是带着路径属性的前缀，不过抓包中并没在一起。</p>
<h2 id="几个管理概念"><a href="#几个管理概念" class="headerlink" title="几个管理概念"></a><a href="http://www.tcpipguide.com/free/t_BGPAutonomousSystemTypesTrafficFlowsandRoutingPoli.htm">几个管理概念</a></h2><h3 id="Local-Transit-Traffic"><a href="#Local-Transit-Traffic" class="headerlink" title="Local/Transit Traffic"></a>Local/Transit Traffic</h3><p><strong>Local Traffic</strong>，直译成中文是本地流量，这种流量要么是起源于本AS，要么是终点在本AS内，也就是起始或终点在本AS内的流量叫做Local Traffic。</p>
<p><strong>Transit Traffic</strong>，直译成中文是穿越流量，这种流量起源于外部AS，并且目的地也不在本AS内，也就是起始或终点都不在本AS内的流量叫做Transit Traffic。</p>
<h3 id="Stub-Multihomed-AS"><a href="#Stub-Multihomed-AS" class="headerlink" title="Stub/Multihomed AS"></a>Stub/Multihomed AS</h3><p><strong>Stub AS</strong>：仅和另外一个AS相连。</p>
<p><strong>Multihomed AS</strong>：和两个或两个以上的AS相连接。</p>
<p><img src="/2020/10/11/14-BGP/1603520481717-cbf0e5dd-bdf5-4add-b3f5-847ee4bf4bed.png" alt="img"></p>
<p>比如上图中的AS2，它同时和AS1及AS3连接，所以它是一个Multihomed AS，而AS1和AS3只和AS2这一个AS相连，所以它们是Stub AS。</p>
<h3 id="No-Transit-Restricted-AS-Criteria–Based-Transit-Policy"><a href="#No-Transit-Restricted-AS-Criteria–Based-Transit-Policy" class="headerlink" title="No Transit/Restricted AS/Criteria–Based Transit Policy"></a>No Transit/Restricted AS/Criteria–Based Transit Policy</h3><p><strong>No Transit Policy</strong>：直译过来就是不许穿越策略，也就是不允许处理上面提到过的穿越流量（Transit Traffic）。</p>
<p><strong>Restrict AS Transit Policy</strong>：直译过来是严格的AS穿越策略，也就是只允许部分AS的穿越流量通过，但不允许其他AS的穿越流量通过的策略。</p>
<p><strong>Criteria–Based Transit Policy</strong>：Criteria–Based，直译过来是基于标准的意思，也就是用标准去确定这些流量是否能穿越，符合规定的标准的穿越流量可以通过。</p>
<h3 id="如何使用这些概念"><a href="#如何使用这些概念" class="headerlink" title="如何使用这些概念"></a>如何使用这些概念</h3><p>以上这几个概念在什么时候用得上呢？一般是在规划BGP如何使用的时候。比如你有一些路由器想跑BGP的时候，肯定要先申请AS号码，这时候就得先定位你想跑BGP的这些路由器的作用是什么，你是只给你自己服务还是说你也要给别人通过BGP提供服务，不同的定位决定了BGP不同的玩法。如果你这些BGP的路由器只给自己服务，也就是说你的BGP路由器是流量的终点，是互联网的末端，跑BGP只是想通过BGP协议接受运营商的路由去进行选路，所以这种情况下，你的AS是一个Stub AS，这时候Private AS就足够了；如果你的AS不只是你自己用，你还要给别人提供服务，那么你就是一个Transit AS，跑的是Transit Traffic，那么这时你的BGP的AS号就得申请公有的AS号了，因为要对外提供服务不能只和自己玩了，那么这时你的Transit的是什么呢，你下面可能有一些小的ISP运营商，你上面有些比较大的ISP运营商，你要为他们之间提供Transit 服务，这时候你就是作为一个Transit AS存在的了。</p>
<p>Multihomed AS是说，当你是末端用户，也就是Stub AS的时候，如果你只和某一个ISP运营商连接的话，万一这个运营商挂掉了你就没法提供服务或连接网络了，也就是单点故障了，这时除了连接到主用ISP以外还要连接到另一个备份的ISP运营商，也就是和两个不同运营商的不同AS相连接，这种情况下会用到Multihomed AS这个概念。</p>
<h1 id="基础属性"><a href="#基础属性" class="headerlink" title="基础属性"></a>基础属性</h1><h2 id="协议基本知识"><a href="#协议基本知识" class="headerlink" title="协议基本知识"></a>协议基本知识</h2><ul>
<li><p>BGP目前版本为BGP-4，使用TCP作为传输层协议，这样重传、确认、排序等一系列传输层需要实现的功能就由TCP完成而无需BGP操心，BGP会监听TCP的179端口；</p>
</li>
<li><p>由于BGP使用TCP作为传输层协议，是传输是可靠的，在可靠的链路上需不要使用定期更新，所以BGP使用增量更新和触发更新；</p>
</li>
<li><p>每个AS都有一个标识号，也就是AS号，范围是1-65535，其中1-64511是共有AS号，64512-65535是私有AS号；</p>
</li>
<li><p>BGP的设计初衷就是在AS之间传递路由，因此它的一跳实际上是一个AS；</p>
</li>
<li><p>BGP是距离矢量协议，所以具有距离矢量协议的特征，比如水平分割原则（BGP路由器从iBGP获得的路由不会向它的iBGP邻居通告），路由是基于传闻，数据一跳一跳传播等特征。</p>
</li>
<li><p>BGP有三个管理距离，从IBGP学到的路由的AD为200，从EBGP学到的路由AD为20，这是因为BGP的设计初衷就是在AS之间传递路由，所以AS之间的EBGP路由AD值比较小，而在AS内部的路由传递，BGP希望IGP自己搞定，因此IBGP路由的AD值设置为一个较大的AD值，200；</p>
</li>
<li><p>BGP的Router ID和OSPF一样，RID是一个用来标识路由器的IP地址，长度为32位，作用是唯一地标识一台路由器，不能和其他路由器的Router ID重复，可以在BGP路由进程中手工指定，如果没有指定，路由器默认选择环回接口（Loopback接口）中最高的IP作为RID；如果没有环回地址，路由器使用所有激活的物理接口中最高的IP作为RID；</p>
</li>
<li><p>BGP计时器有两个，一个是Keepalive Interval，默认时间为60秒，意思是邻居之间每隔60秒发送Keepalive报文给对方，用来判断邻居是否还存在；另一个是Hold time，默认180秒，意思是如果邻居之间超过180秒还没收到对方的Keepalive信息则认为对方不可达；</p>
</li>
</ul>
<h2 id="BGP水平分割"><a href="#BGP水平分割" class="headerlink" title="BGP水平分割"></a><a href="https://community.cisco.com/t5/routing/why-we-need-bgp-split-horizon-rule/td-p/1891507">BGP水平分割</a></h2><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>BGP水平分割原则是指，当运行BGP的路由器从一个iBGP邻居处收到的路由更新，不能再传递给其他iBGP邻居。</p>
<p><img src="/2020/10/11/14-BGP/1605854882539-3250979d-0b09-4052-9443-be86b81957c8.jpeg" alt="img"></p>
<p>用上面的拓扑来说明水平分割就是，R1和R2是eBGP邻居，R1将网段1.1.1.1/32宣告进BGP并将该路由通过BGP协议宣告给R2，R2又将该路由宣告给iBGP邻居R3，但此时R3不能将从iBGP邻居R2处学到的1.1.1.1/32的路由宣告给iBGP邻居R4。</p>
<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3><p>为什么需要水平分割原则呢？是因为在eBGP中发挥防止路由环路功能的属性参数，AS Path，在iBGP会话中，不起作用。因为AS Path只有在离开一个AS后才会加上这个AS的号码，用来告诉其他路由器这条路由经过了哪些AS，不要再将它发回到那些AS中，否则会引起路由环路。如果没有水平分割原则，意味着iBGP邻居之间可以多次传递路由，比如一条由R1最初生成的1.1.1.1/32的路由，经过多次传递后可能会重新传回给生成它的R1，如果R1之前已经宣告撤销了1.1.1.1/32，就会使得本该被撤销的路由无法真正撤销。为了避免上面提到的风险，有了水平分割原则，并且水平分割原则无法被关闭，但如果有时候必须要打破水平分割原则该如何呢？可以用Full mesh或Route Reflectors。</p>
<h3 id="Full-mesh"><a href="#Full-mesh" class="headerlink" title="Full mesh"></a>Full mesh</h3><p>BGP的Full mesh就是所有BGP路由器都和其他路由器建立iBGP邻居，这样做的好处是由于所有路由器之间都是iBGP邻居，所以水平分割原则不会对路由的宣告有影响。</p>
<p><img src="/2020/10/11/14-BGP/1605858839062-d1b3f60b-c415-45c9-93fd-19e098f49689.jpeg" alt="img"></p>
<p>比如上图中，R2，R3和R4之间就是Full  mesh状态，彼此两两都是iBGP邻居，这种Full mesh情况下，R2就可以将另一个AS的BGP路由直接发送给另一边界处的R4，不受水平分割的影响了。</p>
<h3 id="Route-Reflectors"><a href="#Route-Reflectors" class="headerlink" title="Route Reflectors"></a>Route Reflectors</h3><p>路由反射器在后面会具体说。</p>
<h2 id="BGP三张表"><a href="#BGP三张表" class="headerlink" title="BGP三张表"></a>BGP三张表</h2><ul>
<li><p>邻居表（Neighbor Table）：表中包含着关于BGP邻居的信息。查看邻居表的命令为show ip bgp summary（简略邻居信息）、show ip bgp neighbor（详细邻居信息）;</p>
</li>
<li><p>BGP表（Forwarding Database）：表中包含着查看BGP表的命令为show ip bgp；</p>
</li>
<li><p>路由表（Routing Table）：查看路由表的命令为show ip route；</p>
</li>
</ul>
<p>查看哪条路由未加表的命令为：show ip bgp rib-failure；</p>
<h2 id="路由处理过程"><a href="#路由处理过程" class="headerlink" title="路由处理过程"></a>路由处理过程</h2><h3 id="三个路由信息库"><a href="#三个路由信息库" class="headerlink" title="三个路由信息库"></a>三个路由信息库</h3><h4 id="Adj-RIBs-In"><a href="#Adj-RIBs-In" class="headerlink" title="Adj-RIBs-In"></a>Adj-RIBs-In</h4><p>The Adj-RIBs-In contains unprocessed routing information that has been advertised to the local BGP speaker by its peers. —-RFC4271,Page 4</p>
<p>直译过来就是，Adj-RIBs-In中存放着的由BGP邻居发送来的未经处理的路由信息。这个“未经处理”指的是什么呢？就是没经过任何路由策略过滤或属性修改。说白了就是邻居发来的原始的路由信息是什么样的，原封不动的保存在Adj-RIBs-In中。通过命令 show ip bgp neighbor x.x.x.x received-routes查看Adj-RIBs-In。但这里也要注意，如果<strong>路由器的IOS比较老的情况下</strong>，想查看邻居发过来的未经处理的路由信息，必须在想查看路由的这个邻居上配置一条命令’neighbor X.X.X.X soft-reconfiguration inbound’，比如说我是12.1.1.2，现在我想查看12.1.1.1发过来的未经处理的原始BGP路由信息，就得在12.1.1.1上配置一条neighbor 12.1.1.2 soft-reconfiguration inbound，否则会提示’% Inbound soft reconfiguration not enabled on 12.1.1.1’，这是因为‘neighbor X.X.X.X soft-reconfiguration inbound’这条命令的作用是让所有BGP的路由前缀保存在本地设备内存中，即使这些路由前缀被BGP的入向策略拒绝掉也会在内存中，如果不配置这条命令，则无法查看。<strong>如果路由器的IOS比较新的情况下</strong>，是不需要配置这条命令的，具体参见后面‘协议配置——重置BGP连接部分’。</p>
<p><img src="/2020/10/11/14-BGP/1604476253448-3873112d-06bc-4d64-9295-9a7bd6604e44.jpeg" alt="img"></p>
<h4 id="Loc-RIB"><a href="#Loc-RIB" class="headerlink" title="Loc-RIB"></a>Loc-RIB</h4><p>The Loc-RIB contains the routes that have been selected by the local BGP speaker’s Decision Process.—-RFC4271,Page 5</p>
<p>Loc-RIB英文全称是Local Routing Information Base，是Adj-RIBs-In中邻居发送过来的原始路由信息，经过BGP路由选择出来的Best路由条目会放入Loc-RIB（BGP表）中存储。</p>
<h4 id="Adj-RIBs-Out"><a href="#Adj-RIBs-Out" class="headerlink" title="Adj-RIBs-Out"></a>Adj-RIBs-Out</h4><p>The Adj-RIBs-Out contains the routes for advertisement to specific peers by means of the local speaker’s UPDATE messages.  —-RFC4271,Page 4</p>
<p>Adj-RIBs-Out中存储着宣告给特定邻居的路由条目，这些路由条目通过update报文发送给邻居。通过命令show ip bgp neighbor x.x.x.x advertise-routes来查看Adj-RIBs-Out。</p>
<p><img src="/2020/10/11/14-BGP/1604474909285-72ca8f6f-2fb4-47df-ac1d-603ace6726bd.jpeg" alt="img"></p>
<p>上面的截图中输出表示，R1向邻居12.1.1.2宣告了1条5.5.5.5/32的BGP路由，这条路由的下一跳是192.168.15.5。</p>
<h3 id="处理过程"><a href="#处理过程" class="headerlink" title="处理过程"></a><a href="https://community.cisco.com/t5/routing/bgp-adj-rib-in-loc-rib-adj-rib-out/td-p/509060">处理过程</a></h3><p><img src="/2020/10/11/14-BGP/1602916955680-a0a9e71d-98b9-4181-8004-3202d4c19523.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1602920356680-b4902eb7-399e-4165-9f71-a3e7d376f2b6.jpeg" alt="img"></p>
<ul>
<li><p>把邻居们（eBGP\iBGP方式建立的）发来的所有路由前缀保存到Adj-RIBs-In中，检查下一跳是否可达，如果不可达则该路由不可能成为最优的BGP路由；</p>
</li>
<li><p>将上面存储的所有路由用BGP Policy过滤，过滤后同一个目标前缀可能有多条路径；</p>
</li>
<li><p>对去往同一前缀有多条路径的路由执行路由选择，在多条路径中选择出一条去往目标前缀最优的路径，比的是BGP的路径属性，最优的BGP路由带有&gt;符号，表示该路由是BGP表中去往某一路径的最优路由，最优的BGP路由会保存在Loc-RIB，也就是BGP表中；</p>
</li>
<li><p>将选择出来的BGP最优路由一方面要看是否能放入路由表中，另一方面要将它放入Adj-RIBs-Out中宣告给其他对等体邻居。是否放入路由表的决策过程为，如果目的地址有其他IGP路由，则需要比较两者的AD值，越小越优。如果BGP路由的AD值小，则会将这条之前在BGP表最优的路由放入路由表中，如果BGP路由的AD值大则不会放入路由表中。如果目的地址没有其他IGP路由，则该BGP路由直接放入路由表中；</p>
</li>
</ul>
<h2 id="BGP路由通告"><a href="#BGP路由通告" class="headerlink" title="BGP路由通告"></a>BGP路由通告</h2><ul>
<li>当存在多条路径时，BGP路由器只选取BGP表中最优的路由，也就是带&gt;标识为Best的；</li>
<li>BGP路由器只把自己使用的路由，也就是自己认为Best的路由发送给邻居：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1605781972710-f94c8b2e-8de5-4864-b843-3472d31e2c11.png" alt="img"></p>
<p>比如上图中，到10.0.196.0/24这个前缀有两条路径，只把下面带&gt;的那个，就是下一跳是172.28.144.5的那条发送给邻居，不是Best的就存在本地的Adj-RIBs-in中。</p>
<ul>
<li><p>BGP路由器从eBGP获得的路由会向它所有的BGP邻居通告，包括eBGP和iBGP；</p>
</li>
<li><p>BGP路由器从iBGP获得的路由不会向它的iBGP邻居通告，因为有水平分割原则并且要避免出现环路（存在RouterReflect的情况除外）；</p>
</li>
<li><p>BGP路由器从iBGP处获得的路由是否通告给其他的eBGP路由器要看IGP和BGP同步的情况来决定；</p>
</li>
</ul>
<h2 id="BGP计时器"><a href="#BGP计时器" class="headerlink" title="BGP计时器"></a>BGP计时器</h2><h3 id="Holdtime-amp-Keepalive"><a href="#Holdtime-amp-Keepalive" class="headerlink" title="Holdtime&amp;Keepalive"></a>Holdtime&amp;Keepalive</h3><p>Holdtime和Keepalive是BGP用来确定邻居还存在的重要机制，当路由器之间没有Update报文可供交换时，运行BGP的路由器之间会相互发送Keepalive报文，看邻居是否还存在，如果收到Keepalive报文的时间在Hold Time规定范围内，则确定了对方还存在，收到Keepalive报文后，Holdtime计时器会重置；如果HoldTime计时器过期前都没收到Keepalive或update报文，则会认为对方已经挂掉，那么路由器就会认为从这个挂掉的邻居那收到的路由前缀已经失效，将这些路由从BGP表以及路由表中去掉，并用其他可用路径代替这些被移除的路径。Keepalive是HoldTime数值的三分之一，RFC4271中对这两个值的建议时间为，HoldTime为90秒，Keepalive为30秒，Juniper设备默认的计时器也是整个数字，但思科和华为对BGP默认的Hold Time为180秒，Keepalive为60秒，也就是每过60秒发送Keepalive报文，如果180秒内没收到邻居的Keepalive报文或update报文，则说明邻居已经挂掉。</p>
<p>在思科设备中对HoldTime和Keepalive进行更改的命令为：neighbor X.X.X.X timers A B。其中X.X.X.X是需要更改计时器的邻居路由器的RID，A是Keepalive的时间，B是HoldTime的时间。如果配置命令为 neighbor 1.1.1.1 timers 10 30，说明将对邻居1.1.1.1的Keepalive时间设置为10秒，HoldTime时间设置为30秒。这里必须注意的是，Open报文中交互的只是HoldTime，而不会对Keepalive进行交互。</p>
<h4 id="Holdtime"><a href="#Holdtime" class="headerlink" title="Holdtime"></a>Holdtime</h4><p>Holdtime的数值表示一个路由器在多长时间未接到邻居信息以后认为这个邻居已经挂掉，比如思科设备默认的Hold time为180秒，从180开始倒数计时，那么如果在180秒内还没收到邻居发来的消息，也就是计时器到0之前都没收到邻居的消息，则会认为邻居已经挂掉，那么路由器就会认为从这个挂掉的邻居那收到的路由前缀已经失效，将这些路由从BGP表以及路由表中去掉，并用其他可用路径代替这些被移除的路径；如果在HoldTime计时器到期前收到了Keepalive或Update报文，则说明邻居还存在，此时HoldTime计时器会重置为180秒，重新进行新一次的倒计时并循环往复。HoldTime在Open报文中会相互交互。</p>
<h4 id="Keepalive"><a href="#Keepalive" class="headerlink" title="Keepalive"></a>Keepalive</h4><p>Keepalive计时器不会在Open报文中交互，Keepalive在思科设备中默认时间是60S，也就是三分之一的Holdtime时间。</p>
<h4 id="计时器协商"><a href="#计时器协商" class="headerlink" title="计时器协商"></a>计时器协商</h4><p>当两个BGP邻居配置的计时器不同时，两边用Open报文交互了HoldTime的数值，所以彼此知道对方路由器所配置的数值，此时：</p>
<ul>
<li><p>HoldTime采用两个路由器设置值的最小值，也就是说，如果一边的HoldTime为60，另一边的HoldTime为30，则最后采用较小的30，作为HoldTime值。</p>
</li>
<li><p>Keepalive的话，如果手工配置的Keepalive timer小于两边配置的最小的HoldTime的三分之一，则采用配置值；如果手工配置的Keepalive timer大于两边配置的最小的HoldTime的三分之一，则采用两边配置最小的HoldTime的三分之一这个值作为Keepalive。</p>
</li>
<li><p>如果配置了timer bgp 0 0，则表示两边的邻居永远不会down。</p>
</li>
</ul>
<h3 id="触发更新计时器"><a href="#触发更新计时器" class="headerlink" title="触发更新计时器"></a>触发更新计时器</h3><p>英文全称为：MinRouteAdvertisementIntervalTimer（MRAI Timer），BGP不会周期性更新路由，仅在需要的时候更新，由于公网的路由可能的动荡，为了保持BGP路由的稳定性，因此触发更新（包括宣告新路由或撤销路由在内）也会有一定的收敛时间，IBGP peer为5秒，EBGP peer为30秒，在这段时间内，BGP仍可以进行路由信息的收集，但不能宣告\撤销任何BGP路由，所以BGP收敛会比较慢。</p>
<h3 id="ConnectRetryTimer"><a href="#ConnectRetryTimer" class="headerlink" title="ConnectRetryTimer"></a>ConnectRetryTimer</h3><p>翻译成中文就是重传计时器，这个计时器定义的是重新连接请求之前的超时间隔。</p>
<h1 id="报文格式"><a href="#报文格式" class="headerlink" title="报文格式"></a>报文格式</h1><p><strong>BGP路由器之间交互任何BGP报文之前，必须先建立TCP连接。</strong></p>
<p><img src="/2020/10/11/14-BGP/1602922475484-91341961-eb1b-4120-893a-64b997b1ed70.png" alt="img"></p>
<h2 id="报头部分"><a href="#报头部分" class="headerlink" title="报头部分"></a>报头部分</h2><p><img src="/2020/10/11/14-BGP/1602920546094-f41633a0-9c83-4ce8-b8b4-115c15a7548c.jpeg" alt="img"></p>
<p>BGP的每个报文都有固定大小的报头：</p>
<ul>
<li><p>Marker：长度为16位，用来检测BGP对等体之间同步丢失情况，并且在支持验证功能的情况下进行报文验证。如果报文类型为open或open报文中没有包含验证消息，此字段被置为全1；</p>
</li>
<li><p>Length：长度为2位，表示BGP报文包括头部在内的长度；</p>
</li>
<li><p>Type：1为Open，2为Update，3为Notification，4为Keepalive；</p>
</li>
</ul>
<h2 id="消息部分"><a href="#消息部分" class="headerlink" title="消息部分"></a>消息部分</h2><p>BGP消息部分的字段根据报头部分中的Type字段不同而不同。</p>
<h3 id="Open"><a href="#Open" class="headerlink" title="Open"></a>Open</h3><h4 id="报文概述"><a href="#报文概述" class="headerlink" title="报文概述"></a>报文概述</h4><p>当两台运行BGP协议的路由器已经建立好TCP连接后，他们开始尝试用Open报文建立连接，双方使用Open报文标识自己，并且规定自己的BGP运行参数，如果Open信息被接受则会回送一条Keepalive信息进行确认，确认后再发送Update信息。BGP会话由发送Open信息建立。Open信息的作用是为两台设备建立连接，标识发送Open设备的AS号及Router ID，并且协商BGP会话的重要参数（Keepalive、认证等）。如果两台路由器中的任意一台不接受Open信息中的参数则会发送Notification告知对方无法建立邻居的问题所在。Open信息的最小长度为29字节。</p>
<h4 id="报文格式-1"><a href="#报文格式-1" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2020/10/11/14-BGP/1602922557293-f1109fed-d776-4633-a956-50614cf147cc.png" alt="img"></p>
<ul>
<li><p>当Type位值为1时，说明此消息为BGP的Open信息；</p>
</li>
<li><p>Version：长度为1字节，标识着发送Open信息的路由器运行的BGP版本，通常这个值为4，表示运行的是BGP-4版本；</p>
</li>
<li><p>My Autonomous System：长度为2字节，标识着发送Open信息路由器的AS号；</p>
</li>
<li><p>Hold Time：长度为2字节，该字段的值默认为180秒，表示如果邻居之间超过180秒还没收到对方的Keepalive信息则认为对方不可达；</p>
</li>
<li><p>BGP Identifier：长度为4字节，和之前OSPF的Router ID作用一致，用来标识运行BGP协议的路由器的身份，选取方式也和OSPF的Router ID选取方式一致，在Cisco设备中，路由器上环回接口的最高IP地址是BGP的Identifier，如果未配置环回接口，则将选择任何最高IP地址物理接口作为BGP标识符的值。</p>
</li>
<li><p>Optional Parameters Length：用来表示后面可选参数字段的长度，如果该字段为0说明该Open信息内没有可选字段；</p>
</li>
<li><p>Optional Parameters：可选参数，包含了一个可选参数列表，每个参数都由一个长度为8位的类型字段、长度为8位的长度字段以及一个可变长度的参数数值字段组成。用来宣告是否支持验证、多协议支持和路由刷新等可选功能，通常被成为能力值，意思就是这台路由器具备什么能力。</p>
</li>
</ul>
<p>A BGP speaker that supports a particular capability may use this capability with its peer after the speaker determines (as described above) that the peer supports this capability.  Simply put, a given capability can be used on a peering if that capability has been advertised by both peers.  If either peer has not advertised it, the capability cannot be used.</p>
<p>A BGP speaker determines that its peer doesn’t support capabilities advertisement if, in response to an OPEN message that carries the Capabilities Optional Parameter, the speaker receives a NOTIFICATION mecification [RFC4271] and not a new requirement.)  In this case, the speaker SHOULD attempt to re-establish a BGP connection with the peer without sending to the peer the Capabilities Optional Parameter.</p>
<p>​                                                                                                      —-RFC 5492 page 2</p>
<p>上面这段话的大概意思是，两个BGP在建立邻居时,会用open报文协商彼此支持的BGP特性,如果两者支持相同的特性那么两者会使用该特性;如果两者支持的特性不同,则会发送Notification报文给对方,然后在不发送Capabilities Optional Parameter的情况下重新建立邻居。</p>
<h4 id="wireshark抓包"><a href="#wireshark抓包" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1603529213037-94e7762a-0b7c-42d0-8daa-c6342e411501.jpeg" alt="img"></p>
<h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><h4 id="报文概述-1"><a href="#报文概述-1" class="headerlink" title="报文概述"></a>报文概述</h4><p>当两台BGP Speaker通过Open报文建立连接后，开始交互路由信息的过程，路由器会将那些经过路由决策筛选出来的路由条目宣告给邻居。这些需要宣告给Peer的路由信息会放入BGP的Update报文，Update会发送给每一个已用Open信息建立会话的邻居。每一个Update报文中有以下的某一个或全部元素：</p>
<ul>
<li>路由通告：一条路由的特征；</li>
<li>路由撤销：不可达网络的列表。</li>
</ul>
<p>必须注意的是，一个Update报文息中，<strong>只能通告一组路径属性相同的路由前缀，但能撤销多条路由</strong>。这是因为撤销路由只需要被撤销网段的网络号即可，而宣告路由则需要很多信息，比如要宣告路由的多种路径属性，这需要占用很大空间。当然update报文也可以只撤销路由而不进行任何宣告。实际上，只能通告一条路由这句话并不是简单的一个update报文里只有一个网络前缀，而是说<strong>一个Update<strong><strong>报文</strong></strong>中只发送一组路径属性相同的NLRI的路由前缀</strong>，可以参照下面的抓包对这句话进行理解：</p>
<p><img src="/2020/10/11/14-BGP/1603523038289-894d3dce-0b2c-41e2-93d4-4c22079582bf.jpeg" alt="img"></p>
<h4 id="报文格式-2"><a href="#报文格式-2" class="headerlink" title="报文格式"></a>报文格式</h4><p>update报文的结构比较复杂，具体参见<a href="http://www.tcpipguide.com/free/t_BGPRouteInformationExchangeUpdateMessages-2.htm">这个网页</a>，我截了两张图在下面，就不展开说了。</p>
<p><img src="/2020/10/11/14-BGP/1603272586679-19d4ef81-69ea-4aa6-a045-82542fc62745.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603272604223-10f263b6-0e7b-409a-81c2-7ed6ebf6f9c2.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603273204503-900cf73e-f6f2-499f-8e88-ad05152ca8ff.png" alt="img"></p>
<h4 id="wireshark抓包-1"><a href="#wireshark抓包-1" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p>update报文的格式看起来非常复杂，实际上wireshark的抓包并没有上面看起来那么复杂，每个update报文中是具有相同路径属性的前缀的集合：</p>
<p><img src="/2020/10/11/14-BGP/1604121221487-88cfea81-1bfc-4399-b616-62b08c6163d3.jpeg" alt="img"></p>
<h3 id="Keepalive-1"><a href="#Keepalive-1" class="headerlink" title="Keepalive"></a>Keepalive</h3><h4 id="报文概述-2"><a href="#报文概述-2" class="headerlink" title="报文概述"></a>报文概述</h4><p>当BGP通过Open报文建立连接后，BGP Speaker之间开始用Update报文交互路由信息，当路由信息交互完毕后，BGP进入了一个平稳的状态，只有当路由情况发生变化时，才会再度交互Update报文，此时BGP不会依靠TCP的连接状态去判断对方是否还在，而是用彼此交换Keepalive报文来确定对端没有Down掉。Keepalive报文交互的间隔是Hold Time时间的三分之一，在思科设备中，Hold Time默认时间是180秒，它的三分之一就是60秒，所以默认Keepalive时间是60秒。如果协商后的Hole Time为0，那么两个BGP Speaker之间不会交互Keepalive报文保活。</p>
<h4 id="报文格式-3"><a href="#报文格式-3" class="headerlink" title="报文格式"></a>报文格式</h4><p>Keepalive报文中没有任何实际的信息，它里面只有BGP的报头。</p>
<p><img src="/2020/10/11/14-BGP/1603525086435-f267f43c-0591-4dc2-9070-721d4d978e38.png" alt="img"></p>
<h4 id="wireshark抓包-2"><a href="#wireshark抓包-2" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1604121302480-be354d8f-bc18-4cc2-a217-7ddbf80d6ba0.jpeg" alt="img"></p>
<h3 id="Notification"><a href="#Notification" class="headerlink" title="Notification"></a>Notification</h3><h4 id="报文概述-3"><a href="#报文概述-3" class="headerlink" title="报文概述"></a>报文概述</h4><p>当BGP Speaker建立好连接后，可能会出现一些影响到BGP日常通信的错误，当这种问题出现时，BGP会通过Notification报文将这个错误通告给它的所有对等体（Peer，也就是邻居），当Notification报文发送时，通常会导致BGP的连接中止。Notification中有许多能告知为什么发生错误的字段，这里面包括了一组主要的错误代码以及一些错误代码的子代码，有些错误可能还会附加额外的信息帮助诊断问题所在。</p>
<h4 id="报文格式-4"><a href="#报文格式-4" class="headerlink" title="报文格式"></a>报文格式</h4><p><img src="/2020/10/11/14-BGP/1603530841097-821393b5-5d56-49dc-a574-023bd19a82e9.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603530909552-cc263cfb-4dac-417b-a8ed-3a99665c312e.jpeg" alt="img"></p>
<h4 id="wireshark抓包-3"><a href="#wireshark抓包-3" class="headerlink" title="wireshark抓包"></a>wireshark抓包</h4><p><img src="/2020/10/11/14-BGP/1603530778521-69ac95dd-107b-40db-89ca-2e39eb78a7c5.jpeg" alt="img"></p>
<h3 id="Route-refresh"><a href="#Route-refresh" class="headerlink" title="Route-refresh"></a>Route-refresh</h3><p>当路由策略发生变化时，用Route-refresh报文去请求邻居重新通告路由，因为BGP不会周期性发送更新，只有在路由产生变化时才会发送Update报文更新路由。首先先查看邻居是否支持，只有支持了该特性时才能使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip bgp neighbors 192.168.23.3 | section Neighbor capabilities</span><br><span class="line">  Neighbor capabilities:</span><br><span class="line">    Route refresh: advertised and received(new)</span><br><span class="line">    Four-octets ASN Capability: advertised and received</span><br><span class="line">    Address family IPv4 Unicast: advertised and received</span><br><span class="line">    Enhanced Refresh Capability: advertised and received</span><br><span class="line">    Multisession Capability:</span><br><span class="line">    Stateful switchover support enabled: NO for session 1</span><br></pre></td></tr></table></figure>

<p>从上面可以看到，该路由器支持新的Route refresh功能，所以可以使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#debug ip bgp in</span><br><span class="line">BGP debugging is on for address family: IPv4 Unicast</span><br><span class="line">R2#debug ip bgp updates</span><br><span class="line">BGP updates debugging is on for address family: IPv4 Unicast</span><br><span class="line">R2#clear ip bgp 192.168.23.3 in</span><br><span class="line">R2#</span><br><span class="line">*Nov 27 07:18:17.834: BGP: 192.168.23.3 sending REFRESH_REQ(5) for afi/safi: 1/1, refresh code is 0</span><br><span class="line">*Nov 27 07:18:17.835: BGP: 192.168.23.3 rcv message type 5, length (excl. header) 4</span><br><span class="line">*Nov 27 07:18:17.835: BGP: 192.168.23.3 rcvd REFRESH_REQ for afi/safi: 1/1, refresh code is 1</span><br><span class="line">*Nov 27 07:18:17.835: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) rcvd Refresh Start-of-RIB</span><br><span class="line">*Nov 27 07:18:17.835: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) refresh_epoch is 2</span><br><span class="line">*Nov 27 07:18:17.837: BGP(0): 192.168.23.3 rcvd UPDATE w/ attr: nexthop 192.168.23.3, origin i, metric 0, merged path 3, AS_PATH</span><br><span class="line">R2#</span><br><span class="line">*Nov 27 07:18:17.837: BGP(0): 192.168.23.3 rcvd 3.3.3.0/24...duplicate ignored</span><br><span class="line">*Nov 27 07:18:17.837: BGP: 192.168.23.3 rcv message type 5, length (excl. header) 4</span><br><span class="line">*Nov 27 07:18:17.837: BGP: 192.168.23.3 rcvd REFRESH_REQ for afi/safi: 1/1, refresh code is 2</span><br><span class="line">*Nov 27 07:18:17.837: BGP: nbr_topo global 192.168.23.3 IPv4 Unicast:base (0xC4A27798:1) rcvd Refresh End-of-RIB</span><br></pre></td></tr></table></figure>

<p>从上面的Debug中能看出，发送了sending REFRESH_REQ报文给邻居去请求重新发送路由通告，使得BGP新配置的策略能够尽早生效。</p>
<h1 id="邻居建立"><a href="#邻居建立" class="headerlink" title="邻居建立"></a>邻居建立</h1><h2 id="过程概述"><a href="#过程概述" class="headerlink" title="过程概述"></a>过程概述</h2><p>由于BGP是一个EGP协议，所以它的邻居的建立和之前学的其他IGP协议（比如OSPF和EIGRP）完全不同，IBGP协议只要在路由器上配置了以后就能自动发现邻居，比如在运行OSPF的路由器上，配置了router ospf 1、network  x.x.x.x  y.y.y.y  area z宣告了网段进入OSPF后，其他相连接的路由器也宣告网段进OSPF的话，只要OSPF建立邻居的组播地址（224.0.0.5，224.0.0.6）能正常通信，两者就自动开始建立邻居了，但BGP不同，它必须明确指定和哪个路由器建立邻居，才会启动建立邻居的过程，如果不宣告则不会进行邻居建立。BGP协议由于在传输层采用了TCP协议，BGP邻居建立不像OSPF、EIGRP这些IGP一样邻居之间必须直连才能建立邻居，因为BGP的控制报文（Keepalive、Open、Update、Notification和Withdraw报文）能够被路由从而跨越多个子网进行传输，这意味着BGP支持单跳、多跳的邻居建立:</p>
<p><img src="/2020/10/11/14-BGP/1604466928833-39308be4-3b1f-4e54-b28b-4a3428b9d3e1.png" alt="img"></p>
<p>由于TCP需要经由三次握手建立连接，所以BGP的邻居建立实际上分成了两部分：</p>
<ul>
<li>TCP连接建立阶段：Idle、Connect、Active；</li>
<li>BGP连接建立阶段：Opensent、Openconfirm、Established；</li>
</ul>
<p>BGP的有限邻居状态机（Finite State Machine，FSM）共有6个状态，其中Idle、Connect、Active属于TCP建立连接阶段，在这个阶段中，会交换交换TCP报文用来建立TCP连接，因为BGP协议需要可靠的TCP连接来传递BGP报文；Opensent、Openconfirm、Established属于BGP建立连接阶段，其中Opensent和Openconfirm两个阶段对应的是运行BGP的路由器交换BGP会话所必需的属性值，Established阶段表示邻居进入了稳定阶段，可以接受彼此的BGP路由更新。</p>
<h2 id="TCP连接建立阶段"><a href="#TCP连接建立阶段" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h2><p>在BGP连接建立前，必须先建立TCP连接，因为BGP的四层协议采用的是TCP协议，BGP报文交换需要TCP提供稳定的传输，如果TCP连接中断，BGP会话也会中断，当然TCP阶段建立和BGP阶段建立是两个独立的阶段，并不是只要TCP建立成功以后的BGP连接建立也会成功，因为TCP连接建立成功只是BGP连接建立的基础，而BGP建立阶段也要协商参数，也可能出现错误导致BGP阶段无法建立。当BGP的有限状态机在Idle、Active和Connect几个阶段来反复时，说明是TCP连接出现了问题。</p>
<h3 id="Idle"><a href="#Idle" class="headerlink" title="Idle"></a>Idle</h3><p>Idle是BGP有限状态机的第一个状态，BGP在检测到“Start event启动事件”之前是不会和邻居路由器开始建立邻居过程的。当路由器检测到BGP的Start event后（当路由器配置了一个新的BGP邻居或BGP Peer重置时），BGP会<strong>尝试</strong>和邻居建立TCP连接并且也会接受其他路由器发送的建立BGP邻居的消息，路由器也会在本地开始寻找一条到邻居的路由用于建立TCP连接。如果完成了上述步骤，则BGP进入下一个阶段——connect；如果在BGP邻居建立过程中发生错误，那么BGP会话会立刻终止并回到Idle状态，接下来ConnectRetry Timer（重连计时器）会设置为60秒，在重传计时器倒数到0之前，不会再尝试去建立邻居。每次连接建立失败后重新回到Idle状态的话，会导致ConnectRetry Timer（重连计时器）的时间比上次加倍。</p>
<p>导致BGP进程终止回到Idle状态的原因可能有以下几种：</p>
<ul>
<li><p>TCP的179端口未打开；</p>
</li>
<li><p>高于1023的TCP随机端口未打开；</p>
</li>
<li><p>任意一端地址配置错误；</p>
</li>
<li><p>任意一段AS号配置错误；</p>
</li>
</ul>
<h3 id="Connect"><a href="#Connect" class="headerlink" title="Connect"></a>Connect</h3><p>在Connect状态，路由器会在本地尝试找到一条到邻居的路由，初始化TCP连接并尝试TCP三次握手且等待三次握手完成。认证也是在TCP建立期间完成的。在Connect状态下，BGP会启动重传计时器（ConnectRetry），等待TCP完成连接，在思科设备上使用’show tcp brief’来查看TCP会话建立的结果：</p>
<p><img src="/2020/10/11/14-BGP/1603870822553-1785edbd-ea7d-4232-a324-032ab46e6de7.jpeg" alt="img"></p>
<ul>
<li><p>如果TCP连接成功，那么BGP在这个状态的时间会比较短，接着会向邻居对等体发送Open报文，并进入OpenSent状态；</p>
</li>
<li><p>如果TCP连接失败，那么会进入Active状态反复尝试进行TCP连接；</p>
</li>
<li><p>如果重传计时器（ConnectRetry）过期之前，BGP路由器没有收到邻居对等体的响应，那么BGP会停留在Connect状态，会对邻居对等体尝试进行新的TCP连接，此时ConnectRetryTimer会重置且进入Active状态。如果在这过程中对配置进行了更改或收到同一个IP又发过来的三次握手的SYN&lt;比如三次握手还没完，shutdown了这个neighbor&gt;（思科原文用的是If any other input is received），那么会话会重新回到Idle开始；</p>
</li>
</ul>
<h3 id="Active"><a href="#Active" class="headerlink" title="Active"></a>Active</h3><p>TCP连接如果没成功建立，则会在Active状态反复尝试TCP连接。</p>
<ul>
<li>如果在Active状态TCP连接成功建立，则会发送Open报文，Hold Timer会设置为4分钟，也就是240秒，然后进入OpenSent状态；</li>
<li>如果TCP连接建立失败，则进入Connect状态并且重置ConnectRetryTimer；</li>
</ul>
<h2 id="BGP连接建立阶段"><a href="#BGP连接建立阶段" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h2><h3 id="OpenSent"><a href="#OpenSent" class="headerlink" title="OpenSent"></a>OpenSent</h3><p>在OpenSent状态，BGP会话的起始路由器会发送Open报文给对端，等待对端响应Open报文。Open报文用来检查两端BGP的参数是否匹配，下列参数会被比较\协商：</p>
<ul>
<li><p>BGP版本必须相符；</p>
</li>
<li><p>Open报文中的源IP地址必须和邻居配置的IP地址相等；</p>
</li>
<li><p>Open报文中两端配置的AS号要相匹配；</p>
</li>
<li><p>BGP的Identifiers（RID）必须唯一；</p>
</li>
<li><p>安全方面的参数（Password、TTL等）；</p>
</li>
</ul>
<p>如果Open报文的协商过程中没有出现错误，将会协商出来Hold Time的时间（以两端配置的最低值为Hold Time），并且发送Keepalive报文（假设Keepalive不设置为0的情况下），发送完keepalive报文后BGP会进入OpenConfirm状态。</p>
<p>如果Open报文的比较过程中出现了错误，会发送Notification报文，BGP状态会回到Idle状态。</p>
<p>如果在OpenSent状态中收到了TCP的disconnect报文，则BGP会关闭连接，重置ConnectRetryTimer，状态变为Active。</p>
<p>如果在OpenSent状态，配置进行了更改，那么状态会变为Idle。</p>
<h3 id="OpenConfirm"><a href="#OpenConfirm" class="headerlink" title="OpenConfirm"></a>OpenConfirm</h3><p>在OpenConfirm状态下，BGP会等待Keepalive或Notification报文。</p>
<ul>
<li>如果收到Keepalive报文则进入Establish状态；</li>
<li>如果等待Keepalive的时间超过了Hold timer计时器的时间或收到Notification报文，那么状态会变为Idle。</li>
</ul>
<h3 id="Established"><a href="#Established" class="headerlink" title="Established"></a>Established</h3><p>在这个状态下，BGP会话建立完毕，BGP邻居之间通过Update报文交换路由。当收到Update和Keepalive报文时，Hold Timer时间会重置，如果收到Update\Keepalive报文的时间超过了Hold Timer，说明邻居之间出现了问题，BGP会重新回到Idle状态。</p>
<h2 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h2><p><img src="/2020/10/11/14-BGP/1603531494696-e8ad273f-826a-4e2c-bc43-6757706012af.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531585796-d49ff4b4-f826-4aa1-8c07-a46cf52a8df6.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531689211-ac810210-d781-4dd4-b9e1-69eaa1cd41ab.jpeg" alt="img"></p>
<h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a><a href="https://packetpushers.net/demystifying-bgp-session-establishments/">实验验证</a></h2><h3 id="直连EBGP邻居"><a href="#直连EBGP邻居" class="headerlink" title="直连EBGP邻居"></a>直连EBGP邻居</h3><p><img src="/2020/10/11/14-BGP/1604477133190-64f883ed-09dc-4383-a526-3f30cb704956.jpeg" alt="img"></p>
<p>线缆直连的单跳路由器之间建立EBGP邻居，是EBGP中最简单也最常见的方式，不需要对BGP进行过多的配置。</p>
<h4 id="基本配置："><a href="#基本配置：" class="headerlink" title="基本配置："></a>基本配置：</h4><p>R1</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line"> !</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> neighbor 12.1.1.2 remote-as 200</span><br></pre></td></tr></table></figure>

<p>R2</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 12.1.1.1 remote-as 100</span><br></pre></td></tr></table></figure>

<h4 id="命令简析"><a href="#命令简析" class="headerlink" title="命令简析"></a>命令简析</h4><ul>
<li>router bgp 命令表示在两台路由器上对BGP进程进行初始化的同时，也指出了本路由器所在的AS，比如R1上配置的是router bgp 100，这个100表示R1属于AS100。</li>
<li>neighbor命令在BGP配置模式中确定建立邻居的路由器的地址和AS号，R1配置的命令为’neighbor 12.1.1.2 remote-as 200’表示R1要和在AS200的IP地址为12.1.1.2的这个路由器建立邻居。R1从这个命令中得知，12.1.1.2在AS200中，和自己不在同一个AS中，所以R1知道了它和R2的BGP为EBGP；neighbor命令还告诉了路由器的TCP协议，只接受地址为12.1.1.2的TCP连接，由于我是在BGP邻居已经建立以后输入的命令，所以可以看到除了监听了neighbor命令中输入的12.1.1.2的179端口以外，12.1.1.1和12.1.1.2的TCP状态是已经建立（ESTAB）。除了TCP方面的影响，在输入neighbor命令后，R1还会运行一个IOS内部的检查机制，叫做samecabletest/same-cable test（<a href="https://learningnetwork.cisco.com/s/question/0D53i00000Kt0ed/is-ebgp-peer-up-bw-two-loopback-interfaces">The reason behind this is because of an internal IOS check mechanism that is known as the same-cable test. IOS makes sure the eBGP neighbor is directly connected (“C” route) before sending BGP open messages to the neighbor.</a>），也就是看EBGP的邻居是否是由同一个线直接连接，并且R1会查询到12.1.1.2的路由是否是类型C的，也就是否是直连路由。R1发送给R2的TCP和BGP报文中的TTL会设置为1，从抓包中可以看出这一点，因为要建立的是EBGP邻居。从show ip cef 12.1.1.2中能看到，到12.1.1.2的路由直连E0/0接口。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1604481355465-b42068c6-5959-4687-9326-04b491092234.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1604488330680-188241c7-9748-4363-830e-10abcdf50a9d.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1604488463443-5f0adf0b-3229-49f5-9579-5b70d31538a8.jpeg" alt="img"></p>
<p>BGP会话建立完毕后，BGP邻居之间使用Update报文交换路由，可以用show ip bgp neighbor查看建立状态：</p>
<p><img src="/2020/10/11/14-BGP/1604488644252-8f4c4472-c185-4999-adaf-e10847185e25.jpeg" alt="img"></p>
<h3 id="环回口EBGP邻居"><a href="#环回口EBGP邻居" class="headerlink" title="环回口EBGP邻居"></a>环回口EBGP邻居</h3><h4 id="实验分析"><a href="#实验分析" class="headerlink" title="实验分析"></a>实验分析</h4><p><img src="/2020/10/11/14-BGP/1604725542204-baa04789-2eca-4945-8ecd-3516af63fe15.jpeg" alt="img"></p>
<p>当两个AS之间有两根或以上的链路连接时，这时如果还用直连的地址建立BGP邻居，那么有以下两个方式：</p>
<ul>
<li>如果只用E0/0或E0/1之中的一个接口建立EBGP邻居，如果当这跟链路中断时，两端的BGP邻居会中断，所有从另一端学到的BGP路由信息都会从BGP路由表中删除，即使还有另一根备份链路能够联通两台路由器也是这样，因为只在其中一个链路上宣告了BGP，从而浪费了另一个链路的路由备份功能；</li>
<li>如果分别使用E0/0和E0/1都和对方建立EBGP邻居，这么做的缺点是，损失了可扩展性。因为在两条链路上分别宣告了BGP，E0/0一个BGP，E0/1一个BGP，也就是一共有两个宣告了BGP的链路，所以所有的路由信息会被宣告两次。</li>
</ul>
<p>经过分析可以发现，上面的两个方案都在高可用性和扩展性方面都存在着一定问题，所以这次不用两台路由器之间直连的地址建立EBGP邻居，而用两个路由器上的Lookback接口建立EBGP邻居。为什么这么做呢？因为loopback接口不是物理上存在的接口，而是一个逻辑上的接口，能够同时提供高可用性和扩展性。高可用性就是，只要两个设备之间的TCP连通性还在，用Loopback接口建立的邻居就不会Down掉，可以充分的利用冗余链路；扩展性就是，两台路由器之间还能加入更多的物理链路，而不会影响Loopback接口，也不用加入其他的配置。Loopback接口会一直保持的up的状态，除非两设备之间的物理链路断掉或逻辑接口被人为Shutdown。当然这两个Loopback接口之间并不是物理直连，所以这两个路由器上必须有对方Loopback的路由，保持这两个Loopback接口的TCP连通性，因为BGP协议的传输层用的是TCP协议。一般情况下，EBGP会用静态路由来保证两个Loopback接口的TCP连通性，而IBGP则用IGP（OSPF、EIGRP）协议提供Loopback的连通性。</p>
<h4 id="配置过程"><a href="#配置过程" class="headerlink" title="配置过程"></a>配置过程</h4><p>由于要用Loopback接口建立邻居，所以在R1和R2上进行如下配置：</p>
<p><strong>R1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 21.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line">bgp router-id 1.1.1.1</span><br><span class="line">neighbor 2.2.2.2 remote 200</span><br><span class="line">!</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 12.1.1.2</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 21.1.1.2</span><br></pre></td></tr></table></figure>

<p><strong>R2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line"></span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 21.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line">bgp router-id 2.2.2.2</span><br><span class="line">neighbor 1.1.1.1 remote 100</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 12.1.1.1</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 21.1.1.1</span><br></pre></td></tr></table></figure>

<p>但配置过后发现，两者并未建立起BGP邻居，由于BGP在传输层采用TCP协议，所以先测试TCP协议是否成功建立，使用Ping命令测试两边Loopback接口的连通性：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#ping 1.1.1.1 source 2.2.2.2</span><br><span class="line">R1#ping 2.2.2.2 source 1.1.1.1</span><br></pre></td></tr></table></figure>

<p>发现两边接口没问题，此时用debug ip bgp查看输出后发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#</span><br><span class="line">BGP: 2.2.2.2 Active open failed – update-source NULL is not available, open active delayed 12288ms (35000ms max, 60% jitter)</span><br></pre></td></tr></table></figure>

<p>这个Debug前半段显示的是，配置中的Update源头不存在，这是一个EBGP邻居会话独有的错误提示，默认情况下，运行思科IOS系统的路由器会用出接口，在这里是E0/0和E0/1，去连接配置中邻居的地址2.2.2.2，所以这个错误提示其实是说，2.2.2.2这个地址和本路由器不直连：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip cef 2.2.2.2</span><br><span class="line">0.0.0.0/0</span><br><span class="line">  no route</span><br></pre></td></tr></table></figure>

<p>输入命令show ip bgp neighbors 2.2.2.2 | include External BGP neighbor也能得到类似的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp neighbors 2.2.2.2 | include External BGP neighbor</span><br><span class="line">  External BGP neighbor not directly connected.</span><br><span class="line">  External BGP neighbor configured for connected checks (single-hop no-disable-connected-check)</span><br></pre></td></tr></table></figure>

<p>为什么在两边都有对方Loopback接口路由的情况下，依然TCP连接还失败呢？一方面是因为BGP的报文默认TTL为1，而两个Loopback接口之间至少需要两跳，也就是至少TTL=2才行，所以TCP连接一直无法建立；另一方面是因为BGP默认的update接口为直连口，必须将update源配置为Loopback接口才行。</p>
<p><img src="/2020/10/11/14-BGP/1604743789511-77243268-b13b-45ae-9e80-2b4e770d1323.png" alt="img"></p>
<p>所以分别在R1和R2上配置如下命令BGP才能顺利建立邻居关系：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line">neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="Update-source"><a href="#Update-source" class="headerlink" title="Update-source"></a>Update-source</h4><p>BGP建立邻居时没有用到组播地址，所以它无法像IGP那样自动发现邻居，需要手工指定，邻居的IP由本地的BGP neighbor命令指定，而该BGP连接的源IP（更新源）默认情况下为流量的出接口IP，只有当本地配置的邻居IP与邻居用于BGP连接建立的源IP相同时，BGP连接才能被正常建立，如果两台路由器之间需要用Loopback接口建立邻居，那么对方的Loopback接口就不是直连的IP，不满足BGP建立邻居的要求，无法建立起BGP邻居，解决这个问题，需要配置neighbor x.x.x.x update-source Loopback0这条命令，下面来看EBGP和IBGP两种不同情况：</p>
<ul>
<li>EBGP邻居之间的建立通常用直连的IP地址建立，建立EBGP邻居关系时，会首先检查直连路由，并且TTL默认为1，这么做是为了确保想要建立的邻居路由器和本路由器之间只有一跳，这么设计的初衷是为了保护EBGP的会话，缓解收到基于TCP或IP的攻击，也说明BGP的设计者认为EBGP用直连接口建立是最好的选择。如果此时用Loopback接口建立邻居的话就，就得指定Loopback接口为更新源，也就是配置一条neighbor x.x.x.x update-source Loopback0的命令，从而顺利完成邻居建立。那么，是需要在两边都配置这条命令还是只需要在一端配置呢？各个厂家的规定不同，<strong>思科<strong><strong>只在一端配</strong></strong>置****即可</strong>，<strong>但<strong><strong>Juniper是必须在两端都配置该命令</strong></strong>才能建立起邻居</strong>，所以严谨起见还是查阅厂家文档更万无一失。当R1和R2到对方的Loopback的网段使用静态或动态路由获取时，BGP邻居可以正常建立，但如果两端都用默认路由互指的话，BGP邻居无法正常建立，这么设计的原因是为了防环。</li>
<li>IBGP为了保持邻居关系的稳定，一般使用Loopback接口建立，这是因为如果使用物理接口，一旦用于建立BGP邻居关系的接口发生故障，BGP邻居就Down了，而且在AS内部，通常路径都是由冗余备份的，也就是有多条路径能够到达两个路由器，邻居之间的Loopback路由可通过IGP获取并提供一定的路由冗余性，只要还有其他的路径能维持两台路由器之间的TCP连通性，则BGP邻居就不受单一路径故障的影响，能一直维持BGP邻居的稳定。所以IBGP邻居用Loopback接口建立邻居时，也需要配置TTL和update-source这两条命令。</li>
</ul>
<p><strong>一端配置分析</strong></p>
<p>在上面的拓扑中，如果使用思科设备时只在一端，比如只在R2上配置了Update-source Loopback0这条命令，则建立邻居的步骤如下：</p>
<ol>
<li><p>R1尝试建立源为1.1.1.1，目标为2.2.2.2的EBGP邻居；</p>
</li>
<li><p>R2尝试建立源为2.2.2.2，目标为1.1.1.1的EBGP邻居；</p>
</li>
<li><p>R1收到R2试图建立TCP连接的SYN报文，因为TCP成功建立连接后路由器才会发送Open报文开始建立BGP邻居，R1拒绝了R2建立邻居的请求，因为R1上并<strong>没有配置</strong>Update-source Loopback0这条命令，所以R1认为它要和2.2.2.2建立邻居，而不是12.1.1.2&lt;因为BGP连接的源IP（更新源）默认情况下为流量的出接口IP&gt;；</p>
</li>
<li><p>R2收到了R1试图建立TCP连接的SYN报文，并且接受了TCP连接建立的请求，因为TCP连接的源地址为1.1.1.1，目标地址为2.2.2.2，R2<strong>配置了</strong>Update-source Loopback0这条命令，将BGP连接的更新源地址配置成了Loopback0；</p>
</li>
<li><p>R2用TCP的SYN-ACK报文回复R1，回复的报文源地址为2.2.2.2，目标地址为1.1.1.1；</p>
</li>
<li><p>R1收到了R2发过来的SYN-ACK报文，回复了TCP的ACK报文；</p>
</li>
<li><p>R1和R2之间的TCP连接成功建立，R1是TCP的Client端，R2是TCP的Server端，TCP连接建立的抓包如下：</p>
</li>
</ol>
<p><img src="/2020/10/11/14-BGP/1605066243442-4ce5f168-6dfe-4b04-963e-7bb3e93b8165.png" alt="img"></p>
<p>Update-source Loopback0这条命令只会对路由器初始化TCP连接时的动作产生影响，而不会对路由器作为TCP Server去回应TCP连接的动作产生影响。只要路由器从配置的neighbor地址上收到请求，就会允许连接建立。具体到上面的例子就是，R2配置了Update-source Loopback0这条命令，所以会使用2.2.2.2作为更新源，尝试与1.1.1.1建立BGP连接，而R1没有配置更新源的命令，所以更新源还是默认的12.1.1.1，但两者之间的TCP连接建立是没问题的，因为R2向R1的连接是没问题的。</p>
<p>如果使用loopback接口建立连接时忘记配置update-source这条命令，在debug bgp的时候会显示类似‘BGP: 2.2.2.2 Active open failed - tcb is not available, open active delayed 12288ms (35000ms max, 60% jitter)’的信息，里面的tcb表示tcp control block，也就是TCP连接受阻。</p>
<p>从上面可以看到，仅需保证<strong>一方</strong>满足上面的条件即可，也就是说一边配置update-source Loopback0命令即可，但为了加深印象、加快邻居建立以及防止漏配方便排错，<strong>建议两边都配置上</strong>。</p>
<h4 id="ebgp-multihop"><a href="#ebgp-multihop" class="headerlink" title="ebgp-multihop"></a>ebgp-multihop</h4><ul>
<li><p>如果在配置ebgp-multihop时并未指定具体条数，也就是配置了neighbor x.x.x.x ebgp-multihop命令时，则BGP报文的TTL被设置为255的同时，路由器会放弃直连检测；</p>
</li>
<li><p>如果在配置ebgp-multihop时明确的将数值配置成1，也就是配置了neighbor x.x.x.x ebgp-multihop 1，则BGP报文的TTL仍旧为1，路由器也会继续进行直连检测；</p>
</li>
<li><p>如果在配置bgp-multihop时将条数配置为2-255之间的数值，也就是配置了neighbor x.x.x.x ebgp-multihop {2-255}，则BGP报文的TTL值会配置为配置中的具体值，路由器放弃直连检测。</p>
</li>
</ul>
<p><a href="https://www.cisco.com/c/en/us/td/docs/ios/iproute_bgp/command/reference/irg_book/irg_bgp3.html#wp1106590">思科的文档</a>中描述该命令时说的是：</p>
<p>To accept and attempt BGP connections to external peers residing on networks that are not directly connected, use the <strong>neighbor ebgp-multihop</strong> command in router configuration mode. </p>
<p>翻译过来大概意思是，如果想要建立不直连的EBGP邻居时，需要配置该命令，不配置该命令的默认情况下，只有直连的邻居可以建立，因为EBGP默认情况下使用直连接口作为更新源。由于只有直连能够建立邻居，不配置ebgp-multihop时，R1的Loopback接口和R2的Loopback接口无法建立邻居，所以说明不用直连接口建立邻居时，肯定使用了直连检测看建立邻居的接口是否直连。那么能不能只把直连检测关闭呢？因为如果R1和R2之间直连用Loopback接口建立邻居时，TTL=1是能保证两者BGP报文相互传达的，因为中间没有其他路由器，TTL只有经过路由器时才会减1。答案是可以只关闭直连检测，用到的命令是：neighbor x.x.x.x disable-connected-check。</p>
<h4 id="disable-connected-check"><a href="#disable-connected-check" class="headerlink" title="disable-connected-check"></a><a href="https://www.cisco.com/en/US/docs/ios/iproute_bgp/command/reference/irg_bgp3.html#wp1106122">disable-connected-check</a></h4><p><img src="/2020/10/11/14-BGP/1605329079757-18f0c77f-6d55-4e94-8423-44b8a6f5d6f6.jpeg" alt="img"></p>
<p>图中R1和R2直连但属于不同的AS，如果此时想用Loopback接口建立BGP邻居，那么两个Loopback接口之间的TTL是多少才能确保顺利通信呢？答案是1，因为在R2上用traceroute 1.1.1.1 source 2.2.2.2 ttl 1 1时，TTL=1也是能顺利trace到R1的1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1605329564073-ee095c3e-b58c-4d89-a863-efff55a622f8.jpeg" alt="img"></p>
<p>所以如果R1和R2此时想用Loopback接口建立邻居，且希望TTL=1应该如何呢？配置neighbor x.x.x.x disable-connected-check就能关闭直连检测用TTL=1建立Loopback邻居。</p>
<h3 id="EBGP多跳邻居"><a href="#EBGP多跳邻居" class="headerlink" title="EBGP多跳邻居"></a>EBGP多跳邻居</h3><p><img src="/2020/10/11/14-BGP/1605333855982-2ce686eb-1cc6-426e-a5ce-f1db89c02d6d.jpeg" alt="img"></p>
<h4 id="TCP阶段配置："><a href="#TCP阶段配置：" class="headerlink" title="TCP阶段配置："></a>TCP阶段配置：</h4><p>R1和R3用Loopback接口建立邻居，首先要考虑两个Loopback接口的TCP连通问题，这里用静态路由实现：</p>
<p><strong>R1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 3.3.3.3 255.255.255.255 10.1.12.2</span><br></pre></td></tr></table></figure>

<p><strong>R2：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 10.1.12.1</span><br><span class="line">ip route 3.3.3.3 255.255.255.255 10.1.23.3</span><br></pre></td></tr></table></figure>

<p><strong>R3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 10.1.23.2</span><br></pre></td></tr></table></figure>

<p>配置完上述命令后，在R1或R3上分别ping对方的Loopback接口测试两个Loopback接口之间的连通性：</p>
<p><img src="/2020/10/11/14-BGP/1605334269937-4ceb1a68-d19e-4fa0-becb-aff43d469bac.jpeg" alt="img"></p>
<h4 id="BGP阶段配置"><a href="#BGP阶段配置" class="headerlink" title="BGP阶段配置"></a>BGP阶段配置</h4><p><strong>R1：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> neighbor 3.3.3.3 remote-as 300</span><br><span class="line"> neighbor 3.3.3.3 ebgp-multihop 2</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p><strong>R3：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> neighbor 1.1.1.1 remote-as 100</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>配置完BGP后，查看BGP邻居建立情况：</p>
<p><img src="/2020/10/11/14-BGP/1605334487388-0df04fba-ae83-493f-a3e7-1a7543c8f3ea.jpeg" alt="img"></p>
<h3 id="GRE隧道建立eBGP"><a href="#GRE隧道建立eBGP" class="headerlink" title="GRE隧道建立eBGP"></a>GRE隧道建立eBGP</h3><p><img src="/2020/10/11/14-BGP/1605337723554-d72de155-b116-4eed-be36-7f0fa6d181cf.jpeg" alt="img"></p>
<h4 id="TCP连接建立阶段-1"><a href="#TCP连接建立阶段-1" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h4><p>用GRE隧道建立BGP连接，首先要保证GRE隧道两端隧道的地址以及两个Loopback接口的连通性，这里用静态路由实现。由于使用了GRE隧道，R3上就不需要为1.1.1.1或2.2.2.2配置静态路由，因为GRE隧道的原目的IP地址是13.1.1.1和23.1.1.2：</p>
<p><img src="/2020/10/11/14-BGP/1605339705410-9b730824-b918-4139-9067-31b269e6ec4f.jpeg" alt="img"></p>
<p>R3和这两个端口直连，已经有了它们的路由：</p>
<p><img src="/2020/10/11/14-BGP/1605339592675-d65a903d-760b-4bc8-b4fc-4120dfccbac4.jpeg" alt="img"></p>
<p>所以在配置完tunnel和静态路由后，TCP连通性已经没有问题。</p>
<h4 id="BGP连接建立阶段-1"><a href="#BGP连接建立阶段-1" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h4><p><strong>R1</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 12.1.1.1 255.255.255.0</span><br><span class="line"> tunnel source 13.1.1.1</span><br><span class="line"> tunnel destination 23.1.1.2</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 13.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">ip route 2.2.2.2 255.255.255.255 12.1.1.2</span><br><span class="line">ip route 23.1.1.2 255.255.255.255 13.1.1.3</span><br></pre></td></tr></table></figure>

<p><strong>R2</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Tunnel0</span><br><span class="line"> ip address 12.1.1.2 255.255.255.0</span><br><span class="line"> tunnel source 23.1.1.2</span><br><span class="line"> tunnel destination 13.1.1.1</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">！</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 12.1.1.1</span><br><span class="line">ip route 13.1.1.1 255.255.255.255 23.1.1.3</span><br></pre></td></tr></table></figure>

<p>通过上面的配置，R1和R2可以在不改变BGP的TTL值情况下成功建立邻居，这种使用Loopback接口通过Tunnel（隧道）方式建立的BGP邻居，在逻辑上只有一跳，比如TCP建立过程中的SYN包中的TTL为1：</p>
<p><img src="/2020/10/11/14-BGP/1605758827224-66b75b48-d67f-45f2-a15b-872d6e6f0122.jpeg" alt="img"></p>
<p>所以结合上边几个实验可以得出结论，当配置了正确的update更新源时，ebgp-multihop命令只需要在两台设备物理上被其他设备隔开，也就是需要物理上多跳时必须配置，因为这种情况下的TTL大于默认值1；在设备直连并且通过Loopback接口建立邻居时，只是用‘disable-connected-check’命令就能建立起邻居，因为这种情况下的TTL=1，和默认的TTL相同，只需要关闭直连检测就行。</p>
<h3 id="iBGP直连邻居建立"><a href="#iBGP直连邻居建立" class="headerlink" title="iBGP直连邻居建立"></a>iBGP直连邻居建立</h3><p><img src="/2020/10/11/14-BGP/1605770492770-88d203c0-7a3d-4084-baa2-b5a2808f1e17.jpeg" alt="img"></p>
<p>上图中，AS100有两个相邻AS，AS100和AS200，由于AS100会承载起源和目标都不在本AS的流量，比如位于AS300的R5要发送数据给位于AS200的R1时会经过AS100，所以AS100是一个Transit AS，R2和R4是AS100的边界路由器；AS200和AS300由于之和AS100相连，所以它俩是Local AS；为了成功传递AS200和AS300之间的流量，所以两个边界路由器，R2和R4必须想办法交换他们从eBGP邻居那学到的路由条目，这种情况下就要用到iBGP了，R2和R4建立iBGP邻居后，两者就能交换彼此的路由。与eBGP不同，iBGP不在乎两个iBGP邻居之间的跳数是多少，因为iBGP设计的初衷就是为了让处于AS边界的路由器，例如R2，把它从eBGP邻居那学到的路由发送给在同一个AS的其他边界路由器，比如R4，虽然图中R2和R4之间只间隔了一个路由器R3，但在实际中两个边界路由器之间可能隔着很多其他路由器，因此没法要求iBGP邻居之间直连。</p>
<h4 id="TCP连接建立阶段-2"><a href="#TCP连接建立阶段-2" class="headerlink" title="TCP连接建立阶段"></a>TCP连接建立阶段</h4><p>前面说过，要使得R2和R4建立BGP邻居首先要保证两台路由器TCP层面的连通性，可以使用静态路由或动态路由来达到这个目的从而使得BGP邻居顺利建立，这个实验中，我们用OSPF协议来保证AS100内部三个路由器彼此的TCP连通性，配置OSPF的时候在R3上偷懒使用了network 0.0.0.0  0.0.0.0 area 0，生产网络中中为了提高安全性还是尽量别这么配置，要宣告接口进OSPF，下面来看基本配置和连通性配置：</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 21.1.1.1 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 21.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 23.1.1.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 23.1.1.2 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 23.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> ip address 43.1.1.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 45.1.1.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"> network 43.1.1.4 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 45.1.1.5 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这时查看R2、R3、R4的路由表可以发现，他们彼此有对方全部接口的路由，所以TCP连接没问题：</p>
<p><img src="/2020/10/11/14-BGP/1605937051694-6d81b024-2aad-4c53-8e3d-015fb739432a.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605937056382-89ddc6e5-a8df-4608-a1fc-13f220aee46d.jpeg" alt="img"></p>
<h4 id="BGP连接建立阶段-2"><a href="#BGP连接建立阶段-2" class="headerlink" title="BGP连接建立阶段"></a>BGP连接建立阶段</h4><p>BGP阶段的目标是，R2、R3、R4彼此之间建立全互联（Full mesh）的iBGP邻居，R1和R2建立eBGP邻居，R4和R5建立eBGP邻居。配置如下：</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 21.1.1.2 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 21.1.1.1 remote-as 200</span><br><span class="line"> neighbor 23.1.1.3 remote-as 100</span><br><span class="line"> neighbor 43.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 23.1.1.2 remote-as 100</span><br><span class="line"> neighbor 43.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 23.1.1.2 remote-as 100</span><br><span class="line"> neighbor 43.1.1.3 remote-as 100</span><br><span class="line"> neighbor 45.1.1.5 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 45.1.1.4 remote-as 100</span><br></pre></td></tr></table></figure>

<p>用show ip bgp summary命令查看各路由器之间邻居建立关系：</p>
<p><img src="/2020/10/11/14-BGP/1605937941284-9cf80bc0-35ae-4179-81ba-5e7e386a81f4.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605938090917-82b7b9d1-e81c-4667-a45f-bd6508ca8b40.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1605938122830-1a2848ee-1eff-4a73-9c53-726af4c9ed8f.jpeg" alt="img"></p>
<h3 id="iBGP邻居Loopback口建立"><a href="#iBGP邻居Loopback口建立" class="headerlink" title="iBGP邻居Loopback口建立"></a>iBGP邻居Loopback口建立</h3><p><img src="/2020/10/11/14-BGP/1605938292002-8ec1b06c-c387-49bf-b6dc-83f9823f25d5.jpeg" alt="img"></p>
<p>TCP连接建立阶段和上个实验相同，依旧用OSPF建立TCP连接，这里就不再赘述了，下面来看BGP连接建立阶段。</p>
<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 100</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 100</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 100</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>配置完后查看BGP邻居可以看到三个路由器之间彼此建立了iBGP邻居：</p>
<p><img src="/2020/10/11/14-BGP/1605939195577-a5483819-ae78-457b-99b0-7b2da3a1dcdc.jpeg" alt="img"></p>
<h3 id="iBGP邻居Next-hop-self"><a href="#iBGP邻居Next-hop-self" class="headerlink" title="iBGP邻居Next-hop-self"></a>iBGP邻居Next-hop-self</h3><p>iBGP邻居的一个潜在的坑就是，它不会自动更改next-hop-self也就是不会改变BGP表中的下一跳部分的值，让我们具体看个例子：</p>
<p><img src="/2020/10/11/14-BGP/1606194876453-c6a4c483-744d-4953-a2e1-3c5de47bd6a0.jpeg" alt="img"></p>
<h4 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h4><p>R1和R2是iBGP邻居，用OSPF协议保证TCP连通性；R2和R3是eBGP邻居，用直连接口建立。</p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 12</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet1/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 12</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 3</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 3</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.2 remote-as 12</span><br></pre></td></tr></table></figure>

<p>此时iBGP、eBGP邻居都已顺利建立：</p>
<p><img src="/2020/10/11/14-BGP/1606195723044-dcf613c7-f9e5-408b-879f-e93da064fbbc.jpeg" alt="img"></p>
<h4 id="路由分析"><a href="#路由分析" class="headerlink" title="路由分析"></a>路由分析</h4><p>R3使用network命令将3.3.3.0/24的路由引入BGP，该路由在R3上是最优，所以传递给eBGP邻居R2，由于3.3.3.0/24始发于R3，所以在R3上的下一跳值为0.0.0.0：</p>
<p><img src="/2020/10/11/14-BGP/1606196061404-502790f4-3eb1-4d68-ae52-646bf385b19e.jpeg" alt="img"></p>
<p>现在来看R2上关于3.3.3.0/24的路由，收到R3发来的eBGP路由后，由于没有入向策略，所以这条路由不会被入向策略拒绝而直接进入Adj-RIBs-in路由表中，第一步先会检查下一跳是否可达，在R2上，这条路由的下一跳地址是192.168.23.3，R2的路由表中有去往该地址的路由，因为R2和它直连，所以这条路由有资格被选做最优的BGP路由；第二步进行BGP的路径选择，由于去往3.3.3.0只有一条BGP路由故该路由直接为最优，思科在前面加上&gt;表示Best；第三步BGP将这条是Best的路由的BGP放入Loc-RIB和Adj-RIBs-out表中，放入Adj-RIBs-out中的路由会更新发送给其他邻居，在本拓扑中也就是也就是发送给R1；第四步这条最优的BGP路由会发送到路由表，经过执行路由表选择程序，看它能否放入路由表中，由于R2的IGP路由表中没有关于3.3.3.0这条前缀的路由，所以这条BGP就是最佳的路由，最终加入路由表中。</p>
<p>这条路由中的Next Hop部分为什么是192.168.23.3呢？因为R2和R3使用直连接口建立邻居，eBGP邻居发过来的路由使用更新源地址作为Next Hop，也就是eBGP邻居彼此建立邻居用的地址，R2上配置eBGP邻居的命令是‘neighbor 192.168.23.3 remote-as 3’，所以由R3这个eBGP邻居宣告过来路由的下一跳是192.168.23.3。假设如果两者使用Loopback接口建立eBGP邻居，则R3宣告给R2的路由的Next Hop部分就是R3的Loopback接口地址。</p>
<p><img src="/2020/10/11/14-BGP/1606197045599-61017c05-5182-4694-942e-63d44419fe37.jpeg" alt="img"></p>
<p>R1收到来自iBGP邻居R2的关于3.3.3.0的BGP路由，由于没有入向BGP策略所以将该路由放入Adj-RIBs-in中：</p>
<p><img src="/2020/10/11/14-BGP/1606278129352-58cd2d5c-8aeb-4cdc-ae2e-6674e3a929b2.jpeg" alt="img"></p>
<p>可以看到，这条BGP路由在R1上的下一跳依旧是192.168.23.3，这是因为路由来自iBGP邻居时Next Hop部分在AS内传递时不会发生改变（除非做了策略），这个Next Hop始终指向的是下一个AS，也就是通告该路由的eBGP邻居的接口IP，具体到这个拓扑中就是，R1收到来自iBGP邻居R2的这条路由时，不会对Next Hop部分做更改，3.3.3.0这条路由的Next Hop在AS12内传递时的Next Hop始终是R3和本AS建立邻居的接口的IP地址，192.168.23.3。</p>
<p>但查看R1的路由表会发现，R1路由表中并没有到下一跳192.168.23.3的路由，所以这条路由并不是最优的BGP路由也不会加入路由表：</p>
<p><img src="/2020/10/11/14-BGP/1606285162672-433db18f-c660-466e-92c4-3ee8a9611cc9.jpeg" alt="img"></p>
<p>那么，R1即使有到3.3.3.0的路由但这种情况下却没法给该前缀发送数据，如果想给该路由发送数据怎么办呢？可以看到，R1之所以没法给该前缀发送数据是因为下一跳不可达，所以该路由并不是最佳路由也没法加入路由表，只需要将下一跳可达，那么这条路由就能加入路由表，R1也就能给该前缀发送数据了，如何让下一跳192.168.23.3可达呢？有两种方法，一种是将192.168.23.0网段宣告进BGP，另一种现网中在使用的是使用Next-hop-self命令改变这条路由的下一跳地址，这里只具体分析这种方法，在R2上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router bgp 12</span><br><span class="line">R2(config-router)#neighbor 1.1.1.1 next-hop-self</span><br></pre></td></tr></table></figure>

<p>来看看配置前后BGP表的变化：</p>
<p><img src="/2020/10/11/14-BGP/1606285610313-5793d9db-3813-4c61-82bb-c8e01a624cfd.jpeg" alt="img"></p>
<p>在R2上对邻居R1配置了Next-hop-self命令后，R2上该BGP路由的Next Hop值由不可达的192.168.23.3变为了2.2.2.2这个可达的地址，于是该BGP路由也是Best的，由于没有其他IGP路由，所以直接加入路由表，于是R1可以发送数据到3.3.3.0网段。</p>
<h3 id="Peer-Group"><a href="#Peer-Group" class="headerlink" title="Peer Group"></a>Peer Group</h3><p>当配置BGP邻居时，可能有时每个邻居的配置除了地址以外完全相同，为了避免每个邻居都要重复舒服一边命令，可以使用peer group来简化输入流程。</p>
<h4 id="EBGP邻居实验"><a href="#EBGP邻居实验" class="headerlink" title="EBGP邻居实验"></a>EBGP邻居实验</h4><p><img src="/2020/10/11/14-BGP/1608539673036-e2c4a0fe-590b-4c7a-b94c-47f0854748d2.png" alt="img"></p>
<p>当R1分别和R2、R3、R4用Loopback接口分别建立EBGP邻居并且将路由的metric设置为6666时，会发现配置R1时，每个邻居都要配置update-source loopback0和ebgp-multihop2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1(config)#route-map SET_MED permit 10</span><br><span class="line">R1(config-route-map)#set metric 6666</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 remote-as 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 remote-as 3</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 remote-as 4</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 route-map SET_MED out</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 route-map SET_MED out</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 route-map SET_MED out</span><br></pre></td></tr></table></figure>

<p>如果使用peer  group的话，可以省掉那些配置相同的部分，不用每个邻居都配置一遍：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 remote-as 2</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 remote-as 3</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 remote-as 4</span><br><span class="line"></span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 peer-group</span><br><span class="line"></span><br><span class="line">R1(config-router)#neighbor 2.2.2.2 peer-group R2_R3_R4</span><br><span class="line">R1(config-router)#neighbor 3.3.3.3 peer-group R2_R3_R4</span><br><span class="line">R1(config-router)#neighbor 4.4.4.4 peer-group R2_R3_R4</span><br><span class="line"></span><br><span class="line">如果想对R2\R3\R4做任何策略的话，只需要对R2_R3_R4这个peer group做就行了，比如对R2\R3\R4应用配置邻居时的update-source和eBGP-multihop：</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 update-source loopback 0</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 ebgp-multihop 2</span><br><span class="line">R1(config-router)#neighbor R2_R3_R4 route-map SET_MED out</span><br></pre></td></tr></table></figure>

<p>R2\R3\R4的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.12.1</span><br><span class="line">!</span><br><span class="line">router bgp 2</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.13.1</span><br><span class="line">!</span><br><span class="line">router bgp 2</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">ip route 1.1.1.1 255.255.255.255 192.168.14.1</span><br><span class="line">!</span><br><span class="line">router bgp 4</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1</span><br><span class="line"> neighbor 1.1.1.1 ebgp-multihop 2</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="IBGP邻居实验"><a href="#IBGP邻居实验" class="headerlink" title="IBGP邻居实验"></a>IBGP邻居实验</h4><p><img src="/2020/10/11/14-BGP/1609497517529-efe5c344-f274-4051-886d-31de60145bb9.jpeg" alt="img"></p>
<p>TCP层用OSPF打通，为了节省配置直接配置的‘network 0.0.0.0 255.255.255.255 area 0’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor R2_R3_R4 peer-group</span><br><span class="line"> neighbor R2_R3_R4 remote-as 1234</span><br><span class="line"> neighbor R2_R3_R4 update-source Loopback0</span><br><span class="line"> neighbor R2_R3_R4 next-hop-self</span><br><span class="line"> neighbor 2.2.2.2 peer-group R2_R3_R4</span><br><span class="line"> neighbor 3.3.3.3 peer-group R2_R3_R4</span><br><span class="line"> neighbor 4.4.4.4 peer-group R2_R3_R4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router bgp 1234</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 1234</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h2 id="如何宣告前缀进BGP"><a href="#如何宣告前缀进BGP" class="headerlink" title="如何宣告前缀进BGP"></a>如何宣告前缀进BGP</h2><p>宣告前缀进BGP有两个方法，</p>
<ul>
<li>用Network命令；</li>
<li>重分布；</li>
</ul>
<h3 id="Network命令"><a href="#Network命令" class="headerlink" title="Network命令"></a>Network命令</h3><p><img src="/2020/10/11/14-BGP/1606121717084-e0347cc5-12e6-4e0f-b4b5-7314a89ddd07.jpeg" alt="img"></p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 65101</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.12.1 remote-as 65101</span><br></pre></td></tr></table></figure>

<p>上面在宣告1.1.1.1/32这条路由进BGP时，必须宣告的和IGP路由表中的路由完全一样才行，也就是说前缀和掩码都必须相同，因为Loopback0的IP地址为1.1.1.1/32，所以在IGP路由表中是：</p>
<p><img src="/2020/10/11/14-BGP/1606121924273-cde94629-bcb1-43e9-adc1-b8f351cd147a.jpeg" alt="img"></p>
<p>所以应该宣告1.1.1.1掩码为32位进BGP，也就是network 1.1.1.1 mask 255.255.255.255。如果此时network命令后的前缀和路由表中不一样则输入的命令不会有效。如果宣告正确的话如图所示：</p>
<p><img src="/2020/10/11/14-BGP/1606122027282-264383c8-c56f-4049-b458-e485c4e5323a.jpeg" alt="img"></p>
<h3 id="重分布命令"><a href="#重分布命令" class="headerlink" title="重分布命令"></a>重分布命令</h3><p>也可以使用redistribute命令将路由重分布进BGP，用比如此时我们在R1上创建一个IP地址为111.111.111.111/32的Loopback接口，将该接口宣告进OSPF协议，并将OSPF协议用‘redistribute ospf1’重分布进BGP进程，会得到以下BGP表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.1/32       0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;   111.111.111.111/32</span><br><span class="line">                       0.0.0.0                  0         32768 ?</span><br></pre></td></tr></table></figure>

<h2 id="BGP黑洞与同步"><a href="#BGP黑洞与同步" class="headerlink" title="BGP黑洞与同步"></a>BGP黑洞与同步</h2><h3 id="实验说明"><a href="#实验说明" class="headerlink" title="实验说明"></a>实验说明</h3><p><img src="/2020/10/11/14-BGP/1606287822270-adf20e04-8588-4ee7-b000-d143cce20d00.jpeg" alt="img"></p>
<p>拓扑如上，R1和R2，R5和R6之间为eBGP邻居关系，R2和R5之间为iBGP邻居，R3和R4不运行BGP协议。</p>
<h3 id="基本配置-1"><a href="#基本配置-1" class="headerlink" title="基本配置"></a>基本配置</h3><p>R1:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 65101</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.1 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.12.2 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.24.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.24.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 5.5.5.5 remote-as 65102</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"> neighbor 192.168.12.1 remote-as 65101</span><br></pre></td></tr></table></figure>

<p>R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.56.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 5.5.5.5 0.0.0.0 area 0</span><br><span class="line"> network 192.168.35.5 0.0.0.0 area 0</span><br><span class="line"> network 192.168.45.5 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 65102</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 65102</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 192.168.56.6 remote-as 65103</span><br></pre></td></tr></table></figure>

<p>R6：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 6.6.6.6 255.255.255.255</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.56.6 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 65103</span><br><span class="line"> bgp router-id 6.6.6.6</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.56.5 remote-as 65102</span><br></pre></td></tr></table></figure>

<p>R6的BGP表和路由表：</p>
<p><img src="/2020/10/11/14-BGP/1606288634698-79b1a9c2-2e81-4525-a994-2353ac3870ed.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1606288667588-8b8c2431-a4bf-4531-ad40-6bd32ff1dcca.jpeg" alt="img"></p>
<h3 id="路由分析-1"><a href="#路由分析-1" class="headerlink" title="路由分析"></a>路由分析</h3><p>中间的AS 65102为Transit AS，AS 65102里的路由器的TCP连接由OSPF协议连通，R1上宣告了一条1.1.1.1/32的路由，宣告给eBGP邻居R2，由R2宣告给iBGP邻居R5，在R2上对邻居R5配置了Next-hop-self命令所以该路由在R5上是最优，可以最终传递给R5的eBGP邻居R6。但要注意，R2将BGP路由更新传递给R5时，是将BGP的update报文放在IP报内经过R3或R4发送给R5的，对于不运行BGP协议的R3和R4来说，这个BGP的update报文都是普通IP包，源目的地址为5.5.5.5和2.2.2.2，这两个地址的路由它们的路由表中有，可以正常转发，它们直接转发而不查看内部：</p>
<p><img src="/2020/10/11/14-BGP/1606289900580-2c1a04d4-7337-4e6c-be6f-e2bec78e6662.jpeg" alt="img"></p>
<p>此时在R6上能否ping通1.1.1.1呢？答案是不能，为什么不能ping通呢？先看R6，R6的路由表中有1.1.1.1/32的路由，下一跳是192.168.56.5，路由表中有到下一跳的路由，从E0/0发出即可：</p>
<p><img src="/2020/10/11/14-BGP/1606290419468-a6337b7c-22b7-499b-ae4a-3daeb29f2f00.jpeg" alt="img"></p>
<p>现在Ping包到了R5：</p>
<p><img src="/2020/10/11/14-BGP/1606290587409-bd67dba1-f48c-4070-9939-feade9321cbd.jpeg" alt="img"></p>
<p>从抓包中可以看到，ping包（ICMP）到了R5以后，目标IP地址是1.1.1.1，而R5的路由表中到1.1.1.1的下一跳是2.2.2.2，而到2.2.2.2的下一跳是192.168.45.4或192.168.35.3，也就是把数据包交给R3或R4，而R3或R4由于不运行BGP，不会知道去往会丢弃掉去往1.1.1.1这个不知道目的地的数据包，所以ping包无法通，至此形成路由黑洞。经过R3去往1.1.1.1网段的ping包抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1606293474582-8898b39b-d4c8-4f73-8f05-bf67adb0cc09.jpeg" alt="img"></p>
<p>问题产生的原因就是不运行BGP的R3、R4不知道AS外部1.1.1.1如何到达，要解决路由黑洞就要让中间的R2、R3有这个路由，可以采取iBGP全互联，将外部路由重发布进IGP（BGP的庞大路由对IGP来说一般无法搞定），路由反射器、联邦或MPLS解决。</p>
<h1 id="高级特性"><a href="#高级特性" class="headerlink" title="高级特性"></a>高级特性</h1><h2 id="联邦（confederation）"><a href="#联邦（confederation）" class="headerlink" title="联邦（confederation）"></a>联邦（confederation）</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>由于BGP有水平分割原则（运行BGP协议的路由器从一个iBGP邻居处收到的路由更新，不能再传递给其他iBGP邻居），iBGP邻居之间往往无法传递路由，为了解决该问题，除了可以使用full mesh、路由反射器以外，还可以用联邦。当然现网中为了传递iBGP之间的路由，几乎很少使用联邦，99.99%用的还是路由反射，联邦只是相对full mesh来说省事一些。</p>
<h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><ul>
<li><p>在联邦内部保留联邦外部的Next Hop属性；</p>
</li>
<li><p>公布给联邦的路由的MED属性在整个联邦范围内予以保留；</p>
</li>
<li><p>路由的Local-Preference属性在整个联邦范围内给予保留；</p>
</li>
<li><p>在联邦范围内，将成员AS号压入AS_Path，但不公布到联邦外，并且使用TYPE3和TYPE4的AS_Path；</p>
</li>
<li><p>AS_Path中的联邦AS号用于在联邦内部避免环路；</p>
</li>
<li><p>联邦通过将一个AS“拆分”成多个小AS的方式解决iBGP路由传递的问题，比如下图中的AS345，被“拆分”成了AS 64512和AS64513，R3和R4之间是联邦iBGP关系，R4和R5之间是联邦eBGP关系。在联邦内部，R3和R4都属于AS64512，对于R4来说，R4属于AS64513，但对于联邦外部的路由器来说，R3\R4\R5都是AS345，外部根本不知道有AS64512、64513的存在。</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607506648291-f30c1d1a-a63a-48b3-81ec-b832413ad9dc.jpeg" alt="img"></p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p><img src="/2020/10/11/14-BGP/1607587871106-fe7fc954-b70b-4f06-833d-753c30356946.jpeg" alt="img"></p>
<p>AS2中的所有路由器运行OSPF协议打通TCP的连通性，AS2中又分为2个联邦AS。</p>
<h4 id="OSPF配置"><a href="#OSPF配置" class="headerlink" title="OSPF配置"></a>OSPF配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router ospf 1</span><br><span class="line">R2(config-router)#network 192.168.23.0 0.0.0.255 area 0</span><br><span class="line">R2(config-router)#network 192.168.24.0 0.0.0.255 area 0</span><br><span class="line">R2(config-router)#network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3(config)#router ospf 1</span><br><span class="line">R3(config-router)#network 192.168.23.0 0.0.0.255 area 0</span><br><span class="line">R3(config-router)#network 192.168.35.0 0.0.0.255 area 0</span><br><span class="line">R3(config-router)#network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4(config)#router ospf 1</span><br><span class="line">R4(config-router)#network 192.168.24.0 0.0.0.255 area 0</span><br><span class="line">R4(config-router)#network 192.168.45.0 0.0.0.255 area 0</span><br><span class="line">R4(config-router)#network 4.4.4.4 0.0.0.0 area 0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5(config)#router ospf 1</span><br><span class="line">R5(config-router)#network 192.168.35.0 0.0.0.255 area 0</span><br><span class="line">R5(config-router)#network 192.168.45.0 0.0.0.255 area 0</span><br><span class="line">R5(config-router)#network 5.5.5.5 0.0.0.0 area 0</span><br></pre></td></tr></table></figure>

<h4 id="BGP-confederation配置"><a href="#BGP-confederation配置" class="headerlink" title="BGP confederation配置"></a>BGP confederation配置</h4><p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config)#router bgp 24</span><br><span class="line">R2(config-router)#bgp confederation identifier 2</span><br><span class="line">R2(config-router)#bgp confederation peers 35</span><br><span class="line">R2(config-router)#neighbor 4.4.4.4 remote-as 24</span><br><span class="line">R2(config-router)#neighbor 4.4.4.4 update-source loopback 0</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 remote-as 35</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 update-source loopback 0</span><br><span class="line">R2(config-router)#neighbor 3.3.3.3 ebgp-multihop 2</span><br></pre></td></tr></table></figure>

<ul>
<li><p>当配置BGP 联邦时，BGP的AS号要使用所在联邦的AS号，也就是使用24这个子AS号，所以这里配置命令为‘router bgp 24’；</p>
</li>
<li><p>前边说过，联邦的AS_Path只在联邦内部传递，也就是说R2所在的联邦的AS号24只在AS内部传递，那么联邦外的路由器如何知道R2真正的AS号，AS2呢？用命令‘bgp confederation identifier 2’来告诉其他AS的路由器，R2的主AS号为2，配置以后，对于联邦外的AS来说，整个AS就不是AS24了，而是AS2；</p>
</li>
<li><p>接下来要配置R2的其他所有BGP联邦的子AS号，在这里由于只有两个子AS，AS24和AS35，所以R2只需要配置另一个子AS，AS35就行了：bgp confederation peers 35。如果除了AS35以外还有另一个子AS，比如AS78，那么R2配置‘bgp confederation peers 35 78’即可，后面可以跟多个AS号；</p>
</li>
<li><p>R2和R4同在子AS24中，像配置普通的iBGP邻居一样配置即可；R3和R2分别在不同的子AS中，属于联邦的eBGP邻居，所以相比配置R4要多配置一条eBGP多跳的命令，因为eBGP的TTL默认为1跳，但R2和R3使用Loopback接口建立的eBGP邻居，TTL至少要2才能让报文传递到彼此成功建立邻居，所以这里配置‘neighbor 3.3.3.3 ebgp-multihop 2’这条命令。</p>
</li>
</ul>
<p>R3\R4\R5的配置和R2类似：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line">router bgp 35</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 24</span><br><span class="line"> neighbor 2.2.2.2 remote-as 24</span><br><span class="line"> neighbor 2.2.2.2 ebgp-multihop 2</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 35</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line">router bgp 24</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 35</span><br><span class="line"> neighbor 2.2.2.2 remote-as 24</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 35</span><br><span class="line"> neighbor 5.5.5.5 ebgp-multihop 2</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line">router bgp 35</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> bgp confederation identifier 2</span><br><span class="line"> bgp confederation peers 24</span><br><span class="line"> neighbor 3.3.3.3 remote-as 35</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 24</span><br><span class="line"> neighbor 4.4.4.4 ebgp-multihop 2</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<h4 id="验证阶段"><a href="#验证阶段" class="headerlink" title="验证阶段"></a>验证阶段</h4><p>现在在R5上用Loopback接口宣告进BGP一条55.55.55.55/32的路由，看其他路由器上这条路由的显示</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5(config)#interface loopback 5</span><br><span class="line">R5(config-if)#ip address 55.55.55.55 255.255.255.255</span><br><span class="line">R5(config-if)#exit</span><br><span class="line">R5(config)#router bgp 35</span><br><span class="line">R5(config-router)#network 55.55.55.55 mask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>R3关于这条路由的显示：</p>
<p><img src="/2020/10/11/14-BGP/1607745757988-544c8220-467a-45fd-9007-f6fd1e2eb352.jpeg" alt="img"></p>
<p>在R3上这条路由中，会显示‘confed-internal’表示该路由来自联邦子AS内部的iBGP邻居，现在来看看R2：</p>
<p><img src="/2020/10/11/14-BGP/1607745960837-b1f3ead9-7cea-4958-9de0-1e894c8a0af9.jpeg" alt="img"></p>
<p>在R2上显示‘confed-external’表示该路由来自联邦子AS的外部eBGP邻居。联邦AS之间的AS_Path类型为‘AS_CONFED_SEQUENCE’，用来在联邦内防环，该属性不会出联邦：</p>
<p><img src="/2020/10/11/14-BGP/1607751702754-80767e96-88d2-4c73-a00d-6f1bb8d64188.jpeg" alt="img"></p>
<p>现在让R1和R2之间建立eBGP邻居，看看R1上这条路由的显示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#neighbor 192.168.12.2 remote-as 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line">R2(config)#router bgp 24</span><br><span class="line">R2(config-router)#neighbor 192.168.12.1 remote-as 1</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1607752112362-05f09e5c-437c-44d2-b48c-28dbcacbdf53.jpeg" alt="img"></p>
<p>可以看到，55.55.55.55/32这条路由在R1上被看作是一条eBGP邻居传过来的路由，至于联邦内部的AS24和AS35是不会告诉处于联邦外部的R1的：</p>
<p><img src="/2020/10/11/14-BGP/1607752276014-0f73e31e-4df7-4db7-8eb1-0cee7c3fa11e.jpeg" alt="img"></p>
<p>现在来看看在如果在R1上宣告一条路由进BGP后会是什么效果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config)#int loop 11</span><br><span class="line">R1(config-if)#ip add 11.11.11.11 255.255.255.255</span><br><span class="line">R1(config-if)#exit</span><br><span class="line">R1(config)#router bgp 1</span><br><span class="line">R1(config-router)#network 11.11.11.11 mask 255.255.255.255</span><br></pre></td></tr></table></figure>

<p>对于R2来说就是普通的由eBGP邻居发送过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752679710-7063dd27-b1bc-4af0-a6d0-096320c9cef3.jpeg" alt="img"></p>
<p>对于R3来说11.11.11.11/32是由联邦eBGP邻居，R2，宣告过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752813623-7fa53bde-da5d-4af7-9be2-e156500f7d23.jpeg" alt="img"></p>
<p>对于R4来说11.11.11.11/32是由联邦iBGP邻居，R2，宣告过来的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607752906491-a721eb7d-69e3-4276-95cf-676d23fcf178.jpeg" alt="img"></p>
<h2 id="路由反射器"><a href="#路由反射器" class="headerlink" title="路由反射器"></a>路由反射器</h2><h3 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h3><p>在AS内部，由于存在iBGP水平分割原则，使得AS内部的iBGP邻居之间传递路由十分麻烦，不得不两两建立iBGP连接，使得AS内部的BGP邻居之间形成full mesh（全互联）状态以获得完整的BGP路由更新，然而这是个扩展性非常低的做法，同时也给网络设备带来了负担，因为BGP对设备资源消耗很大，解决iBGP路由扩展问题的两种有效办法是路由反射器及联邦。路由反射器相比于联邦的优势在于，联邦中所有路由器都需要支持并理解联邦机制，而路由反射器只要RR（route reflector）理解反射机制即可，另外路由反射器的实现机制也相对简单一些，所以现网中99%用的都是路由反射器。</p>
<p>思考路由反射器时，将簇当作一个逻辑的整体去考虑，RR和client共同构成反射簇，相关配置在RR上完成，只有它才知道，RR只通告或反射它所知道的最佳路径。</p>
<p>为了维护BGP拓扑，RR在反射路由的时候不修改某些BGP路径属性，包括NH、AS_Path、Local-Preference和MED，并且增加了ORIGINATOR和CLUSTER_LIST用来防环。</p>
<p>路由反射器的反射规律如下：</p>
<ul>
<li><p>如果路由是从非client的iBGP对等体学习到的，则反射给所有的client和eBGP邻居；</p>
</li>
<li><p>如果路由是从client学习到的，则反射给所有非client的iBGP邻居以及除了该client以外的所有client；</p>
</li>
<li><p>如果路由是从eBGP邻居学习到的，则反射给所有client和非client的iBGP邻居。</p>
</li>
</ul>
<p>用一句话归纳就是“iBGP邻居非非不传，eBGP邻居反射路由”，也就是iBGP邻居的非client和非client之间不会进行路由反射，但都会反射给eBGP邻居。</p>
<h3 id="规则示例"><a href="#规则示例" class="headerlink" title="规则示例"></a>规则示例</h3><p><img src="/2020/10/11/14-BGP/1608350627934-6f5707b8-9bfb-4643-80c9-1c0c9bda3142.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1608350630941-06534341-1b18-4b91-8fbe-3bacf08791df.jpeg" alt="img"></p>
<h3 id="配置命令"><a href="#配置命令" class="headerlink" title="配置命令"></a>配置命令</h3><p><img src="/2020/10/11/14-BGP/1608352413089-87eac9df-e296-4580-ac44-ff4b719b4847.jpeg" alt="img"></p>
<p>R1\R2之间，R2\R3之间为iBGP邻居，TCP连通性用OSPF打通，R1上宣告一条10.10.10.0/24的路由，由于水平分割原则的存在，R2从iBGP邻居R1那里学到的路由不能发送给R3，所以R3的路由表中没有这条10.10.10.0/24的路由。此时为了打破水平分割原则，在R2上配置路由反射器：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2(config-router)#neighbor 1.1.1.1 route-reflector-client</span><br></pre></td></tr></table></figure>

<p>此时在R3上已经有了10.10.10.0/24这条路由：</p>
<p><img src="/2020/10/11/14-BGP/1608353398313-11059a4d-6900-4702-8919-d411e3893a25.jpeg" alt="img"></p>
<p>在R3上如果想修改Cluster ID可以用命令‘bgp cluster-id X.X.X.X’进行修改。</p>
<p>上面输出中能看到，这条经过反射的路由多了两个属性，ORIGINATOR_ID和CLUSTER_LIST，下面来看看这两个属性。</p>
<h3 id="ORIGINATOR-ID与CLUSTER-LIST"><a href="#ORIGINATOR-ID与CLUSTER-LIST" class="headerlink" title="ORIGINATOR_ID与CLUSTER_LIST"></a>ORIGINATOR_ID与CLUSTER_LIST</h3><h4 id="基本概念-2"><a href="#基本概念-2" class="headerlink" title="基本概念"></a>基本概念</h4><p>由于AS_Path属性在AS内部不会发生变化，仅当路由离开本AS时才会被更新，而路由反射器打破了水平分割原则，有可能使路由出现环路，所以AS内必须有相对应的防环机制，所以路由反射器使用两个新的属性进行防环，ORIGINATOR_ID和CLUSTER_LIST，二者为路由反射器使用的可选非传递属性，用来防止环路。</p>
<ul>
<li>ORIGINATOR_ID是一个路由反射器创建的32bit值，该数值是本地AS中路由发起方的iBGP Router ID，注意发起方未必是这条路由的引入者，如果发起方发现其RID在所接收到的路由的ORIGINATOR_ID中，那么就知道已经出现了路由环路，因此会忽略该路由。</li>
<li>CLUSTER_LIST是遗传路由传递所经过的路由反射簇（Cluster）的ID，AS内的每个路由反射簇都有一个32bit的簇ID，如果簇中包含了多个RR，则需手工为每个RR配置簇ID。当RR将来自客户的路由反射给非客户时，同时将其簇ID附加到CLUSTER_LIST中，那么就知道出现了环路，则忽略该路由。CLUSTER_LIST属性只用于RR防环，RR只在反射路由的时候才会创建或更新CLUSTER_LIST，而下面几种情况，RR不会创建该属性：1、RR自己始发的路由；2、RR向EBGP邻居发送路由更新时，将会清除所有的CLUSTER_LIST属性；3、当RR从eBGP邻居收到路由，传递给client或非client时，不会创建CLUSTER_LIST。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1608365403976-5c775260-036a-49d4-a053-a13a03f9c471.jpeg" alt="img"></p>
<h4 id="ORIGINATOR-ID取值"><a href="#ORIGINATOR-ID取值" class="headerlink" title="ORIGINATOR_ID取值"></a>ORIGINATOR_ID取值</h4><p><img src="/2020/10/11/14-BGP/1608367486050-fa2c2078-7b28-4865-be7a-31d1e52e29b3.jpeg" alt="img"></p>
<p>R1位于AS100，与R2是eBGP邻居关系，将1.1.1.0/24的路由传递给R2，R2传递给iBGP邻居R3，但由于水平分割原则，R3不会将从iBGP邻居R2处学到的1.1.1.0/24路由传递给另一个iBGP邻居R4，这种情况下如果想将路由传递给R4，使R3成为RR，R4为R3的client，R3就能将路由传递给R4了，此时身为RR的R3会添加ORIGINATOR_ID和CLUSTER_LIST进路由，其中ORIGINATOR属性为R2的Router ID，也就是2.2.2.2而不是R1的Router ID，1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1608367767846-b91f554c-6c26-45ef-ba84-884d58f25851.jpeg" alt="img"></p>
<h4 id="CLUSTER-LIST与BGP选路"><a href="#CLUSTER-LIST与BGP选路" class="headerlink" title="CLUSTER_LIST与BGP选路"></a>CLUSTER_LIST与BGP选路</h4><p><img src="/2020/10/11/14-BGP/1608367924110-f6b40265-a996-421a-9833-e2d515285aba.jpeg" alt="img"></p>
<p>R1宣告11.11.11.0/24进BGP，R5分别通过R2和R4学到这条路由，在其他属性一致的情况下，Cluster list短的路由更优：</p>
<p><img src="/2020/10/11/14-BGP/1608368122153-83f9884d-67e4-4e1c-aa85-7ad11f16cfd2.jpeg" alt="img"></p>
<h3 id="冗余RR环境"><a href="#冗余RR环境" class="headerlink" title="冗余RR环境"></a>冗余RR环境</h3><p>单RR可能会存在单点故障，因此从冗余性的角度出发，一个簇中可以拥有多台RR，Client与每一台RR都有物理连接并建立BGP对等体关系，在其中一台RR出现故障的情况下，Client仍然有替代连接。因为Client不知道主机是别人的Client，所以RR本身也可以成为别人的Client，使用荣誉RR增加了网络的健壮性，ORIGINATOR_ID和CLUSTER_LIST属性用来在冗余RR中避免环路，可以将两个RR的Cluster ID配置为一样，可以进一步起到防环作用，所有的RR之间建议采取全互联的形式，比如：</p>
<p><img src="/2020/10/11/14-BGP/1608369164961-37ba507a-2b08-4c2a-a229-a0247a72a5b2.jpeg" alt="img"></p>
<h2 id="手工汇总"><a href="#手工汇总" class="headerlink" title="手工汇总"></a>手工汇总</h2><p>BGP支持自动汇总和手工汇总，但自动汇总存在很多问题，所以建议使用手工汇总。手工汇总的命令为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">aggregate-address address / length [ advertise-map map-name ] [ as-set ] [ attribute-map map-name ] [ summary-only ] [ suppress-map map-name ]</span><br></pre></td></tr></table></figure>

<p>常见配置为aggregate-address X.X.X.X  Y.Y.Y.Y，在不加任何关键字的情况下，同时传递明细路由和汇总路由。</p>
<h3 id="summary-only"><a href="#summary-only" class="headerlink" title="summary-only"></a>summary-only</h3><p>加上参数summary-only后，只传递汇总路由，明细路由被抑制不进行传播。这种情况下的汇总路由将丢失明细路由的AS_Path属性，因此可能存在一定的隐患。</p>
<p><img src="/2020/10/11/14-BGP/1608710052439-f810a49a-bde4-4b8f-b1ec-baf5e6255530.jpeg" alt="img"></p>
<p>基本配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br><span class="line"> </span><br><span class="line"> R2</span><br><span class="line"> router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br><span class="line"></span><br><span class="line">R3</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 summary-only</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br><span class="line"></span><br><span class="line"> R4</span><br><span class="line"> router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>此时在R3上show ip bgp查看BGP表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show ip bgp</span><br><span class="line">BGP table version is 10, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.0.0       0.0.0.0                            32768 i</span><br><span class="line"> s&gt;   172.16.1.0/24    192.168.13.1             0             0 100 i</span><br><span class="line"> s&gt;   172.16.2.0/24    192.168.13.1             0             0 100 i</span><br><span class="line"> s&gt;   172.16.10.0/24   192.168.23.2             0             0 200 i</span><br><span class="line"> s&gt;   172.16.11.0/24   192.168.23.2             0             0 200 i</span><br></pre></td></tr></table></figure>

<p>这条172.16.0.0/24的汇总路由，由于是本地产生的，所以Next Hop是0.0.0.0，weight为默认的32768，origin为i，其余的明细路由标记为‘s’，因为有summary-only，因此都被抑制了。</p>
<p>在R4上show ip bgp查看BGP表</p>
<p><img src="/2020/10/11/14-BGP/1608710967456-9f912dd4-dbb4-440f-ae28-4944de635ecb.jpeg" alt="img"></p>
<p>可以看到汇总路由带上了atomic-aggregate属性，用来告知下游路由器，这是汇总路由，丢失了明细路由的属性，同时aggregator属性标识了汇总的地点为AS300内的Router ID为3.3.3.3路由器。抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608711140898-8e923bcc-567f-4b12-91a9-57e301bd000b.jpeg" alt="img"></p>
<h3 id="AS-SET"><a href="#AS-SET" class="headerlink" title="AS-SET"></a>AS-SET</h3><p>汇总命令加上关键词‘as-set’后，产生的这条汇总路由就可以继承明细路由的某些路径属性，从而规避一些问题。as-set继承明细属性的规则如下：</p>
<ul>
<li><p>AS_Path：将收到的所有明细路由的AS号都放在{}中，计算AS_Path长度时，带{}的AS只被算作一个AS号；</p>
</li>
<li><p>Origin：继承最差的Origin属性；</p>
</li>
<li><p>Community：继承所有明细路由的Community，形成一个列表；</p>
</li>
<li><p>MED：不继承；</p>
</li>
<li><p>LP：取明细路由中LP最大值；</p>
</li>
<li><p>Next-Hop：汇总路由为0.0.0.0，因为汇总路由由本地产生。</p>
</li>
</ul>
<p>在R3上将汇总的配置命令替换为‘aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only’，刷新BGP以后R3上的BGP表为：</p>
<p><img src="/2020/10/11/14-BGP/1608796173697-f2da4dbb-ba17-48c4-af8e-5ccb3e28460d.jpeg" alt="img"></p>
<p>可以看到R3上这条汇总路由的AS_Path继承了明细路由的AS_Path，以{100，200}的形式呈现，这样能起到放缓作用，而且不会由于丢失明细路由的AS_Path而带来隐患，注意这里{}内的AS_Path类型是AS_SET，是无序的AS列表。</p>
<p><img src="/2020/10/11/14-BGP/1608796557547-8e333b33-870b-4b32-9f4b-9870f3e32001.jpeg" alt="img"></p>
<p>可以看到由于配置汇总路由时使用了AS-SET的关键字使得汇总路由得以继承明细路由的部分属性，因此产生的路由仍然保留有AGGREGATOR属性，但没有atomic-agg属性了，因为有了AS-SET关键字以后明细路由的属性都得以保留，不需要通告下游路由器这条路由的属性丢失，自然也就不需要atomic-agg属性了。</p>
<p>在R4上抓取R3发给R4的BGP update报文：</p>
<p><img src="/2020/10/11/14-BGP/1608796813231-56f8e211-1665-475c-b650-e19c63bdfd04.jpeg" alt="img"></p>
<h3 id="suppress-map-xxxx-as-set"><a href="#suppress-map-xxxx-as-set" class="headerlink" title="suppress-map xxxx  as-set"></a>suppress-map xxxx  as-set</h3><p>用于宣告聚合路由及抑制特定的明细路由，后边跟上的route-map XXX里route-map匹配（permit）的路由将被过滤，其他放行。抑制列表虽然调用route-map，但route-map只用于匹配路由，不能设置路由属性，也就是不能使用set命令。</p>
<h4 id="实验1"><a href="#实验1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/2020/10/11/14-BGP/1608970784715-868738dd-42a9-4574-aad9-50681f727209.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback22</span><br><span class="line"> ip address 11.22.22.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback33</span><br><span class="line"> ip address 11.33.33.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 1</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 11.22.22.0 mask 255.255.255.0</span><br><span class="line"> network 11.33.33.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.12.2 remote-as 23</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> R2：</span><br><span class="line"></span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> neighbor 192.168.12.1 remote-as 1</span><br><span class="line"> neighbor 192.168.23.3 remote-as 23</span><br><span class="line"> neighbor 192.168.23.3 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.23.2 remote-as 23 </span><br></pre></td></tr></table></figure>

<p>R3在配置汇总抑制列表前的BGP表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  11.11.11.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.22.22.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.33.33.0/24    192.168.23.2             0    100      0 1 i</span><br></pre></td></tr></table></figure>

<p>现在来配置汇总和抑制列表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router bgp 23</span><br><span class="line"> aggregate-address 11.0.0.0 255.0.0.0 as-set suppress-map SUPPRESS</span><br></pre></td></tr></table></figure>

<p>这种配置下，除了汇总路由，明细路由的11.11.11.0/24会被干掉，放行其他明细路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  11.0.0.0         192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.22.22.0/24    192.168.23.2             0    100      0 1 i</span><br><span class="line"> *&gt;i  11.33.33.0/24    192.168.23.2             0    100      0 1 i</span><br></pre></td></tr></table></figure>

<p>如果将上面有关汇总的配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS deny 10</span><br><span class="line"> match ip address prefix-list 1</span><br></pre></td></tr></table></figure>

<p>等于route-map不匹配（deny）任何条目，因此所有明细路由都会被放行。</p>
<p>如果将配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 deny 11.11.11.0/24</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">route-map SUPPRESS permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br></pre></td></tr></table></figure>

<p>效果也是不匹配任何路由，所有明细路由被放行。</p>
<p>如果将配置改为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map SUPPRESS permit 10</span><br></pre></td></tr></table></figure>

<p>则明细全都被干掉，不放行任何明细。</p>
<p>如果将配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map SUPPRESS deny 10</span><br></pre></td></tr></table></figure>

<p> 则放行所有明细。</p>
<h4 id="实验2"><a href="#实验2" class="headerlink" title="实验2"></a>实验2</h4><p>可以在BGP中用‘邻居地址+route-map’实现相同功能，但用route-map实现的话，最后是隐含干掉any的，而suppress-map则不同。比如也在R2上进行汇总然后干掉明细的11.11.11.0/24的话，R2配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24               #抓取11.11.11.0/24这条要过滤掉的路由</span><br><span class="line">!</span><br><span class="line">route-map DENY deny 10                                    #deny掉这条需要过滤的明细路由</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">route-map DENY permit 20                                  #放行其他明细路由，由于route-map最后是deny掉any的，如果不放行则没有明细路由传递</span><br><span class="line">!</span><br><span class="line">router bgp 23</span><br><span class="line"> neighbor 192.168.23.3 route-map DENY out                 #对邻居R3的out方向用设定好的route-map</span><br><span class="line"> aggregate-address 11.0.0.0 255.0.0.0 as-set              </span><br></pre></td></tr></table></figure>

<h4 id="实验3"><a href="#实验3" class="headerlink" title="实验3"></a>实验3</h4><p><img src="/2020/10/11/14-BGP/1608972665566-3934c61c-f426-4ba8-a7f1-c6f50fb2605f.jpeg" alt="img"></p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.2.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback10</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/3</span><br><span class="line"> ip address 192.168.35.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br><span class="line"> neighbor 192.168.35.5 remote-as 500</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">!</span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.35.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 500</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.35.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>现在要求在R3上做汇总，将路由汇总为172.16.0.0/24，传给R5的除了汇总路由以外还有172.16.1.0/24这条明细路由，而传给R4的路由只有汇总路由。总体思路是，由于有四条明细路由而只想让R5知道其中一条明细路由，所以这里使用as-set搭配summary-only进行汇总，先将所有明细路由都抑制掉，然后再对特定的邻居R5使用非抑制列表，将需要传递给R5的那条明细路由传递给R5。</p>
<p>R3的配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 172.16.1.0/24             #抓取路由172.16.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map PASS permit 10                                #配置抑制列表需要的route-map，将上面抓取的路由和route-map相匹配</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only    #用as-set搭配summary-only进行汇总，使得R4、R5上只有172.16.0.0/24的路由</span><br><span class="line"> neighbor 192.168.35.5 unsuppress-map PASS              #对邻居使用非抑制列表用来将172.16.1.0/24的路由传递给R5</span><br></pre></td></tr></table></figure>

<h3 id="attribute-map"><a href="#attribute-map" class="headerlink" title="attribute-map"></a>attribute-map</h3><p>attribute-map命令可以修改汇聚路由的属性，比如汇聚路由的origin、metric等，但该命令仅仅对汇总路由产生作用，对明细不起效。</p>
<p><img src="/2020/10/11/14-BGP/1609046627457-ebdf3cd0-97a6-4011-a8e1-15b361e8de8c.jpeg" alt="img"></p>
<p>在R2上将明细路由汇总为192.168.0.0/16并修改其属性。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp 12</span><br><span class="line"> aggregate-address 192.168.0.0 255.255.0.0 attribute-map TEST</span><br><span class="line"></span><br><span class="line">route-map TEST permit 10</span><br><span class="line"> set metric 666</span><br></pre></td></tr></table></figure>

<p>汇总前和汇总后的BGP表对比</p>
<p><img src="/2020/10/11/14-BGP/1609125163847-d1b205bd-640d-4483-a41f-6fc587226dfd.jpeg" alt="img"></p>
<p>但此时再看R3的路由表：</p>
<p><img src="/2020/10/11/14-BGP/1609125266918-a23f52ac-e49f-4eb3-b5f1-dd466b5b9519.jpeg" alt="img"></p>
<p>由于R2和R3是eBGP邻居，所以汇总这条路由也传递给了R3，有可能造成路由环路，必须过滤掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 1 deny 192.168.0.0 0.0.255.255</span><br><span class="line"></span><br><span class="line">router bgp 12</span><br><span class="line">neighbor 10.1.23.3 distribute-list 1 out</span><br></pre></td></tr></table></figure>

<h3 id="advertise-map"><a href="#advertise-map" class="headerlink" title="advertise-map"></a>advertise-map</h3><p>当advertise-map与summary-only命令合用时，aggregate-address的汇总路由下面的明细路由均会被抑制，同时如果advertise-map匹配的条目中的明细路由如果全部挂掉，则汇总路由也会消失，但只要advertise-map匹配的明细中有一条路由还在，那么汇总路由就会在，并且汇总路由仅会继承advertise-map匹配的明细路由的BGP路径属性。结合下面这个实验具体说明advertise-map的作用。</p>
<h4 id="实验1-1"><a href="#实验1-1" class="headerlink" title="实验1"></a>实验1</h4><p><img src="/2020/10/11/14-BGP/1609126288482-59fa9336-e024-4c4e-8cf5-6a111edbb799.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 permit 172.16.1.0/24           #抓取1.0和2.0两条明细路由</span><br><span class="line">ip prefix-list 1 permit 172.16.2.0/24</span><br><span class="line"></span><br><span class="line">route-map TEST permit 10                        #设置抓取两条明细路由的route-map</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">router bgp 300</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set summary-only advertise-map TEST</span><br></pre></td></tr></table></figure>

<p>手动汇总时的advertise-map调用了抓取了1.0/24和2.0/24的route-map，所以明细路由均会被压制，汇总路由仅会继承route-map TEST所匹配的明细路由的属性，由于route-map TEST匹配的明细路由是来自AS100的R1的1.0/24和2.0/24，所以汇总路由的Path属性中只继承了1.0和2.0的AS_Path，也就是300和100。只要1.0和2.0其中有一条存在，汇总路由就会存在，如果1.0和2.0都挂掉，那么汇总路由也会不存在。</p>
<p><img src="/2020/10/11/14-BGP/1609129461304-78cd98b4-7efa-41e4-b08a-c5714e1d20fa.jpeg" alt="img"></p>
<h4 id="实验2-1"><a href="#实验2-1" class="headerlink" title="实验2"></a>实验2</h4><p>R3宣告192.168.1.0和2.0进BGP进程，同时将1.0的community设置为no-adv，设置为no-adv以后，1.0路由从R1传递给R2后，不会再传递给R1，因为community为no-adv的路由不会再宣告给其他邻居：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 1 permit 192.168.1.0</span><br><span class="line">!</span><br><span class="line">route-map TEST permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line"> set community no-advertise</span><br><span class="line">!</span><br><span class="line">route-map TEST permit 20</span><br><span class="line"> set community none</span><br><span class="line">!</span><br><span class="line">router bgp 3</span><br><span class="line"> neighbor 10.1.23.2 send-community</span><br><span class="line"> neighbor 10.1.23.2 route-map TEST out</span><br></pre></td></tr></table></figure>

<p>在如上配置以后，R2能学到1.0和2.0两条路由，而R1只能学到2.0，学不到community为no-adv的1.0路由。</p>
<ul>
<li>当R2配置了‘aggregate-address 192.168.0.0 255.255.0.0’后，R1能学到汇总路由及明细路由2.0；</li>
<li>当R2配置了‘aggregate-address 192.168.0.0 255.255.0.0 as-set’后，R1只能学到2.0路由而无法学习到汇总路由，原因是因为1.0携带了no-adv的community，当汇总路由加了关键字‘as-set’后，汇总路由会继承明细路由1.0的community，因此汇总路由也携带了no-adv的community，不会发送汇总路由到R1：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  192.168.2.0      10.1.12.2                0    100      0 3 i</span><br></pre></td></tr></table></figure>

<ul>
<li>如果在上面的基础上在R2上进行如下配置：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">access-list 11 deny   192.168.1.0</span><br><span class="line">access-list 11 permit any                               抓取除了192.168.1.0以外的其他路由，那就是抓取2.0这条路由</span><br><span class="line">!</span><br><span class="line">route-map ADV permit 10</span><br><span class="line"> match ip address 11</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line">aggregate-address 192.168.0.0 255.255.0.0 as-set advertise-map ADV</span><br></pre></td></tr></table></figure>

<p>上面的配置大概意思是说，汇总路由继承2.0的属性，而不继承192.168.1.0的属性，也就是不再有1.0的no-adv的community属性，所以汇总路由可以传递给R1。</p>
<p>配置以后R1的路由表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1#show ip bgp</span><br><span class="line">BGP table version is 7, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  192.168.0.0/16   10.1.12.2                0    100      0 3 i</span><br><span class="line"> *&gt;i  192.168.2.0      10.1.12.2                0    100      0 3 i</span><br></pre></td></tr></table></figure>

<h2 id="Route-Dampening"><a href="#Route-Dampening" class="headerlink" title="Route Dampening"></a>Route Dampening</h2><h3 id="基本概念-3"><a href="#基本概念-3" class="headerlink" title="基本概念"></a>基本概念</h3><p>那些时有时无的不稳定路由称作路由翻滚，当路由翻滚出现在BGP中时，会导致邻居之间反复的发送update报文，从而增加设备的硬件资源消耗。BGP Dampening这个特性存在的意义是，减少那些翻滚路由的传播的同时，不会影响那些稳定路由的收敛。使用BGP dampening以后，会减少路由的硬件资源消耗并且增强网络总体的稳定性，稳定的路由会持续宣告给其他路由器，而翻滚的路由则会被抑制等它稳定后再进行传播。</p>
<p>具体步骤是，当路由翻滚出现后，给它分配一个惩罚值，翻滚越多惩罚值越大并且不断地积累。同时惩罚值又以一定的速率降低，每一个半衰期结束，如果在半衰期时间内路由不再翻滚的话，惩罚值会变为原来的一半。如果惩罚值超出了预先设置的阈值，也就是抑制阈值，路由会被抑制，也就是这条路由不再对外不发布，直到N个半衰期以后，惩罚值降低到另一个阈值，也就是低于重新使用阈值后，才会解除对路由的抑制。</p>
<p><strong>必须注意的是，Route Dampening只对eBGP路由生效，而对iBGP路由无效。</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">惩罚值： 每次摆动增加1000</span><br><span class="line">抑制阈值：   2000</span><br><span class="line">重新使用阈值：   750 </span><br><span class="line">半衰期： 15分钟</span><br><span class="line">最大抑制时间：  60分钟（半衰期的4倍） </span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1609145745191-9554c7a3-5fe5-4949-bddf-3e18fb539939.jpeg" alt="img"></p>
<p>正常情况下，所有路由的惩罚值都是0，惩罚值是瞬间增加的，例如某条路又出现翻滚后，则惩罚值瞬间会增加到1000，这时会有半衰期，也就是15分钟，15分钟后如果该路由没有出现翻滚，则惩罚值降低为一半，降低到500， 再经过15分钟变成250，这时如果路由又一次发生抖动，惩罚值再加1000，变成1250，在此之前，这条路由正常使用。如果在中间又抖动了一次，惩罚值再加1000，变成2250，超过了阈值规定的2000，则这条路由将被抑制，不更新也不使用，这段时间路由进入了抑制期。如果15分钟内这条路由不再翻动了，则惩罚值降低为一半，也就是1125，但仍然被抑制，只有当该路由的惩罚值降低为750，小于重新使用的界限（1000）时，路由会再次被启用。</p>
<h3 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show ip bgp dampening parameters                  #查看关于dampening的相关参数，比如各种阈值的设定和半衰期的时间</span><br><span class="line">show ip bgp dampening flap-statistics             #查看翻滚路由目前的状态</span><br><span class="line">show ip bgp dampening                             #查看那些路由被抑制了</span><br><span class="line">bgp dampening                                     #启动BGP dampening，默认对全部EBGP路由有效，也可以加route-map对特定路由起作用</span><br></pre></td></tr></table></figure>

<h1 id="路径属性"><a href="#路径属性" class="headerlink" title="路径属性"></a>路径属性</h1><p>BGP路由器通常会收到多条去往同一路由前缀的BGP路由，像IGP一样，这时就需要进行路径选择流程，选出最佳路径。但不像IGP一样只有一到两个属性用来选路，比如RIP是跳数小的路径更优，OSPF是Cost值小的路径更优，而BGP有很多属性用来决定一条路径是否更优：</p>
<p><img src="/2020/10/11/14-BGP/1606295209278-331107aa-8bf9-4244-82d9-68772a55575f.png" alt="img"></p>
<p>这些属性又分为公认属性（Well-known）和可选属性（Optional），公认属性又分为公认必遵（Well-known mandatory）和公认自决（Well-known discretionary）；可选属性又分为可选传递（Optional transitive）和可选非传递（Optional non-transitive）：</p>
<h2 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h2><p><img src="/2020/10/11/14-BGP/1606295493589-47555be0-9014-4d3c-87d1-dd081aee444b.jpeg" alt="img"></p>
<h2 id="Origin"><a href="#Origin" class="headerlink" title="Origin"></a>Origin</h2><h3 id="理论知识"><a href="#理论知识" class="headerlink" title="理论知识"></a>理论知识</h3><p>公认必遵属性，明确了路由更新的来源，一共有三种：</p>
<ul>
<li><p>IGP，在BGP表中用‘i’表示，通过BGP的network命令宣告进BGP，也就是起源于IGP，因为BGP network命令宣告的路由必须在路由表中存在；</p>
</li>
<li><p>EGP，在BGP表中用‘e’表示，通过EGP协议重发布而来，现在已经没有EGP协议使用，因此不会见到e开头的路由；</p>
</li>
<li><p>Incomplete，在BGP表中用‘?’表示，通过其他渠道学习到的，路由来源的信息不完全，通常是由其他路由协议重分布进BGP的路由，当然整个不完整不表示这条路由可能会失效而是说路由的起源信息不完整；</p>
</li>
</ul>
<p>这三种来源路径之间的优选原则是IGP&gt;EGP&gt;Incomplete。</p>
<p>起始属性可以通过命令修改：</p>
<ul>
<li><p>route-map ORI permit 10                     #先配置route-map；</p>
</li>
<li><p>match ip address 1                               #确定要对哪些路由的origin属性进行修改；</p>
</li>
<li><p>set origin incomplete\igp                    #将origin属性修改成incomplete或igp；</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606363442113-2388ac61-1c87-44da-b2fa-4e8e121f7aca.png" alt="img"></p>
<h3 id="实验验证-1"><a href="#实验验证-1" class="headerlink" title="实验验证"></a>实验验证</h3><p><img src="/2020/10/11/14-BGP/1606373497233-3b069aee-0b56-41c5-b46f-25c370ec66ed.jpeg" alt="img"></p>
<p>R2和R3是eBGP邻居，R3上宣告一条3.3.3.0/24的路由到R2，现在要在R2上对这条BGP路由的origin属性进行更改，由之前的‘i’改为‘?’。R2更改origin属性之前的BGP表：</p>
<p><img src="/2020/10/11/14-BGP/1606374455509-4723d744-e245-4bcd-a5c9-885461d938dd.jpeg" alt="img"></p>
<p>之前BGP邻居的配置这里就不写了，只看和改变origin属性有关的配置，改变origin的配置可以在R2上的in方向，也可以在R3上out方向，我们在R2的in方向上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">先用ACL匹配需要改变origin的这条路由：</span><br><span class="line">access-list 1 permit 3.3.3.0 0.0.0.255</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">然后用route-map将匹配的路由的origin变成incomplete：</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line"> set origin incomplete</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 最后在R2的in方向上对邻居使这条route-map在in方向上生效：</span><br><span class="line"> router bgp 12</span><br><span class="line"> neighbor 192.168.23.3 route-map 1 in</span><br><span class="line"> do clear ip bgp * soft                             #软刷新使BGP的配置生效 </span><br></pre></td></tr></table></figure>

<h2 id="AS-Path"><a href="#AS-Path" class="headerlink" title="AS_Path"></a><a href="https://sites.google.com/site/amitsciscozone/bgp/bgp-as_path-attribute">AS_Path</a></h2><h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><p>公认必遵属性，描述到达目标网络要经过的AS号序列，最重要的作用是防止BGP路由环路，如果BGP speaker发现自己的AS号出现在接收到的BGP路由更新的AS_Path中，那么说明可能有路由环路，路由器会忽略该路由更新。另一个重要作用，是在BGP选路过程中，作为AS跳数的丈量，AS_Path中包含的AS个数越少，表示距离目的网络更近，在其他路径属性相同的情况下，AS_Path越短越优先，先添加的AS号在右边，后添加的AS号在左边。AS_Path属性包含在建立邻居时的update报文中：</p>
<p><img src="/2020/10/11/14-BGP/1606541976124-06905b2f-5080-4202-939d-c2d0c13bf3fe.jpeg" alt="img"></p>
<p>在BGP表中的Path部分也是AS_Path，例如去往6.6.6.0/24的最佳BGP路由，也就是下一跳是192.168.13.3的这条，先经过了AS65300，然后经过AS65100最后发送到本AS：</p>
<p><img src="/2020/10/11/14-BGP/1606461813458-08659f18-aecb-4131-b7c2-b383895e14df.png" alt="img"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>Four types of AS segments are supported within the AS_PATH in Cisco IOS-</p>
<ol>
<li><ol>
<li><strong>AS_SET -</strong> Unordered set of ASes a prefix in the UPDATE message has traversed</li>
<li><strong>AS_SEQUENCE -</strong> Ordered set of ASes a prefix in the UPDATE message has traversed</li>
</ol>
</li>
<li><ol>
<li><strong>AS_CONFED_SET -</strong> Unordered set of Member AS numbers in the local confederation that the UPDATE message has traversed</li>
<li><strong>AS_CONFED_SEQUENCE -</strong> Ordered set of Member AS numbers in the local confederation that the UPDATE message has traversed</li>
</ol>
</li>
</ol>
<p>AS_Path共分为四类：</p>
<ul>
<li>AS_SEQUENCE：RFC1771中的英文定义是‘ordered set of ASs a route in the UPDATE message has traversed’，就是按照该BGP路由经过AS的顺序有序列出来的有序AS列表，这里要注意，如果一个AS号在AS_Path部分越靠右，表示这条路由越早经过这个AS，比如下图中到6.6.6.0/24这条BGP路由，下一跳为192.168.13.3的这个，AS65300在最右边，表示该路由从AS65300发出，然后经过AS 65100到达本AS：<img src="/2020/10/11/14-BGP/1606544505722-70ceea4d-88f2-4740-a076-18c8780c781c.jpeg" alt="img"></li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606541922954-a785b815-01a8-435c-abb0-7851305a65d1.jpeg" alt="img"></p>
<ul>
<li>AS_SET：RFC1771中的英文定义是‘unordered set of ASs a route in the UPDATE message has traversed’，就是无序的将该BGP路由所经过的AS号无序列出来的一个无顺序的AS列表。一开始的时候我觉得，AS_Path不就是用来表示经过了哪些AS的嘛，肯定是要用上面提到的AS_SEQUENCE这种有序的排列类型的AS_Path啊，为什么还要有AS_SET这种无序的AS列表呢？后来才明白，AS_SET是在路由汇总时使用的，具体的参见后面实验部分。下图括号中的100，300就是AS_SET类型的AS_Path，但由于AS_SET是无序的，所以从中无法看出该路由是先经过了AS 100还是AS 300：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606544378538-c946baf4-38de-4fc5-b83c-7ea539b54016.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1606544663113-af5e3d1d-2dce-4d5b-b72b-1ab7ffd94bfc.jpeg" alt="img"></p>
<ul>
<li>AS_CONFED_SEQUENCE：和之前的AS_SEQUENCE用法完全一样，都是有顺序的AS列表，区别在于列表中的AS号属于本地联邦中的AS号：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606546397647-7b4b4908-a9ec-4476-9ec9-19265dabe2de.png" alt="img"></p>
<ul>
<li>AS_CONFED_SET：和之前的AS_SET用法完全一样，都是无序的AS列表，区别在于列表中的AS号属于本地联邦中的AS号。</li>
</ul>
<h3 id="生成-amp-修改AS-Path"><a href="#生成-amp-修改AS-Path" class="headerlink" title="生成&amp;修改AS_Path"></a>生成&amp;修改AS_Path</h3><p>When a BGP speaker advertises a prefix it learned from another BGP speaker, it modifies the prefix’s AS_PATH attribute based on location of BGP peer to which the prefix will be sent i.e. iBGP or eBGP peer-</p>
<ul>
<li><ul>
<li>The AS_PATH attribute is *<strong>not*</strong> modified when a prefix is advertised to an iBGP peer</li>
<li>The AS_PATH attribute is modified as follows when a prefix is advertised to an eBGP peer-</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>if the first path segment of the AS_PATH is of type <strong>AS_SEQUENCE</strong>, the local system prepends its own AS number as the last element of the sequence.</li>
<li>if the first path segment of the AS_PATH is of type <strong>AS_SET</strong>, the local system prepends a new path segment of type AS_SEQUENCE to the AS_PATH, including its own AS number in that segment</li>
</ul>
</li>
</ul>
</li>
<li><ul>
<li><ul>
<li>if the AS_PATH is empty, the local system creates a path segment of type AS_SEQUENCE, places its own AS into that segment, and places that segment into the AS_PATH.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>当BGP路由生成一条BGP路由时，起源路由器会将该路由用update报文通告给其他邻居：</p>
<ul>
<li>当通告给eBGP邻居时，这个update报文中会包含着类型为AS_SEQUENCE的AS_Path，路由器会将它的AS号放入该AS_Path中；</li>
<li>当通告给iBGP邻居时，这个update报文中AS_Path部分将为空，因为路由发送给iBGP不会修改AS_Path属性；</li>
</ul>
<h4 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h4><p>当运行BGP协议的路由器将一个从其他路由器学到的前缀宣告给另一个BGP邻居时，路由器是否修改前缀的AS_Path属性取决于通告的路由器是iBGP邻居还是eBGP邻居：</p>
<p>当BGP路由前缀被通告给iBGP邻居时，AS_Path属性不会被修改；</p>
<p>当BGP路由前缀被通告给eBGP邻居时，AS_Path属性会被修改：</p>
<ul>
<li>如果AS_Path已经有数值且该数值类型为AS_SEQUENCE时，路由器会将它自己的AS号加到序列的左侧，因为靠左侧的AS编号是最新经过的AS；</li>
<li>如果AS_Path已经有数值且该数值类型为AS_SET时，路由器会为AS_Path添加一段包含自己AS号在内，属性为AS_SEQUENCE的新序列，这个AS_SEQUENCE新序列和之前的AS_SET相互独立，但AS_SEQUENCE和之前的AS_SET是有先后之分的，下图中的AS_PATH表示路由先经过了{10 20}这个类型为AS_SET的AS，然后经过了30这个类型为AS_SEQUENCE的AS：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606720824164-a63a96d8-5594-486a-98cd-9f76d5dea377.jpeg" alt="img"></p>
<ul>
<li>如果AS_Path值为空，路由器会创建一个属性为AS_SEQUENCE的序列并将自身的序列号加入其中。</li>
</ul>
<p>这也意味着如果要修改AS_Path属性，必须在AS边界路由器上执行策略。</p>
<h4 id="实验-1"><a href="#实验-1" class="headerlink" title="实验"></a>实验</h4><p><strong>AS_SEQUENCE</strong></p>
<p><img src="/2020/10/11/14-BGP/1606558436164-ea4d34d6-2b37-463d-9cc4-414d57506a22.jpeg" alt="img"></p>
<p><em>R1发给R2的update中的AS_Path：</em></p>
<p><img src="/2020/10/11/14-BGP/1606557673901-11a9663a-f954-4068-a823-8bf7902b5715.jpeg" alt="img"></p>
<p>R1和R2之间是eBGP邻居，所以该update在离开AS100时，会生成类型为AS_SEQUENCE的AS_Path序列，并将自己的AS号，也就是100，放入其中。</p>
<p><em>R2发给R3的update中的AS_Path：</em></p>
<p><img src="/2020/10/11/14-BGP/1606558402536-1d25129e-c3e1-4bf3-a11f-ae7149b9642f.jpeg" alt="img"></p>
<p>R2和R3之间是eBGP邻居，且该update中已经有了类型为AS_SEQUENCE的AS_Path，这个AS_Path值为100，这时R2会将它自己的AS号，200，加到序列号的左侧，也就是加到100的左侧。</p>
<p><strong>AS_SET</strong></p>
<p><img src="/2020/10/11/14-BGP/1606808699034-fdf3d310-922a-4484-8cc4-ebe6d8e34e12.png" alt="img"></p>
<p>R1和R3、R2和R3、R3和R4之间都是ebgp邻居，R1上用loop 1和loop 2两个环回口宣告172.16.1.0/24和172.16.2.0/24的两条BGP路由，R2上用loop 1和loop 2两个环回口宣告172.16.11.0/24和172.16.10.0/24的两条BGP路由，在R3上用aggregate-address as-set命令汇总，由于在汇总时带了AS_Set命令，产生的这条汇总路由可以继承明细路由的某些路径属性，比如AS_Path、Origin、Community等，具体参见后面路由汇总部分，现在我们只观察AS_Path部分。</p>
<p><strong>基本配置：</strong></p>
<p>R1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.2.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.1.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.2.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.13.3 remote-as 300</span><br></pre></td></tr></table></figure>



<p>R2：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback1</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback2</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 192.168.23.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R3：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/2</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> aggregate-address 172.16.0.0 255.255.0.0 as-set</span><br><span class="line"> neighbor 192.168.13.1 remote-as 100</span><br><span class="line"> neighbor 192.168.23.2 remote-as 200</span><br><span class="line"> neighbor 192.168.34.4 remote-as 400</span><br></pre></td></tr></table></figure>

<p>R4：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router bgp 400</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.34.3 remote-as 300</span><br></pre></td></tr></table></figure>

<p>R4上的BGP表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 18, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.0.0       192.168.34.3             0             0 300 &#123;100,200&#125; i</span><br><span class="line"> *&gt;   172.16.1.0/24    192.168.34.3                           0 300 100 i</span><br><span class="line"> *&gt;   172.16.2.0/24    192.168.34.3                           0 300 100 i</span><br><span class="line"> *&gt;   172.16.10.0/24   192.168.34.3                           0 300 200 i</span><br><span class="line"> *&gt;   172.16.11.0/24   192.168.34.3                           0 300 200 i</span><br></pre></td></tr></table></figure>

<p>先看最上面172.16.0.0这条汇总路由的update：</p>
<p><img src="/2020/10/11/14-BGP/1606810192758-f13beb3b-f858-4a80-a5f6-7180087afaba.jpeg" alt="img"></p>
<p>这条汇总路由的AS_Path部分包含两部分，值为300的为AS_SEQ 类型，用来标识路由起源，它是有序的；值为{100,200}为AS_SET类型，用来标识汇总前的明细的AS列表，它是无序的，用来防环。</p>
<p>如果你做实验并抓包了会发现，update中除了172.16.0.0/16这条汇总路由以外，携带了明细路由，这些明细路由的AS_PATH类型都是AS_SEQ 类型：</p>
<p><img src="/2020/10/11/14-BGP/1606810685377-3bd43c21-8322-4452-91ed-0cdcd2d46d77.png" alt="img"></p>
<p><strong>修改AS_Path</strong></p>
<p><img src="/2020/10/11/14-BGP/1606812352537-db9c189d-a051-4aa3-a7f5-e08931e71ff9.png" alt="img"></p>
<p>R1和R3、R2和R3之间都是EBGP邻居，R1和R2上均宣告一条1.1.1.0/24的BGP路由，目前R3上的BGP表如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *    1.1.1.0/24       192.168.23.2             0             0 200 i</span><br><span class="line"> *&gt;                    192.168.13.1             0             0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到目前到1.1.1.0/24选择的是从R1到达，如何通过控制AS_PATH来影响选路呢？可以在R1上做策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set as-path prepend 6666</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 192.168.13.3 route-map 1 out</span><br></pre></td></tr></table></figure>

<p>这样配置后，R3上从R2学到的关于1.1.1.0的路由中的AS_PATH就由‘100  i’变成了‘100  6666  i’，当然这种操作在现网中还是不建议，因为6666这个AS并不存在，虽然加长了AS_PATH但带入了一个根本不存在的AS，所以可以用‘et as-path prepend 100 100 100’这种重复本AS的方式加长来实现目的同时避免不必要的麻烦。当然也可以在R3上对R1使用route-map：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"> R3：</span><br><span class="line"> ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set as-path prepend 6666</span><br><span class="line"> router bgp 300</span><br><span class="line"> neighbor 192.168.13.1 route-map 1 in</span><br></pre></td></tr></table></figure>

<p>做完配置后，R3上从R1学到的关于1.1.1.0的路由的AS_Path就会变成‘6666  100  i’，这是因为R3收到1.1.1.0的时候，AS_Path已经是‘100  i’了，而新加入的AS号只能在左边插入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   1.1.1.0/24       192.168.23.2             0             0 200 i</span><br><span class="line"> *                     192.168.13.1             0             0 6666 100 i</span><br></pre></td></tr></table></figure>

<p>使用策略修改AS_Path只能在BGP路由器上对其eBGP邻居执行，是因为AS_Path只有在AS边界才会发生改变，因此如果<strong>对iBGP邻居做AS_Path的策略修改是无效的</strong>。</p>
<h2 id="Next-hop"><a href="#Next-hop" class="headerlink" title="Next-hop"></a>Next-hop</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>Next-hop是公认必遵属性，描述了到目的地的下一跳路由器。</p>
<h3 id="传递规则"><a href="#传递规则" class="headerlink" title="传递规则"></a>传递规则</h3><h4 id="路由传递自eBGP邻居"><a href="#路由传递自eBGP邻居" class="headerlink" title="路由传递自eBGP邻居"></a>路由传递自eBGP邻居</h4><p>如果BGP 路由传递自EBGP peer，那么这条BGP路由的NH就是通告者的接口IP，EBGP邻居一般使用对方的直连接口IP互指neighbor，但如果是采用Loopback接口建立的EBGP邻居，则NH就是EBGP邻居的更新源地址（一般情况下EBGP邻居不适用Loopback接口建立邻居）。</p>
<p><img src="/2020/10/11/14-BGP/1606903026168-5a263917-63c4-4f93-9a70-b88da2131ca7.jpeg" alt="img"></p>
<p>比如上面拓扑中的R1和R2为EBGP邻居，R1上宣告了一条1.1.1.0/24的BGP路由，该路由通过update报文传递给R2，由于R1和R2建立邻居使用的是直连接口，该直连接口的IP地址为10.1.12.1，所以在R2的BGP表中，该路由的下一跳为10.1.12.1，也就是说要去往1.1.1.0/24的数据，发送给10.1.12.1，也就是发给R1就行了，看到这，是不是感觉BG在nexthop方面很像之前的RIP呢？这是因为两者都是距离矢量路由协议，都是基于传闻传递的路由，而不是状态链路路由协议，所以不知道整体拓扑的连接情况，所以红茶三杯在讲BGP的时候曾经说过，BGP其实很像RIP协议，只不过多了很多的特性和属性，这个说法一个原厂大佬朋友也很赞同。</p>
<p><img src="/2020/10/11/14-BGP/1606903296486-57eafd1c-16cb-4d5d-abc7-ec64c03efca3.jpeg" alt="img"></p>
<h4 id="路由传递自iBGP邻居"><a href="#路由传递自iBGP邻居" class="headerlink" title="路由传递自iBGP邻居"></a>路由传递自iBGP邻居</h4><p><strong>同AS的路由器引入了某路由</strong></p>
<p><img src="/2020/10/11/14-BGP/1606988007404-a4dc754d-6e18-443c-be04-d96375bfb902.jpeg" alt="img"></p>
<p>R1、R2、R3都在AS 123内，R1\R2，R2\R3之间为iBGP邻居都用直连接口建立，R1\R2之间网段为192.168.12.0/24，R2\R3之间网段为192.168.23.0/24，R1上宣告了一条1.1.1.1/32的BGP路由，并将其宣告给了iBGP邻居R2，如果这时不做额外的配置，那么由于水平分割原则（从一个iBGP邻居处收到的路由条目不会再传递给另一个iBGP邻居），那么R2不会将1.1.1.1/32这条路有宣告给R3，如果此时在R2上配置了路由反射器，打破了水平分割原则，所以R3能收到这条路由，在R3上这条路有的Next Hop依旧为R1的更新源地址，也就是R1和R2建立邻居的地址，192.168.12.1：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.1/32       192.168.12.1             0    100      0 i</span><br></pre></td></tr></table></figure>

<p><strong>路由传递自iBGP邻居，描述的是AS外的目的地</strong></p>
<p>从外部AS传递进来的路由，Next Hop为通告该路由的eBGP 邻居，且整个Next Hop会随着路由在AS内部传递而不发生改变，除非做了策略，否则始终指向的是下一个AS（通告该路由的eBGP 论据接口IP）。下面来看个例子：</p>
<p><img src="/2020/10/11/14-BGP/1606989582716-20f2c0f8-3a48-435d-91f4-e7dad91046a5.jpeg" alt="img"></p>
<p>R1\R2为eBGP邻居，R2\R2为iBGP邻居，在R1上宣告一个1.1.1.0/24的路由，该路由宣告给R2，再由R2宣告给R3，来看这条路由在R3上的Next Hop：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到，R3上关于该路由的Next Hop和在R2上一致，始终是R2建立eBGP邻居的那个IP：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor 10.1.12.1 remote-as 100</span><br></pre></td></tr></table></figure>

<p><strong>路由传递自iBGP邻居，并由AS内BGP路由引入</strong></p>
<ul>
<li><p>如果是通过aggregate-address命令被注入的，那么Next Hop等于执行汇总的路由器的更新源地址；</p>
</li>
<li><p>如果是通过network或重发布注入的，那么在注入前，该前缀的IGP下一跳将成为BGP的Next Hop；</p>
</li>
<li><p>如果本地的BGP宣告者成为了下一跳地址，那么在本地BGP RIB中的下一跳字段就是0.0.0.0；</p>
</li>
</ul>
<h3 id="Next-hop-self命令"><a href="#Next-hop-self命令" class="headerlink" title="Next-hop-self命令"></a>Next-hop-self命令</h3><p>由于next hop在传递给EBGP邻居时会改变，而传递给iBGP邻居时不会改变所以在建立iBGP邻居时，这样导致法网iBGP邻居的路由下一跳不可达从而不会加入路由表，此时可以用‘neighbor 1.1.1.1 next-hop-self’命令将传递给iBGP邻居路由的下一跳设置为自己，使得BGP路由的下一跳可达，具体用法及实验参照邻居建立中iBGP邻居部分。</p>
<h2 id="Local-Preference"><a href="#Local-Preference" class="headerlink" title="Local-Preference"></a>Local-Preference</h2><h3 id="基本概念-4"><a href="#基本概念-4" class="headerlink" title="基本概念"></a>基本概念</h3><p>Local-Preference是公认自决属性，默认值为100，只用于iBGP邻居之间，决定离开AS的最优路径，一般用于控制本AS的出口设备。</p>
<ul>
<li>Local-Preference就是本地优先级，当一个AS收到一个去往同意目的地的，但经过两个AS的路由，在其他BGP路由属性完全一致的情况下，根据两条路由的local-preference决定，值越大越优，比如下图中的路由器D，从C和E两个路由器都收到了去往172.20.0.0的路由，但E发过来的路由属性中Local-Preference值大于C发过来的路由属性，所以去往E的路由更优：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607149141276-33b3db5c-2872-426d-93d9-68314eaef8ad.jpeg" alt="img"></p>
<ul>
<li><p>Local-Preference只能在AS内部的iBGP邻居之间传递，而不会传递给其他eBGP邻居，Local-Preference除非做了策略，否侧在AS内的iBGP邻居之间传递时不会丢失，如果eBGP邻居之间收到的路由的路径属性中携带了Local-Preference的话，会触发notification报文造成BGP会话中断，但可以在AS边界路由器上使用IN方向策略；</p>
</li>
<li><p>Local-Preference在向eBGP邻居发送路由更新时，不能携带LP属性，对方收到该eBGP路由的LP值为空，也就是说路径属性中根本没有LP这个字段，但它会在本地为这条路由赋一个默认值，也就是100，然后再传递给自己的iBGP邻居；</p>
</li>
<li><p>本地network命令及重发布命令发布的路由，LP值默认为100，并能在AS内向其他iBGP邻居传输，传输过程中除非部署了策略，否则LP值不会发生变化；</p>
</li>
<li><p>修改默认LP值的命令为：bgp default local-preference  XXX。</p>
</li>
</ul>
<h3 id="实验及抓包"><a href="#实验及抓包" class="headerlink" title="实验及抓包"></a>实验及抓包</h3><h4 id="基础实验"><a href="#基础实验" class="headerlink" title="基础实验"></a>基础实验</h4><p><img src="/2020/10/11/14-BGP/1607148741237-dcc8acdd-c13d-431e-aa78-398444e1ac91.jpeg" alt="img"></p>
<p>R1发送给R2的update抓包中可以看到，eBGP邻居之间的路由属性中没有Local-Preference属性：</p>
<p><img src="/2020/10/11/14-BGP/1607148820773-a562ce75-c05a-4bce-938e-bfe7e024c66e.jpeg" alt="img"></p>
<p>R2发送给iBGP邻居R3的update报文抓包中可以看到，iBGP邻居之间的路由属性中有Local-Preference属性，这里没有用策略修改，所以默认值是100：</p>
<p><img src="/2020/10/11/14-BGP/1607149038111-368b4537-ff1d-43c9-a1dd-1f72316b54ed.jpeg" alt="img"></p>
<h4 id="单独修改LP"><a href="#单独修改LP" class="headerlink" title="单独修改LP"></a>单独修改LP</h4><p><img src="/2020/10/11/14-BGP/1607153818205-254dbe49-34ed-44ce-a3c9-7b4caf32f553.jpeg" alt="img"></p>
<p>拓扑和上一个实验相同，区别在于R1上除了宣告1.1.1.0/24以外，也宣告了111.111.111.0/24，在R3上的BGP表中如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br><span class="line"> * i  111.111.111.0/24 10.1.12.1                0    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>从上面的BGP表中可以看到，默认情况下，两条路由在R3上的Local-Preference都是100，现在我们在R2上对111.111.111.0/24的路由做策略，让这条路由的LP变为200：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line">ip prefix-list 1 seq 5 permit 111.111.111.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.23.3 route-map LP out</span><br></pre></td></tr></table></figure>

<p>R3上的BGP表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config)#do show ip bgp</span><br><span class="line">BGP table version is 1, local router ID is 33.33.33.33</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  1.1.1.0/24       10.1.12.1                0    100      0 100 i</span><br><span class="line"> * i  111.111.111.0/24 10.1.12.1                0    200      0 100 i</span><br></pre></td></tr></table></figure>

<h2 id="MED"><a href="#MED" class="headerlink" title="MED"></a>MED</h2><h3 id="基本概念-5"><a href="#基本概念-5" class="headerlink" title="基本概念"></a>基本概念</h3><p>MED是可选非传递属性，当其他属性相同时，MED值越小越优，用于AS之间影响路由，一般用于控制进入本AS的入口设备，思科设备默认MED=0，默认情况下只比较来自同一邻居AS的BGP路由的MED值，如果同一个目的地的两条路由来自不同的AS则不进行MED值的比较。下图中路由器A从路由器B和C上都收到了172.20.0.0这条路由，B和C在同一AS所以比较MED值，由于B这条路由的<strong>MED值更小所以更优</strong>，故A会选择路由器B的路由：</p>
<p><img src="/2020/10/11/14-BGP/1607152363500-f40cd17c-bc9e-4210-845b-8dfba9804f43.jpeg" alt="img"></p>
<h3 id="设置方法"><a href="#设置方法" class="headerlink" title="设置方法"></a>设置方法</h3><ul>
<li><p>将IGP路由引入BGP时关联Route-map进行设置；</p>
</li>
<li><p>对BGP 邻居使用IN\OUT方向的Route-map进行设置；</p>
</li>
<li><p>非Route-map方式：</p>
</li>
</ul>
<ol>
<li>使用network或redistribute方式将IGP路由引入BGP时，MED将继承IGP路由的Metric（直连路由及静态路由的Metric为0）；</li>
<li>使用aggregate-address方式引入路由则MED为空；</li>
</ol>
<h3 id="MED传递"><a href="#MED传递" class="headerlink" title="MED传递"></a>MED传递</h3><p>当BGP路由通告给eBGP邻居时：</p>
<ul>
<li>如果该BGP路由是本地始发的，也就是在本路由器上通过network或redistribute引入的，则发送给eBGP邻居时携带MED值；</li>
<li>如果该BGP路由是从其他BGP邻居雪莱的，则将该路由通告给eBGP邻居时不携带MED（路由属性中没有MED部分），换句话说，就是MED不会被传出本AS；</li>
</ul>
<p>当BGP路由通告给iBGP邻居时，一定会携带MED值，如果接收或产生的路由的MED为空，那么在向iBGP邻居通告时，将MED设置为0。</p>
<p><strong>总的来说就是MED在iBGP邻居之间传递没有问题，不会丢失，但在eBGP邻居之间传递要看路由是否起源于自己，起源于自己就带MED，不起源于自己就不带MED。</strong></p>
<h3 id="MED继承"><a href="#MED继承" class="headerlink" title="MED继承"></a>MED继承</h3><ul>
<li><p>network本地从IGP路由协议学到的路由进BGP，MED值继承IGP协议中的metric；</p>
</li>
<li><p>network本地直连接口的网段进BGP，MED值为0；network本地静态路由进BGP，MED值为0；</p>
</li>
<li><p>redistribute本地从IGP路由协议学到的路由进BGP，MED值继承IGP协议中的me</p>
</li>
<li><p>redistribute本地直连接口网段进BGP，MED值为0；redistribute本地静态路由进BGP，MED值为0。</p>
</li>
</ul>
<h3 id="其他配置命令"><a href="#其他配置命令" class="headerlink" title="其他配置命令"></a>其他配置命令</h3><p><strong>bgp always-compare-med</strong></p>
<p>默认情况下，只有来自相同AS的外部路由才比较MED值，但如果配置了这条命令，即使是来自不同AS的路由，也会比较MED。如果配置了该命令，那么建议在整个AS中都这么配置，以避免路由选择环路。</p>
<p><strong>bgp bestpath med missing-as-worst</strong></p>
<p>如果某路由MED属性丢失，一般的做法是给MED默认设置为0，但如果配置了这条命令，再收到没有MED值的路由，会将该路由的MED值设置为最大，也就是4294967295。</p>
<p><strong>set metric-type internal</strong></p>
<p>用在route-map中，当用route-map匹配某些条目且使用了该set命令后，比如在out方向上向邻居应用了带set metric-type internal的route-map命令以后，被匹配的这些路由条目更新给邻居后，BGP的MED属性会继承这些路由在本地IGP的metric值。</p>
<p><strong>bgp bestpath med confed</strong></p>
<p>配置这条命令后，在选路时，路由器只比较具有带有AS_CONFED_SEQ属性的条目，此命令用于联邦路由器，同时weight及LP属性比MED具有更高的优先级。</p>
<p><strong>bgp deterministic-med</strong></p>
<p>用于确保来自相同的AS的不同对等体通告的路由<strong>先</strong>进行MED比较。</p>
<p>此命令和bgp always-compare-med的关系如下：</p>
<p><img src="/2020/10/11/14-BGP/1607325749976-bb8b43cd-6938-4c68-8979-b77ea1e6cc4f.png" alt="img"></p>
<ul>
<li><p>如果两条命令都关闭：则按缺省的从上往下的顺序进行比较 ，则 1、2 先比较，2 优选（因为 2 具有更小的 RID）； 然 后 2 与 3 比较，2 为 external，所以 2 优选。</p>
</li>
<li><p>如果打开bgp always-compare-med：则 1、2 先比较，1 优选（因为 1 具有更小的 MED） ；由于 1、3 在一个相同的 AS 中，所以再次比MED，选 3。</p>
</li>
<li><p>如果打开deterministic-med，路由前缀的信息按AS重新分组：</p>
</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607326342712-e22a5f44-5d91-4f47-9ed8-ef6cf3f94c48.png" alt="img"></p>
<ul>
<li>如果都打开，则2、3 同 AS 内先比较，2 的 MED 小所以优选；2 与 1 再比较，由于开了 always-compare-med 所以比 MED，2 的 MED 小，所以 2 为最佳路径.</li>
</ul>
<p><strong>Default-metric X</strong></p>
<p>修改MED值的缺省值，但此命令对直连路由不生效，直连路由的MED仍为0</p>
<h2 id="COMMUNITY"><a href="#COMMUNITY" class="headerlink" title="COMMUNITY"></a>COMMUNITY</h2><h3 id="基本概念-6"><a href="#基本概念-6" class="headerlink" title="基本概念"></a>基本概念</h3><p>community属性为可选传递。</p>
<p>community属性是一组4个8位组的数值，RFC1997规定前2B表示AS号，后2B表示基于管理项目设置的标识符，格式为AA:NN，32位的BGP community被分成了两部分，前16位一般用来标识使用该community的AS号，后16位一般用来标识作用。而CISCO默认显示格式为NN:AA，可使用全局配置命令，ip bgp-community new-format将思科默认格式改为RFC格式。</p>
<p>例如将AS12的某条路由的community值改为10000，RFC采用十六进制表示community属性，而CISCO采用十进制。RFC格式为12：10000，十六进制为0X000C2710，再转换为十进制796432：</p>
<p><img src="/2020/10/11/14-BGP/1607411667258-8766defd-a867-4338-b5b1-ed02012bb9f5.png" alt="img"></p>
<p>用于简化路由策略的执行，可以将某些路由分配一个特定的community属性，之后可基于community值而不是每条路由进行BGP属性的设置了。community属性对邻居起作用。具体如何执行呢？让我们用一个北美ISP举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - Prepending</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">65001:0   - prepend once  to all peers</span><br><span class="line">65001:XXX - prepend once  at peerings to AS XXX</span><br><span class="line">65002:0   - prepend twice to all peers</span><br><span class="line">65002:XXX - prepend twice at peerings to AS XXX</span><br><span class="line">65003:0   - prepend 3x to all peers</span><br><span class="line">65003:XXX - prepend 3x    at peerings to AS XXX</span><br><span class="line">65004:0   - prepend 4x to all peers</span><br><span class="line">65004:XXX - prepend 4x    at peerings to AS XXX</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - Regional</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">Will only work for regional peers</span><br><span class="line">64980:0   - announce to customers but not to EU peers</span><br><span class="line">64981:0   - prepend once  to all EU peers</span><br><span class="line">64982:0   - prepend twice to all EU peers</span><br><span class="line">64983:0   - prepend 3x    to all EU peers</span><br><span class="line">64984:0   - prepend 4x    to all EU peers</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">customer traffic engineering communities - LocalPref</span><br><span class="line">--------------------------------------------------------</span><br><span class="line">3356:70   - set local preference to 70</span><br><span class="line">3356:80   - set local preference to 80</span><br><span class="line">3356:90   - set local preference to 90</span><br></pre></td></tr></table></figure>

<p>上边是一个过去的北美ISP的配置，用来说明如何使用community属性来简化配置。如果该ISP将一条前缀打上3356：90的标签，那么这条前缀的local preference将被设定为90，如果将路由打上标签64983：0，则该路由在发送到欧洲的邻居对等体之前将复制自身AS三次。这么做就不用每次对一条路由做策略时都需要配置相同的route-map了，只需要将路由前缀打上相应的TAG划分到相应的community中就能实现相应的路由操作。</p>
<p>community属性是可选传递，在设置后，同时需要向邻居发送（SEND），邻居才能真正收到这个community，而且要每个邻居设置一次，举例看一下：</p>
<p><img src="/2020/10/11/14-BGP/1608088856876-8908d4b4-40fa-4c24-929b-b9941e16dfbb.jpeg" alt="img"></p>
<p>如果R1上针对11.11.11.0/24设置了community，那么必须在R1上配置‘neighbor 10.1.12.2 send-community’那么R2才能收到这个community，但如果R2上不对R3配置send-community，这个community R3是不知道的，必须在R2上对R3设置‘send-community’R3才能收到这个community。配置send-community是思科和华为的做法，juniper默认不用配置就能传递community。</p>
<p>除了上面这个community，还有一个扩展community（extended community），具体在MPLS VPN部分会具体写这个，不要混淆两者。</p>
<h3 id="基本概念实验"><a href="#基本概念实验" class="headerlink" title="基本概念实验"></a>基本概念实验</h3><p><img src="/2020/10/11/14-BGP/1607413844338-02a82838-759c-4271-97d2-8c39c53a5a3b.png" alt="img"></p>
<p>左边的customer路由器连接到ISP1上，位于北美的ISP1又分别连接了ISP2和ISP3，假设ISP2是位于欧洲的服务器，当ISP1发送路由更新到位于欧洲的ISP2上之前，需要先将本地的AS号复制四次，这里用community进行配置，将这些发送给欧洲的路由前缀的community值设置为64984：0。</p>
<h4 id="基本配置-2"><a href="#基本配置-2" class="headerlink" title="基本配置"></a>基本配置</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer#show running-config | section bgp</span><br><span class="line">router bgp 10</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 10.10.10.10 mask 255.255.255.255</span><br><span class="line"> neighbor 192.168.10.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP1#show running-config | section bgp</span><br><span class="line">router bgp 1</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.10.10 remote-as 10</span><br><span class="line"> neighbor 192.168.12.2 remote-as 2</span><br><span class="line"> neighbor 192.168.13.3 remote-as 3</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP2#show running-config | section bgp</span><br><span class="line">router bgp 2</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.12.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP3#show running-config | section bgp</span><br><span class="line">router bgp 3</span><br><span class="line"> no synchronization</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 192.168.13.1 remote-as 1</span><br><span class="line"> no auto-summary</span><br></pre></td></tr></table></figure>

<p>此时ISP1已经从Customer路由器上学到了路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 1.1.1.1</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   10.10.10.10/32   192.168.10.10            0             0 10 i</span><br></pre></td></tr></table></figure>

<h4 id="配置customer"><a href="#配置customer" class="headerlink" title="配置customer"></a>配置customer</h4><p>首先使用前缀列表抓取10.10.10.10/32这条需要进行配置的路由，假设这条前缀要发送给位于欧洲的ISP2，在customer上赋予community值方便在ISP1上进行操作：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#ip prefix-list LOOPBACK permit 10.10.10.10/32</span><br></pre></td></tr></table></figure>

<p>接下来用route-map来设置BGP的community，所有符合前缀列表的路由将被赋予community值，也就是64984：0，因为发送给欧洲的路由前缀的community值设置为64984：0。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#route-map SET_COMMUNITY permit 10</span><br><span class="line">Customer(config-route-map)#match ip address prefix-list LOOPBACK</span><br><span class="line">Customer(config-route-map)#set community 64984:0</span><br><span class="line">Customer(config-route-map)#exit</span><br><span class="line">Customer(config)#route-map SET_COMMUNITY permit 20</span><br></pre></td></tr></table></figure>

<p>现在来对ISP1使用这条route-map，赋予发往ISP1的路由community值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Customer(config)#router bgp 10</span><br><span class="line">Customer(config-router)#neighbor 192.168.10.1 route-map SET_COMMUNITY out</span><br><span class="line">Customer(config-router)#neighbor 192.168.10.1 send-community</span><br></pre></td></tr></table></figure>

<p>对ISP1配置了send-community是因为community为可选传递属性，路由器不会自动发送community到邻居。</p>
<h4 id="配置ISP1"><a href="#配置ISP1" class="headerlink" title="配置ISP1"></a>配置ISP1</h4><p>接下来在ISP1上用配置community：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#ip community-list 1 permit 64984:0</span><br></pre></td></tr></table></figure>

<p>首先配置community列表，该列表和access-list以及prefix-list很像，但只用于BGP的community上，这个community-list 匹配的是由customer发过来的community值为64984:0的路由前缀，其实也就是抓取的10.10.10.10/32这条路由。接下来用route-map设置将这条路由的AS号复制四次：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#route-map PREPEND_EU permit 10     </span><br><span class="line">ISP1(config-route-map)#match community 1</span><br><span class="line">ISP1(config-route-map)#set as prepend 1 1 1 1                 </span><br><span class="line">ISP1(config-route-map)#exit</span><br><span class="line">ISP1(config)#route-map PREPEND_EU permit 20</span><br></pre></td></tr></table></figure>

<p>接下来将这条route-map应用到邻居ISP2的出方向上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1(config)#router bgp 1 </span><br><span class="line">ISP1(config-router)#neighbor 192.168.12.2 route-map PREPEND_EU out</span><br></pre></td></tr></table></figure>

<h4 id="验证配置"><a href="#验证配置" class="headerlink" title="验证配置"></a>验证配置</h4><p>在customer上软刷新BGP后在ISP1上可以看到它已经收到了BGP 的community值，最后一行的‘Community: 4258791424’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1#show ip bgp 10.10.10.10</span><br><span class="line">BGP routing table entry for 10.10.10.10/32, version 6</span><br><span class="line">Paths: (1 available, best #1, table Default-IP-Routing-Table)</span><br><span class="line">  Advertised to update-groups:</span><br><span class="line">        1    2</span><br><span class="line">  10</span><br><span class="line">    192.168.10.10 from 192.168.10.10 (10.10.10.10)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, external, best</span><br><span class="line">      Community: 4258791424</span><br></pre></td></tr></table></figure>

<p>可以看到ISP1确实收到了community但并没有按照AA:NN的格式显示，是因为思科默认使用自己的格式显示，而不是使用RFC格式，在ISP1上配置‘<strong>ip bgp community new-format</strong>’后会恢复成RFC格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP1#show ip bgp 10.10.10.10</span><br><span class="line">BGP routing table entry for 10.10.10.10/32, version 6</span><br><span class="line">Paths: (1 available, best #1, table Default-IP-Routing-Table)</span><br><span class="line">  Advertised to update-groups:</span><br><span class="line">        1    2</span><br><span class="line">  10</span><br><span class="line">    192.168.10.10 from 192.168.10.10 (10.10.10.10)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, external, best</span><br><span class="line">      Community: 64984:0</span><br></pre></td></tr></table></figure>

<p>再来看ISP2上该配置是否生效了，对比ISP3上的这条路由发现配置生效了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ISP2#show ip bgp</span><br><span class="line">BGP table version is 12, local router ID is 192.168.12.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line"></span><br><span class="line">   Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; 10.10.10.10/32   192.168.12.1                           0 1 1 1 1 1 10 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ISP3#show ip bgp</span><br><span class="line">BGP table version is 12, local router ID is 192.168.13.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line"></span><br><span class="line">   Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line">*&gt; 10.10.10.10/32   192.168.13.1                           0 1 10 i</span><br></pre></td></tr></table></figure>

<p>如果以后Customer要发送其他路由到位于Europe的ISP2路由器，那么只需要在Customer上将之前配置的抓取路由的前缀列表进行适当更改，匹配上那条新路由即可。</p>
<h3 id="常见命令"><a href="#常见命令" class="headerlink" title="常见命令"></a>常见命令</h3><h4 id="No-advertise"><a href="#No-advertise" class="headerlink" title="No-advertise"></a>No-advertise</h4><p>当为一条前缀配置了no-advertise命令时，收到这条前缀的BGP路由器，R2，会将这条前缀存储在自己的BGP表中，而不会向其他邻居宣告这条路由。用下图中的拓扑举个例子，如果在R1上配置了no-advertise这条community的命令，则R1传给R2的路由，R2不会再发给任何BGP对等体邻居。</p>
<p><img src="/2020/10/11/14-BGP/1607503143643-50577307-155f-4823-80c0-b96799b932cb.jpeg" alt="img"></p>
<h4 id="No-export"><a href="#No-export" class="headerlink" title="No-export"></a>No-export</h4><p><img src="/2020/10/11/14-BGP/1607754498509-3367b21f-897b-4f77-a1a6-4280e96f79d6.jpeg" alt="img"></p>
<p>当为一条前缀配置了no-export命令时，收到这条前缀的BGP路由器R2只会将这条路由宣告给iBGP邻居而不会宣告给任何eBGP邻居（会传递给联邦eBGP邻居）。用上图中的拓扑举个例子，如果在R1上配置了no-export这条community的命令，则R1传给R2的路由，R2只会传递给在AS 2345内部的路由器，也就是只传给R3\R4\R5，但不会传递给eBGP邻居R6。</p>
<h4 id="Local-as"><a href="#Local-as" class="headerlink" title="Local-as"></a>Local-as</h4><p><img src="/2020/10/11/14-BGP/1607757025165-fa185539-f6de-44de-a524-5c338937b283.jpeg" alt="img"></p>
<p>local-as和之前的no export有些类似，区别在于当为一条前缀配置了local-as命令时，如果定义了联邦，只会在联邦AS内部传递不会传递给联邦eBGP邻居。用上图中的拓扑举个例子，如果在R1上配置了local-as这条community的命令，则R1传给R2的路由，R2只会传递给联邦iBGP邻居R3，但不会传递给联邦eBGP邻居R4。</p>
<h3 id="为路由分配community"><a href="#为路由分配community" class="headerlink" title="为路由分配community"></a>为路由分配community</h3><p><img src="/2020/10/11/14-BGP/1607761644664-5889c622-4e78-4f6b-8d12-8be44c16f269.jpeg" alt="img"></p>
<p>在R1上为路由11.11.11.0/24分配community 100：11，并且传递给R2，那么R1上配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24              #抓取需要分配community的前缀</span><br><span class="line">!</span><br><span class="line">route-map COMMUNITY permit 10                            #用route-map为抓取的前缀分配community值</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">route-map COMMUNITY permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community                       #默认情况下不发送community值给邻居，配置命令后会发送</span><br><span class="line"> neighbor 10.1.12.2 route-map COMMUNITY out              #对邻居的out方向使用route-map</span><br></pre></td></tr></table></figure>

<p>一条前缀路由可携带多个community形成一个列表，如果要针对特定路由在原有的community基础之上再增加一个community，则在route-map中set community时，增加additive关键字即可，比如R1在上面配置的基础上加上如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map COMMUNITY permit 10</span><br><span class="line">set community 100:12 additive</span><br></pre></td></tr></table></figure>

<p>最后route-map的结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-route-map)#do show run | s route-map</span><br><span class="line"> neighbor 10.1.12.2 route-map COMMUNITY out</span><br><span class="line">route-map COMMUNITY permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11 100:12 additive</span><br><span class="line">route-map COMMUNITY permit 20</span><br></pre></td></tr></table></figure>

<h3 id="community-list"><a href="#community-list" class="headerlink" title="community-list"></a>community-list</h3><h4 id="基本概念-7"><a href="#基本概念-7" class="headerlink" title="基本概念"></a>基本概念</h4><p>ip community-list和ACL类似，ACL用来抓取前缀，ip community-list用来抓取community的值，和ACL类似，community-list也有标准和扩展之分，1-99为标准，100-199为扩展，标准ip community-list 后面只能跟XX:NN的格式，而扩展的community-list可以使用正则表达式匹配路由，下面扩展community-list后面的regexp是正则表达式的意思，在笔记的其他章节会涉及到：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p extcommunity-list standard list-name &#123; deny | permit &#125; generic &#123; transitive | nontransitive &#125; aa4 : nn</span><br><span class="line"></span><br><span class="line">no ip extcommunity-list standard generic &#123; transitive | nontransitive &#125; list-name</span><br><span class="line"></span><br><span class="line">ip extcommunity-list expanded list-name &#123; deny | permit &#125; generic &#123; transitive | nontransitive &#125; regexp</span><br><span class="line"></span><br><span class="line">no ip extcommunity-list expanded generic &#123; transitive | nontransitive &#125; list-name</span><br></pre></td></tr></table></figure>

<p>当使用扩展community-list且后面接了正则表达式的情况下，设备是否配置了ip bgp-community new-format会影响community-list匹配的结果。</p>
<h4 id="删除特定值"><a href="#删除特定值" class="headerlink" title="删除特定值"></a>删除特定值</h4><p>前面说过，一条路由允许携带多个community值，构成一个community列表，那么如果不是要删除全部的community值，而是想删除1个或几个community值，例如一个带有12：11、12：1111以及no-export的community列表，要删除其中的no-export的话：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 1 permit no-export              #匹配要删除其中的no-export的community值</span><br><span class="line">route-map test permit 10</span><br><span class="line"> set comm-list 1 delete                           #用这条命令删除</span><br></pre></td></tr></table></figure>



<p>如果要删除多个但不是所有community值的话，则可在一个community-list中写多条：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 1 permit no-export</span><br><span class="line">ip community-list 1 permit 12:1111</span><br></pre></td></tr></table></figure>

<p>然后在用set comm-list 1 delete去删除，这里必须注意community-list必须写多行，如果在一行里写多个community，比如ip community-list 1 permit no-export  12:1111则不生效，删除不了这两个值。</p>
<h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p><img src="/2020/10/11/14-BGP/1608087693890-ce7fc733-63b1-4c34-87c9-b705c3de78c9.jpeg" alt="img"></p>
<p>在上面实验的基础上，R1传递给R2的11.11.11.0/24的路由，携带了community值，100：11，这个值可以在R2上用ip community-list进行匹配，从而可以进一步在route-map中使用这个community-list去设置策略。我们先在R2上用community-list去匹配100：11，通知添加一个no-export的community到该路由。</p>
<p>R2的配置如下：</p>
<p><img src="/2020/10/11/14-BGP/1608090080532-26c63b47-ebe1-4bf2-96cb-f8f34da2db2b.jpeg" alt="img"></p>
<p>R3上关于11.11.11.0这条路由：</p>
<p><img src="/2020/10/11/14-BGP/1608091005056-0b2ca818-77cd-471f-88cb-e8789aa70bff.jpeg" alt="img"></p>
<h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>在上面例子的基础上，11.11.11.0/24路由前缀所携带的community属性为‘100：11 no-export’，看以下的community-list是否能匹配到这条路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11</span><br><span class="line"></span><br><span class="line">#匹配，这种写法将匹配community中包含100：11的路由</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11 no-advertise</span><br><span class="line"></span><br><span class="line">#不匹配，这种写法要求community中同时包含100：11及no-advertise才匹配成立，换句话说，100：11和no-advertise是与的关系</span><br></pre></td></tr></table></figure>



<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit 100:11</span><br><span class="line">ip community-list 11 permit no-export(no-advertise)</span><br><span class="line"></span><br><span class="line">#匹配，这种写法将只要community中包含100：11或no-export(no-advertise)就行，换句话说，100：1和no-export(no-advertise)是或的关系，只要满足一个就匹配</span><br></pre></td></tr></table></figure>

<h4 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h4><p><img src="/2020/10/11/14-BGP/1608094871413-6517807d-2f79-4410-b6d3-12f4b0949169.jpeg" alt="img"></p>
<p>在上面实验的基础上，12.12.12.0/24也携带了no-export的community值:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map NO-EXPORT permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set community no-export</span><br><span class="line">!</span><br><span class="line">route-map NO-EXPORT permit 20</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community</span><br><span class="line"> neighbor 10.1.12.2 route-map NO-EXPORT out</span><br></pre></td></tr></table></figure>

<p>如果我们只希望匹配community值为no-export的路由，该如何呢？如果是直接匹配no-export的话，不仅会匹配到12.12.12.0/24，也会匹配到community值为100：11 no-export的11.11.11.0/24这条路由，这里要用到exact-match的关键字了，在R3上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list 11 permit no-export</span><br><span class="line">route-map test permit 10</span><br><span class="line">  match community 11 exact-match                #也就是严格匹配no-export的community</span><br></pre></td></tr></table></figure>

<p>如果不加exact-match关键字，则该community-list将匹配11及12的路由，加了以后，则只匹配community为no-export的路由，不能多也不能少。</p>
<h4 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h4><p><img src="/2020/10/11/14-BGP/1608098576710-41d92014-e30c-4ee6-8571-4ed4b75f7028.jpeg" alt="img"></p>
<p>R2收到R1传过来的两条路由，分别携带的community属性如上，这里我们只想删除11.11.11.0/24所携带的no-export属性，这里有两种办法。</p>
<p>*<strong>方法一：*</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip community-list 11 permit 100:11 no-export            </span><br><span class="line">ip community-list standard del permit no-export         </span><br><span class="line">route-map test permit 10                               </span><br><span class="line">  match community 11                                   </span><br><span class="line">  set comm-list del delete                               </span><br><span class="line">route-map test permit 20</span><br><span class="line"></span><br><span class="line">router bgp 200</span><br><span class="line">  neighbor 10.1.12.1 remote-as 100</span><br><span class="line">  neighbor 10.1.12.1 route-map test in              </span><br></pre></td></tr></table></figure>

<ul>
<li><p>ip community-list 11 permit 100:11 no-export，这条名称为11的标准community-list用来匹配community值为100:11 no-export的对象，在这也就是抓取11.11.11.0/24这条路由；</p>
</li>
<li><p>ip community-list standard del permit no-export，这条名称为del的标准community-list用来匹配community值为no-export的对象；</p>
</li>
<li><p>match community 11，表示匹配名称为11的community-list，也就是11.11.11.0/24这条路由；</p>
</li>
<li><p>set comm-list del delete，表示将11.11.11.0/24这条路由中no-export的对象删除，之前这条路由的community有100:11和no-export两个，删除掉no-export后只剩下100:11了；</p>
</li>
<li><p>neighbor 10.1.12.1 route-map test in，在邻居10.1.12.1的in方向上使用route-map test；</p>
</li>
</ul>
<p>如果想把11.11.11.0/24路由的100：11以及no-export两个community值都删除，则修改del的这条community-list即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip community-list standard del permit no-export</span><br><span class="line">ip community-list standard del permit 100:11</span><br></pre></td></tr></table></figure>

<p><a href="https://community.cisco.com/t5/routing/how-to-strip-a-specific-community-list/td-p/3183348">*<strong>方法二：*</strong></a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 11.11.11.0/24                       #抓取要进行操作的前缀</span><br><span class="line">ip community-list expanded REMOVE_COMMUNITY permit no-export      #抓取要删除的community值</span><br><span class="line">!</span><br><span class="line">route-map MODIFY_COMMUNITY permit 10                              #对11.11.11.0/24这条前缀将no-export的community删除</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set comm-list REMOVE_COMMUNITY delete</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.12.1 remote-as 100</span><br><span class="line"> neighbor 10.1.12.1 route-map MODIFY_COMMUNITY in                 #对邻居10.1.12.1的in方向使用删除community的route-map</span><br></pre></td></tr></table></figure>

<h3 id="Atomic-Aggregate及aggregator"><a href="#Atomic-Aggregate及aggregator" class="headerlink" title="Atomic_Aggregate及aggregator"></a><a href="https://www.networkers-online.com/blog/2010/12/bgp-attributes-atomic-aggergate-atribute/">Atomic_Aggregate及aggregator</a></h3><p>Atomic_Aggregate是公认自决属性；Aggregator是可选传递属性。</p>
<p><img src="/2020/10/11/14-BGP/1608194376455-1a68636e-737c-4714-88cb-988f7d8fd52e.jpeg" alt="img"></p>
<p>R1和R2均发布了路由，R3上对这些明细路由进行了汇总，汇总成172.16.0.0/16，汇总路由被R3传递给了其他BGP邻居，然而这条汇总路由丢失了明细路由的所有属性，其中的AS_Path最关键，因为一旦丢失了明细路由的AS_Path属性，这条汇总路由就极有可能产生路由环路。因此有必要让R3警告下游的BGP邻居，告诉它们两点，其一，这是一条汇总路由，其二汇总路由发生的地方，也就是汇总路由的始发AS和始发路由器。</p>
<p>在R3上配置‘aggregate-address 172.16.0.0 255.255.0.0’或‘aggregate-address 172.16.0.0 255.255.0.0 summary-only’进行汇总时，R4上关于汇总路由如下：</p>
<p><img src="/2020/10/11/14-BGP/1608201218196-7b20dee0-1925-49f1-a440-618cb02dfcd4.jpeg" alt="img"></p>
<p>抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608274329140-2523f10e-f467-4955-aa59-dbf8afac060a.png" alt="img"></p>
<p>其中Aggregator是可选传递属性，用来标识路由是在AS300的路由器3.3.3.3上经过汇总的；Atomic_Aggregate是公认自决属性，由于配置路由汇总时没有带上AS_SET命令，所以AS_PATH中只有路由被汇总路由器的AS号300，有可能会将汇总路由传回明细路由的AS100或200从而产生环路，所以在汇总路由不携带明细路由的AS_PATH时，需要加上atomic_aggregate属性警告下游BGP peer，这是一条汇总路由，局和路径丢失了某些信息，可能不是去往目的地的最佳路径（The purpose of the attribute is to alert BGP speakers along the path that some information have been lost due to the route aggregation process and that the aggregate path might not be the best path to the destination.）</p>
<p>如果在R3上汇总命令中加上as-set关键字，则汇总路由就继承了明细路由的AS_Path属性，没有丢失AS_PATH信息，就不需要加上Atomic_Aggregate属性了，汇总时加上AS_SET的抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1608277413278-189c6204-da99-4ac9-beee-41139bbe5d39.png" alt="img"></p>
<p>R4上关于172.16.0.0的输出中也没有了Atomic_Aggregate，具体如下：</p>
<p><img src="/2020/10/11/14-BGP/1608277473593-a136e600-a514-4fca-ab60-a2b371bdc35e.png" alt="img"></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>Aggregate是可选传递属性，用来标识路由在哪个AS的哪个路由器上进行过汇总，只要是汇总路由就会携带Aggregate属性；Atomic_Aggregate是公认自决属性，用来提醒沿途路由器，聚合路由丢失了某些属性，可能不是最佳路径。在汇总时如果不使用AS_SET命令，则汇总路由不携带明细路由的AS_Path，这时候执行汇总的路由器会将用Atomic_Aggregate属性来提醒其他路由器。如果汇总时使用了AS_SET命令，则明细路由的AS会用AS_SET形式保存在汇总路由的AS_Path中，没有丢失属性，所以这时汇总路由不携带Atomic_Aggregate属性。</p>
<p>思科设备的对汇总路由的默认做法是，汇总路由默认不携带明细路由的所有AS_Path信息，如果汇总时没有使用AS_SET命令，则汇总路由必携带Atomic_Aggregate属性；而juniper的做法和思科完全相反，汇总路由默认会携带所有明细路由的AS_Path，这意味着用来提醒属性丢失的Atomic_Aggregate属性不是必须有的。</p>
<h3 id="ORIGINATOR-ID和CLUSTER-LIST"><a href="#ORIGINATOR-ID和CLUSTER-LIST" class="headerlink" title="ORIGINATOR_ID和CLUSTER_LIST"></a>ORIGINATOR_ID和CLUSTER_LIST</h3><h4 id="基本概念-8"><a href="#基本概念-8" class="headerlink" title="基本概念"></a>基本概念</h4><p>由于AS_Path属性在AS内部不会发生变化，仅当路由离开本AS时才会被更新，而路由反射器打破了水平分割原则，有可能使路由出现环路，所以AS内必须有相对应的防环机制，所以路由反射器使用两个新的属性进行防环，ORIGINATOR_ID和CLUSTER_LIST，二者为路由反射器使用的可选非传递属性，用来防止环路。</p>
<ul>
<li>ORIGINATOR_ID是一个路由反射器创建的32bit值，该数值是本地AS中路由发起方的iBGP Router ID，注意发起方未必是这条路由的引入者，如果发起方发现其RID在所接收到的路由的ORIGINATOR_ID中，那么就知道已经出现了路由环路，因此会忽略该路由。</li>
<li>CLUSTER_LIST是遗传路由传递所经过的路由反射簇（Cluster）的ID，AS内的每个路由反射簇都有一个32bit的簇ID，如果簇中包含了多个RR，则需手工为每个RR配置簇ID。当RR将来自客户的路由反射给非客户时，同时将其簇ID附加到CLUSTER_LIST中，如果CLUSTER_LIST为空则创建一个，如果反射路由器发现其本地簇ID出现在了其受到的CLUSTER_LIST中，那么就知道出现了环路，则忽略该路由。CLUSTER_LIST属性只用于RR防环，RR只在反射路由的时候才会创建或更新CLUSTER_LIST，而下面几种情况，RR不会创建该属性：1、RR自己始发的路由；2、RR向EBGP邻居发送路由更新时，将会清除所有的CLUSTER_LIST属性；3、当RR从eBGP邻居收到路由，传递给client或非client时，不会创建CLUSTER_LIST。</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1608365403976-5c775260-036a-49d4-a053-a13a03f9c471-1642643880956170.jpeg" alt="img"></p>
<h4 id="ORIGINATOR-ID取值-1"><a href="#ORIGINATOR-ID取值-1" class="headerlink" title="ORIGINATOR_ID取值"></a>ORIGINATOR_ID取值</h4><p><img src="/2020/10/11/14-BGP/1608367486050-fa2c2078-7b28-4865-be7a-31d1e52e29b3-1642643880956174.jpeg" alt="img"></p>
<p>R1位于AS100，与R2是eBGP邻居关系，将1.1.1.0/24的路由传递给R2，R2传递给iBGP邻居R3，但由于水平分割原则，R3不会将从iBGP邻居R2处学到的1.1.1.0/24路由传递给另一个iBGP邻居R4，这种情况下如果想将路由传递给R4，使R3成为RR，R4为R3的client，R3就能将路由传递给R4了，此时身为RR的R3会添加ORIGINATOR_ID和CLUSTER_LIST进路由，其中ORIGINATOR属性为R2的Router ID，也就是2.2.2.2而不是R1的Router ID，1.1.1.1：</p>
<p><img src="/2020/10/11/14-BGP/1608367767846-b91f554c-6c26-45ef-ba84-884d58f25851-1642643880956172.jpeg" alt="img"></p>
<h4 id="CLUSTER-LIST与BGP选路-1"><a href="#CLUSTER-LIST与BGP选路-1" class="headerlink" title="CLUSTER_LIST与BGP选路"></a>CLUSTER_LIST与BGP选路</h4><p><img src="/2020/10/11/14-BGP/1608367924110-f6b40265-a996-421a-9833-e2d515285aba-1642643880956176.jpeg" alt="img"></p>
<p>R1宣告11.11.11.0/24进BGP，R5分别通过R2和R4学到这条路由，在其他属性一致的情况下，Cluster list短的路由更优：</p>
<p><img src="/2020/10/11/14-BGP/1608368122153-83f9884d-67e4-4e1c-aa85-7ad11f16cfd2-1642643880956178.jpeg" alt="img"></p>
<h4 id="冗余RR环境-1"><a href="#冗余RR环境-1" class="headerlink" title="冗余RR环境"></a>冗余RR环境</h4><p>单RR可能会存在单点故障，因此从冗余性的角度出发，一个簇中可以拥有多台RR，Client与每一台RR都有物理连接并建立BGP对等体关系，在其中一台RR出现故障的情况下，Client仍然有替代连接。因为Client不知道主机是别人的Client，所以RR本身也可以成为别人的Client，使用荣誉RR增加了网络的健壮性，ORIGINATOR_ID和CLUSTER_LIST属性用来在冗余RR中避免环路，可以将两个RR的Cluster ID配置为一样，可以进一步起到防环作用，所有的RR之间建议采取全互联的形式，比如：</p>
<p><img src="/2020/10/11/14-BGP/1608369164961-37ba507a-2b08-4c2a-a229-a0247a72a5b2-1642643880956180.jpeg" alt="img"></p>
<h2 id="Weight"><a href="#Weight" class="headerlink" title="Weight"></a>Weight</h2><p>weight属性为思科私有，作用范围是本路由器，该值既不会被包含在update报文中，也不会传递给任何BGP邻居，只在路由器本地产生影响，中文翻译为权重值，越大越优先。取值范围为0-65535。如果路由是从其他BGP邻居学过来的，则weight值为默认的0；如果路由是从本地network产生的，则weight值为32768；本地重发不的直连接口路由或静态路由的weight为32768；本地汇总产生的BGP路由weight值为32768。</p>
<h1 id="协议配置"><a href="#协议配置" class="headerlink" title="协议配置"></a>协议配置</h1><h2 id="建立邻居"><a href="#建立邻居" class="headerlink" title="建立邻居"></a>建立邻居</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">network X.X.X.X  mask Y.Y.Y.Y  route-map NNNN</span><br></pre></td></tr></table></figure>

<p>在IGP中，network命令用于确定要发送和接收路由更新的接口，以及通告哪些直连的网络；</p>
<p>在BGP中，network命令与BGP在哪些接口上运行无关。仅仅是讲本地某个网络注入到BGP里，该路由我们称为可靠的。也就是说，只有<strong>路由表</strong>中有这个路由条目，且它不在BGP表中，才能使用network命令讲它注入到BGP表中。比如下面这个路由器的路由表中，有10.0.0.0/24这条路由，才能在BGP中用network 10.0.0.0 mask 255.255.255.0这条命令来宣告，将它注入进BGP中。而不能注入一条路由表中没有的路由，比如这个路由器中没有192.168.1.0/24这条路由，所以就不能network这条路由进BGP。再比如路由表中有192.168.0.0/24的路由，如果network 192.0.0.0也不成功。</p>
<p>后边的route-map NNNN，就是对前边宣告路由进行属性上的操控。</p>
<p><img src="/2020/10/11/14-BGP/1609745691690-86261972-ba32-479b-87ef-504ff1c266f6.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X remote-as Y.Y.Y.Y</span><br></pre></td></tr></table></figure>

<p>neighbor 的这个地址必须是IP可达的。</p>
<h2 id="邻居身份验证"><a href="#邻居身份验证" class="headerlink" title="邻居身份验证"></a>邻居身份验证</h2><p>BGP支持MD5身份验证，要在BGP对等体邻居之间的TCP连接上启用MD5身份验证，使用命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X password YYYY</span><br></pre></td></tr></table></figure>

<p>同一个BGP连接，密码必须一致，不同的邻居可设置不同的密码。认证配置完毕后，将通过对等体之间的TCP连接传输所有的数据端进行验证，注意这只是基本的身份验证功能并不是加密，抓包如下：</p>
<p><img src="/2020/10/11/14-BGP/1609747001219-ee22a6d2-bd7e-4a04-9524-0efc44562612.jpeg" alt="img"></p>
<h2 id="重置BGP连接"><a href="#重置BGP连接" class="headerlink" title="重置BGP连接"></a>重置BGP连接</h2><h3 id="硬重置"><a href="#硬重置" class="headerlink" title="硬重置"></a>硬重置</h3><p>硬重置意味着将所有的BGP邻居的TCP连接以及BGP邻居状态都重新复位。</p>
<p>clear ip bgp *       //表示将所有邻居的TCP、BGP连接都重新复位；</p>
<p>clear ip bgp *  {neighbor-address}     //表示将特定邻居的TCP、BGP连接重新复位，比如如果配置clear ip bgp * 1.1.1.1，表示将邻居1.1.1.1的TCP、BGP连接重新复位。</p>
<h3 id="软重置"><a href="#软重置" class="headerlink" title="软重置"></a><a href="https://community.cisco.com/t5/routing/clear-ip-bgp-soft-command/td-p/1827626">软重置</a></h3><p>和硬重置不同，软重置不会拆重建邻居的TCP或BGP连接，而是浸出法更新的操作以便让新的路由策略生效。软重置可以单独用于出站或入栈策略，也可以同时用于出站入站策略。</p>
<p>clear ip bgp * soft          //对所有的邻居的出站及入站进行软重置</p>
<p>clear ip bgp soft out      //出站软重置，会重新发送update消息给所有邻居；</p>
<p>clear ip bgp soft in        //入站软重置，本地重新发送route-refresh给所有BGP邻居；</p>
<p>clear ip bgp {neighbor-address}  soft in/out   //对特定邻居使用软重置；</p>
<p>执行入站软重置的方法有两种：</p>
<h4 id="Soft-Reconfiguration"><a href="#Soft-Reconfiguration" class="headerlink" title="Soft Reconfiguration"></a>Soft Reconfiguration</h4><p>这种重置方式的中文叫‘<strong>使用存储的路由更新信息的软重置</strong>’，是一种相对老一些的软重置方式，使用这种方式进行软重置，需要在输入命令前先使用命令neighbor x.x.x.x soft-reconfiguration inbound才可以进行软重置。在BGP进程中使用以上命令会将x.x.x.x邻居发来的最原始、未经过滤变更的BGP路由存储在本地内存中，当配置入站方向的软重置后（输入命令clear ip bgp * soft 【in】），路由器不再向邻居发送更新请求，而是直接对在内存中存储的那些原始未经改变的BGP路由执行新配置的入站策略，以此来防止出发大批量的路由更新而造成资源的浪费，但这种操作仍然比较消耗内存，因此在性能不太好的设备上使用时要非常谨慎。</p>
<h4 id="Dynamic-Inbound-Soft-Reset"><a href="#Dynamic-Inbound-Soft-Reset" class="headerlink" title="Dynamic Inbound Soft Reset"></a>Dynamic Inbound Soft Reset</h4><p>这种重置方式的中文叫‘动态入站软重置’，英文‘Route Refresh capability’说的也是它，在2000年发布的RFC2918中正式规定，思科从IOS 12.1开始全面支持入站路由的动态软重置，目前在用的几乎所有路由器都支持动态入站软重置。这种软重置的能力<strong>不需要进行任何的命令配置</strong>，在BGP邻居建立时会预先协商好，当输入命令clear ip bgp * soft 【in】【out】（没错，和前一种软重置触发的命令相同）时，路由器会自动向所有支持这个特性的邻居发送route-refresh报文，要求这些邻居重新发送它们的路由宣告。</p>
<p>如何知道邻居设备是否支持这种新的软重置呢？看show ip bgp neighbors X.X.X.X的显示中的‘Route refresh’后的部分，带new的就是支持不配置直接刷新的：</p>
<p><img src="/2020/10/11/14-BGP/1608624995973-839b197a-ad0a-4cb5-ac7b-b5d7a2a42989.jpeg" alt="img"></p>
<h4 id="软重置总结"><a href="#软重置总结" class="headerlink" title="软重置总结"></a>软重置总结</h4><p>第一种软重置方式由于内存消耗过大已经被第二种方式替代，目前几乎所有在网运行BGP的路由器都支持第二种更新的方式进行软重置，无需配置任何命令，遇到软重置时提示让你配置‘soft-reconfiguration inbound’的，说明邻居只支持老的刷新方式，不过一般很难遇到了。所以如果你觉得看到两种软重置有点懵逼，忽略第一种直接看第二种就好。如果想进一步搞明白，推荐看<a href="https://community.cisco.com/t5/switching/soft-reset-and-route-refresh-in-bgp/td-p/2674389">帖子1</a>、<a href="https://community.cisco.com/t5/routing/clear-ip-bgp-soft-command/td-p/1827626">帖子2</a>和<a href="https://ccieblog.co.uk/bgp/route-refresh-capability-vs-soft-reconfiguration">帖子3</a>，我上面的内容摘抄\翻译自这。</p>
<h2 id="查看邻居支持的特性"><a href="#查看邻居支持的特性" class="headerlink" title="查看邻居支持的特性"></a>查看邻居支持的特性</h2><p>使用命令‘show ip bgp neighbot x.x.x.x |  section Neighbor capabilities’查看邻居X.X.X.X支持的BGP特性，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2#show ip bgp neighbors 192.168.23.3 | section Neighbor capabilities</span><br><span class="line">  Neighbor capabilities:</span><br><span class="line">    Route refresh: advertised and received(new)</span><br><span class="line">    Four-octets ASN Capability: advertised and received</span><br><span class="line">    Address family IPv4 Unicast: advertised and received</span><br><span class="line">    Enhanced Refresh Capability: advertised and received</span><br><span class="line">    Multisession Capability:</span><br><span class="line">    Stateful switchover support enabled: NO for session 1</span><br></pre></td></tr></table></figure>

<h2 id="BGP表含义"><a href="#BGP表含义" class="headerlink" title="BGP表含义"></a>BGP表含义</h2><p>BGP表就是上面说的Loc-RIB（Local Routing Information Base），用命令‘show ip bgp’查看：</p>
<p><img src="/2020/10/11/14-BGP/1606113319088-6ea8349a-9d45-4efe-9691-43c5ef2e6bf1.jpeg" alt="img"></p>
<p>可以看到，R2的BGP表中有一条1.1.1.1/32的路由，前面的*和&gt;是神么意思呢？</p>
<ul>
<li>*****表示这条路由是有效的，BGP可以使用它，只要路由器从其他BGP邻居收到一条路由就表示这条路由有效，和下一跳能否到达没有关系，一个<a href="https://community.cisco.com/t5/other-network-architecture/bgp-valid-status-code/td-p/355514">帖子里</a>关于valid是这么说的：The prefix is marked as valid if received from a peer or locally originated. The next hop reachability doesn’t affect this flag.那什么情况下，一条BGP路由无效呢？那个帖子里说：When a path is dampened among other conditions. In such a case, the prefix is not received anymore from the peer. It is kept for the sake of conserving the history information and is not marked as valid.大概意思是说，当一条路由在被阻断的情况下就无效了，比如这条路由不再从邻居那边收到，但为了保存历史信息，会被标记成无效留下来；</li>
<li>&gt;表示这条路由被选为BGP中的最优（但不代表着它一定是路由表中最优的）：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1606113482740-b217341b-d421-4096-b281-c5ec35b4b4f5.jpeg" alt="img"></p>
<p>那么不是最优的BGP路由如何表示呢？前面没有&gt;符号的就不是最优路由，例如下面：</p>
<p><img src="/2020/10/11/14-BGP/1606113245098-5668e18a-fc9f-474f-88d4-8c2b2918f7ca.jpeg" alt="img"></p>
<ul>
<li><p>Next Hop，表示去往目标网络下一跳发给谁，在最上面图中的next hop部分值为192.168.12.1，表示在R2上通过BGP去往1.1.1.1/32，需要把数据发给192.168.12.1即可。如果这部分值为0.0.0.0呢？表示该路由始发于本路由器，所以不需要发给别的地址，故该部分值为0.0.0.0；</p>
</li>
<li><p>后面几个值，Metric、LocPrf、Weight以及Path都是BGP的属性，用来选取最佳路径，会在后面具体解释；</p>
</li>
<li><p>最后面还有一个‘i’，这是BGP的origin code，就是路由更新的来源，一共有三种途径，其中‘i’表示通过BGP中的network命令注入到BGP中的，也就是起源于IGP，因为BGP通过的network命令宣告进入的必须在IGP的路由表中；其中‘e’是由EGP这种早期的协议重发布而来，该协议现网中已不再使用；其中‘？’表示从其他渠道学习到的，也就是该路由来源的信息不完全，重发布路由的origin都是这个标记；</p>
</li>
<li><p>BGP表中开头部分还有个‘BGP table version’表示BGP表的版本号，每当最佳路径产生变化时，BGP表的版本号会随之增加。</p>
</li>
<li><p>Status Codes中还有一些其他的代码：s是suppressed，翻译成中文是被抑制，表示BGP知道该路由前缀但不会对它进行通告，通常发生在该路由前缀是路由汇总中一部分的时候；d是damped，翻译成中文是衰减，表示BGP不会宣告这条路由前缀，因为该路由频繁翻滚（路由一会儿存在过一会儿又消失），标志为d的路由会被限制传播范围，这个特性有三个作用，一是减少路由器因为路由翻滚而带来的高负载，二是增加路由稳定，三是防止路由长时间的震荡。；h是history，翻译成中文是历史，表示BGP学到过这条路由但目前该路由不存在；r是RIB-failure，表示BGP学到过这条路由但并未将它加入路由表中，这种情况常见于有其他AD管理距离更低的路由协议也学到了该路由时；S是Stable，表示过期的路由，用于不间断转发，当远程BGP邻居返回时，必须刷新此条目。</p>
</li>
</ul>
<h3 id="关于思科的valid"><a href="#关于思科的valid" class="headerlink" title="关于思科的valid"></a>关于思科的valid</h3><p>思科设备关于BGP路由的valid，也就是是否有效这个，它和华为或Juniper的做法都不一样，Juniper和华为是需要这条BGP路由下一跳可达才会标记valid，而思科的BGP路由下一跳即使不可达也不影响这条路由的valid（The prefix is marked as valid if received from a peer or locally originated. The next hop reachability doesn’t affect this flag.），比如下图中，3.3.3.0/24这条路由是valid，也就是有效的，但它的下一跳192.168.23.3在路由表中并不存在，这并不影响它是否是valid，每个厂家关于路由协议都有自己的理解，所以在不同厂家设备对接的时候一定要了解这些差异，具体出处在<a href="https://community.cisco.com/t5/other-network-architecture/bgp-valid-status-code/td-p/355514">这个帖子</a>：</p>
<p><img src="/2020/10/11/14-BGP/1609574798947-f5e93db6-8524-480c-b5cc-23c4f3004c90.png" alt="img"></p>
<h3 id="关于思科的‘-gt-best’"><a href="#关于思科的‘-gt-best’" class="headerlink" title="关于思科的‘&gt;-best’"></a>关于思科的‘&gt;-best’</h3><p>BGP表中的Best表示这条路由是BGP表中的最优，而不代表它一定就是路由表中的最优。决定一条BGP路由是否是路由表中的最优有两个过程，第一个过程是BGP表维护过程，大概就是BGP表中去往同一目的地的候选路由进行比较，选出一条BGP表中的最优路由，这个过程比的是BGP的属性，比如AS_PATH或MED这种，如果在BGP的路由表中最优则会有&gt;的标识，<strong>标识它是BGP表中的最优</strong>，如果去往目的地只有一条BGP路由，那么它不需要比较，直接就是BGP表中的最优；第二个过程是由路由表维护过程，BGP中带&gt;符号最优的这条BGP路由和IGP路由进行比较，如果IGP路由协议中有和BGP路由去往同一个前缀的路由，则Best的BGP路由和IGP路由进行比较AD值，AD值越小的越优，AD值小的进入路由表；如果IGP路由协议中没有和BGP路由去往同一个前缀的路由，则BGP的Best路由直接进入路由表中。这部分笔记出自于<a href="https://community.cisco.com/t5/routing/bgp-gt-best-status-code/td-p/4265857">这个帖子</a>。</p>
<h2 id="show-ip-bgp-summary"><a href="#show-ip-bgp-summary" class="headerlink" title="show  ip bgp summary"></a>show  ip bgp summary</h2><p><img src="/2020/10/11/14-BGP/1608540858816-cc5a8027-e5f6-48d7-9963-9500715b25bf.png" alt="img"></p>
<ul>
<li><p>BGP table version，每当BGP表发生变化时，这个数字+1；</p>
</li>
<li><p>main table version，被注入到主路由表中的最后一个table version；</p>
</li>
<li><p>AS，邻居的AS号；</p>
</li>
<li><p>MsgRcvd：从邻居那里收到的消息数；</p>
</li>
<li><p>MsgSent：发送给该邻居的消息数；</p>
</li>
<li><p>TblVer：发送给该邻居的最后一个bgp table的version；</p>
</li>
<li><p>InQ：来自该邻居的等待处理的消息数；</p>
</li>
<li><p>OutQ：队列中等待被发送到该邻居的消息数；</p>
</li>
<li><p>State：BGP当前的会话状态，可能有Idle、Opensent等，如果状态为admin表示该邻居被管理型Shutdown，当处于establish状态时，不会显示状态提示，而显示一个表示PfxRcd的数字，也就是上图中所示的状态，表示从该邻居处收到的前缀条目，图中表示从邻居10.1.12.2收到了1个路由前缀。</p>
</li>
</ul>
<h2 id="BGP-Policy-Accounting"><a href="#BGP-Policy-Accounting" class="headerlink" title="BGP Policy Accounting"></a>BGP Policy Accounting</h2><p>基本概念</p>
<p>BGP Policy Accounting能对BGP 邻居发送来的IP流量进行度量或流量统计。Policy accounting is enabled on an input interface, and counters based on parameters such as community list, autonomous system number, or autonomous system path are assigned to identify the IP traffic. </p>
<p>在R2上抓取R1发过来的去往30.30.30.0/24的流量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 30 permit 30.30.30.0/24 </span><br><span class="line"></span><br><span class="line">route-map setComm permit 10 </span><br><span class="line">  match ip address prefix-list 30 </span><br><span class="line">  set community 300:30 </span><br><span class="line">  </span><br><span class="line">ip community-list 30 permit 300:30 </span><br><span class="line"></span><br><span class="line">route-map PA permit 10 </span><br><span class="line">  match community 30 </span><br><span class="line">  set traffic-index 30 </span><br><span class="line">  </span><br><span class="line">router bgp 12</span><br><span class="line">  table-map PA </span><br><span class="line">  neighbor 10.1.23.3 route-map setComm in</span><br><span class="line">  </span><br><span class="line">interface fast0/0</span><br><span class="line">  ip address 10.1.12.2 255.255.255.0</span><br><span class="line">  bgp-policy accounting input</span><br></pre></td></tr></table></figure>

<p><a href="https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/iproute_bgp/configuration/15-s/irg-15-s-book/irg-bgp-pol-acct.html">https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/iproute_bgp/configuration/15-s/irg-15-s-book/irg-bgp-pol-acct.html</a></p>
<p><a href="https://community.cisco.com/t5/networking-documents/how-to-configure-the-bgp-policy-accounting-feature/ta-p/3132729">https://community.cisco.com/t5/networking-documents/how-to-configure-the-bgp-policy-accounting-feature/ta-p/3132729</a></p>
<p>1、设定进行审计的条件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device(config)# ip community-list community-list-number &#123;permit | deny&#125; community-number</span><br><span class="line">Device(config)# route-map map-name [permit | deny] [sequence-number]</span><br><span class="line">Device(config-route-map)# match community-list community-list-number [exact]</span><br><span class="line">Device(config-route-map)# set traffic-index bucket-number</span><br></pre></td></tr></table></figure>



<p>1、定义要统计的感兴趣流量，并设置流量索引，Communitu-list、AS_PATH或者 AS号等参数都可以用于抓取感兴趣流量</p>
<p>2、将IP流量归类，在BGP进程中使用route-map关键字关联上面定义好的route-map。BGP将基于route-map中定义的规则对路由表中的路由进行归类，其实就是把感兴趣流量归类到traffic-indexzh中</p>
<p>1、需要进行流量可以根据BGP的community或AS_Path属性进行分类。如果用community属性进行分类，则需要用ip community-list列表来抓取流量；如果用AS_Path属性进行分类，则需要用ip as-path access-list列表来抓取流量。</p>
<p>2、创建route-map来匹配之前配置的community-list或AS_Path list，并为收集到的流量信息设置存储桶的名称。</p>
<p>3、用route-map中的set traffic-index命令来规定如何将那些被route-map匹配的数据包进行分类</p>
<h2 id="BGP路由重发布"><a href="#BGP路由重发布" class="headerlink" title="BGP路由重发布"></a>BGP路由重发布</h2><h3 id="BGP重发布到IGP"><a href="#BGP重发布到IGP" class="headerlink" title="BGP重发布到IGP"></a>BGP重发布到IGP</h3><p>讲BGP路由重发布到IGP时，默认不重新发布IBGP路由，只重发布EBGP路由，在MPLS VPN环境的PE没有这个限制。如果想让IBGP路由也被重发布的话，需要使用命令‘bgp redistribute-internal’。</p>
<h3 id="OSPF重发布进BGP"><a href="#OSPF重发布进BGP" class="headerlink" title="OSPF重发布进BGP"></a>OSPF重发布进BGP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">router bgp X</span><br><span class="line">  redistribute ospf 1</span><br></pre></td></tr></table></figure>

<p>默认情况下，只会将OSPF中O以及OIA的路由重发布进BGP。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 external 1 external 2</span><br></pre></td></tr></table></figure>

<p>只重发布OSPF的外部路由E1、E2进BGP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 external 1</span><br></pre></td></tr></table></figure>

<p>只重发布OSPF的外部路由E1进BGP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 nssa-external 1 nssa-external 2</span><br></pre></td></tr></table></figure>

<p>只重新发布OSPF的NSSA路由进BGP</p>
<h2 id="其它常用命令"><a href="#其它常用命令" class="headerlink" title="其它常用命令"></a>其它常用命令</h2><p>show ip bgp neighbors {address} received-routes</p>
<p>显示从指定邻居收到的所有BGP路由，也就是本地入站策略执行前的原始路由</p>
<p>show ip bgp neighbors {address} routes</p>
<p>显示从指定邻居那里收到的所有路由，是上一条命令的子集，这里显示的是执行入站策略后剩下的路由</p>
<p>show ip bgp neighbors {address} advertised-routes</p>
<p>显示通告给特定邻居的所有BGP路由</p>
<p>neighbor maximum-prefix XX</p>
<p>限制从邻居处接受的前缀的最大数，如果超出了这个数字，路由器就会关闭与该邻居的BGP连接，在应用clear ip bgp xxx之前都不会再次建立BGP会话</p>
<p>neighbor maximum-prefix XX restart 2</p>
<p>当从邻居处收到的前缀数量超过XX这个数字，断开与邻居的BGP连接，2分钟后才能重新连接</p>
<p>Neighbor maximum-prefix  300  90%  warning-only</p>
<p>当从邻居处接受的前缀数量超过了最大数字，300，的90%时（默认值为75%），生成一条消息日志</p>
<h1 id="BGP决策"><a href="#BGP决策" class="headerlink" title="BGP决策"></a>BGP决策</h1><h2 id="决策过程总览"><a href="#决策过程总览" class="headerlink" title="决策过程总览"></a>决策过程总览</h2><p>在一个既有IGP又有BGP的环境中，路由决策分为两个部分，一个是BGP表的决策过程，一个是路由表的决策过程。BGP表的决策过程大概就是BGP表中去往同一目的地如果有多条BGP路由，要选出一条最优路由，这个过程比的是BGP属性的优先程度，比如AS_PATH或MED这种，如果一条BGP路由在BGP路由表中最优则会有&gt;的标识，<strong>标识它是BGP表中的最优</strong>，如果去往目的地只有一条BGP路由，那么它不需要比较，直接就是BGP表中的最优；第二个过程是由路由表决策过程，BGP中带&gt;符号最优的这条BGP路由和IGP路由进行比较，如果IGP路由协议中有和BGP路由去往同一个前缀的路由，则Best的BGP路由和IGP路由进行比较AD值，AD值越小的越优，AD值小的进入路由表；如果IGP路由协议中没有和BGP路由去往同一个前缀的路由，则BGP的Best路由直接进入路由表中。这部分笔记出自于<a href="https://community.cisco.com/t5/routing/bgp-gt-best-status-code/td-p/4265857">这个帖子</a>。</p>
<h2 id="BGP路由信息库"><a href="#BGP路由信息库" class="headerlink" title="BGP路由信息库"></a>BGP路由信息库</h2><p>BGP路由信息数据库，BGP Routing Information Base (RIB)，包含三个部分：</p>
<ul>
<li><p>ADJ-RIBS-IN：存储来自对等体邻居的、未经处理的消息，所包含的路由都是可用路由。说白了就是邻居发来的原始的路由信息是什么样的，原封不动的保存在Adj-RIBs-In中。通过命令 show ip bgp neighbor x.x.x.x received-routes查看Adj-RIBs-In。</p>
</li>
<li><p>Loc-RIB：存储着去往每个目标地址的最佳BGP路由。大体过程是，BGP路由器通过对ADJ-RIBS-IN中的路由使用它入向路由策略，那些符合入向策略的策略路由中，如果有多条路由去往同一目标地址的，则需要经过BGP的路由决策过程，从它们中选出最优（BEST）的放入Loc-RIB中并标记上&gt;符号，如果去往该目标地址只有一条路由，则直接将路由放入Loc-RIB中并标记上&gt;符号。</p>
</li>
<li><p>ADJ-RIBS-OUT：宣告给对等体邻居的路由，这些路由条目通过update报文发送给邻居，通告给邻居的是最优的路由。通过命令show ip bgp neighbor x.x.x.x advertise-routes来查看Adj-RIBs-Out。</p>
</li>
</ul>
<p>可以说，BGP的RIB有以上这三个不同的数据库，或者说RIB是由以上三个部分构成的一个单独的数据库。</p>
<p>The BGP Routing Information Base (RIB) consists of three parts:</p>
<ul>
<li><p><strong>Adj-RIBs-In</strong>: Stores unprocessed routing information that has been learned from BGP Updates received from peers. The routes contained in Adj-RIBs-In are considered feasible routes.</p>
</li>
<li><p><strong>Loc-RIB</strong>: Contains the routes that the BGP speaker has selected by applying the decision process to the routes contained in Adj-RIBs-In. These routes populate the routing table (RIB) along with routes discovered by other routing protocols.</p>
</li>
<li><p><strong>Adj-RIBs-Out</strong>: Contains the routes that the BGP speaker advertises to its peers in BGP Updates. The outgoing routing policies determine what routes are placed in Adj-RIBs-Out.</p>
</li>
</ul>
<p>These three parts of the RIB may be three distinct databases, or the RIB may be a single database with pointers to distinguish the three parts.</p>
<h2 id="BGP决策过程"><a href="#BGP决策过程" class="headerlink" title="BGP决策过程"></a>BGP决策过程</h2><h3 id="BGP表处理、决策过程"><a href="#BGP表处理、决策过程" class="headerlink" title="BGP表处理、决策过程"></a>BGP表处理、决策过程</h3><ul>
<li><p>Phase 1 calculates the degree of preference for each feasible route in the Adj-RIBs-In. It is invoked whenever a router receives a BGP Update from a peer in a neighboring AS containing a new route, a changed route, or a withdrawn route. Each route is considered separately, and a nonnegative integer is derived that indicates the degree of preference for that route.</p>
</li>
<li><p>Phase 2 chooses the best route out of all the available routes to a particular destination and installs the route in the Loc-RIB. It is invoked only after phase 1 has been completed. Loops are also detected in Phase 2 by examining the AS_PATH. Any routes with the local AS number in the AS_PATH are dropped.</p>
</li>
<li><p>Phase 3 adds the appropriate routes to the Adj-RIBs-Out for advertisement to peers. It is invoked after the Loc-RIB has changed, and only after phase 2 has been completed. Route aggregation, if it is to be performed, happens during this phase.</p>
</li>
<li><p>从邻居处收到的所有BGP路由原封不动的保存到Adj-RIBs-In中，去往同一目的地可能存在多条BGP路由，所以从多条BGP路由中选出一条最优的BGP路由。</p>
</li>
<li><p>每当路由器收到由邻居AS对等体发来的BGP update（注意，update中可能有新路由，变更现有路由或撤销原有路由）报文后，就会计算所有Adj-RIBs-In中可用BGP路由的优先级，算出来的优先级是一个整数（非负数的），这个值代表着这条路由的优先程度，这个优先程度是BGP用来对每条路由进行排序的依据，列出哪条路由是最优，哪条路由是次优。</p>
</li>
<li><p>在计算完所有Adj-RIBs-In中路由的优先级后，在那些既符合入向策略且下一跳可达的路由中，选出一条BEST的路由(在BGP表中标记上&gt;，表示它是BEST最优的)，将这条最优路由放入Loc-RIB中。一条BGP路由的下一跳如果不可达，则它不能成为最优。如果去往目标地址有多条路由则用优先级选出一条最优的，如果去往该目的地址只有一条路由，则该路由即为最优BGP路由。这些被计算优先级的路由是Adj-RIBs-In中的所有未经本地策略改变的。本阶段除了选出最优的路由以外也会进行路由防环的检测，路由器会查看收到路由的AS_PATH，如果本路由器所处的AS号在新收到路由的AS_PATH中，则会丢弃该路由，因为有本AS的AS_PATH号意味着路由曾经到过本AS，为了防止环路必须丢弃该路由。</p>
</li>
<li><p>在完成了上一步骤后，将选出来的最优且无环的路由放入Adj-RIBs-Out中，宣告给对等体邻居。如果配置了路由汇总，也会在本阶段进行。</p>
</li>
</ul>
<h3 id="路由表决策过程"><a href="#路由表决策过程" class="headerlink" title="路由表决策过程"></a>路由表决策过程</h3><p>由BGP表决策过程选出来的BEST的BGP路由，将参与<strong>路由表的决策过程</strong>，如果有去往同一目的的IGP路由，则比较最优BGP路由和IGP路由的AD值，谁小谁加路由表；如果没有其他去往相同目的地的IGP路由，则BGP路由直接为最优。</p>
<h2 id="属性优先级判定"><a href="#属性优先级判定" class="headerlink" title="属性优先级判定"></a>属性优先级判定</h2><h3 id="总体规则"><a href="#总体规则" class="headerlink" title="总体规则"></a>总体规则</h3><p>当到达同一个目标地址有多条BGP路由时，由BGP路由属性来判断优先选择哪条BGP路由，如果两条路由的某个属性能分出哪条更优先时，则停止比较，如果两条路由的一个属性相同无法比出结果，则比较下一个属性，例如路由A和路由B这两条路由去往同一个目的地，先比较Weight值，如果路由A的weight值更大，则路由A为最优，停止比较；如果路由A和B的Weight值相同无法比较出谁更优，则比较下一个属性值，Local Preference，以此类推，直到有一个属性能分出胜负后，停止比较。这个比较过程是在Adj-RIBs-In中做的。</p>
<p>那么这个属性优先级排定和之前说的每条路由计算出一个非负数的优先级有什么联系呢？<a href="https://community.cisco.com/t5/routing/what-s-the-role-of-degree-of-preference-in-the-adj-ribs-in-in/m-p/4270220#M345214">这个帖子</a>中是这么说的：‘The BGP decision process is an integral part of the process that assigns the degree of preference to each prefix for its ranking. It may help to think of it in this way: the process for degree of preference reads each entry of the Adj-RIBs-In and the process for degree of preference uses the BGP decision process on that prefix and uses the results of the BGP decision process to assign the ranking.’大概意思是说，这个属性优先级判定是前面提到的，给Adj-RIB-in中所有路由计算优先级的一部分，计算优先级的过程会读取Adj-RIBs-in中的每条路由信息并用属性优先级判定过程来决定一条路由的优先级程度，然后决定哪条BGP路由为最优。</p>
<p><img src="/2020/10/11/14-BGP/1610164572582-7ee675dc-4a44-4395-a795-c724dbff7a41.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611376250625-781c53c5-faac-4e88-b31f-a9fa42936d8e.jpeg" alt="img"></p>
<ol>
<li>Weight值是思科IOS专有属性，Weight值越大越优先，Weight值只在本路由器上有意义，在一个路由器上对Weight值进行更改，不会传递给其他路由器，不会影响其他路由器上的Weight值。</li>
<li>如果Weight值相等，那么LOCAL_PREF值大的路由更优先。</li>
<li>如果LOCAL_PREF值相等，那么优先选择起源于本地的路由（例如在本路由器使用network或aggregate命令宣告的），即下一跳是0.0.0.0的路由（在BGP表中，当前路由器宣告的BGP路由下一跳为0.0.0.0），优先顺序从高到低为：default-originate（针对每个邻居配置）、default-information-originate（针对每种地址簇配置）、network、redistribute、aggregate-address；</li>
<li>如果LOCAL_PREF相同并且没有起源于本路由器的路由，则比较AS_PATH长度，越短越优先。路由聚合时使用AS-SET后产生的AS_PATH列表中{}里的AS号长度只选一个AS号的长度，比如如果AS_PATH中有{100 300 500}则只算一个AS号的长度，如果AS_PATH中有{100 300 500} 400，则算两个AS号长度。在联邦内的AS_PATH列表中的（）的AS号长度不做计算依据。如果配置了bgp bestpath as-path ignore这条命令，则跳过比较AS_PATH这步。</li>
<li>如果AS_PATH长度相同，则比较ORIGIN属性，IGP&gt;EGP&gt;Incomplete。</li>
<li>如果ORIGIN属性相同，则比较MED，越小越优先。一般情况下属性值比到这一步只可能是，需要比较的路由都来自同一个AS的不同EBGP邻居。可以配置bgp always-compare-med这条命令使得即使来源于不同的AS也进行MED比较。</li>
<li>如果MED也相同，则EBGP路由优于联邦EBGP路由，联邦EBGP路由优于IBGP路由。</li>
<li>如果上一步也依旧无法比较出是否优选，则优选到BGP NEXT_HOP更近的路由，该路由在AS内部是去往下一跳IGP度量值最小的路由。严格来说应该说，一台路由器从<strong>本AS</strong>的两个BGP邻居各收到一条路由，这两条BGP路由具有相同的路由前缀，首先这两条BGP路由的Next hop是不相同的才具有可比性，这时候比较本地到达这两个Next_hop的IGP的度量值，谁的Metric小，就优选谁。</li>
<li>如果有多条来自同一个相邻AS的路由并通过Maximum-paths命令激活了负载均衡属性，则将所有开销相同的路由加入Loc-RIB。</li>
<li>如果所有路由都来自EBGP邻居，则优选最先收到的EBGP邻居传来的路由，降低路由翻滚的影响。最老的EBGP邻居意味着可能是最稳定的BGP邻居，因此在这条规则中做了优选。这条比较规则主要针对EBGP路由起效，但现在基本不再使用，因为不确定性比较强。如果配置了‘bgp bestpath compare-routerid’命令后则跳过本原则。</li>
<li>如果没有激活负载均衡，优选Router ID最小的，在使用了路由反射器的情况下，优选ORIGINATOR_ID小的。</li>
<li>如果在使用了路由反射器的情况下ORIGINATOR_ID相同，则优选CLUSTER_LIST小的路由。</li>
<li>如果路由CLUSTER_LIST依旧相同，则优选IP地址小的邻居发送过来的路由。</li>
</ol>
<h3 id="weight越大越优"><a href="#weight越大越优" class="headerlink" title="weight越大越优"></a>weight越大越优</h3><h4 id="基本概念-9"><a href="#基本概念-9" class="headerlink" title="基本概念"></a>基本概念</h4><p>weight属性为思科私有，作用范围是本路由器，该值既不会被包含在update报文中，也不会传递给任何BGP邻居，只在路由器本地产生影响，中文翻译为权重值，<strong>越大越优先</strong>。取值范围为0-65535。如果路由是从其他BGP邻居学过来的，则weight值为默认的0；如果路由是从本地network产生的，则weight值为32768；本地重发不的直连接口路由或静态路由的weight为32768；本地汇总产生的BGP路由weight值为32768。</p>
<h4 id="如何操控"><a href="#如何操控" class="headerlink" title="如何操控"></a>如何操控</h4><p>*<strong>方法1*</strong></p>
<p>如果想对weight值进行更改，那么应该在本路由器上进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor &#123;ip address|peer-group_name&#125; weight XXXX</span><br></pre></td></tr></table></figure>

<p>例如，C从A和B都学到了1.1.1.0/24这条BGP路由，在不对weight值进行操控的情况下，这两条路由在C上的weight值都是0，因为该路由是从其他邻居那学过来的，weight值默认为0，此时我如果想让从B学到的路由更优选，则配置可以配置‘neighbor B weight 200’，那么从B获得的路由1.1.1.0/24的路由的weight值为200，为Best路由，被C优选：</p>
<p><img src="/2020/10/11/14-BGP/1610775563455-87517886-85d7-4639-b5e3-2cd1ef763cc8.jpeg" alt="img"></p>
<p>但按照上面的方式进行配置也有另一个问题就是，简单的将从B宣告过来的所有路由的weight值都设置成为了200，如果A和B也同时宣告过来一条2.2.2.0/24的路由，C想优选从A发过来的这条2.2.2.0/24路由按上面的配置则无法做到，此时需要用到下面这条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">neighbor X.X.X.X  filter-list 1 weight XXX</span><br></pre></td></tr></table></figure>

<p>这条命令是将邻居X.X.X.X发送过来的，且被Filter-list 1 匹配的条目的weight值设置为XXX。这条命令可以对同一个邻居使用多次，也就是对不同的路由设置不同的weight，但命令‘neighbor 1.1.1.1filter-list 1’在同一个邻居的in 或out方向，只能使用一次，这两条命令有很大区别。</p>
<p>*<strong>方法2*</strong></p>
<p>使用route-map进行修改，达到去往100.0.1.0/24走左边的R3路由器，而去往100.0.2.0/24走右边的R5路由器。</p>
<p><img src="/2020/10/11/14-BGP/1610776730473-0c3330ce-1b99-46da-8f92-4b95f8980ac1.jpeg" alt="img"></p>
<p>这时候我们可以将R3传来的100.0.1.0/24路由的weight值设置为10，将R4传来的100.0.2.0/24路由的weight值设置为10，这样就能达成要求：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map 1 in</span><br><span class="line"> neighbor 5.5.5.5 route-map 2 in</span><br></pre></td></tr></table></figure>

<p>配置完以后，用show ip bgp 查看：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#do show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    100     10 100 i</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<p>此时达成了题干要求，但这么配置是否是最优的呢？并不是，因为R3和R5都有去往1.0和2.0的路由，互为备份，如果按照上面的配置方式，一旦R3或R5某一方向的链路出现问题，假设这里是R1和R3之间的链路出现问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1(config-router)#neighbor 10.1.13.3 shutdown</span><br></pre></td></tr></table></figure>

<p>那么此时R4的路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<p>也就是去往100.0.1.0/24的路由完全没有了，为什么会这样呢？是因为在R4上配置的route-map为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br></pre></td></tr></table></figure>

<p>route-map的结尾默认有一条deny any，没匹配上的路由就会被deny掉，route-map1中只匹配了100.0.1.0/24这条路由，所以虽然R3发送了两条BGP路由到R4，但R4上的入向策略将没被route-map 1匹配到的2.0/24路由给deny掉了，所以R4只从R3收到了route-map1匹配到的1.0/24这条路由。同理R4入向策略过滤掉的route-map2没匹配到的1.0路由，R4从R5上只收到了2.0/24这条路由，所以不管是R3方向或R5方向上的链路中断，则R4上没有备份路径。所以如果想要两个方向互为备份路径应该如何配置呢？需要对R4上配置的route-map进行更改：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map 1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 1 permit 20</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 5</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set weight 10</span><br><span class="line">!</span><br><span class="line">route-map 2 permit 20</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set weight 5</span><br></pre></td></tr></table></figure>

<p>配置完的新route-map对1.0/24和2.0/24都进行了匹配，R4可以从R3和R5上都收到两条BGP路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config-route-map)#do show ip bgp</span><br><span class="line">BGP table version is 10, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     5.5.5.5                  0    100      5 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                  0    100     10 100 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      5 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100     10 200 i</span><br></pre></td></tr></table></figure>

<h3 id="Local-Preference越大越优"><a href="#Local-Preference越大越优" class="headerlink" title="Local-Preference越大越优"></a>Local-Preference越大越优</h3><h4 id="基本概念-10"><a href="#基本概念-10" class="headerlink" title="基本概念"></a>基本概念</h4><p>Local-Preference是公认自决属性，默认值为100，只用于iBGP邻居之间，决定离开AS的最优路径，一般用于控制本AS的出口设备。</p>
<ul>
<li>Local-Preference就是本地优先级，当一个AS收到一个去往同意目的地的，但经过两个AS的路由，在其他BGP路由属性完全一致的情况下，根据两条路由的local-preference决定，值越大越优，比如下图中的路由器D，从C和E两个路由器都收到了去往172.20.0.0的路由，但E发过来的路由属性中Local-Preference值大于C发过来的路由属性，所以去往E的路由更优：</li>
</ul>
<p><img src="/2020/10/11/14-BGP/1607149141276-33b3db5c-2872-426d-93d9-68314eaef8ad-1642643991222194.jpeg" alt="img"></p>
<ul>
<li><p>Local-Preference只能在AS内部的iBGP邻居之间传递，而不会传递给其他eBGP邻居，Local-Preference除非做了策略，否则在AS内的iBGP邻居之间传递时不会丢失，如果eBGP邻居之间收到的路由的路径属性中携带了Local-Preference的话，会触发notification报文造成BGP会话中断，但可以在AS边界路由器上使用IN方向策略；</p>
</li>
<li><p>Local-Preference在向eBGP邻居发送路由更新时，不能携带LP属性，对方收到该eBGP路由的LP值为空，也就是说路径属性中根本没有LP这个字段，但它会在本地为这条路由赋一个默认值，也就是100，然后再传递给自己的iBGP邻居；</p>
</li>
<li><p>本地network命令及重发布命令发布的路由，LP值默认为100，并能在AS内向其他iBGP邻居传输，传输过程中除非部署了策略，否则LP值不会发生变化；</p>
</li>
<li><p>修改默认LP值的命令为：bgp default local-preference  XXX。</p>
</li>
</ul>
<h4 id="如何操控-1"><a href="#如何操控-1" class="headerlink" title="如何操控"></a>如何操控</h4><p>使用route-map来修改本地优先级，实验拓扑如下，使用LP来操控路由，使得R4去往100.0.1.0/24走R3方向且LP=200，去往100.0.2.0/24走R5方向且LP=200。</p>
<p><img src="/2020/10/11/14-BGP/1610785384351-c9d2aa43-e2bc-43ff-ba08-0c107e2d04b4.jpeg" alt="img"></p>
<p>由于LP在IBGP邻居之间可以传递，所以这里既可以在R4的In方向上使用route-map来操控LP，也可以在R3和R5上对R4的OUT方向使用route-map来操控。</p>
<p>*<strong>方式1：*</strong></p>
<p>先看在R4的In方向上使用route-map：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 2 seq 5 permit 100.0.2.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 20</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 10</span><br><span class="line"> match ip address prefix-list 2</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map LP1 in</span><br><span class="line"> neighbor 5.5.5.5 route-map LP2 in</span><br></pre></td></tr></table></figure>

<p>route-map LP1和LP2后面之所以写了两个空的permit 20，是因为route-map最后都默认有一个deny any，如果不写空的permit 20，则其他路由会被deny掉，无法传到R4上，也就没法达到备份路径的效果。R3从R1（R5从R2）获取的eBGP路由中的LP值为空，到了R3\R5后被赋予了默认值100，这个值不被route-map改变的话，传到邻居R4后还是默认值100。</p>
<p>配置完结果如下：</p>
<p><img src="/2020/10/11/14-BGP/1610786417710-b571938f-7ef2-4304-91ce-76aabffd3fed.jpeg" alt="img"></p>
<p>为什么会这样选择最优路由呢？因为weight值相同，不起源于本地的路由默认weight值都是0，所以比较LP值，而LP值不相同，拥有200LP值的路径被优选，因为LP值越大越优先。</p>
<p>*<strong>方法2：*</strong></p>
<p>在R3和R5上分别对out方向的R4使用route-map来操控LP，因为R4和R3\R5都为ibgp邻居关系，而LP在IBGP邻居之间是可以传递的。配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP1 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map LP1 out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">ip prefix-list LP2 seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 10</span><br><span class="line"> match ip address prefix-list LP2</span><br><span class="line"> set local-preference 200</span><br><span class="line">!</span><br><span class="line">route-map LP2 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map LP2 out</span><br></pre></td></tr></table></figure>

<p>配置后结果如下：</p>
<p><img src="/2020/10/11/14-BGP/1610788896487-998dc664-31d0-4b00-b906-27f6aedda7b5.jpeg" alt="img"></p>
<h3 id="优选本地起源路由"><a href="#优选本地起源路由" class="headerlink" title="优选本地起源路由"></a>优选本地起源路由</h3><h4 id="基本概念-11"><a href="#基本概念-11" class="headerlink" title="基本概念"></a>基本概念</h4><p>优选起源于本地的路由，也就是那些在本路由器上network、aggregate或redistribute的，也就是下一跳是0.0.0.0的路由，因为在BGP表中，起源于当前路由器的路由，下一跳为0.0.0.0。</p>
<h4 id="实验验证-2"><a href="#实验验证-2" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610857596183-6c383ba3-048f-4cb6-8e6b-d7a6d26b5979.jpeg" alt="img"></p>
<p>R3上宣告一条8.0.0.0/8的BGP路由，R4上network一条同样的8.0.0.0/8的路由，来验证起源于本地的路由是否被优选。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">R3(config)#ip route 8.0.0.0 255.0.0.0 null 0                   配置一条目的地是null接口的路由使得8.0.0.0路由能宣告进BGP</span><br><span class="line">R3(config)#router bgp 345</span><br><span class="line">R3(config-router)#network 8.0.0.0 mask 255.0.0.0</span><br><span class="line">配置完毕后查看R3的BGP表：</span><br><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0         32768 i</span><br><span class="line"> *&gt;   100.0.1.0/24     10.1.13.1                0             0 100 i</span><br><span class="line"> *&gt;   100.0.2.0/24     10.1.13.1                0             0 100 i</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">R4(config)#ip route 8.0.0.0 255.0.0.0 null 0</span><br><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#network 8.0.0.0 mask 255.0.0.0</span><br><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0         32768 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 i</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    200      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    200      0 200 i</span><br></pre></td></tr></table></figure>

<p>但此时必须注意，虽然R4上优选了起源于本地的路由，但要知道，这两条路由不是上来就用‘优选起源于本地的路由’这条规则来比较，而是先要比Weight值，然后比较Local-Preference，比较完前两个才使用‘优选起源于本地的路由’这条规则来比较。这里也按照这个顺序进行比较，先看Weight值，由于起源于本地路由默认的weight值为32768，所以在第一部比较出来了就不会再用其他规则进行比较，这里用route-map将weight值改成一样的来验证。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map WEIGHT permit 10</span><br><span class="line"> set weight 0</span><br><span class="line"></span><br><span class="line">router bgp 345</span><br><span class="line"> network 8.0.0.0 route-map WEIGHT</span><br></pre></td></tr></table></figure>

<p>如此配置以后，再查看R4的BGP表发现，此时R4上8.0.0.0的Weight值为0：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 7, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   8.0.0.0          0.0.0.0                  0             0 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 i</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    200      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    200      0 200 i</span><br></pre></td></tr></table></figure>

<p>这时R4优选了本地起源的路由，因为首先比较的Weight值相同，接下来比较的Local-Preference值也相同，都为默认的100，起源于本地这条LP也是100具体见下图，接下来是起源于本地的路由更优，所以选择了本地那条下一跳为0.0.0.0的路由。<img src="/2020/10/11/14-BGP/1610869076686-fa5bb6f4-7caa-43f1-8e78-5c4eab29e824.jpeg" alt="img"></p>
<h3 id="AS-PATH越短越优"><a href="#AS-PATH越短越优" class="headerlink" title="AS_PATH越短越优"></a>AS_PATH越短越优</h3><h4 id="基本概念-12"><a href="#基本概念-12" class="headerlink" title="基本概念"></a>基本概念</h4><p>AS_PATH是公认必遵属性，描述到达目标网络所要经过的AS号序列，最重要的作用是防环。当且仅当update报文被发送给其他的AS（也就是EBGP peer）时，BGP路由器才会将其AS号追加在AS_PATH中。也就是如果要修改AS_PATH属性，则必须在AS边界路由器上执行，对IBGP邻居去执行修改AS_PATH的策略是无效的。</p>
<p><img src="/2020/10/11/14-BGP/1610869583847-dfa585d5-6256-4f21-aab3-fed01d40be5f.png" alt="img"></p>
<p>例如在上面的BGP表中，去往4.4.4.4/32的路由有两条，要对这两条路由进行比较，看谁更优先，首先看这两条路由的weight值，都为0，所以比较下一个属性，local-preference，虽然BGP表中为空，但两者在本地都被赋予了默认值100，所以继续比较下一项，看两者谁是起源于本地的，由于两条路由的Nexthop都不为0.0.0.0，意味着两条路由都不起源于本地，所以继续比较下一项AS_PATH，越短越优，下一跳为192.168.34.4的这条路由只经过了一个AS（AS4），短于经过了两个AS（AS4-AS1）的下一跳为192.168.13.1的路由，所以AS_PATH短的被优选。</p>
<p>如果做了聚合路由时，使用AS-SET关键字后产生的AS_PATH列表中的{}，无论里边有几个号码，只算做一个AS号的长度，比如如果800 {200 100}只算两个AS号的长度，{200 100 300 400}也只算一个AS号的长度。</p>
<p>如果做了联邦，则联邦AS的AS号不算做长度计算的依据，也就是如果AS_PATH为（65412  65413）100，只算一个AS号的长度。</p>
<h4 id="实验验证-3"><a href="#实验验证-3" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610870199066-58d578a2-089e-4299-9161-c7e489122714.jpeg" alt="img"></p>
<p>由于AS_PATH只在update报文发送给其他AS时才发生变化，这意味着修改操控它必须在AS边界路由器上执行策略，所以既可以在R1\R2的out方向上对AS345的EBGP邻居修改，也可以在R3和R5的In方向上进行修改。</p>
<p>*<strong>方法1：*</strong></p>
<p>方法1采用在R1\R2的out方向上做策略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.2.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 88888 88888 88888</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 10.1.13.3 route-map AS_PATH out</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 44444 44444 44444</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> neighbor 10.1.25.5 route-map AS_PATH out</span><br></pre></td></tr></table></figure>

<p>此时R4上BGP表如下：</p>
<p><img src="/2020/10/11/14-BGP/1610871790826-e221e4cf-b569-485d-bca4-d03f17f54697.jpeg" alt="img"></p>
<p>由于从R3和R4都收到了去往100.0.1.0/24和100.0.2.0/24的路由，这时需要选择最优路由，先看Weight值越大越优，由于所有路由都不是本地起源所以都为默认值0，所以比较下一个属性，Local-Preference越大越优，由于LP不会通过EBGP邻居传递，所以两条起源于外AS的路由在本AS内的LP为空，本AS路由器会赋予相同的默认值100，所以比较下一个属性，优选起源于本AS的路由，由于路由都不起源于本AS，Nexthop不为0.0.0.0，所以比较下一个，AS_PATH小的优选。这时划红线的两条路由的AS_PATH较长所以不被选择，路由器会选择AS_PATH较短的两条路由。</p>
<p>*<strong>方法2：*</strong></p>
<p>从R3和R5上配置in方向的route-map对AS_PATH进行操控。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3：</span><br><span class="line"></span><br><span class="line">ip prefix-list AS_PATH seq 5 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 88888 88888 88888</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 10.1.13.1 route-map AS_PATH in</span><br><span class="line"> </span><br><span class="line"> R4：</span><br><span class="line"> </span><br><span class="line"> ip prefix-list AS_PATH seq 5 permit 100.0.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list AS_PATH</span><br><span class="line"> set as-path prepend 44444 44444 44444</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 10.1.25.2 route-map AS_PATH in</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕以后R4的路由表如下：</span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 16, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> * i                   5.5.5.5                  0    100      0 44444 44444 44444 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 88888 88888 88888 100 i</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br></pre></td></tr></table></figure>

<p>*<strong>方法1对比方法2：*</strong></p>
<p>两种办法都能达到操控路由的目的，最显著的区别在于AS_PATH在R4上的表现，在R1上操控AS_PATH然后对out方向EBGP邻居使用route-map的话，AS_PATH是‘100 88888 88888 88888 i’，而在R3的in方向对邻居使用route-map的话，AS_PATH是‘88888 88888 88888 100 i’。之所以结果不同是因为route-map是在Adj-RIBs-IN上使用的，而传给邻居的BGP路由是Adj-RIBs-Out中的，out中的路由传递给eBGP邻居之前加上本AS的号码。</p>
<p>在R1上操控AS_PATH然后对out方向EBGP邻居使用route-map，route-map的操控结果在Adj-RIBs-IN上已经发挥作用，route-map生效后路由变成了‘88888 88888 88888 i’，i是表示该路由通过network注入的本AS，接下来通过route-map添加的AS号88888在左边，因为AS_PATH中越靠右表示更先经历该AS，靠左边表示晚一些经过该AS。由于去往该目标地址只有这一条路由，该路由为最优，所以带有‘88888 88888 88888 i’AS_PATH的路由进入了Loc-RIB和Adj-RIBs-Out中，接下来要将该路由发送给EBGP邻居，所以要在AS_PATH中靠左的位置加上本AS的号码，最后AS_PATH为‘100  88888 88888 88888 i’。</p>
<p>在R3上操控AS_PATH然后对EBGP邻居in方向使用route-map，route-map的操控结果在Adj-RIBs-IN上发挥作用，Adj-RIBs-IN中存储的是邻居发送过来的无更改的路由，这时R1发过来的路由在AS_PATH中已经加上了AS100的号码，也就是‘100 i’然后route-map对AS_PATH进行操控，加上了88888这个AS号码，后加入的AS号要在靠左的地方，所以最后AS_PATH为‘88888 88888 88888  100  i’。</p>
<h3 id="比较Origin-Code"><a href="#比较Origin-Code" class="headerlink" title="比较Origin Code"></a>比较Origin Code</h3><h4 id="基本概念-13"><a href="#基本概念-13" class="headerlink" title="基本概念"></a>基本概念</h4><p>Origin code的优先排序为：I（IGP）&gt;E（EGP）&gt;？（Incomplete），由于EGP协议已经不再使用，所以可以简单的将该规则记为IGP&gt;Incomplete，IGP表示路由起源于IGP，由network命令引入BGP。？表示是从其他渠道学习到的，该路由来源的信息不完全，一般是由重发布引入的。可以在show ip bgp中的path最右边看到origin code。一般不建议使用origin code对BGP选路进行操控。</p>
<p><img src="/2020/10/11/14-BGP/1610940171116-a813b671-0a15-4b0d-b598-d41ae6b0c4b6.png" alt="img"></p>
<h4 id="实验验证-4"><a href="#实验验证-4" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1610941989856-5799d0e9-7c5e-41fc-b98e-cc59f59abf06.jpeg" alt="img"></p>
<p>在不进行任何配置的情况下，R4上去往100.0.1.0/24及100.0.2.0/24会通过R3走，本实验通过操控origincode使得两条路由改走R5方向去往目标网段。可以在R1上不使用network的方式发布两条路由而改为使用重发布方式将两条路由引入BGP，也可以在R1上使用route-map的方式进行操控，还可以在R3的out方向用route-map操控，抑或可以在R4的in方向上进行修改。</p>
<p><strong>方法1：</strong></p>
<p>首先使用在R1上network时修改origin的方式，在R1上配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">route-map ORIGIN permit 10</span><br><span class="line"> set origin incomplete</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> network 100.0.1.0 mask 255.255.255.0 route-map ORIGIN</span><br><span class="line"> network 100.0.2.0 mask 255.255.255.0 route-map ORIGIN</span><br></pre></td></tr></table></figure>

<p>配置完R4的路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                  0    100      0 100 ?</span><br></pre></td></tr></table></figure>

<p>此时要选出最优路由依旧得从头开始比较，Weight值的话，两者相同都是0，因为都不是首发于本地的路由，默认weight值为0；Local-Preference比较，由于路由宣告自其它AS，LP不在EBGP邻居之间传递，所以用默认值100；两条路由都不是起源于本地，nexthop都不是0.0.0.0；AS_PATH比较，两边的AS_PATH长度值都是2；比较origin code，I&gt;?，所以优选走R5方向。</p>
<p><strong>方法2：</strong></p>
<p>在R3上对R4的out方向使用route-map更改origin code从而达到在R4上优选R5路径的目的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list ORIGIN seq 5 permit 100.0.1.0/24</span><br><span class="line">ip prefix-list ORIGIN seq 10 permit 100.0.2.0/24</span><br><span class="line">!</span><br><span class="line">route-map ORIGIN permit 10</span><br><span class="line"> match ip address prefix-list ORIGIN</span><br><span class="line"> set origin incomplete</span><br><span class="line">!</span><br><span class="line">route-map ORIGIN permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 4.4.4.4 route-map ORIGIN out</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕后R4的路由表为：</span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 13, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 ?</span><br><span class="line"> *&gt;i                   5.5.5.5                  0    100      0 200 i</span><br></pre></td></tr></table></figure>

<p>此时要选出最优路由依旧得从头开始比较，Weight值的话，两者相同都是0，因为都不是首发于本地的路由，默认weight值为0；Local-Preference比较，由于路由宣告自其它AS，LP不在EBGP邻居之间传递，所以用默认值100；两条路由都不是起源于本地，nexthop都不是0.0.0.0；AS_PATH比较，两边的AS_PATH长度值都是2；比较origin code，I&gt;?，所以优选走R5方向。</p>
<h3 id="MED越小越优"><a href="#MED越小越优" class="headerlink" title="MED越小越优"></a>MED越小越优</h3><h4 id="基本概念-14"><a href="#基本概念-14" class="headerlink" title="基本概念"></a>基本概念</h4><p>MED为可选非传递属性，一般用于AS之间的BGP选路，用来影响进入本AS的流量。默认情况下，要比较MED值仅在所有备选路由来自同一AS才会比较MED，也就是说同一个目的地的两条路由来自不同AS时，不进行MED值的比较。MED只在直接相连的AS间影响业务，<strong>只在AS内传递MED值，不会跨AS传递，思科设备MED值默认为0。</strong></p>
<p>MED设置方法：</p>
<ul>
<li><p>将IGP路由引入BGP时关联route-map进行设置；</p>
</li>
<li><p>对BGP peer应用IN/OUT方向的route-map进行设置；</p>
</li>
<li><p>非route-map方式：1、使用network或redistribute方式将IGP路由引入BGP时，MED将继承IGP路由的Metric（直连路由及静态路由的Metric为0）；2、使用aggregate-address方式引入路由，则MED为空。</p>
</li>
</ul>
<h4 id="实验验证-5"><a href="#实验验证-5" class="headerlink" title="实验验证"></a>实验验证</h4><p>通过更改MED值，使得原来优选R3方向的路由优选走R5方向。</p>
<p><img src="/2020/10/11/14-BGP/1611026347438-ac5ad4bd-b001-4e56-8491-c16d357932e7.jpeg" alt="img"></p>
<p>在R4上进行配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">route-map MED permit 10</span><br><span class="line"> set metric 200</span><br><span class="line">!</span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 3.3.3.3 route-map MED in</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 配置完毕后R4的BGP表如下：</span><br><span class="line"> </span><br><span class="line"> R4#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                200    100      0 100 i</span><br><span class="line"> * i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> *&gt;i                   3.3.3.3                200    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>可以看到配置已经生效，在Weight值相同，Local-Preference相同，都不是起源于本地的路由，AS_PATH长度相同，Origin Code相同的情况下，比较MED时，路由并没有优选MED更小的R5方向，这是为什么呢？因为默认情况下，来源于不同AS_PATH路由不比较MED值，具体来说就是来源于R3方向的路由AS_PATH中显示它是来自AS100，来源于R5方向的路由AS_PATH中显示它来自AS200，这种情况下是不比较MED的：</p>
<p><img src="/2020/10/11/14-BGP/1611027413416-ed657332-ea54-443b-8d60-2b0613c67a72.jpeg" alt="img"></p>
<p>如果想用MED来为两条路由分出优先与否，则需要配置上‘bgp  always-compare-med’这条命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#bgp always-compare-med</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">配置完此命令后在看BGP表：</span><br><span class="line">R4(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 5, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;i  100.0.1.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                200    100      0 100 i</span><br><span class="line"> *&gt;i  100.0.2.0/24     5.5.5.5                  0    100      0 200 i</span><br><span class="line"> * i                   3.3.3.3                200    100      0 100 i</span><br></pre></td></tr></table></figure>

<p>配置完命令后，来自不同AS的路由也开始比较MED值，越小越优，所以路由会优选R5方向。</p>
<h3 id="优选EBGP邻居的路由"><a href="#优选EBGP邻居的路由" class="headerlink" title="优选EBGP邻居的路由"></a>优选EBGP邻居的路由</h3><h4 id="基本概念-15"><a href="#基本概念-15" class="headerlink" title="基本概念"></a>基本概念</h4><p>优选EBGP邻居发来的路由（相比较IBGP邻居学过来的），在联邦EBGP和IBGP中优选联邦EBGP邻居。</p>
<p><img src="/2020/10/11/14-BGP/1611027668707-9589d443-430b-4d17-abd7-5f5540aa9508.jpeg" alt="img"></p>
<p>例如上图中，R5同时从R4及R2收到关于100.0.1.0/24的路由，在前几个比较条件都无法分出谁优选的情况下（Weight值相同，LP值相同，都不是起源于本地的路由，AS_PATH长度都为1，Origin Code都是i，MED值都为0），会优选来自R2的路由，因为R5和R2之间是EBGP邻居，优先于R5和R4的IBGP邻居发来的路由。</p>
<h4 id="实验验证-6"><a href="#实验验证-6" class="headerlink" title="实验验证"></a>实验验证</h4><p>由于水平分割原则的存在，R4无法将从ibgp邻居R3处学到的路由发送给另一个ibgp邻居R5，为了打破水平分割原则，这里将R4配置成路由反射器，使R3的路由能够发送给R5：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4：</span><br><span class="line"></span><br><span class="line">router bgp 345</span><br><span class="line"> neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 这时看R5的路由表：</span><br><span class="line"> </span><br><span class="line"> R5#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 5.5.5.5</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> * i  100.0.1.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;                    10.1.25.2                0             0 200 i</span><br><span class="line"> * i  100.0.2.0/24     3.3.3.3                  0    100      0 100 i</span><br><span class="line"> *&gt;                    10.1.25.2                0             0 200 i</span><br></pre></td></tr></table></figure>

<p>这时R5已经从R4处学到了100.0.1.0/24，这时Weight值相同都为0，Local-Preference也相同为0，路由都不起源于本地，AS_PATH长度相同都为1，Origin Code都为 i 也相同，MED值都为0，接下来由于R2方向学到的路由为EBGP路由所以优选这条。</p>
<h3 id="优选到NEXTHOP最近的"><a href="#优选到NEXTHOP最近的" class="headerlink" title="优选到NEXTHOP最近的"></a>优选到NEXTHOP最近的</h3><h4 id="基本概念-16"><a href="#基本概念-16" class="headerlink" title="基本概念"></a>基本概念</h4><p>当路由器从两个BGP邻居各收到一条路由，这两条BGP路由有相同的路由前缀，首先这两条BGP路由的NEXT_HOP必须是不相同的，否则不具有可比性，这时候会比较到达这两个NEXT_HOP的IGP度量值，谁的Metric小，就选谁。</p>
<p><img src="/2020/10/11/14-BGP/1611038313328-86466f24-88e7-49cd-8c2c-042bbe87993a.jpeg" alt="img"></p>
<p>比如R4从R3和R5都收到了关于100.0.1.0/24的路由<img src="/2020/10/11/14-BGP/1611038676694-4b75de24-7671-452d-9f12-6ff54f777351.jpeg" alt="img">：</p>
<p>两条路由一条NEXTHOP是3.3.3.3，一条是5.5.5.5，R4会比较到这两个NEXTHOP的IGP路由的metric值，越小越优，在上图中到两个NEXTHOP的metric相同，都是11。</p>
<p><img src="/2020/10/11/14-BGP/1611047431133-bbb1ef88-4714-4ba1-861f-8db64e5dce25.jpeg" alt="img"></p>
<h4 id="实验验证1"><a href="#实验验证1" class="headerlink" title="实验验证1"></a>实验验证1</h4><p>用上面的拓扑，操控NEXTHOP的metric值，使得R4用该规则优选R5方向的路由，由于要操控的是IGP的metric值，所以可以将R4连接R3接口的COST值调大，那么R4到达NH 3.3.3.3的metric值就变大了，R4就会优选R5这条BGP路径因为到达NH 5.5.5.5的metric值较小。</p>
<p><img src="/2020/10/11/14-BGP/1611039761141-61d18f1c-ce99-4c99-97fc-f4c631c1a02a.jpeg" alt="img"></p>
<p>在对配置改动之前，e0/0接口的cost值是10。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#int e0/0</span><br><span class="line">R4(config-if)#ip ospf cost 100</span><br></pre></td></tr></table></figure>

<p><img src="/2020/10/11/14-BGP/1611040114929-b1c5e261-5584-4174-8d28-acfc0550bcb8.jpeg" alt="img"></p>
<p>改完COST值后，还是得从第一条BGP比较规则一条一条往下看，Weight值相同为默认的0，Local-Preference相同为默认的100，两条路由都不起源于本地，AS_PATH长度相同都为2，Origin Code相同为i，MED相同为0，路由属性相同都是ibgp邻居出来的路由，现在比较到Next Hop的IGP的Metric值，到3.3.3.3的metric值为101，到5.5.5.5的metric值为11，优选到Next Hop的metric值小的5.5.5.5。</p>
<p><img src="/2020/10/11/14-BGP/1611043967580-095b2d0f-0bb8-474c-8d0d-ae56a864ab12.jpeg" alt="img"></p>
<p>用show ip bgp 100.0.1.0来查看metric更为直观一些。</p>
<h4 id="实验验证2"><a href="#实验验证2" class="headerlink" title="实验验证2"></a>实验验证2</h4><p><img src="/2020/10/11/14-BGP/1611044324196-2557103e-08ff-44c4-85eb-fe4464c4300c.jpeg" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R5：</span><br><span class="line"></span><br><span class="line">R5(config)#router bgp 345</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 remote-as 345</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 up loop 0</span><br><span class="line">R5(config-router)#neighbor 3.3.3.3 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">R4(config-router)#router bgp 345</span><br><span class="line">R4(config-router)#neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">R3(config-if)#ip add 100.0.30.3 255.255.255.0</span><br><span class="line">R3(config)#router bgp 345</span><br><span class="line">R3(config-router)#neighbor 5.5.5.5 remote-as 345</span><br><span class="line">R3(config-router)#neighbor 5.5.5.5 next-hop-self</span><br><span class="line">R3(config-router)#network 100.0.30.0 mask 255.255.255.0</span><br></pre></td></tr></table></figure>

<p>这时R5会从第一条规则开始比较，Weight值相等都为默认的0，Local-Preference相等都为默认的100，都不是起源于本地的路由因为nexthop不为0.0.0.0，AS_PATH长度相同，Origin Code相同都为i，MED相同都为0，都是IBGP邻居发来的路由，貌似优选到NextHOP最近的这条能逼出来，因为一个感觉上路由一个从R3直接发过来，另一个经由R4反射过来，实际上是这样吗？来看R5的路由：</p>
<p><img src="/2020/10/11/14-BGP/1611046578419-70901f57-e681-42b8-bdb7-c35bd646eb4f.jpeg" alt="img"></p>
<p>为什么两条路由的下一跳都是3.3.3.3呢？</p>
<p>先看R3发过来这条。因为R3和R5是ibgp邻居关系，配置了next-hop-self，如果不配置的话下一跳是10.1.13.1，R5上没有这个地址，下一跳不可达没有资格选为最优，必须配置next-hop-self。从R3发过来的这条BGP路由的IGP的metric为21。</p>
<p>然后看R4反射过来的这条。由于R4是路由反射器，在反射的时候不改变下一跳，R3和R4使用loopback建立邻居，所以下一跳也是3.3.3.3。</p>
<p>两条路由Next hop相同，所以相对应的IGP的Metric也相同。这条依旧比不出来，真正发挥作用的是后面的‘如果多条路径始发路由器ID或路由器ID相同，那么优选Cluster-Iist最短的路径’。</p>
<h3 id="BGP负载均衡"><a href="#BGP负载均衡" class="headerlink" title="BGP负载均衡"></a>BGP负载均衡</h3><h4 id="基本概念-17"><a href="#基本概念-17" class="headerlink" title="基本概念"></a>基本概念</h4><p>当前面的8条选路原则都无法优选出最优路由时，并且在BGP进程下面配置了负载均衡的命令：‘Maximum-path【ibgp】n’（n的取值范围为2-6，如果不关联ibgp关键字，则只会对External路由执行等价负载均衡，也就是只对EBGP路由负载均衡。如果要对internal路由做负载均衡，则需关联ibgp关键字。）那么将执行等价负载均衡，也就是将这些等价的路径都放入IP路由表使用，但是要注意，虽然这些路径在本地都用了，但最终<strong>只有一条</strong>BGP路径是BEST最优的。</p>
<p>具备等价负载均衡条件的候选路径需满足如下条件：</p>
<ul>
<li>必须有相同的路径属性，如Weight、LP、AS_PATH（不仅是长度，整个AS_PATH包括所经过的AS号都要相同）、Origin Code、MED及IGP的Distance值；</li>
<li>每一条路径的下一跳都不相同。</li>
</ul>
<p><strong>如果路由器没有配置maximum-paths，那么将进行到下一条选路原则进行比较。</strong></p>
<h4 id="IBGP负载均衡实验"><a href="#IBGP负载均衡实验" class="headerlink" title="IBGP负载均衡实验"></a>IBGP负载均衡实验</h4><p>将之前的拓扑进行一部分更改来看负载均衡。</p>
<p><img src="/2020/10/11/14-BGP/1611132578176-b2e997a2-6e11-4cf8-8fc5-5fd4f228135a.jpeg" alt="img"></p>
<p>配置等价负载均衡之前，R4关于100.0.1.0/24的路由如下:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp 100.0.1.0/24</span><br><span class="line">BGP routing table entry for 100.0.1.0/24, version 6</span><br><span class="line">Paths: (2 available, best #2, table default)</span><br><span class="line">Flag: 0x100</span><br><span class="line">  Not advertised to any peer</span><br><span class="line">  Refresh Epoch 1</span><br><span class="line">  12</span><br><span class="line">    5.5.5.5 (metric 11) from 5.5.5.5 (5.5.5.5)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal</span><br><span class="line">      rx pathid: 0, tx pathid: 0</span><br><span class="line">  Refresh Epoch 1</span><br><span class="line">  12</span><br><span class="line">    3.3.3.3 (metric 11) from 3.3.3.3 (3.3.3.3)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal, best</span><br><span class="line">      rx pathid: 0, tx pathid: 0x0</span><br></pre></td></tr></table></figure>

<p>可以看到R4从R3和R5分别收到一条去往该网段的路由，这两条路由具有相同的路径属性，Weight值为0、LP为100、AS_PATH都是AS12长度为1、Origin Code为i、MED为0，到达下一跳IGP路由的Distance值也相同，所以此时可以配置等价负载均衡。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4(config)#router bgp 345</span><br><span class="line">R4(config-router)#maximum-paths ibgp 2</span><br></pre></td></tr></table></figure>

<p>这里为什么要配置成‘maximum-paths ibgp 2’呢？因为R4这两条路由都是由IBGP邻居宣告而来，如果不配置关键字‘ibgp’的话，只会对EBGP路由生效。配置过后效果如下：</p>
<p><img src="/2020/10/11/14-BGP/1611133346539-25bbfd6f-aa0b-4405-a986-70e6b646a5a9.jpeg" alt="img"></p>
<p>从BGP表中也能看出来，虽然是等价负载均衡，但只有一条路由有Best的标志，也就是说R4只会将这条Best的路由更新给邻居，而不会讲两条负载均衡的路由同时告诉邻居。</p>
<p><img src="/2020/10/11/14-BGP/1611133926460-3a2aaaa0-6797-42b0-a898-5c805faa108a.jpeg" alt="img"></p>
<p>查看100.0.1.0这条路由具体信息可知，这两条路由之间的流量比是1:1。</p>
<h4 id="EBGP等价负载均衡"><a href="#EBGP等价负载均衡" class="headerlink" title="EBGP等价负载均衡"></a>EBGP等价负载均衡</h4><p><img src="/2020/10/11/14-BGP/1611134102094-4d3f218d-6003-4491-803f-613830363da1.jpeg" alt="img"></p>
<h3 id="优选最老的EBGP邻居传来的路由"><a href="#优选最老的EBGP邻居传来的路由" class="headerlink" title="优选最老的EBGP邻居传来的路由"></a>优选最老的EBGP邻居传来的路由</h3><p>这条选路规则主要针对EBGP路由起效，但现在基本不用这条来操控路由，因为不确定性太大。最老的EBGP邻居意味着可能是最稳定的BGP邻居，所以在这里做了优选。如果配置了‘bgp bestpath compare-routerid’命令后，将跳过该规则，如果多条路径具有相同的router ID也会跳过本规则，因为这意味着这些路由都是由同一台路由器发过来的。下图中的‘Up/Down’部分显示的就是BGP邻居建立的具体时间。</p>
<p><img src="/2020/10/11/14-BGP/1611198596764-ceebc662-8fd2-4c16-aab5-31a5b27e28fe.jpeg" alt="img"></p>
<h3 id="优选RID最小的BGP邻居的路由"><a href="#优选RID最小的BGP邻居的路由" class="headerlink" title="优选RID最小的BGP邻居的路由"></a>优选RID最小的BGP邻居的路由</h3><h4 id="基本概念-18"><a href="#基本概念-18" class="headerlink" title="基本概念"></a>基本概念</h4><p>RID是路由器上的最大IP地址，一般配置成环回地址，也可以通过bgp router-id命令手工设置。如果一条路径包含RR属性，路由产生者ID（Originator）将在最优路径选择过程中代替RID。</p>
<h4 id="实验验证-7"><a href="#实验验证-7" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1611369990352-05cb9392-9d1a-44ad-be40-6b4b365a2e64.jpeg" alt="img"></p>
<p>R4从R3和R5分别获得一条去往100.0.1.0/24的路径：</p>
<p><img src="/2020/10/11/14-BGP/1611370199871-a7d50475-75ee-4218-a7a2-73da8d102526.jpeg" alt="img"></p>
<p>从输出结果可以看到，R4优选的R3发来的路由，用BGP选路规则依次比较两条路由。Weight值两者相同都为默认的0，Local-Preference两者相同都为默认的100，两条路由都不是起源于本路由器NEXTHOP都不为0.0.0.0，AS_PATH长度相同，Origin Code相同都为i，MED值相同都为0，都由IBGP邻居宣告而来，到Next hop距离相同，没有负载均衡，不是EBGP路由所以不会优选最老的EBGP邻居发过来的路由，Router ID不相同，R3的Router  ID为3.3.3.3，小于R5的Router ID5.5.5.5，优选R3的路由，比较完毕。</p>
<h4 id="补充实验"><a href="#补充实验" class="headerlink" title="补充实验"></a>补充实验</h4><p><img src="/2020/10/11/14-BGP/1611303117372-3751e049-c478-47c8-bd96-bc37cc31e322.png" alt="img"></p>
<p>R1\R2\R3三者为IBGP邻居，都在AS123中，互相之间使用loopback接口建立邻居，R2为RR，将R1上宣告的路由11.11.11.0/24反射给R3，此时R3分别从R1和R2分别各获得一条去往11.11.11.0/24的路由，此时分析哪条路由为最优。</p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 1.1.1.1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 11.11.11.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 2.2.2.2 remote-as 123</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 123</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 2.2.2.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.2 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.2 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 123</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 1.1.1.1 route-reflector-client</span><br><span class="line"> neighbor 3.3.3.3 remote-as 123</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.23.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 3.3.3.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.3 0.0.0.0 area 0</span><br><span class="line"> network 192.168.23.3 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 123</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> neighbor 1.1.1.1 remote-as 123</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 1.1.1.1 next-hop-self</span><br><span class="line"> neighbor 2.2.2.2 remote-as 123</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 2.2.2.2 next-hop-self</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 这时在R3上查看关于11.11.11.0的路由：</span><br><span class="line"> </span><br><span class="line"> R3#show ip bgp 11.11.11.0</span><br><span class="line">BGP routing table entry for 11.11.11.0/24, version 2</span><br><span class="line">Paths: (2 available, best #2, table default)</span><br><span class="line">  Not advertised to any peer</span><br><span class="line">  Refresh Epoch 3</span><br><span class="line">  Local</span><br><span class="line">    1.1.1.1 (metric 11) from 2.2.2.2 (2.2.2.2)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal</span><br><span class="line">      Originator: 1.1.1.1, Cluster list: 2.2.2.2</span><br><span class="line">      rx pathid: 0, tx pathid: 0</span><br><span class="line">  Refresh Epoch 3</span><br><span class="line">  Local</span><br><span class="line">    1.1.1.1 (metric 11) from 1.1.1.1 (1.1.1.1)</span><br><span class="line">      Origin IGP, metric 0, localpref 100, valid, internal, best</span><br><span class="line">      rx pathid: 0, tx pathid: 0x0</span><br></pre></td></tr></table></figure>

<p>下面使用规则对两条路由进行分析，Weight值相同都为默认的0，Local-Preference相同都为默认的100，都不起源于本地，AS_PATH长度相同，BGP的Origin Code相同都为i，MED相同（metric）都是0，两者都是IBGP邻居发来的所以没法优选EBGP邻居，到NEXTHOP最近的会被优选两者的NEXTHOP都是1.1.1.1所以相同，没有配置负载均衡，由于是IBGP邻居不能用建立邻居时间规则来优选路由，看起来优选Router ID最小的这条规则发挥了作用，因为一个router ID是1.1.1.1，一个router ID是2.2.2.2，但实际上并不是这样。<strong>当使用了RR的时候，Originator值将代替Router ID的值</strong>，最终两条路由的下一跳都是1.1.1.1。用show ip bgp 命令看得更清楚：</p>
<p><img src="/2020/10/11/14-BGP/1611305179960-d189e78e-af1b-41d9-b5f0-b10d29099634.png" alt="img"></p>
<h3 id="优选Cluster-List最短路由"><a href="#优选Cluster-List最短路由" class="headerlink" title="优选Cluster_List最短路由"></a>优选Cluster_List最短路由</h3><h4 id="基本概念-19"><a href="#基本概念-19" class="headerlink" title="基本概念"></a>基本概念</h4><p>Cluster_List是路由反射器使用的可选非传递属性用来防止环路，在反射路由的时候才会创建或更新Cluster_list，这个值是路由传递时经过的路由反射簇的ID，长度32bit。</p>
<p><img src="/2020/10/11/14-BGP/1611373905314-2403235d-f762-4c59-8b5f-f23e2cb373a8.png" alt="img"></p>
<h4 id="实验验证-8"><a href="#实验验证-8" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1611374333641-967b3997-5898-4581-bc11-1da616a1551c.jpeg" alt="img"></p>
<p>R1\R2\R3\R4\R5两两为ibgp邻居，R1上宣告11.11.11.0/24的路由进BGP，在R5上会从R2和R4分别收到一条去往该目的地的路由，R2\R3\R4都为RR，观察R5上如何优选去往11.11.11.0/24的路由。</p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 1.1.1.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 11.11.11.1 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.13.1 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> network 1.1.1.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.12.1 0.0.0.0 area 0</span><br><span class="line"> network 192.168.13.1 0.0.0.0 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 2.2.2.2 remote-as 64512</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 remote-as 64512</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 2.2.2.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.12.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.25.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 2.2.2.2</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 64512</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 remote-as 64512</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 route-reflector-client</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R3：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 3.3.3.3 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.13.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.34.3 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 3.3.3.3</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 1.1.1.1 remote-as 64512</span><br><span class="line"> neighbor 1.1.1.1 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 64512</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 route-reflector-client</span><br><span class="line"> neighbor 4.4.4.4 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R4：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 4.4.4.4 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.34.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.45.4 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 4.4.4.4</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 4.4.4.4</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 3.3.3.3 remote-as 64512</span><br><span class="line"> neighbor 3.3.3.3 update-source Loopback0</span><br><span class="line"> neighbor 3.3.3.3 route-reflector-client</span><br><span class="line"> neighbor 3.3.3.3 next-hop-self</span><br><span class="line"> neighbor 5.5.5.5 remote-as 64512</span><br><span class="line"> neighbor 5.5.5.5 update-source Loopback0</span><br><span class="line"> neighbor 5.5.5.5 next-hop-self</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">R5：</span><br><span class="line"></span><br><span class="line">interface Loopback0</span><br><span class="line"> ip address 5.5.5.5 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 192.168.45.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/1</span><br><span class="line"> ip address 192.168.25.5 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">router ospf 1</span><br><span class="line"> router-id 5.5.5.5</span><br><span class="line"> network 0.0.0.0 255.255.255.255 area 0</span><br><span class="line">!</span><br><span class="line">router bgp 64512</span><br><span class="line"> bgp router-id 5.5.5.5</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 2.2.2.2 remote-as 64512</span><br><span class="line"> neighbor 2.2.2.2 update-source Loopback0</span><br><span class="line"> neighbor 4.4.4.4 remote-as 64512</span><br><span class="line"> neighbor 4.4.4.4 update-source Loopback0</span><br></pre></td></tr></table></figure>

<p>R5上关于11.11.11.0路由：</p>
<p><img src="/2020/10/11/14-BGP/1611374815793-a8d525e9-b445-4b20-bbcd-4cea66d798ff.jpeg" alt="img"></p>
<p>用BGP选路规则对路由进行比较。Weight值相同都是默认的0，Local-Preference值相同都是默认的100，都不是起源于本地的路由，AS_PATH长度相同都是本AS内的路由，Origin Code都为i，MED值相同都为0，都是IBGP邻居传过来的路由，到NEXTHOP的距离相同，没有配置负载均衡，由于是IBGP路由所以不比较是否是最老的EBGP邻居，由于都有RR所以Router ID都是最初被反射的R1的Router ID都是1.1.1.1，Cluster list长度不同，从R2过来这条长度为1从R4过来这条长度为2，所以优选Cluster list长度短的R2这条路由。</p>
<h3 id="优选邻居IP地址小的路由"><a href="#优选邻居IP地址小的路由" class="headerlink" title="优选邻居IP地址小的路由"></a>优选邻居IP地址小的路由</h3><p>如果前面12条规则都无法优选出路由，那么只能比较邻居的IP地址，就是配置BGP命令时‘neighbor X.X.X.X  remoteYY’中的这个X.X.X.X的地址。</p>
<h2 id="非等价负载均衡"><a href="#非等价负载均衡" class="headerlink" title="非等价负载均衡"></a>非等价负载均衡</h2><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p><img src="/2020/10/11/14-BGP/1611540954939-91c95c80-5172-4624-8648-71db1a0e9d86.jpeg" alt="img"></p>
<p>AS123内的三台路由器运行OSPF，通告各自互联接口以及Loopback  0接口，loopback0接口地址为X.X.X.X/32，X为设备编号，IBGP邻居关系基于loopback接口建立，R1在BGP中通告11网段路由，R4在BGP中通告44网段路由。</p>
<h3 id="eBGP非等价负载均衡"><a href="#eBGP非等价负载均衡" class="headerlink" title="eBGP非等价负载均衡"></a>eBGP非等价负载均衡</h3><h4 id="R4如何优选路由"><a href="#R4如何优选路由" class="headerlink" title="R4如何优选路由"></a>R4如何优选路由</h4><p>由于R4从R2及R3都收到了关于11.11.11.11的路由，所以接下来比结合之前的路由决策看看为什么优选：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R4#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 4.4.4.4</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *   11.11.11.11/32   10.1.34.3                              0 123 i</span><br><span class="line"> *&gt;                   10.1.24.2                              0 123 i</span><br><span class="line"> *&gt;  44.44.44.0/24    0.0.0.0                  0         32768 i</span><br></pre></td></tr></table></figure>

<p>Weight值相同都为0因为两条路由都不起源于本地而不起源于本地路由的Weight值默认为0，Local-Preference为默认的100由于从eBGP邻居发来所以不带这个属性在R4上为默认值100，两条路由都不起源于本地，AS_PATH长度相同都为1，Origin Code相同都为i，MED相同都为0，性质相同都为eBGP邻居发来的路由，NEXTHOP的距离相同，没有配置负载均衡，由于不是EBGP路由所以‘优选最老EBGP邻居’这条不适用，优选Router ID小的由于R2的Router ID2.2.2.2小于R3的Router ID3.3.3.3，所以优选下一跳是10.1.24.2这边。</p>
<h4 id="配置非等价负载均衡"><a href="#配置非等价负载均衡" class="headerlink" title="配置非等价负载均衡"></a>配置非等价负载均衡</h4><p>由于R3方向带宽比较小，所以即使R4需要双出口也不能做负载均衡，因为两边带宽差别比较大，所以这种情况下用非等价负载均衡更为合适。</p>
<p>R4配置：</p>
<p><img src="/2020/10/11/14-BGP/1611567459595-32c11f3e-1e1b-4641-81f0-46a879958943.jpeg" alt="img"></p>
<p>这里使用的是BGP的link bandwidth特性，借助的是BGP的一个扩展community来实现的，配置该属性以后，R4将会根据带宽来考量R2\R4这两个EBGP邻居，当从R2\R4收到路由时，会给收到的路由黏贴上一个扩展的community属性，这个community属性和接口的带宽是有关联的，会为BGP的非等价负载均衡提供进一步的信息。<strong>dmzlink-bw这条命令只能去指向一个EBGP邻居，不能配置给ibgp邻居。</strong></p>
<p><img src="/2020/10/11/14-BGP/1611567771897-cab47ba9-88b1-43da-8913-9aeb34e42eb7.jpeg" alt="img"></p>
<p>上面标红的的DMZ-LINK BW ……就是这个community属性，这个值是接口带宽除以8计算得来。</p>
<p><img src="/2020/10/11/14-BGP/1611567884314-5bbba951-093f-4d3a-bbc0-4e418c058141.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611567928912-758da3dc-6002-4892-aed0-ed197af5654f.jpeg" alt="img"></p>
<p>用show ip route 可以看到，路由表中已经负载均衡，进一步看11.11.11.11这条路由会发现，两者形成了非等价负载均衡，比例是60:1，但注意由于CEF的存在，CEF的默认的负载均衡是基于目标地址而不是基于每个数据包的，实际上市基于源、目的地址对的负载均衡，也就是到一个目的地址只走固定的线路：</p>
<p><img src="/2020/10/11/14-BGP/1611569614571-7a1cfd5d-45a8-436a-9c4a-1eb81971c1db.jpeg" alt="img"></p>
<p>所以要在R4的E0/0和S1/0两个接口上配置‘ip load-sharing per-packet’命令，配置后去往目标地址的数据包才会基于比例分路线走。</p>
<h3 id="iBGP的非等价负载均衡"><a href="#iBGP的非等价负载均衡" class="headerlink" title="iBGP的非等价负载均衡"></a>iBGP的非等价负载均衡</h3><p><img src="/2020/10/11/14-BGP/1611570260474-c499283e-767d-4b2f-9378-eb882404da05.jpeg" alt="img"></p>
<p>R1从R2和R3都能获取到44.44.44.44/32这条路由，但由于之前提到过的，R4两条链路带宽差别比较大的情况，R1去往R4也不适合使用等价负载均衡，而更适合使用非等价负载均衡才能让带宽有效利用。所以在R2和R3上进行配置，使得R4根据带宽黏贴在路由上的扩展community属性，能传给R1，执行非等价负载均衡。</p>
<p><img src="/2020/10/11/14-BGP/1611570592531-eb0aadba-a184-42bb-bdf7-ee1854effd6f.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611570610429-87a46ad8-a99f-4d2f-bfb9-75e01cca9208.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611570628095-bf98b7f3-6d3c-49d3-9b58-38ef634f49b8.jpeg" alt="img"></p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>通过利用BGP的Link Bandwidth特性，能够在AS边界路由器外部链路带宽不等价的情况下，实现BGP路由的非等价负载均衡。改特性通过在BGP进程的IPV4或VPNV4地址簇中使用‘bgp dmzlink-bw’命令激活。这个特性搭配BGP multipath特性，即可实现非等价负载均衡。</p>
<p>BGP Link Bandwidth 特性用于在扩展community属性中通告一条AS出口链路的带宽。</p>
<p>这个特性配置在一台AS边界路由器上，指向其EBGP邻居，那么此时该特性所描述的就是该路由器与其EBGP邻居之间的链路带宽。而且该链路带宽信息（使用扩展community描述）除了AS边界路由器自己使用（用于本地的非等价负载均衡），还可以像AS内的ibgp邻居传递，使得AS内部其他路由器也能使用该community做非等价负载均衡，当然前提是得配置send-community extended命令才行。</p>
<p>激活Link Bandwidth的预备条件：</p>
<ul>
<li><p>激活maximum-paths特性；</p>
</li>
<li><p>当要向ibgp邻居通告Link Bandwidth特性时，需send-community extended；</p>
</li>
<li><p>CEF或dCEF必须在所有彩玉该特性的路由器上打开。</p>
</li>
</ul>
<p>Link Bandwidth特性的限制：</p>
<ul>
<li><p>该特性只能配置在BGP晋城的IPV4或VPNV4地址簇下；</p>
</li>
<li><p>BGP只能够在Link Bandwidthcommunity中通告与eBGP邻居直连的链路（接口）带宽；</p>
</li>
<li><p>在IPV4及VPNV4地址簇中，ibgp及eBGP负载均衡都是支持的，但IBGP\EBGP负载均衡却只能在VPNV4地址簇中才能够支持，也就是ibgp与eBGP的负载均衡。</p>
</li>
</ul>
<h1 id="BGP策略"><a href="#BGP策略" class="headerlink" title="BGP策略"></a>BGP策略</h1><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><h3 id="正则表达式的组成"><a href="#正则表达式的组成" class="headerlink" title="正则表达式的组成"></a>正则表达式的组成</h3><p><img src="/2020/10/11/14-BGP/1612163771020-2e2171de-d1e4-46fe-9289-683ad952a202.jpeg" alt="img"></p>
<h3 id="原子字符"><a href="#原子字符" class="headerlink" title="原子字符"></a>原子字符</h3><h4 id="基本概念-20"><a href="#基本概念-20" class="headerlink" title="基本概念"></a>基本概念</h4><table>
<thead>
<tr>
<th>.</th>
<th>匹配任何单个的字符，包括空格，比如a、b、c、1、2、3都可以被.匹配到</th>
</tr>
</thead>
<tbody><tr>
<td>^</td>
<td>一个字符串的开始</td>
</tr>
<tr>
<td>$</td>
<td>一个字符串的结束</td>
</tr>
<tr>
<td>_</td>
<td>下划线 任意的一个分隔符如^、$、空格、tab、逗号、{ 、}</td>
</tr>
<tr>
<td>|</td>
<td>管道符，表示逻辑或的关系</td>
</tr>
<tr>
<td>\</td>
<td>转义符，用来将紧跟其后的控制字符转变为普通字符</td>
</tr>
</tbody></table>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^$</th>
<th>匹配那些为空的字符串，因为起始字符和结束字符中间没有任何东西，用到AS_PATH控制列表中就是匹配那些AS_PATH为空的路由，也就是那些起源于本AS的路由，因为路由在发送给相邻AS时才会加入AS_PATH，所以起源于本AS的路由AS_PATH部分为空</th>
</tr>
</thead>
<tbody><tr>
<td>^51_</td>
<td>匹配那些以51开始后面有一个空格的字符串，比如51 66，51 100，51 888，用到AS_PATH控制列表中就是匹配那些和本AS相连最后经过AS51的路由，也就是那些从邻居AS51发来的路由</td>
</tr>
<tr>
<td>_51$</td>
<td>匹配那些以51结尾且前面有个空格的字符串，比如100 51,666 51，用到AS_PASH中就是那些起源于AS51路由</td>
</tr>
<tr>
<td><em>51</em></td>
<td>匹配那些51前后各有一个空格的字符串，比如100 51 200,666 51 888，用到AS_PATH中就是那些穿越过AS51的路由</td>
</tr>
<tr>
<td>^a.$</td>
<td>匹配一个以a开始，任意单一字符结束的字符串，如a0，a!，aa，ab等</td>
</tr>
<tr>
<td>^100_</td>
<td>匹配一个以100开始，后面跟一个分隔符的字符串，只限制了开始的字符，并没限制后边跟了多少。如100、100 200、100 300 400、100 200 500 600等，‘_’用来匹配AS号之间的空格。如果在匹配AS_PATH的时候，用^100_来匹配的话，表示匹配那些最后经过AS100的路由，也就是相邻AS号是100的路由。</td>
</tr>
<tr>
<td>^100$</td>
<td>匹配100，如果在匹配AS_PATH的时候，表示匹配只经过AS100的路由</td>
</tr>
<tr>
<td>100$|400$</td>
<td>匹配一个以100或400结束的字符串，前面有几个字符并没有规定，比如100、1400、300 400、131400、1100等都匹配这个正则表达式</td>
</tr>
<tr>
<td>^(65000)$</td>
<td>\是转义符，正则表达式会把\后面的当做常规字符而不是有特殊功能的字符去对待，该正则表达式仅仅匹配（65000），一般用于匹配联邦中的AS_PATH，联邦中的AS_PATH是用小括号括起来的</td>
</tr>
<tr>
<td>[123].[7-9]</td>
<td>[123]表示匹配123中的一个任意数字，可以是1,2或3。‘.’表示匹配任何单个字符或空格，[7-9]表示匹配7到9中的人一个数字。所以167,258,3 7,118等都符合正则表达式</td>
</tr>
<tr>
<td>100</td>
<td>由于并没配置开始和结束字符，只要字符串里有100的就可以被匹配上，比如1100，100666，abc100cba等</td>
</tr>
</tbody></table>
<h3 id="乘法字符"><a href="#乘法字符" class="headerlink" title="乘法字符"></a>乘法字符</h3><h4 id="基本概念-21"><a href="#基本概念-21" class="headerlink" title="基本概念"></a>基本概念</h4><p>一个乘法字符可以应用于一个单字符或多个字符，不能单独使用必须搭配常规字符使用，如果应用于多字符，需将字符串放入（）中。由于?和*两个字符都有出现0次的所以一定要谨慎使用，因为可能正则表达式会匹配到无穷多个结果，也就是所有都被匹配到，可能失去了使用正则表达式的意义。</p>
<table>
<thead>
<tr>
<th>*</th>
<th>匹配前面字符0次或多次出现，如果a*，表示匹配a、aaa、aaaa</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>匹配前面字符1次或多次出现</td>
</tr>
<tr>
<td>?</td>
<td>匹配前面字符0次或1次出现</td>
</tr>
</tbody></table>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^(abc)?$</th>
<th>匹配abc出现0次或1次，也就是匹配abc或abc根本不出现，可能匹配到无穷多个结果，慎用</th>
</tr>
</thead>
<tbody><tr>
<td>^abc?$</td>
<td>匹配ab在前面，后面的c出现1次或0次，也就是ab或abc</td>
</tr>
<tr>
<td>^abc*d$</td>
<td>匹配abd、abcd、abccd、abcccd、abccccd等，只要c在abd中间出现0次或多次都可以</td>
</tr>
<tr>
<td>^abc+d$</td>
<td>匹配abcd、abccd、abcccd等，只要c在abd中间出现1次或多次都可以</td>
</tr>
<tr>
<td>^abc?d$</td>
<td>匹配abd、abcd</td>
</tr>
</tbody></table>
<h3 id="范围字符"><a href="#范围字符" class="headerlink" title="范围字符"></a>范围字符</h3><h4 id="基本概念-22"><a href="#基本概念-22" class="headerlink" title="基本概念"></a>基本概念</h4><table>
<thead>
<tr>
<th>[]</th>
<th>表示一个范围，只匹配包含在范围内的字符之一。可以在一个范围的开始使用^来排除范围内所有字符，也可以使用下划线 _ 来指定一个区间</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><table>
<thead>
<tr>
<th>^[abcd]$</th>
<th>匹配只要出现了a、b、c、d的内容，[]表示包含在范围内字符之一，所以a\b\c\d四者之一都匹配这条</th>
</tr>
</thead>
<tbody><tr>
<td>[a-c 1-2]</td>
<td>匹配a、a1、b1、xyz2、nc2等内容，之所以能匹配很多结果是因为正则表达式没有写开始和结束符号，意味着只要任意一部分符合正则表达式即可</td>
</tr>
<tr>
<td>[^act]$</td>
<td>[]中加入^符号表示排除范围内所有字符，[^act]就是排除所有包含a\c\t的，后面加上表示结束的$符号，整体连起来表示排除所有以a\c\t结尾的内容</td>
</tr>
</tbody></table>
<h3 id="使用as-path-access-list匹配路由"><a href="#使用as-path-access-list匹配路由" class="headerlink" title="使用as-path access-list匹配路由"></a>使用as-path access-list匹配路由</h3><h4 id="基本概念-23"><a href="#基本概念-23" class="headerlink" title="基本概念"></a>基本概念</h4><p><img src="/2020/10/11/14-BGP/1611717862269-6ce42bb3-ffb2-44cc-9a98-eee1d59e3e6d.jpeg" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1611736583906-c2894a12-29ed-4f39-8b38-ae40c856c363.jpeg" alt="img"></p>
<p>一条路由的AS_PATH如果经过了123、443、579这三个AS，那么在底层它的AS_PATH是‘123_443_579’的形式存在，正则表达式‘443’就能匹配这条路由。<strong>as-path access-list中也默认隐含拒绝所有，也就是deny any</strong>。</p>
<table>
<thead>
<tr>
<th>^$</th>
<th>^表示开始，$表示结束，开始连接着结束表示中间没有任何东西，在AS_PATH访问列表中则表示匹配不包含任何AS号的AS_PATH，也就是匹配本AS内的路由，因为始发于本AS的路由没有进过任何AS，AS_PATH部分为空，只有离开本AS的时候AS_PATH才会有内容</th>
</tr>
</thead>
<tbody><tr>
<td>.*</td>
<td>点代表任意字符，<em>表示出现0次或多次，也就是任意字符可以出现0次或多次，所以就是匹配所有，等同于any，由于AS_PATH access list末尾隐藏了deny any，所以如果不想所有都被deny掉，结尾可以跟一个permit .</em></td>
</tr>
<tr>
<td>^100$</td>
<td>匹配100这个AS_PATH</td>
</tr>
<tr>
<td>^100_</td>
<td>表示以100开始的字符串，也就是100 200、100 555 666等等都匹配，在AS_PATH访问控制列表中则表示匹配那些从AS100直接发到本AS的路由，因为100在AS_PATH中最靠左说明AS100和本AS直接连接</td>
</tr>
<tr>
<td>_100$</td>
<td>匹配以100结束的AS_PATH，也就是匹配那些起源于AS100的路由，因为在AS_PATH中最靠右的AS号表示最先经历的AS，也就是起源AS</td>
</tr>
<tr>
<td>100$</td>
<td>匹配那些包含100这个数字在内结束的AS_PATH，比如1100、666100，这个和上面的区别在于是否有前面的‘_’，这个符号代表空格，有没有空格差别很大</td>
</tr>
<tr>
<td>^10[012349]$</td>
<td>匹配100、101、102、103、104、109这几个AS_PATH</td>
</tr>
<tr>
<td>^10[^0-6]$</td>
<td>匹配除了100-106以外的AS_PATH</td>
</tr>
<tr>
<td>^10.</td>
<td>匹配100-109以及10这些AS_PATH，因为‘.’也包含空格</td>
</tr>
<tr>
<td>^(100|200)$</td>
<td>匹配包含100或200的AS_PATH</td>
</tr>
<tr>
<td>12(_34)?_56</td>
<td>匹配12 56及12 34 56这两个AS_PATH</td>
</tr>
<tr>
<td>^[0-9]+$</td>
<td>‘[0-9]’表示任何在0-9之间的数字都可以被匹配，‘*’表示重复出现1次或多次，0-9重复出现1次或多次则表示任何数字，也就是匹配任何一个数字，包括但不限于1,123,1235,12363434等，‘^’表示开始，‘$’表示结束，当把这些都组合到一起时候表示，匹配单一的一个数字，这个数字可以是任何数，放到AS_PATH访问控制列表中表示任何直接连接到本AS的AS_PATH中只有单个AS的路由，换句话说就是那些起源自直连AS的路由，因为AS_PATH中只有一个数字的话，表示路由只经过一个AS后就传到了本AS且和本AS直连</td>
</tr>
<tr>
<td>^([0-9]+)_51$</td>
<td>‘_51$’表示路由起源AS为51，‘([0-9]+)’表示0-9可以出现1次或多次，也就是任意的和本AS相连的AS号都能匹配，‘_’表示空格，连起来表示匹配起自AS51，AS51在与本AS直连的AS后面，大概就是‘本AS-任意AS-AS51’这样连接的</td>
</tr>
<tr>
<td>^51_([0-9]+)$</td>
<td>‘^51_’表示路由经过的最后一个AS是AS51，‘([0-9]+)’表示任意多个任意的AS号，也就是路由AS_PATH最后的经过的一个AS为51，倒数第二个AS可以是任意的，所以在AS_PATH访问控制列表中是匹配那些和AS51直连的AS发来的路由，而AS51又和本AS直连</td>
</tr>
</tbody></table>
<h4 id="配置示例1"><a href="#配置示例1" class="headerlink" title="配置示例1"></a>配置示例1</h4><p><img src="/2020/10/11/14-BGP/1611919345029-5c7fa9cc-87ca-4240-ac54-8c1b4d073999.png" alt="img"></p>
<p>基本配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">interface Loopback10</span><br><span class="line"> ip address 172.16.10.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback11</span><br><span class="line"> ip address 172.16.11.2 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Loopback22</span><br><span class="line"> ip address 22.22.22.22 255.255.255.0</span><br><span class="line">!</span><br><span class="line">interface Ethernet0/0</span><br><span class="line"> ip address 10.1.23.2 255.255.255.0</span><br><span class="line"> duplex auto</span><br><span class="line">!</span><br><span class="line">ip prefix-list 10 seq 5 permit 172.16.10.0/24</span><br><span class="line">ip prefix-list 10 seq 10 permit 172.16.11.0/24</span><br><span class="line">ipv6 ioam timestamp</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 10</span><br><span class="line"> match ip address prefix-list 10</span><br><span class="line"> set as-path prepend 600</span><br><span class="line">!</span><br><span class="line">route-map AS_PATH permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 200</span><br><span class="line"> bgp router-id 2.2.2.2</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 22.22.22.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.10.0 mask 255.255.255.0</span><br><span class="line"> network 172.16.11.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.23.3 remote-as 300</span><br><span class="line"> neighbor 10.1.23.3 route-map AS_PATH out</span><br></pre></td></tr></table></figure>

<p>在R2上一共配置了3个loopback接口，loopback10和11用来模拟从AS600发来的路由，loopback 12用来代表本AS起源的路由，来验证过滤效果。配置ip 前缀列表匹配需要增加AS_PATH的路由，也就是172.16.10.0/24和172.16.11.0/24，创建route-map来对匹配的两条路由的AS_PATH进行操控，用prepend命令为AS_PATH重增加600这个AS来模拟从AS600发来的路由，此时R3上路由表为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-if)#do show ip bgp</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   22.22.22.0/24    10.1.23.2                0             0 200 i</span><br><span class="line"> *&gt;   172.16.10.0/24   10.1.23.2                0             0 200 600 i</span><br><span class="line"> *&gt;   172.16.11.0/24   10.1.23.2                0             0 200 600 i</span><br></pre></td></tr></table></figure>

<p>现在要在R3上进行配置，目标是过滤掉所有从AS600发过来的路由，总体思路是，先用AS_PATH访问控制列表匹配AS_PATH中最近一个是600的那些路由，然后用rfilter-list从in方向上过滤掉：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip as-path access-list 10 deny _600$</span><br><span class="line">ip as-path access-list 10 permit .*</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> neighbor 10.1.23.2 filter-list 10 in</span><br></pre></td></tr></table></figure>

<p>‘_600&amp;’这个正则表达式匹配的是与本AS相连，起源于AS600的路由，前面加上deny就是将从AS600发来的路由过滤掉，后面的‘permit .*’就是放行所有其他路由，这个as_path访问控制列表就是讲从AS600发来的路由过滤掉，并放行其他路由。如果写完正则表达式以后不知道匹配的路由是否是自己想要的，可以用命令‘show ip bgp regexp xxxx’来验证：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp regexp _600$</span><br><span class="line">BGP table version is 4, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   172.16.10.0/24   10.1.23.2                0             0 200 600 i</span><br><span class="line"> *&gt;   172.16.11.0/24   10.1.23.2                0             0 200 600 i</span><br></pre></td></tr></table></figure>

<p>从上面验证的结果可以看出，该正则表达式的结果就是我们想要的，然后在对邻居R2的in方向上用filter-list应用AS_PATH访问控制列表，此时再看R3的路由表，已经达到了我们想要的结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 6, local router ID is 3.3.3.3</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">              t secondary path,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;   22.22.22.0/24    10.1.23.2                0             0 200 i</span><br></pre></td></tr></table></figure>

<h4 id="配置示例2"><a href="#配置示例2" class="headerlink" title="配置示例2"></a>配置示例2</h4><p><img src="/2020/10/11/14-BGP/1612154577098-ccfd8578-2d63-4940-a11c-dbb051e87991.png" alt="img"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip as-path access-list 1 permit _600$</span><br><span class="line">route-map NOAS600 permit 10</span><br><span class="line"> match as-path 1</span><br><span class="line"> set community no-advertise</span><br><span class="line">!</span><br><span class="line">route-map NOAS600 permit 20</span><br><span class="line">!</span><br><span class="line">router bgp 300</span><br><span class="line"> neighbor 10.1.23.2 route-map NOAS600 in</span><br></pre></td></tr></table></figure>

<h4 id="配置示例3"><a href="#配置示例3" class="headerlink" title="配置示例3"></a>配置示例3</h4><p><img src="/2020/10/11/14-BGP/1612064079452-e2e752bc-558f-4f73-ab3f-3850b5d1377f.png" alt="img"></p>
<p>如上图所示，AS100和AS203,302,401,500为邻居，这时AS100想匹配那些起源于直连的AS（比如AS203,302,401,500）的路由以及那些起源于直连本AS的邻居AS（比如AS202,301,400）的路由。</p>
<p>用正则表达式匹配这些路由最简单直接的办法就是写出来那些需要匹配的AS号然后进行匹配，我们要匹配的AS有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">203</span><br><span class="line">203 202</span><br><span class="line">302</span><br><span class="line">302 301</span><br><span class="line">401</span><br><span class="line">401 400</span><br><span class="line">500</span><br></pre></td></tr></table></figure>

<p>在现有拓扑连接情况下要匹配这些AS只需要将他们都写入正则表达式即可，也就是写7行匹配语句，每一行如上所示，这样就能匹配所有需要的AS，但如果以后拓扑发生变化，不只有这7个AS的话正则表达式就无法匹配所有需要匹配的AS了，比如如果AS100新加了一个邻居，AS666，那么之前的正则表达式就匹配不到这个AS666了，而起源于这个AS的路由也是需要被匹配到的，因为它也是AS100的直连AS。所以考虑到拓扑的扩展可能性，必须匹配到所有可能的路由就不能这么写。</p>
<ol>
<li><p>我们知道，正则表达式得有开始和终结符号，所以‘^’和‘$’是肯定要有的；</p>
</li>
<li><p>由于匹配的目标有两个，一个是起源于直连AS的路由，另一个是起源于直连AS的邻居的路由。起源于直连AS的路由的AS_PATH只有一个AS号，暂时写为‘^X$’,X表示任意的AS号；起源于直连AS的邻居的路由有两个AS号，暂时写为‘^X  X$’；</p>
</li>
<li><p>接下来要确定‘X’这个任意的AS号如何用正则表达式匹配，因为X表示一个AS号，而AS号中肯定没有数字、括号、逗号这种特殊字符，所以它肯定是一个数字，又因为我们不知道这个数字具体是什么，它可能有一个或多个单独的数字组成，比如可能是5，10,123或1010，它代表了0-9之间所有可能的数字，这些数字可能出现1次或多次，所以用‘[0-9]+’来表示这个X，因此正则表达式可以写成：</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+$</span><br><span class="line">^[0-9]+ [0-9]+$</span><br></pre></td></tr></table></figure>

<p>但这么写是不是就是最佳的表示方式呢？并不是，第一行和第二行的区别在于，第二行多了一个‘[0-9]+’，而第一行没有这个‘[0-9]+’，换句话说，‘[0-9]+’存在了0次或1次，而‘?’正好能表示字符出现 0次或1次，因此可以将这个正则表达式优化为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^[0-9]+ ([0-9]+)?$</span><br></pre></td></tr></table></figure>

<h4 id="如何验证"><a href="#如何验证" class="headerlink" title="如何验证"></a>如何验证</h4><p>在配置完正则表达式以后可以使用命令‘show ip bgp regexp’来检查所匹配的路由是否和想要的相一致，也可以用<a href="https://regexr.com/">该网页</a>检查，不过是英文版的，但有详细的正则表达式说明。</p>
<h3 id="在cisco-IOS中的应用"><a href="#在cisco-IOS中的应用" class="headerlink" title="在cisco IOS中的应用"></a>在cisco IOS中的应用</h3><p>show 和more的输出中，可使用管道符‘|’搭配正则表达式来过滤输出结果，输入‘|’的方式为‘shift+\’，‘\’在回车键的上边。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show run | ?</span><br><span class="line">  append    Append redirected output to URL (URLs supporting append operation</span><br><span class="line">            only)</span><br><span class="line">  begin     Begin with the line that matches</span><br><span class="line">  count     Count number of lines which match regexp</span><br><span class="line">  exclude   Exclude lines that match</span><br><span class="line">  format    Format the output using the specified spec file</span><br><span class="line">  include   Include lines that match</span><br><span class="line">  redirect  Redirect output to URL</span><br><span class="line">  section   Filter a section of output</span><br><span class="line">  tee       Copy output to URL</span><br></pre></td></tr></table></figure>

<p>管道符后面可以接多种的限制词语，比如begin XXX就是以XXX开始的；include XXX就是显示包含XXX在内的shou run语句；section XXX就是包含XXX的章节比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R3#show run | section router</span><br><span class="line">router bgp 300</span><br><span class="line"> bgp router-id 3.3.3.3</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> neighbor 10.1.13.1 remote-as 100</span><br><span class="line"> neighbor 10.1.23.2 remote-as 200</span><br><span class="line"> neighbor 10.1.23.2 route-map NOAS600 in</span><br></pre></td></tr></table></figure>

<h2 id="BGP过滤器"><a href="#BGP过滤器" class="headerlink" title="BGP过滤器"></a>BGP过滤器</h2><h3 id="Prefix-list"><a href="#Prefix-list" class="headerlink" title="Prefix-list"></a>Prefix-list</h3><p><img src="/2020/10/11/14-BGP/1612166607378-7789d9ae-f060-4c65-bfc3-743c1aada82b.png" alt="img"></p>
<p>在R2上用prefix-list只过滤掉12.12.12.0/24的路由，放行其他路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 deny 12.12.12.0/24</span><br><span class="line">ip prefix-list 1 seq 10 permit 0.0.0.0/0 le 32</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> neighbor 10.1.23.3 prefix-list 1 out</span><br></pre></td></tr></table></figure>

<p>0.0.0.0/0 le 32等同于any，当然在R1的out方向进行过滤也没问题。</p>
<h3 id="Distribute-list"><a href="#Distribute-list" class="headerlink" title="Distribute-list"></a>Distribute-list</h3><p><img src="/2020/10/11/14-BGP/1612169303385-7277153a-d0ea-4450-a0ab-c923d5c3d159.png" alt="img"></p>
<p>拓扑依旧，在R2上用distribute-list只过滤掉12.12.12.0/24的路由，放行其他路由</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">配置方式1：</span><br><span class="line">R2：</span><br><span class="line"></span><br><span class="line">access-list 1 deny   12.12.12.0</span><br><span class="line">access-list 1 permit any</span><br><span class="line">!</span><br><span class="line">router bgp 12</span><br><span class="line"> neighbor 10.1.23.3 distribute-list 1 out</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">配置方式2：</span><br><span class="line">ip prefix-list 12 deny 12.12.12.0/24</span><br><span class="line">ip prefix-list 12 permit 0.0.0.0/0 le 32</span><br><span class="line">router bgp 12</span><br><span class="line"> distribute-list prefix 12 out</span><br></pre></td></tr></table></figure>

<h3 id="Route-map"><a href="#Route-map" class="headerlink" title="Route-map"></a>Route-map</h3><h4 id="关联network命令"><a href="#关联network命令" class="headerlink" title="关联network命令"></a>关联network命令</h4><p>​                                               </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip prefix-list 11 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 12 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map RP2 permit 10</span><br><span class="line"> match ip address prefix-list 12</span><br><span class="line"> set community 100:12</span><br><span class="line">!</span><br><span class="line">route-map RP1 permit 10</span><br><span class="line"> match ip address prefix-list 11</span><br><span class="line"> set community 100:11</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 1.1.1.1</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0 route-map RP1</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0 route-map RP2</span><br><span class="line"> neighbor 10.1.12.2 remote-as 200</span><br><span class="line"> neighbor 10.1.12.2 send-community</span><br><span class="line">ip bgp-community new-format</span><br></pre></td></tr></table></figure>

<p>分别用前缀列表11以及12抓取11.11.11.0/24，12.12.12.0.0/24，然后分别写两个route-map，对两条路由赋予community属性，然后将route-map挂在network命令后边，在宣告的时候直接打上community，也可以对邻居的out方向使用route-map。然后对邻居R2配置send community命令，使得community能够发送给R2，而后配置bgp-community new-format命令将显示的格式调整到RFC默认格式。</p>
<p><img src="/2020/10/11/14-BGP/1612237793106-0bfcedfc-e18b-4ad9-bfad-5fe96657c875.png" alt="img"></p>
<p>但必须注意的是，在network后面使用route-map影响的是所有的BGP邻居，如果除了R2以外还有其他邻居，比如R3，则这个community也会发给R3。如果只想对特定的邻居发送community，最好将route-map挂在neighbor命令后。</p>
<h4 id="关联neighbor命令"><a href="#关联neighbor命令" class="headerlink" title="关联neighbor命令"></a>关联neighbor命令</h4><p><img src="/2020/10/11/14-BGP/1612251386842-b2b7f3d9-1841-4f8c-9a0e-1b25e8771768.png" alt="img"></p>
<p>拓扑和之前相等，此时在R1上进行配置，对R2传递路由时设定11.11.11.0/24的MED值为1000；12.12.12.0/24的MED值为2000</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list 11 seq 5 permit 11.11.11.0/24</span><br><span class="line">!</span><br><span class="line">ip prefix-list 12 seq 5 permit 12.12.12.0/24</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 10</span><br><span class="line"> match ip address prefix-list 11</span><br><span class="line"> set metric 1000</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 20</span><br><span class="line"> match ip address prefix-list 12</span><br><span class="line"> set metric 2000</span><br><span class="line">!</span><br><span class="line">route-map MED1 permit 30</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> network 11.11.11.0 mask 255.255.255.0</span><br><span class="line"> network 12.12.12.0 mask 255.255.255.0</span><br><span class="line"> neighbor 10.1.12.2 route-map MED1 out</span><br></pre></td></tr></table></figure>

<p>由于route-map最后有deny  any的隐藏项，所以最后还是加上了‘route-map MED1 permit 30’的语句，放行其他路由，以防以后宣告的其他路由被deny掉无法传递到R2。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R2上输出验证route-map中的MED（metric）是否配置成功</span><br><span class="line">R2#show ip bgp</span><br><span class="line">BGP table version is 3, local router ID is 2.2.2.2</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;  11.11.11.0/24    10.1.12.1             1000             0 100 i</span><br><span class="line"> *&gt;  12.12.12.0/24    10.1.12.1             2000             0 100 i</span><br></pre></td></tr></table></figure>

<h4 id="关联重发布命令"><a href="#关联重发布命令" class="headerlink" title="关联重发布命令"></a>关联重发布命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redistribute ospf 1 route-map RP</span><br><span class="line">redistribute eigrp 100 route-mmap RP</span><br></pre></td></tr></table></figure>

<h3 id="Unsuppress-map"><a href="#Unsuppress-map" class="headerlink" title="Unsuppress-map"></a>Unsuppress-map</h3><p><img src="/2020/10/11/14-BGP/1612253858243-063560f9-ba84-4e80-8663-d6cc03756d0b.png" alt="img"></p>
<p>R1和R2为BGP邻居，R1上宣告了两条路由，1.1.1.0/24核1.1.2.0/24，在R1上进行路由汇总，将路由汇总为1.0.0.0/8，抑制明细，但希望放行1.1.1.0/24这条路由：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line"></span><br><span class="line">ip prefix-list 1 seq 5 permit 1.1.1.0/24</span><br><span class="line">!</span><br><span class="line">route-map UN permit 10</span><br><span class="line"> match ip address prefix-list 1</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> bgp router-id 11.11.11.11</span><br><span class="line"> bgp log-neighbor-changes</span><br><span class="line"> network 1.1.1.0 mask 255.255.255.0</span><br><span class="line"> network 1.1.2.0 mask 255.255.255.0</span><br><span class="line"> aggregate-address 1.0.0.0 255.0.0.0 summary-only</span><br><span class="line"> neighbor 192.168.12.2 remote-as 200</span><br><span class="line"> neighbor 192.168.12.2 unsuppress-map UN</span><br></pre></td></tr></table></figure>

<p>在R1上进行完路由汇总以后，由于要放行其中一条明细路由，所以用unsuppress-map进行操作，unsuppress-map 后面跟的route-map中被匹配到的路由不会被抑制</p>
<ul>
<li><p>先写一条前缀列表匹配（抓取）需要放行的路由‘ip prefix-list 1 seq 5 permit 1.1.1.0/24’；</p>
</li>
<li><p>由于unsuppress-map后面需要跟route-map，所以写一个匹配路由的route-map，里面只用match语句匹配该路由即可，不需要接set语句；</p>
</li>
<li><p>对邻居192.168.12.2使用unsuppress-map命令后面接之前写好的那条匹配了路由的route-map；</p>
</li>
</ul>
<p>最后的R2上查看BGP表查看配置效果：</p>
<p><img src="/2020/10/11/14-BGP/1612255401163-8f65e2b7-4edf-4842-ab33-744de6016b4a.png" alt="img"></p>
<h2 id="默认路由"><a href="#默认路由" class="headerlink" title="默认路由"></a>默认路由</h2><h3 id="静态路由方式"><a href="#静态路由方式" class="headerlink" title="静态路由方式"></a>静态路由方式</h3><p>在路由表中如果有‘ip route 0.0.0.0 0.0.0.0 XXX’的静态路由，在BGP进程中可以使用‘network 0.0.0.0’将此路由注入BGP进程，使得BGP中也有默认路由，该方法在BGP中引入默认路由会被传递给所有BGP邻居。</p>
<h3 id="neighbor-XXX-default-originate"><a href="#neighbor-XXX-default-originate" class="headerlink" title="neighbor XXX default-originate"></a>neighbor XXX default-originate</h3><h4 id="基本概念-24"><a href="#基本概念-24" class="headerlink" title="基本概念"></a>基本概念</h4><p>本在BGP中配置‘neighbor XXX  default-originate’则会向特定的邻居XXX传递默认路由，<strong>此配置无需路由表中存在默认路由</strong>，有点类似OSPF的default-originate always命令。</p>
<h4 id="实验验证-9"><a href="#实验验证-9" class="headerlink" title="实验验证"></a>实验验证</h4><p><img src="/2020/10/11/14-BGP/1612342846544-f02027ac-1289-4152-8d2b-8939c27903b4.png" alt="img"></p>
<p>R1和R2为ebgp邻居，R1向R2下发一个默认路由，使得R2的默认路由指向R1，且要保证默认路由始终有效。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R1：</span><br><span class="line">access-list 1 permit 1.1.1.0 0.0.0.255</span><br><span class="line">!</span><br><span class="line">route-map test permit 10</span><br><span class="line"> match ip address 1</span><br><span class="line">!</span><br><span class="line">router bgp 100</span><br><span class="line"> neighbor 192.168.12.2 remote-as 200</span><br><span class="line"> neighbor 192.168.12.2 default-originate route-map test</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"> 此时R2的BGP表为：</span><br><span class="line"> </span><br><span class="line"> R2(config-router)#do show ip bgp</span><br><span class="line">BGP table version is 2, local router ID is 22.22.22.22</span><br><span class="line">Status codes: s suppressed, d damped, h history, * valid, &gt; best, i - internal,</span><br><span class="line">              r RIB-failure, S Stale, m multipath, b backup-path, f RT-Filter,</span><br><span class="line">              x best-external, a additional-path, c RIB-compressed,</span><br><span class="line">Origin codes: i - IGP, e - EGP, ? - incomplete</span><br><span class="line">RPKI validation codes: V valid, I invalid, N Not found</span><br><span class="line"></span><br><span class="line">     Network          Next Hop            Metric LocPrf Weight Path</span><br><span class="line"> *&gt;  0.0.0.0          192.168.12.1                           0 100 i </span><br></pre></td></tr></table></figure>

<p>只要R1的loopback接口1.1.1.1不down，R1就始终会向R2下发默认路由。</p>
<h3 id="default-information-originate"><a href="#default-information-originate" class="headerlink" title="default-information originate"></a>default-information originate</h3><p>在本地配置一条静态的默认路由，如‘ip route 0.0.0.0 0.0.0.0  null0’，默认情况下，BGP在重新发布静态路由的时候不允许注入默认路由，除非在BGP进程中配置‘default-information originate’：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip rouet 0.0.0.0 0.0.0.0 null0</span><br><span class="line">router bgp X</span><br><span class="line"> default-information originate</span><br><span class="line"> redistribute static</span><br></pre></td></tr></table></figure>





<h1 id="BGP排错步骤"><a href="#BGP排错步骤" class="headerlink" title="BGP排错步骤"></a>BGP排错步骤</h1><p><img src="/2020/10/11/14-BGP/1603531401504-1a1e1779-e0d1-4348-8288-a69e1ee6f914.png" alt="img"></p>
<p><img src="/2020/10/11/14-BGP/1603531207007-db942167-4d58-4c81-af5f-0b00922ab364.png" alt="img"></p>
<h1 id="引用文章"><a href="#引用文章" class="headerlink" title="引用文章"></a>引用文章</h1><p><a href="http://ccietea.com/">BGP技术笔记by红茶三杯</a></p>
<p><a href="http://www.tcpipguide.com/free/index.htm">TCP/IP Guide</a></p>
<p><a href="https://www.cisco.com/c/en/us/support/docs/ip/border-gateway-protocol-bgp/22166-bgp-trouble-main.html">Troubleshooting BGP</a></p>
<p><a href="https://networkgeekstuff.com/networking/cisco-bgp-timers-re-explained/">Cisco BGP Timers re-Explained</a></p>
<p><a href="https://packetpushers.net/demystifying-bgp-session-establishments/">Demystifying BGP Session Establishments</a></p>
<p><a href="https://www.ciscopress.com/articles/article.asp?p=2738462">Introduction to BGP</a></p>
<p><a href="https://www.noction.com/blog/bgp-dampening">BGP Route Dampening: obsolete or still used in the industry?</a></p>
<p><a href="https://sites.google.com/site/amitsciscozone/home/bgp/bgp-route-dampening">BGP Route Dampening</a></p>
<p><a href="https://users.soe.ucsc.edu/~brad/CiscoIOSpdfs/Understanding-BGP-Regular-Expressions.pdf">Understanding BGP Regular Expressions</a></p>
<p>BGP 技术笔记</p>
]]></content>
      <categories>
        <category>路由交换方向</category>
      </categories>
  </entry>
</search>
